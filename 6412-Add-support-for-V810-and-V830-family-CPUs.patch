From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: 20Enderdude20 <lanfrda1@gmail.com>
Date: Thu, 11 Apr 2024 17:30:35 -0700
Subject: [PATCH] 6412: Add support for V810 and V830 family CPUs

Add files via upload

Update and rename V830.opinion to V800.opinion

added some comments to cite where I found these values

Delete V810.sla

this is automatically generated - no worries

Delete Ghidra/Processors/V800/data/languages/V830.sla

this is automatically generated - no worries

Cleanup files and build.gradle as well as certification.manifest
---
 Ghidra/Processors/V800/Module.manifest        |   0
 Ghidra/Processors/V800/build.gradle           |  22 +
 Ghidra/Processors/V800/certification.manifest |  22 +
 .../data/languages/Helpers/Conditions.sinc    |  40 ++
 .../V800/data/languages/Helpers/Extras.sinc   |  27 ++
 .../V800/data/languages/Helpers/Macros.sinc   | 415 ++++++++++++++++++
 .../V800/data/languages/Helpers/Register.sinc |  46 ++
 .../V800/data/languages/Helpers/Tokens.sinc   |  86 ++++
 .../data/languages/Helpers/Variables.sinc     |  84 ++++
 .../languages/Instructions/Arithmetic.sinc    | 252 +++++++++++
 .../data/languages/Instructions/Floats.sinc   |  76 ++++
 .../languages/Instructions/Input_Output.sinc  |  65 +++
 .../languages/Instructions/Load_Store.sinc    | 177 ++++++++
 .../data/languages/Instructions/Logic.sinc    |  60 +++
 .../data/languages/Instructions/Special.sinc  | 377 ++++++++++++++++
 .../Processors/V800/data/languages/V800.ldefs |  29 ++
 .../V800/data/languages/V800.opinion          |  10 +
 .../Processors/V800/data/languages/V810.cspec |  68 +++
 .../Processors/V800/data/languages/V810.pspec |  13 +
 .../V800/data/languages/V810.slaspec          |  39 ++
 .../Processors/V800/data/languages/V830.cspec |  68 +++
 .../Processors/V800/data/languages/V830.pspec |  13 +
 .../V800/data/languages/V830.slaspec          |  38 ++
 Ghidra/Processors/V800/data/manuals/v810.idx  |  66 +++
 Ghidra/Processors/V800/data/manuals/v830.idx  |  66 +++
 25 files changed, 2159 insertions(+)
 create mode 100644 Ghidra/Processors/V800/Module.manifest
 create mode 100644 Ghidra/Processors/V800/build.gradle
 create mode 100644 Ghidra/Processors/V800/certification.manifest
 create mode 100644 Ghidra/Processors/V800/data/languages/Helpers/Conditions.sinc
 create mode 100644 Ghidra/Processors/V800/data/languages/Helpers/Extras.sinc
 create mode 100644 Ghidra/Processors/V800/data/languages/Helpers/Macros.sinc
 create mode 100644 Ghidra/Processors/V800/data/languages/Helpers/Register.sinc
 create mode 100644 Ghidra/Processors/V800/data/languages/Helpers/Tokens.sinc
 create mode 100644 Ghidra/Processors/V800/data/languages/Helpers/Variables.sinc
 create mode 100644 Ghidra/Processors/V800/data/languages/Instructions/Arithmetic.sinc
 create mode 100644 Ghidra/Processors/V800/data/languages/Instructions/Floats.sinc
 create mode 100644 Ghidra/Processors/V800/data/languages/Instructions/Input_Output.sinc
 create mode 100644 Ghidra/Processors/V800/data/languages/Instructions/Load_Store.sinc
 create mode 100644 Ghidra/Processors/V800/data/languages/Instructions/Logic.sinc
 create mode 100644 Ghidra/Processors/V800/data/languages/Instructions/Special.sinc
 create mode 100644 Ghidra/Processors/V800/data/languages/V800.ldefs
 create mode 100644 Ghidra/Processors/V800/data/languages/V800.opinion
 create mode 100644 Ghidra/Processors/V800/data/languages/V810.cspec
 create mode 100644 Ghidra/Processors/V800/data/languages/V810.pspec
 create mode 100644 Ghidra/Processors/V800/data/languages/V810.slaspec
 create mode 100644 Ghidra/Processors/V800/data/languages/V830.cspec
 create mode 100644 Ghidra/Processors/V800/data/languages/V830.pspec
 create mode 100644 Ghidra/Processors/V800/data/languages/V830.slaspec
 create mode 100644 Ghidra/Processors/V800/data/manuals/v810.idx
 create mode 100644 Ghidra/Processors/V800/data/manuals/v830.idx

diff --git a/Ghidra/Processors/V800/Module.manifest b/Ghidra/Processors/V800/Module.manifest
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/Ghidra/Processors/V800/build.gradle b/Ghidra/Processors/V800/build.gradle
new file mode 100644
index 0000000000..a123c02891
--- /dev/null
+++ b/Ghidra/Processors/V800/build.gradle
@@ -0,0 +1,22 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+apply from: "$rootProject.projectDir/gradle/distributableGhidraModule.gradle"
+apply from: "$rootProject.projectDir/gradle/javaProject.gradle"
+apply from: "$rootProject.projectDir/gradle/processorProject.gradle"
+apply from: "$rootProject.projectDir/gradle/jacocoProject.gradle"
+apply from: "$rootProject.projectDir/gradle/javaTestProject.gradle"
+apply plugin: 'eclipse'
+eclipse.project.name = 'Processors V800'
diff --git a/Ghidra/Processors/V800/certification.manifest b/Ghidra/Processors/V800/certification.manifest
new file mode 100644
index 0000000000..ae8b5a17f3
--- /dev/null
+++ b/Ghidra/Processors/V800/certification.manifest
@@ -0,0 +1,22 @@
+data/languages/Helpers/Conditions.sinc||GHIDRA||||END|
+data/languages/Helpers/Extras.sinc||GHIDRA||||END|
+data/languages/Helpers/Macros.sinc||GHIDRA||||END|
+data/languages/Helpers/Register.sinc||GHIDRA||||END|
+data/languages/Helpers/Tokens.sinc||GHIDRA||||END|
+data/languages/Helpers/Variables.sinc||GHIDRA||||END|
+data/languages/Instructions/Arithmetic.sinc||GHIDRA||||END|
+data/languages/Instructions/Floats.sinc||GHIDRA||||END|
+data/languages/Instructions/Input_Output.sinc||GHIDRA||||END|
+data/languages/Instructions/Load_Store.sinc||GHIDRA||||END|
+data/languages/Instructions/Logic.sinc||GHIDRA||||END|
+data/languages/Instructions/Special.sinc||GHIDRA||||END|
+data/languages/V800.ldefs||GHIDRA||||END|
+data/languages/V800.opinion||GHIDRA||||END|
+data/languages/V810.cspec||GHIDRA||||END|
+data/languages/V810.pspec||GHIDRA||||END|
+data/languages/V810.slaspec||GHIDRA||||END|
+data/languages/V830.cspec||GHIDRA||||END|
+data/languages/V830.pspec||GHIDRA||||END|
+data/languages/V830.slaspec||GHIDRA||||END|
+data/manuals/v810.idx||GHIDRA||||END|
+data/manuals/v830.idx||GHIDRA||||END|
diff --git a/Ghidra/Processors/V800/data/languages/Helpers/Conditions.sinc b/Ghidra/Processors/V800/data/languages/Helpers/Conditions.sinc
new file mode 100644
index 0000000000..b1898f5581
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/Helpers/Conditions.sinc
@@ -0,0 +1,40 @@
+#####################################################
+#####		     Conditions			#####
+#####################################################
+
+
+c0003: "v"	is op0003=0x0	{ tmp:1 = ($(OV)) == 1; 		export tmp; }
+c0003: "nv"	is op0003=0x8	{ tmp:1 = ($(OV)) == 0; 		export tmp; }
+c0003: "c"	is op0003=0x1	{ tmp:1 = ($(CY)) == 1; 		export tmp; }
+c0003: "nc"	is op0003=0x9	{ tmp:1 = ($(CY)) == 0; 		export tmp; }
+c0003: "e"	is op0003=0x2	{ tmp:1 = ($(Z)) == 1; 			export tmp; }
+c0003: "ne"	is op0003=0xA	{ tmp:1 = ($(Z)) == 0; 			export tmp; }
+c0003: "nh"	is op0003=0x3	{ tmp:1 = ($(CY) || $(Z)) == 1; 	export tmp; }
+c0003: "h"	is op0003=0xB	{ tmp:1 = ($(CY) || $(Z)) == 0; 	export tmp; }
+c0003: "n"	is op0003=0x4	{ tmp:1 = ($(S)) == 1; 			export tmp; }
+c0003: "p"	is op0003=0xC	{ tmp:1 = ($(S)) == 0; 			export tmp; }
+c0003: "t"	is op0003=0x5	{ tmp:1 = 1; 				export tmp; }
+@if defined(V830)
+c0003: "sa"	is op0003=0xD	{ tmp:1 = ($(SAT)) == 1; 		export tmp; }
+@endif
+c0003: "lt"	is op0003=0x6	{ tmp:1 = ($(S) ^^ $(OV)) == 1; 	export tmp; }
+c0003: "ge"	is op0003=0xE	{ tmp:1 = ($(S) ^^ $(OV)) == 0; 	export tmp; }
+c0003: "le"	is op0003=0x7	{ tmp:1 = ($(S) ^^ $(OV) || $(Z)) == 1; export tmp; }
+c0003: "gt"	is op0003=0xF	{ tmp:1 = ($(S) ^^ $(OV) || $(Z)) == 0; export tmp; }
+
+c0912: "v"	is op0912=0x0	{ tmp:1 = ($(OV)) == 1; 		export tmp; }
+c0912: "nv"	is op0912=0x8	{ tmp:1 = ($(OV)) == 0; 		export tmp; }
+c0912: "c"	is op0912=0x1	{ tmp:1 = ($(CY)) == 1; 		export tmp; }
+c0912: "nc"	is op0912=0x9	{ tmp:1 = ($(CY)) == 0; 		export tmp; }
+c0912: "e"	is op0912=0x2	{ tmp:1 = ($(Z)) == 1; 			export tmp; }
+c0912: "ne"	is op0912=0xA	{ tmp:1 = ($(Z)) == 0; 			export tmp; }
+c0912: "nh"	is op0912=0x3	{ tmp:1 = ($(CY) || $(Z)) == 1; 	export tmp; }
+c0912: "h"	is op0912=0xB	{ tmp:1 = ($(CY) || $(Z)) == 0; 	export tmp; }
+c0912: "n"	is op0912=0x4	{ tmp:1 = ($(S)) == 1; 			export tmp; }
+c0912: "p"	is op0912=0xC	{ tmp:1 = ($(S)) == 0; 			export tmp; }
+c0912: "t"	is op0912=0x5	{ tmp:1 = 1; 				export tmp; }
+c0912: "f"	is op0912=0xD	{ tmp:1 = 0; 	        	export tmp; }
+c0912: "lt"	is op0912=0x6	{ tmp:1 = ($(S) ^^ $(OV)) == 1; 	export tmp; }
+c0912: "ge"	is op0912=0xE	{ tmp:1 = ($(S) ^^ $(OV)) == 0; 	export tmp; }
+c0912: "le"	is op0912=0x7	{ tmp:1 = ($(S) ^^ $(OV) || $(Z)) == 1; export tmp; }
+c0912: "gt"	is op0912=0xF	{ tmp:1 = ($(S) ^^ $(OV) || $(Z)) == 0; export tmp; }
diff --git a/Ghidra/Processors/V800/data/languages/Helpers/Extras.sinc b/Ghidra/Processors/V800/data/languages/Helpers/Extras.sinc
new file mode 100644
index 0000000000..70c3b422c4
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/Helpers/Extras.sinc
@@ -0,0 +1,27 @@
+#####################################################
+#####		 	Extras			#####
+#####################################################
+
+
+# read r0 always return zero
+R0004: _R0004 is _R0004 & _R0004=0	{ local x:4=0; 	export x;	}
+R0004: _R0004 is _R0004			{		export _R0004;	}
+
+R0509: _R0509 is _R0509 & _R0509=0	{ local x:4=0; 	export x;	}
+R0509: _R0509 is _R0509			{		export _R0509;	}
+
+R1620: _R1620 is _R1620 & _R1620=0	{ local x:4=0; 	export x;	}
+R1620: _R1620 is _R1620			{		export _R1620;	}
+
+
+adr9: res is s0008 & op0000
+[ res = (s0008 ^ op0000) + inst_start; ]
+{
+	export *:4 res;
+}
+
+adr26: res is s0009; op1631 & op1616=0
+[ res = ((s0009 << 16) | op1631) + inst_start; ]
+{
+	export *:4 res;
+}
diff --git a/Ghidra/Processors/V800/data/languages/Helpers/Macros.sinc b/Ghidra/Processors/V800/data/languages/Helpers/Macros.sinc
new file mode 100644
index 0000000000..eecb45af51
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/Helpers/Macros.sinc
@@ -0,0 +1,415 @@
+#####################################################
+#####		 	Macros			#####
+#####################################################
+
+
+##### CARRY-Flag #####
+
+macro set_CY_pos(var1, var2)
+{
+	$(CY) = carry(var1, var2);
+}
+
+macro set_CY_pos2(var1, var2, var3)
+{
+	local var12 = var1 + var2;
+	$(CY) = carry(var1, var2) || carry(var12, var3);
+}
+
+macro set_CY_neg(var1, var2)
+{
+	$(CY) = var1 < var2;
+}
+
+macro set_CY_neg_f(var1, var2)
+{
+	$(CY) = var1 f< var2;
+}
+
+macro set_CY_neg2(var1, var2, var3)
+{
+	local var23 = var2 + var3;
+	$(CY) = (var1 < var23);
+}
+
+
+
+##### Overflow-Flag #####
+
+macro set_OV_pos(var1, var2)
+{
+	$(OV) = scarry(var1, var2);
+}
+
+macro set_OV_pos2(var1, var2, var3)
+{
+	local var12 = var1 + var2;
+	$(OV) = scarry(var1, var2) || scarry(var12, var3);
+}
+
+macro set_OV_neg(var1, var2)
+{
+	local A:4 = var1;
+	local B:4 = var2;
+	local R = A - B;
+
+	local A1 = A[31,1];
+	local B1 = B[31,1];
+	local R1 = R[31,1];
+
+	$(OV) = (A1 != B1) && (B1 == R1);
+
+	#OV = 1 if:
+	#pos - neg = neg
+	#neg - pos = pos
+}
+
+
+macro set_OV_neg2(var1, var2, var3)
+{
+	local A:4 = var1;
+	local B:4 = var2;
+	local C:4 = var3;
+	local R = A - B - C;
+
+	local A1 = A[31,1];
+	local B1 = B[31,1];
+	local R1 = R[31,1];
+
+	$(OV) = (A1 != B1) && (B1 == R1);
+}
+
+
+
+##### S/Z-Flags #####
+
+macro set_S(flag)
+{
+	$(S) = flag s< 0;
+}
+
+macro set_S_f(flag)
+{
+	$(S) = flag f< 0;
+}
+
+macro set_Z(var)
+{
+	$(Z) = var == 0;
+}
+
+macro set_Z_f(var)
+{
+	$(Z) = var f== 0;
+}
+
+@if defined(V810)
+##### FRO/FPR-Flags #####
+
+macro set_FRO(var)
+{
+	$(FRO) = nan(var);
+}
+
+macro set_FPR(var1)
+{
+	$(FPR) = ((var1 f- floor(var1)) != 0);
+}
+
+macro set_FPR2(var1, var2)
+{
+	$(FPR) = ((var1 - var2) != 0);
+}
+@endif
+
+##### General-Flag-Macros #####
+
+macro set_general_flags_pos(var1, var2)
+{
+	local res = var1 + var2;
+	set_CY_pos(var1, var2);
+	set_OV_pos(var1, var2);
+	set_S(res);
+	set_Z(res);
+}
+
+macro set_general_flags_neg(var1, var2)
+{
+	local res = var1 - var2;
+	set_CY_neg(var1, var2);
+	set_OV_neg(var1, var2);
+	set_S(res);
+	set_Z(res);
+}
+@if defined(V810)
+macro set_general_flags_neg_f(var1, var2)
+{
+	local res = var1 f- var2;
+	set_CY_neg_f(var1, var2);
+	$(OV) = 0;
+	set_S_f(res);
+	set_Z_f(res);
+	set_FRO(var1);
+}
+@endif
+
+macro set_OV0_S_Z(var)
+{
+	$(OV) = 0;
+	set_S(var);
+	set_Z(var);
+}
+
+
+
+##### General-Macros #####
+
+# if condition is != 0
+macro either_or(res, cond, true, false)
+{
+	res = (true * zext(cond != 0)) + (false * zext(cond == 0));
+}
+
+# if condition is == 1
+macro either_or1(res, cond, true, false)
+{
+	res = (true * zext(cond == 1)) + (false * zext(cond != 1));
+}
+
+macro shift_right_logic(res, var, shift_)
+{
+	local shift = shift_ & 0x1f;
+	local mask = (zext(shift != 0) * var) & (1 << (shift - 1));
+	res = var >> shift;
+	set_OV0_S_Z(res);
+	$(CY) = ((mask != 0) && (shift != 0));
+}
+
+macro shift_right_arith(res, var, shift_)
+{
+	local shift = shift_ & 0x1f;
+	local mask = (zext(shift != 0) * var) & (1 << (shift - 1));
+	res = var s>> shift;
+	set_OV0_S_Z(res);
+	$(CY) = ((mask != 0) && (shift != 0));
+}
+
+macro shift_left_logic(res, var, shift_)
+{
+	local shift = shift_ & 0x1f;
+	local mask = (zext(shift != 0) * var) & (1 << (32 - shift));
+	res = var << shift;
+	set_OV0_S_Z(res);
+	$(CY) = ((mask != 0) && (shift != 0));
+}
+
+macro shift_left_logic_d(res, var, shift_)
+{
+	local shift = shift_ & 0x3f;
+	local mask = (zext(shift != 0) * var) & (1 << (64 - shift));
+	res = var << shift;
+	set_OV0_S_Z(res);
+	$(CY) = ((mask != 0) && (shift != 0));
+}
+
+
+##### Prep/Disp Macros #####
+
+macro push(reg)
+{
+	sp = sp - 4;
+	*:4 sp = reg;
+}
+
+macro pop(reg)
+{
+	reg = *:4 sp;
+	sp = sp + 4;
+}
+
+
+
+##### Search Macros #####
+
+macro SearchRight(res, var, char)
+{
+	local var_:4 = var;
+	res = 0;
+
+	<loop>
+	if ((var_ & 0x1) == char)
+		goto <end>;
+
+	var_ = var_ >> 1;
+	res = res + 1;
+
+	if (res < 32)
+		goto <loop>;
+
+	res = 0;
+
+	<end>
+}
+
+macro SearchLeft(res, var, char)
+{
+	local var_:4 = var;
+	res = 0;
+
+	<loop>
+	if ((var_ >> 31) == char)
+		goto <end>;
+
+	var_ = var_ << 1;
+	res = res + 1;
+
+	if (res < 32)
+		goto <loop>;
+
+	res = 0;
+
+	<end>
+}
+
+macro saturate(var)
+{
+	if (var s> 0x7FFFFFFF)
+		goto <pos_sat>;
+
+	if (var s< -0x80000000)
+		goto <neg_sat>;
+
+	goto <end>;
+
+	<pos_sat>
+     var =  0x7FFFFFFF;
+     goto <end>;
+
+	<neg_sat>
+     var = -0x80000000;
+     goto <end>;
+
+     <end>
+ }
+
+
+##### Float-Macros #####
+
+macro compare_float(res, fcond, reg1, reg2)
+{
+	local un = ((fcond & 1) == 1)	&    (nan(reg2) || nan(reg1));
+	local eq = ((fcond & 2) == 2)   &  (!(nan(reg2) || nan(reg1)))  &  (reg2 f== reg1);
+	local le = ((fcond & 4) == 4)	&  (!(nan(reg2) || nan(reg1)))  &  (reg2 f<  reg1);
+	#local ex = (fcond & 8)		&   ((nan(reg2) || nan(reg1)));
+
+	res = zext(un|eq|le);
+}
+
+macro float2int(var1, var2)
+{
+	local exp = zext(var2[23,8]);
+	local sign = 1 - 2*zext((var2[31,1] == 1));
+	local fraction = zext(var2[0, 23]) | 0x800000;
+	local power = 1 << exp;
+	local res = power*fraction/(0x800000);
+	res = sign * res;
+	var1 = res;
+}
+
+@if defined(V810)
+##### Bit string Operation Macros #####
+
+macro bitsop(select, dmask)
+{
+	r27 = r27 & 0x1f;
+	r26 = r26 & 0x1f;
+	local counter:4 = 0;
+	local swo:4 = 0;
+	local dwo:4 = 0;
+	local sbo = r27;
+	local dbo = r26;
+	local sword = *:4 (r30 + swo);
+	local dword = *:4 (r29 + dwo);
+	local resword:4 = 0;
+	local unaff:4 = 0;
+	<setbitsandinc>
+	if (counter >= r28)
+		goto <end>;
+	local smasked:4 = (sword & (1 << sbo)) >> sbo;
+	local dmasked:4 = dword & (dmask >> (31 - dbo));
+	if (select == 0xb)
+		goto <mov>;
+	if (select == 0xe)
+		goto <not>;
+	if (select == 0x9)
+		goto <and>;
+	if (select == 0xd)
+		goto <andn>;
+	if (select == 0x8)
+		goto <or>;
+	if (select == 0xc)
+		goto <orn>;
+	if (select == 0xa)
+		goto <xor>;
+	if (select == 0xe)
+		goto <xorn>;
+	<ret3>
+	counter = counter + 1;
+	sbo = sbo + 1;
+	dbo = dbo + 1;
+	if (sbo > 0x1f)
+		goto <incsword>;
+	<ret1>
+	if (dbo > 0x1f)
+		goto <incdword>;
+	<ret2>
+	goto <setbitsandinc>;
+
+	<incsword>
+	sbo = 0;
+	swo = swo + 4;
+	sword = *:4 (r30 + swo);
+	goto <ret1>;
+
+	<incdword>
+	dbo = 0;
+	dwo = dwo + 4;
+	*:4 (r29 + dwo) = resword;
+	dword = *:4 (r29 + dwo);
+	goto <ret2>;
+
+	<end>
+	*:4 (r29 + dwo) = resword;
+	call [PC];
+
+	<mov>
+	resword = resword | (dmasked | (smasked << dbo));
+	goto <ret3>;
+	<not>
+	resword = resword | (dmasked | (~smasked << dbo));
+	goto <ret3>;
+	<and>
+	unaff = dmasked;
+	resword = resword | dmasked | (((dmasked & (smasked << dbo)) >> dbo) << dbo);
+	goto <ret3>;
+	<andn>
+	unaff = dmasked;
+	resword = resword | dmasked | (((dmasked & (~smasked << dbo)) >> dbo) << dbo);
+	goto <ret3>;
+	<or>
+	resword = resword | (dmasked | (smasked << dbo));
+	goto <ret3>;
+	<orn>
+	resword = resword | (dmasked | (~smasked << dbo));
+	goto <ret3>;
+	<xor>
+	unaff = dmasked;
+	resword = resword | dmasked | (((dmasked ^ (smasked << dbo)) >> dbo) << dbo);
+	goto <ret3>;
+	<xorn>
+	unaff = dmasked;
+	resword = resword | dmasked | (((dmasked ^ (~smasked << dbo)) >> dbo) << dbo);
+	goto <ret3>;
+
+}
+@endif
\ No newline at end of file
diff --git a/Ghidra/Processors/V800/data/languages/Helpers/Register.sinc b/Ghidra/Processors/V800/data/languages/Helpers/Register.sinc
new file mode 100644
index 0000000000..bef6ca4faa
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/Helpers/Register.sinc
@@ -0,0 +1,46 @@
+#####################################################
+#####	     		Register		#####
+#####################################################
+
+
+##### General-purpose registers (r0 to r31) #####
+@if defined(V830)
+define register offset=0x0 size=0x4             # offset = 0 because it's the start
+[
+  r0   r1   r2   sp   gp   tp   r6   r7   r8   r9
+  r10  r11  r12  r13  r14  r15  r16  r17  r18  r19
+  r20  r21  r22  r23  r24  r25  r26  r27  r28  r29
+  mp   lp
+];
+
+@elif defined(V810)
+define register offset=0x0 size=0x4
+[
+  r0   r1   r2   sp   gp   tp   r6   r7   r8   r9
+  r10  r11  r12  r13  r14  r15  r16  r17  r18  r19
+  r20  r21  r22  r23  r24  r25  r26  r27  r28  r29
+  r30  lp
+];
+@endif
+
+##### Control/Special registers #####
+@if defined(V830)
+define register offset=0x80 size=0x4            # offset = 0x80(128) = PreOffset+PreRegister*Size = 0+32*4 = 128
+[
+  EIPC   EIPSW  FEPC   FEPSW  ECR    PSW    PIR    TKCW   _     _
+  _      _      _      _      _      _      DPC    DPSW   _     _
+  _      _      _      _      _      _      _      _      _     _
+  DBWR   HCCW
+];
+
+@elif defined(V810)
+define register offset=0x80 size=0x4
+[
+  EIPC   EIPSW  FEPC   FEPSW  ECR    PSW    PIR    TKCW   _     _
+  _      _      _      _      _      _      _      _      _     _
+  _      _      _      _      CHCW   ADTRE  _      _      _     _
+  DBWR   HCCW
+];
+@endif
+
+define register offset=0x100 size=0x4 [ PC ];     # offset = 0x100(256) = PreOffset+PreRegister*Size = 128+32*4 = 256
diff --git a/Ghidra/Processors/V800/data/languages/Helpers/Tokens.sinc b/Ghidra/Processors/V800/data/languages/Helpers/Tokens.sinc
new file mode 100644
index 0000000000..9cf27bcf33
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/Helpers/Tokens.sinc
@@ -0,0 +1,86 @@
+#####################################################
+#####	     		Tokens			#####
+#####################################################
+
+
+define token instr(16)
+	op0000 	  = (0,0)
+	op0003 	  = (0,3)
+	op0004 	  = (0,4)
+	_R0004 	  = (0,4)
+	SR0004 	  = (0,4)
+	s0004 	  = (0,4) 	signed
+	s0005 	  = (0,5) 	signed
+	s0108 	  = (1,8) 	signed
+
+	s0008 	  = (0,8)	signed
+
+	s0009 	  = (0,9) 	signed
+
+	op0005 	  = (0,5)
+	op0006 	  = (0,6)
+	op0009 	  = (0,9)
+
+	op0010 	  = (0,10)
+	op0015 	  = (0,15)
+	op0106 	  = (1,6)
+	op0406 	  = (4,6)
+	op0410 	  = (4,10)
+	op0505	  = (5,5)
+	op0510	  = (5,10)
+	op0515 	  = (5,15)
+	op0610 	  = (6,10)
+	op0615 	  = (6,15)
+	op0710 	  = (7,10)
+
+	op0509	  = (5,9)
+	op0912	  = (9,12)
+	op1015	  = (10,15)
+	_R0509	  = (5,9)
+
+	op1113 	  = (11,13)
+	op1114 	  = (11,14)
+	op1115 	  = (11,15)
+	_R1115 	  = (11,15)
+	SR1115 	  = (11,15)
+	s1115 	  = (11,15)	signed
+
+	op1315	  = (13,15)
+
+	op1415 	  = (14,15)
+	op1515 	  = (15,15)
+;
+
+define token instr2(16)
+	op1616 	  = (0,0)
+	op1617 	  = (0,1)
+	op1619 	  = (0,3)
+	op1620 	  = (0,4)
+	op1626	  = (0,10)
+	op1631 	  = (0,15)
+	s1631 	  = (0,15)	signed
+	fcbit1719 = (1,3)
+	op1720 	  = (1,4)
+	op0_1720  = (1,4)
+	op1_1720  = (1,4)
+	s1731 	  = (1,15) 	signed
+	op1821 	  = (2,5)
+	s1821 	  = (2,5) 	signed
+	op2020 	  = (4,4)
+	op2026 	  = (4,10)
+	op2122 	  = (5,6)
+	op2126 	  = (5,10)
+	op2226 	  = (6,10)
+	op2323 	  = (7,7)
+	op2426 	  = (8,10)
+
+	op2631	  = (10,15)
+	_R1620	  = (0,4)
+
+	op2729 	  = (11,13)
+	fcond2730 = (11,14)
+	op2731 	  = (11,15)
+	_R2731 	  = (11,15)
+	op3031 	  = (14,15)
+	op3131 	  = (15,15)
+;
\ No newline at end of file
diff --git a/Ghidra/Processors/V800/data/languages/Helpers/Variables.sinc b/Ghidra/Processors/V800/data/languages/Helpers/Variables.sinc
new file mode 100644
index 0000000000..80cd3a7e71
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/Helpers/Variables.sinc
@@ -0,0 +1,84 @@
+#####################################################
+#####	     		Variables		#####
+#####################################################
+
+@if defined(V830)
+attach variables [ _R0004 _R0509 _R1115 _R2731 _R1620]
+[
+  r0  r1  r2  sp  gp  tp  r6  r7  r8  r9
+  r10 r11 r12 r13 r14 r15 r16 r17 r18 r19
+  r20 r21 r22 r23 r24 r25 r26 r27 r28 r29
+  mp  lp
+];
+
+attach variables [ SR0004 SR1115 ]
+[
+  EIPC   EIPSW  FEPC   FEPSW  ECR    PSW    PIR    TKCW   _     _
+  _      _      _      _      _      _      DPC    DPSW   _     _
+  _      _      _      _      _      _      _      _      _     _
+  DBWR   HCCW
+];
+
+@elif defined(V810)
+attach variables [ _R0004 _R0509 _R1115 _R2731 _R1620]
+[
+  r0  r1  r2  sp  gp  tp  r6  r7  r8  r9
+  r10 r11 r12 r13 r14 r15 r16 r17 r18 r19
+  r20 r21 r22 r23 r24 r25 r26 r27 r28 r29
+  r30  lp
+];
+
+attach variables [ SR0004 SR1115 ]
+[
+  EIPC   EIPSW  FEPC   FEPSW  ECR    PSW    PIR    TKCW   _     _
+  _      _      _      _      _      _      _      _      _     _
+  _      _      _      _      CHCW   ADTRE  _      _      _     _
+  DBWR   HCCW
+];
+@endif
+
+# attach variables [op0_1720] [r0 r2 gp r6 r8 r10 r12 r14 r16 r18 r20 r22 r24 r26 r28 mp];
+# attach variables [op1_1720] [r1 sp tp r7 r9 r11 r13 r15 r17 r19 r21 r23 r25 r27 r29 lp];
+
+
+attach names [fcond2730]
+["f" "un" "eq" "ueq" "olt" "ult" "ole" "ule" "sd" "ngle" "seq" "ngl" "lt" "nge" "le" "ngt"];
+
+@if defined(V830)
+@define I3    "PSW[19,1]"
+@define I2    "PSW[18,1]"
+@define I1    "PSW[17,1]"
+@define I0    "PSW[16,1]"
+@define NP  	"PSW[15,1]"
+@define EP  	"PSW[14,1]"
+@define ID  	"PSW[12,1]"
+@define DP    "PSW[11,1]"
+@define SAT 	"PSW[10,1]"
+@define CY  	"PSW[3,1]"
+@define OV  	"PSW[2,1]"
+@define S   	"PSW[1,1]"
+@define Z   	"PSW[0,1]"
+
+@elif defined(V810)
+@define I3    "PSW[19,1]"
+@define I2    "PSW[18,1]"
+@define I1    "PSW[17,1]"
+@define I0    "PSW[16,1]"
+@define NP  	"PSW[15,1]"
+@define EP  	"PSW[14,1]"
+@define AE  	"PSW[13,1]"
+@define ID  	"PSW[12,1]"
+@define FRO 	"PSW[9,1]"
+@define FIV 	"PSW[8,1]"
+@define FZD 	"PSW[7,1]"
+@define FOV 	"PSW[6,1]"
+@define FUD 	"PSW[5,1]"
+@define FPR 	"PSW[4,1]"
+@define CY  	"PSW[3,1]"
+@define OV  	"PSW[2,1]"
+@define S   	"PSW[1,1]"
+@define Z   	"PSW[0,1]"
+@endif
+
+@define EICC  	"ECR[0,16]"
+@define FECC  	"ECR[16,16]"
diff --git a/Ghidra/Processors/V800/data/languages/Instructions/Arithmetic.sinc b/Ghidra/Processors/V800/data/languages/Instructions/Arithmetic.sinc
new file mode 100644
index 0000000000..560b3d8173
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/Instructions/Arithmetic.sinc
@@ -0,0 +1,252 @@
+# V830 Family:
+# (3) Multiply instructions
+# (3) Multiply-accumulate instructions
+# (12) Arithmetic instructions
+# (4) Saturated operation instructions
+# (2) Divide instructions
+
+# V810 Family:
+# (2) Multiply instructions
+# (10) Arithmetic instructions
+# (2) Divide instructions
+
+
+#####################################################
+#####		       Multiply			#####
+#####################################################
+
+
+# MUL reg1, reg2 - 001000rrrrrRRRRR
+:mul R0004, R0509 is op1015=0x08 & R0004 & R0509
+{
+	local res:8 = sext(R0509) * sext(R0004);
+	R0509 = res:4;
+	shift_right_arith(res, res, 32);
+	mp = res:4;
+}
+
+@if defined(V830)
+define pcodeop __saturate;
+# MULI imm16, reg1, reg2 - 110010rrrrrRRRRR|iiiiiiiiiiiiiiii
+:muli s1631, R0004, R0509 is op1015=0x32 & R0509 & R0004; s1631
+{
+	local res:8 = sext(R0004) * s1631; # how do you indicate saturation?
+	$(SAT) = $(SAT) || $(OV);
+	R0509 = res:4;
+	__saturate(R0509);
+}
+@endif
+
+# MULU reg1, reg2 - 001010rrrrrRRRRR
+:mulu R0004, R0509 is op1015=0x0A & R0004 & R0509
+{
+	local res:8 = zext(R0509) * zext(R0004);
+	R0509 = res:4;
+	shift_right_arith(res, res, 32);
+	mp = res:4;
+}
+
+
+
+#####################################################
+##### 		     Arithmetic			#####
+#####################################################
+
+
+# ADD reg1, reg2 - 000001rrrrrRRRRR
+:add R0004, R0509 is op1015=0x01 & R0004 & R0509
+{
+	set_general_flags_pos(R0509, R0509);
+	R0509 = R0509 + R0004;
+}
+
+# ADD imm5, reg2 - 010001rrrrriiiii
+:add s0004, R0509 is op1015=0x11 & s0004 & R0509
+{
+	set_general_flags_pos(s0004, R0509);
+	R0509 = R0509 + s0004;
+}
+# ADDI imm16, reg1, reg2 - 101001rrrrrRRRRR|iiiiiiiiiiiiiiii
+:addi s1631, R0004, R0509 is op1015=0x29 & R0509 & R0004; s1631
+{
+	set_general_flags_pos(R0004, s1631);
+	R0509 = R0004 + s1631;
+}
+
+# CMP reg1, reg2 - 000011rrrrrRRRRR
+:cmp R0004, R0509 is op1015=0x03 & R0004 & R0509
+{
+	set_general_flags_neg(R0509, R0004);
+}
+
+# CMP imm5, reg2 - 010011rrrrriiiii
+:cmp s0004, R0509 is op1015=0x13 & s0004 & R0509
+{
+	set_general_flags_neg(R0509, s0004);
+}
+
+@if defined(V830)
+# MIN3 reg1, reg2, reg3 - 111110rrrrrRRRRR|01001000000wwwww
+:min3 R0004, R0509, R1620 is op1015=0x3E & R0004 & R0509; op2631=0x12 & R1620
+{
+	local res:4 = R0509;
+	if (R0004 s> R0509)
+		goto <more>;
+	res = R0004;
+	<more>
+	R1620 = res;
+}
+
+# MAX3 reg1, reg2, reg3 - 111110rrrrrRRRRR|01001100000wwwww
+:max3 R0004, R0509, R1620 is op1015=0x3E & R0004 & R0509; op2631=0x13 & R1620
+{
+	local res:4 = R0509;
+	if (R0004 s< R0509)
+		goto <less>;
+	res = R0004;
+	<less>
+	R1620 = res;
+}
+@endif
+
+# MOV reg1, reg2 - 000000rrrrrRRRRR
+:mov R0004, R0509 is op1015=0x00 & R0004 & R0509
+{
+	R0509 = R0004;
+}
+
+# MOV imm5, reg2 - 010000rrrrriiiii
+:mov s0004, R0509 is op1015=0x10 & s0004 & R0509
+{
+	R0509 = s0004;
+}
+
+# MOVEA imm16, reg1, reg2 - 101000rrrrrRRRRR|iiiiiiiiiiiiiiii
+:movea s1631, R0004, R0509 is op1015=0x28 & R0004 & R0509; s1631
+{
+	R0509 = R0004 + s1631;
+}
+
+# MOVHI imm16, reg1, reg2 - 101111rrrrrRRRRR|iiiiiiiiiiiiiiii
+:movhi op1631, R0004, R0509 is op1015=0x2F & R0004 & R0509; op1631
+{
+	R0509 = R0004 + (op1631 << 16);
+}
+
+# SUB reg1, reg2 - 000010rrrrrRRRRR
+:sub R0004, R0509 is op1015=0x02 & R0004 & R0509
+{
+	set_general_flags_neg(R0509, R0004);
+	R0509 = R0509 - R0004;
+}
+
+
+
+#####################################################
+#####		       Saturated		#####
+#####################################################
+
+@if defined(V830)
+# MUL3 reg1, reg2, reg3 - 111110rrrrrRRRRR|01111100000wwwww
+:mul3 R0004, R0509, R1620 is op1015=0x3E & R0004 & R0509; op2631=0x1F & R1620
+{
+	local res:8 = sext(R0509) * sext(R0004); # how do you indicate saturation?
+	$(SAT) = $(SAT) || $(OV);
+	R1620 = res:4;
+	__saturate(R1620);
+}
+
+
+
+# MULT3 reg1, reg2, reg3 - 111110rrrrrRRRRR|01111000000wwwww
+:mult3 R0004, R0509, R1620 is op1015=0x3E & R0004 & R0509; op2631=0x1E & R1620
+{
+	local res:8 = sext(R0509) * sext(R0004);
+	shift_right_arith(res, res, 32);
+	R1620 = res:4;
+}
+
+
+
+# SATADD3 reg1, reg2, reg3 - 111110rrrrrRRRRR|01000000000wwwww
+:satadd3 R0004, R0509, R1620 is op1015=0x3E & R0004 & R0509; op2631=0x10 & R1620
+{
+	set_general_flags_pos(R0509, R0004);
+	$(SAT) = $(SAT) || $(OV);
+	R1620 = R0509 + R0004;
+	__saturate(R1620);
+}
+
+# SATSUB3 reg1, reg2, reg3 - 111110rrrrrRRRRR|01000100000wwwww
+:satsub3 R0004, R0509, R1620 is op1015=0x3E & R0004 & R0509; op2631=0x11 & R1620
+{
+	set_general_flags_neg(R0509, R0004);
+	$(SAT) = $(SAT) || $(OV);
+	R1620 = R0509 - R0004;
+	__saturate(R1620);
+}
+
+
+#####################################################
+#####		  Multiply Accumulate		#####
+#####################################################
+
+
+# MAC3 reg1, reg2, reg3 - 111110rrrrrRRRRR|01110100000wwwww
+:mac3 R0004, R0509, R1620 is op1015=0x3E & R0004 & R0509; op2631=0x1D & R1620
+{
+	local res:8 = sext(R1620) + sext(R0509) * sext(R0004); # how do you indicate saturation?
+	$(SAT) = $(SAT) || $(OV);
+	R1620 = res:4;
+	__saturate(R1620);
+}
+
+# MACI imm16, reg1, reg2 - 110110rrrrrRRRRR|iiiiiiiiiiiiiiii
+:maci s1631, R0004, R0509 is op1015=0x36 & R0509 & R0004; s1631
+{
+	local res:8 = sext(R0509) + sext(R0004) * s1631; # how do you indicate saturation?
+	$(SAT) = $(SAT) || $(OV);
+	R0509 = res:4;
+	__saturate(R0509);
+}
+
+# MACT3 reg1, reg2, reg3 - 111110rrrrrRRRRR|01110000000wwwww
+:mact3 R0004, R0509, R1620 is op1015=0x3E & R0004 & R0509; op2631=0x1C & R1620
+{
+	local res:8 = sext(R0509) * sext(R0004); # how do you indicate saturation?
+	shift_right_arith(res, res, 32);
+	res = res + sext(R1620);
+	$(SAT) = $(SAT) || $(OV);
+	R1620 = res:4;
+	__saturate(R1620);
+}
+@endif
+
+#####################################################
+#####                  Divide			#####
+#####################################################
+
+
+# DIV reg1, reg2 - 001001rrrrrRRRRR
+:div R0004, R0509 is op1015=0x09 & R0004 & R0509
+{
+	local quot:4 = R0509 s/ R0004;
+	local mod:4 = R0509 s% R0004;
+	$(OV) = ((R0509 == 0x80000000 && R0004 == 0xFFFFFFFF) || R0004 == 0x0);
+	set_Z(R0509);
+	set_S(R0509);
+	R0509 = quot;
+	mp = mod;
+}
+
+# DIVU reg1, reg2 - 001011rrrrrRRRRR
+:divu R0004, R0509 is op1015=0x0B & R0004 & R0509
+{
+	local quot:4 = R0509 / R0004;
+	local mod:4 = R0509 % R0004;
+	$(OV) = (R0004 == 0);
+	set_Z(R0509);
+	set_S(R0509);
+	R0509 = quot;
+	mp = mod;
+}
\ No newline at end of file
diff --git a/Ghidra/Processors/V800/data/languages/Instructions/Floats.sinc b/Ghidra/Processors/V800/data/languages/Instructions/Floats.sinc
new file mode 100644
index 0000000000..9b037c6e01
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/Instructions/Floats.sinc
@@ -0,0 +1,76 @@
+# V810 Family:
+# (8) Float instructions
+
+
+
+#####################################################
+#####		 	Float Instructions				#####
+#####################################################
+
+
+# CMPF.S reg1, reg2 - 111110rrrrrRRRRR|000000xxxxxxxxxx
+:cmpf.s R0004, R0509 is op1015=0x3e & R0004 & R0509; op2631=0x0
+{
+	set_general_flags_neg_f(R0509, R0004);
+}
+
+
+# CVT.WS reg1, reg2 - 111110rrrrrRRRRR|000010xxxxxxxxxx
+:cvt.ws R0004, R0509 is op1015=0x3e & R0004 & R0509; op2631=0x2
+{
+	R0509 = int2float(R0004);
+	set_general_flags_neg_f(R0509, 0);
+	set_FPR(R0509);
+}
+
+
+# CVT.SW reg1, reg2 - 111110rrrrrRRRRR|000011xxxxxxxxxx
+:cvt.sw R0004, R0509 is op1015=0x3e & R0004 & R0509; op2631=0x3
+{
+	# set_FRO(R0004);
+	float2int(R0509, R0004);
+	set_general_flags_neg_f(R0509, 0);
+	set_FPR2(R0509, R0004);
+}
+
+
+# ADDF.S reg1, reg2 - 111110rrrrrRRRRR|000100xxxxxxxxxx
+:addf.s R0004, R0509 is op1015=0x3e & R0004 & R0509; op2631=0x4
+{
+	R0509 = R0509 f+ R0004;
+	set_general_flags_neg_f(R0509, 0);
+}
+
+
+# SUBF.S reg1, reg2 - 111110rrrrrRRRRR|000101xxxxxxxxxx
+:subf.s R0004, R0509 is op1015=0x3e & R0004 & R0509; op2631=0x5
+{
+	R0509 = R0509 f- R0004;
+	set_general_flags_neg_f(R0509, 0);
+}
+
+# MULF.S reg1, reg2 - 111110rrrrrRRRRR|000110xxxxxxxxxx
+:mulf.s R0004, R0509 is op1015=0x3e & R0004 & R0509; op2631=0x6
+{
+	R0509 = R0509 f* R0004;
+	set_general_flags_neg_f(R0509, 0);
+}
+
+
+# DIVF.S reg1, reg2 - 111110rrrrrRRRRR|000111xxxxxxxxxx
+:divf.s R0004, R0509 is op1015=0x3e & R0004 & R0509; op2631=0x7
+{
+	R0509 = R0509 f/ R0004;
+	set_general_flags_neg_f(R0509, 0);
+}
+
+define pcodeop __truncate;
+# TRNC.SW reg1, reg2 - 111110rrrrrRRRRR|001011xxxxxxxxxx
+:trnc.sw R0004, R0509 is op1015=0x3e & R0004 & R0509; op2631=0xb
+{
+	set_FRO(R0004);
+	__truncate(R0004);
+	float2int(R0509, R0004);
+	set_general_flags_neg_f(R0509, 0);
+	set_FPR2(R0509, R0004);
+}
diff --git a/Ghidra/Processors/V800/data/languages/Instructions/Input_Output.sinc b/Ghidra/Processors/V800/data/languages/Instructions/Input_Output.sinc
new file mode 100644
index 0000000000..a7b25e5eb4
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/Instructions/Input_Output.sinc
@@ -0,0 +1,65 @@
+# V830 Family:
+# (3) Input port instructions
+# (3) Output port instructions
+
+# V810 Family:
+# (3) Input port instructions
+# (3) Output port instructions
+
+
+#####################################################
+#####		  	Input			#####
+#####################################################
+
+# IN.B disp16[reg1], reg2 - 111000rrrrrRRRRR|dddddddddddddddd
+:in.b s1631[R0004], R0509 is op1015=0x38 & R0004 & R0509; s1631
+{
+	local adr:4 = R0004 + s1631;
+	R0509 = sext(*[port]:1 adr);
+}
+
+# IN.H disp16[reg1], reg2 - 111001rrrrrRRRRR|dddddddddddddddd
+:in.h s1631[R0004], R0509 is op1015=0x39 & R0004 & R0509; s1631
+{
+	local adr:4 = R0004 + s1631;
+	R0509 = sext(*[port]:2 adr);
+}
+
+# IN.W disp16[reg1], reg2 - 111011rrrrrRRRRR|dddddddddddddddd
+:in.w s1631[R0004], R0509 is op1015=0x3B & R0004 & R0509; s1631
+{
+	local adr:4 = R0004 + s1631;
+	R0509 = *[port]:4 adr;
+}
+
+
+
+
+#####################################################
+#####		 	Output			#####
+#####################################################
+
+# OUT.B reg2, disp16[reg1] - 111100rrrrrRRRRR|dddddddddddddddd
+:out.b R0509, s1631[R0004] is op1015=0x3C & R0004 & R0509; s1631
+{
+	local adr:4 = R0004 + s1631;
+	local tmp:4 = R0509;
+	*[port]:1 adr = tmp:1;
+}
+
+# OUT.H reg2, disp16[reg1] - 111101rrrrrRRRRR|dddddddddddddddd
+:out.h R0509, s1631[R0004] is op1015=0x3D & R0004 & R0509; s1631
+{
+	local adr:4 = R0004 + s1631;
+	local tmp:4 = R0509;
+	*[port]:2 adr = tmp:2;
+}
+
+
+# OUT.W reg2, disp16[reg1] - 111111rrrrrRRRRR|dddddddddddddddd
+:out.w R0509, s1631[R0004] is op1015=0x3F & R0004 & R0509; s1631
+{
+	local adr:4 = R0004 + s1631;
+	local tmp:4 = R0509;
+	*[port]:4 adr = tmp;
+}
\ No newline at end of file
diff --git a/Ghidra/Processors/V800/data/languages/Instructions/Load_Store.sinc b/Ghidra/Processors/V800/data/languages/Instructions/Load_Store.sinc
new file mode 100644
index 0000000000..7468a48607
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/Instructions/Load_Store.sinc
@@ -0,0 +1,177 @@
+# V830 Family:
+# (5) Load instructions
+# (5) Store instructions
+# (9) Data manipulation instructions
+
+# V810 Family:
+# (3) Load instructions
+# (3) Store instructions
+# (7) Data manipulation instructions
+
+
+
+#####################################################
+#####		  	Load			#####
+#####################################################
+
+
+# LD.B disp16[reg1], reg2 - 110000rrrrrRRRRR|dddddddddddddddd
+:ld.b s1631[R0004], R0509 is op1015=0x30 & R0004 & R0509; s1631
+{
+	local adr:4 = R0004 + s1631;
+	R0509 = sext(*:1 adr);
+}
+
+# LD.H disp16[reg1], reg2 - 110001rrrrrRRRRR|dddddddddddddddd
+:ld.h s1631[R0004], R0509 is op1015=0x31 & R0004 & R0509; s1631
+{
+	local adr:4 = R0004 + s1631;
+	R0509 = sext(*:2 adr);
+}
+
+# LD.W disp16[reg1], reg2 - 110011rrrrrRRRRR|dddddddddddddddd
+:ld.w s1631[R0004], R0509 is op1015=0x33 & R0004 & R0509; s1631
+{
+	local adr:4 = R0004 + s1631;
+	R0509 = *:4 adr;
+}
+
+@if defined(V830)
+# BDLD [reg1], [reg2] - 111110rrrrrRRRRR|100001----------
+:bdld [R0004], [R0509] is op1015=0x3E & R0004 & R0509; op2631=0x21
+{
+	local extadr:4 = R0004;
+	local intadr:4 = R0509;
+	*:16 intadr = *:16 extadr;
+}
+
+# BILD [reg1], [reg2] - 111110rrrrrRRRRR|100000----------
+:bild [R0004], [R0509] is op1015=0x3E & R0004 & R0509; op2631=0x20
+{
+	local extadr:4 = R0004;
+	local intadr:4 = R0509;
+	*:16 intadr = *:16 extadr;
+}
+@endif
+
+
+#####################################################
+#####		 	Store			#####
+#####################################################
+
+# ST.B reg2, disp16[reg1] - 110100rrrrrRRRRR|dddddddddddddddd
+:st.b R0509, s1631[R0004] is op1015=0x34 & R0004 & R0509; s1631
+{
+	local adr:4 = R0004 + s1631;
+	local tmp:4 = R0509;
+	*:1 adr = tmp:1;
+}
+
+# ST.H reg2, disp16[reg1] - 110101rrrrrRRRRR|dddddddddddddddd
+:st.h R0509, s1631[R0004] is op1015=0x35 & R0004 & R0509; s1631
+{
+	local adr:4 = R0004 + s1631;
+	local tmp:4 = R0509;
+	*:2 adr = tmp:2;
+}
+
+
+# ST.W reg2, disp16[reg1] - 110111rrrrrRRRRR|dddddddddddddddd
+:st.w R0509, s1631[R0004] is op1015=0x37 & R0004 & R0509; s1631
+{
+	local adr:4 = R0004 + s1631;
+	local tmp:4 = R0509;
+	*:4 adr = tmp;
+}
+
+@if defined(V830)
+# BDST [reg2], [reg1] - 111110rrrrrRRRRR|100011----------
+:bdst [R0509], [R0004] is op1015=0x3E & R0004 & R0509; op2631=0x23
+{
+	local extadr:4 = R0004;
+	local intadr:4 = R0509;
+	*:16 extadr = *:16 intadr;
+}
+
+
+# BIST [reg2], [reg1] - 111110rrrrrRRRRR|100010----------
+:bist [R0509], [R0004] is op1015=0x3E & R0004 & R0509; op2631=0x22
+{
+	local extadr:4 = R0004;
+	local intadr:4 = R0509;
+	*:16 extadr = *:16 intadr;
+}
+@endif
+
+
+
+#####################################################
+#####		   Data Manipulation		#####
+#####################################################
+
+
+# SAR reg1, reg2 - 000111rrrrrRRRRR
+:sar R0004, R0509 is op1015=0x07 & R0004 & R0509
+{
+	shift_right_arith(R0509, R0509, R0004);
+}
+
+# SAR imm5, reg2 - 010111rrrrriiiii
+:sar op0004, R0509 is op1015=0x17 & op0004 & R0509
+{
+	shift_right_arith(R0509, R0509, op0004:5);
+}
+
+# SETF cond, reg2 - 010010rrrrrxcccc
+:setf^c0003 R0509 is op1015=0x12 & c0003 & R0509
+{
+	R0509 = zext(c0003);
+}
+
+# SHL reg1, reg2 - 000100rrrrrRRRRR
+:shl R0004, R0509 is op1015=0x04 & R0004 & R0509
+{
+	shift_left_logic(R0509, R0509, R0004);
+}
+
+# SHL imm5, reg2 - 010100rrrrriiiii
+:shl op0004, R0509 is op1015=0x14 & op0004 & R0509
+{
+	shift_left_logic(R0509, R0509, op0004:5);
+}
+
+@if defined(V830)
+# SHLD3 reg1, reg2, reg3 - 111110rrrrrRRRRR|011000 00000 wwwww
+:shld3 R0004, R0509, R1620 is op1015=0x3E & R0004 & R0509; op2631=0x18 & R1620
+{
+	local hi:8 = zext(R1620);
+	shift_left_logic_d(hi, hi, 32);
+	local cat:8 = zext(R0509) + hi;
+	local res:8 = 0;
+	shift_left_logic(res, cat, R0004);
+	R1620 = res(4);
+}
+
+# SHRD3 reg1, reg2, reg3 - 111110rrrrrRRRRR|011001 00000 wwwww
+:shrd3 R0004, R0509, R1620 is op1015=0x3E & R0004 & R0509; op2631=0x19 & R1620
+{
+	local hi:8 = zext(R1620);
+	shift_left_logic_d(hi, hi, 32);
+	local cat:8 = zext(R0509) + hi;
+	local res:8 = 0;
+	shift_right_logic(res, cat, R0004);
+	R1620 = res:4;
+}
+@endif
+
+# SHR reg1, reg2 - 000101rrrrrRRRRR
+:shr R0004, R0509 is op1015=0x05 & R0004 & R0509
+{
+	shift_right_logic(R0509, R0509, R0004);
+}
+
+# SHR imm5, reg2 - 010101rrrrriiiii
+:shr op0004, R0509 is op1015=0x15 & op0004 & R0509
+{
+	shift_right_logic(R0509, R0509, op0004:5);
+}
diff --git a/Ghidra/Processors/V800/data/languages/Instructions/Logic.sinc b/Ghidra/Processors/V800/data/languages/Instructions/Logic.sinc
new file mode 100644
index 0000000000..38bea2f48f
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/Instructions/Logic.sinc
@@ -0,0 +1,60 @@
+# V830 Family:
+# (7) Logical instructions
+
+# V810 Family:
+# (7) Logical instructions
+
+
+#####################################################
+#####		 	Logic			#####
+#####################################################
+
+
+# AND reg1, reg2 - 001101rrrrrRRRRR
+:and R0004, R0509 is op1015=0x0D & R0004 & R0509
+{
+	R0509 = R0509 & R0004;
+	set_OV0_S_Z(R0509);
+}
+
+# ANDI imm16, reg1, reg2 - 101101rrrrrRRRRR|iiiiiiiiiiiiiiii
+:andi op1631, R0004, R0509 is op1015=0x2D & R0509 & R0004; op1631
+{
+	R0509 = R0004 & op1631;
+	set_OV0_S_Z(R0509);
+}
+
+# NOT reg1, reg2 - 001111rrrrrRRRRR
+:not R0004, R0509 is op1015=0x0F & R0004 & R0509
+{
+	R0509 = ~R0004;
+	set_OV0_S_Z(R0509);
+}
+
+# OR reg1, reg2 - 001100rrrrrRRRRR
+:or R0004, R0509 is op1015=0x0C & R0004 & R0509
+{
+	R0509 = R0509 | R0004;
+	set_OV0_S_Z(R0509);
+}
+
+# ORI imm16, reg1, reg2 - 101100rrrrrRRRRR|iiiiiiiiiiiiiiii
+:ori op1631, R0004, R0509 is op1015=0x2C & R0509 & R0004; op1631
+{
+	R0509 = R0004 | op1631;
+	set_OV0_S_Z(R0509);
+}
+
+# XOR reg1, reg2 - 001110rrrrrRRRRR
+:xor R0004, R0509 is op1015=0x0E & R0004 & R0509
+{
+	R0509 = R0509 ^ R0004;
+	set_OV0_S_Z(R0509);
+}
+
+# XORI imm16, reg1, reg2 - 101110rrrrrRRRRR|iiiiiiiiiiiiiiii
+:xori op1631, R0004, R0509 is op1015=0x2E & R0509 & R0004; op1631
+{
+	R0509 = R0004 ^ op1631;
+	set_OV0_S_Z(R0509);
+}
diff --git a/Ghidra/Processors/V800/data/languages/Instructions/Special.sinc b/Ghidra/Processors/V800/data/languages/Instructions/Special.sinc
new file mode 100644
index 0000000000..9fec3df319
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/Instructions/Special.sinc
@@ -0,0 +1,377 @@
+# V830 Family:
+# (5) Branch instructions
+# (11) Special instructions
+
+# V810 Family:
+# (12) Bit String Instructions
+# (4) Branch instructions
+# (7) Special instructions
+
+
+@if defined(V810)
+#####################################################
+#####		       Bit String		#####
+#####################################################
+
+# SCH0BSU [reg2] - 011111rrrrr00000
+:sch0bsu is op1015=0x1f & R0509 & op0004=0x0
+{
+	r29 = 0;
+	<loop0>
+	local bitvar = (*:4 r30) & (0x00000001 << r27);
+	<loop1>
+	if (bitvar == 0)
+		goto <found>;
+	r29 = r29 + 1;
+	if (r29 >= r28)
+		goto <notfound>;
+	r27 = r27 + 1;
+	if (r27 > 0x1f)
+		goto <incadr>;
+	goto <loop1>;
+	<incadr>
+	r30 = r30 + 1;
+	r27 = 0;
+	goto <loop0>;
+
+	<notfound>
+	$(Z)=1;
+	call [PC];
+	<found>
+	$(Z)=0;
+	call [PC];
+}
+
+
+# SCH0BSD [reg2] - 011111rrrrr00001
+:sch0bsd is op1015=0x1f & R0509 & op0004=0x1
+{
+	r29 = 0;
+	<loop0>
+	local bitvar = (*:4 r30) & (0x00000001 << r27);
+	<loop1>
+	if (bitvar == 0)
+		goto <found>;
+	r29 = r29 + 1;
+	if (r29 >= r28)
+		goto <notfound>;
+	r27 = r27 - 1;
+	if (r27 s< 0x0)
+		goto <decadr>;
+	goto <loop1>;
+	<decadr>
+	r30 = r30 - 1;
+	r27 = 0;
+	goto <loop0>;
+
+	<notfound>
+	$(Z)=1;
+	call [PC];
+	<found>
+	$(Z)=0;
+	call [PC];
+}
+
+
+# SCH1BSU [reg2] - 011111rrrrr00010
+:sch1bsu is op1015=0x1f & R0509 & op0004=0x2
+{
+	r29 = 0;
+	<loop0>
+	local bitvar = (*:4 r30) & (0x00000001 << r27);
+	<loop1>
+	if (bitvar != 0)
+		goto <found>;
+	r29 = r29 + 1;
+	if (r29 >= r28)
+		goto <notfound>;
+	r27 = r27 + 1;
+	if (r27 > 0x1f)
+		goto <incadr>;
+	goto <loop1>;
+	<incadr>
+	r30 = r30 + 1;
+	r27 = 0;
+	goto <loop0>;
+
+	<notfound>
+	$(Z)=1;
+	call [PC];
+	<found>
+	$(Z)=0;
+	call [PC];
+}
+
+
+# SCH1BSD [reg2] - 011111rrrrr00011
+:sch1bsd is op1015=0x1f & R0509 & op0004=0x3
+{
+	r29 = 0;
+	<loop0>
+	local bitvar = (*:4 r30) & (0x00000001 << r27);
+	<loop1>
+	if (bitvar != 0)
+		goto <found>;
+	r29 = r29 + 1;
+	if (r29 >= r28)
+		goto <notfound>;
+	r27 = r27 - 1;
+	if (r27 s< 0x0)
+		goto <decadr>;
+	goto <loop1>;
+	<decadr>
+	r30 = r30 - 1;
+	r27 = 0;
+	goto <loop0>;
+
+	<notfound>
+	$(Z)=1;
+	call [PC];
+	<found>
+	$(Z)=0;
+	call [PC];
+}
+
+# MOVBSU [reg2] - 011111rrrrr01011
+:movbsu is op1015=0x1f & R0509 & op0004=0xb
+{
+	var:4 = 0xb;
+	bitsop (var, 0x7fffffff);
+}
+
+# NOTBSU [reg2] - 011111rrrrr01111
+:notbsu is op1015=0x1f & R0509 & op0004=0xf
+{
+	var:4 = 0xf;
+	bitsop (var, 0x7fffffff);
+}
+
+# ANDBSU [reg2] - 011111rrrrr01001
+:andbsu is op1015=0x1f & R0509 & op0004=0x9
+{
+	var:4 = 0x9;
+	bitsop (var, 0xffffffff);
+}
+
+# ANDNBSU [reg2] - 011111rrrrr01101
+:andnbsu is op1015=0x1f & R0509 & op0004=0xd
+{
+	var:4 = 0xd;
+	bitsop (var, 0xffffffff);
+}
+
+# ORBSU [reg2] - 011111rrrrr01000
+:orbsu is op1015=0x1f & R0509 & op0004=0x8
+{
+	var:4 = 0x8;
+	bitsop (var, 0xffffffff);
+}
+
+# ORNBSU [reg2] - 011111rrrrr01100
+:ornbsu is op1015=0x1f & R0509 & op0004=0xc
+{
+	var:4 = 0xc;
+	bitsop (var, 0xffffffff);
+}
+
+define pcodeop __xorbsu;
+# XORBSU [reg2] - 011111rrrrr01010
+:xorbsu is op1015=0x1f & R0509 & op0004=0xa
+{
+	var:4 = 0xa;
+	bitsop (var, 0xffffffff);
+}
+
+# XORNBSU [reg2] - 011111rrrrr01110
+:xornbsu is op1015=0x1f & R0509 & op0004=0xe
+{
+	var:4 = 0xe;
+	bitsop (var, 0xffffffff);
+}
+@endif
+
+
+
+
+#####################################################
+#####		       Branch			#####
+#####################################################
+
+
+#Bcond adr9 - 100ccccdddddddd0
+:b^c0912 adr9 is op1315=0x4 & c0912 & adr9 & op0000=0x0
+{
+	if (c0912)
+		goto adr9;
+}
+:br adr9 is op1315=0x4 & op0912=0x5  & adr9 & op0000=0x0
+{
+	goto adr9;
+}
+:nop adr9 is op1315=0x4 & op0912=0xd & adr9
+{
+	PC = inst_next;
+}
+
+@if defined(V830)
+#ABcond adr9 - 100ccccdddddddd1
+:ab^c0912 adr9 is op1315=0x4 & c0912 & adr9 & op0000=0x1
+{
+	if (c0912)
+		goto adr9;
+}
+:abr adr9 is op1315=0x4 & op0912=0x5 & adr9 & op0000=0x1
+{
+	goto adr9;
+}
+@endif
+
+# JAL disp26 - 101011dddddddddd|ddddddddddddddd0
+:jal adr26 is op1015=0x2B ... & adr26
+{
+	lp = inst_next;
+	call adr26;
+}
+
+# JMP [reg1] - 000110-----RRRRR
+:jmp [R0004] is op1015=0x06 & R0004 & op0004=0x1F
+{
+	return [R0004];
+}
+:jmp [R0004] is op1015=0x06 & R0004 & op0004!=0x1F
+{
+	call [R0004];
+}
+
+# JR disp26 - 101010dddddddddd|ddddddddddddddd0
+:jr adr26 is op1015=0x2A ... & adr26
+{
+	goto adr26;
+}
+
+
+
+#####################################################
+#####		       Special			#####
+#####################################################
+
+@if defined(V830)
+# BRKRET - 011001uuuuuuuu1
+:BRKRET is op1015=0x19 & op0005 & op0000=1
+{
+	PC = DPC;
+	PSW = DPSW;
+	call [PC];
+}
+@endif
+
+# CAXI disp16[reg1], reg2 - 111010rrrrrRRRRR|dddddddddddddddd
+:caxi s1631[R0004], R0509 is op1015=0x3A & R0004 & R0509; s1631
+{
+	local adr:4 = R0004 + s1631;
+	local tkn = *:4 (adr & ~(0x3));
+	local result = R0509 - tkn;
+	*:4 R0004 = tkn * zext(result != 0) + R0509 * zext(result == 0);
+	R0509 = tkn;
+	set_general_flags_neg(R0509, tkn);
+}
+
+@if defined(V830)
+# DI - 011110uuuuuuuuuu
+define pcodeop __disable_irq;
+:di is op1015=0x1E
+{
+	$(ID) = 1;
+	__disable_irq();
+}
+
+# EI - 010110uuuuuuuuuu
+define pcodeop __enable_irq;
+:ei is op1015=0x16
+{
+	$(ID) = 0;
+	__enable_irq();
+}
+@endif
+
+# HALT - 011010uuuuuuuu0
+define pcodeop __halt;
+:halt is op1015=0x1A
+{
+	__halt();
+}
+
+# LDSR reg2, regID - 011100rrrrrIIIII
+:ldsr R0509, SR0004 is op1015=0x1C & SR0004 & R0509
+{
+	SR0004 = R0509;
+}
+
+# STSR regID, reg2 - 011101rrrrrIIIII
+:stsr SR0004, R0509 is op1015=0x1D & R0509 & SR0004
+{
+	R0509 = SR0004;
+}
+
+# NOP - 0000000000000000
+:nop is op0015=0x0
+{
+	PC = inst_next;
+}
+
+# RETI - 011001uuuuuuuu0
+:reti is op1015=0x19 & op0000=0
+{
+	if($(NP)!=1)
+		goto <false>;
+
+	PC = FEPC;
+	PSW = FEPSW;
+	goto <end>;
+
+	<false>
+	PC = EIPC;
+	PSW = EIPSW;
+
+	<end>
+	return[PC];
+}
+
+@if defined(V830)
+# STBY - 011010uuuuuuuuu1
+define pcodeop __stop;
+:stby is op1015=0x1A & op0000=1
+{
+	__stop();
+}
+@endif
+
+# TRAP imm10 - 011000vvvvvvvvvv
+define pcodeop __machinefault;
+:trap op0009 is op1015=0x18 & op0009
+{
+	if($(NP)!=1)
+		goto <np0>;
+	__machinefault();
+	goto <end>;
+	<np0>
+	if($(NP)!=1)
+		goto <ep0>;
+	local vector10:4 = op0009;
+	FEPC = inst_next;
+	FEPSW = PSW;
+	$(FECC) = vector10:2;					# exception code
+	$(NP) = 1;
+	$(ID) = 1;
+	either_or(PC, (HCCW == 1), 0xFE000000, 0xFFFFFE00);
+	goto <end>;
+	<ep0>
+	EIPC = inst_next;
+	EIPSW = PSW;
+	$(EICC) = vector10:2;					# exception code
+	$(EP) = 1;
+	$(ID) = 1;
+	PC = vector10;
+	<end>
+	call [PC];
+}
diff --git a/Ghidra/Processors/V800/data/languages/V800.ldefs b/Ghidra/Processors/V800/data/languages/V800.ldefs
new file mode 100644
index 0000000000..b95de218ec
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/V800.ldefs
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<language_definitions>
+  <language processor="V830"
+            endian="little"
+            size="32"
+            variant="default"
+            version="1.0"
+            slafile="V830.sla"
+            processorspec="V830.pspec"
+            manualindexfile="../manuals/v830.idx"
+            id="V830:LE:32:default">
+    <description>Renesas V830 family</description>
+    <compiler name="default" spec="V830.cspec" id="default"/>
+  </language>
+
+  <language processor="V810"
+            endian="little"
+            size="32"
+            variant="default"
+            version="1.0"
+            slafile="V810.sla"
+            processorspec="V810.pspec"
+            manualindexfile="../manuals/v810.idx"
+            id="V810:LE:32:default">
+    <description>Renesas V810 family</description>
+    <compiler name="default" spec="V810.cspec" id="default"/>
+  </language>
+</language_definitions>
diff --git a/Ghidra/Processors/V800/data/languages/V800.opinion b/Ghidra/Processors/V800/data/languages/V800.opinion
new file mode 100644
index 0000000000..bcd7bac1c1
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/V800.opinion
@@ -0,0 +1,10 @@
+<opinions>
+    <constraint loader="Executable and Linking Format (ELF)" compilerSpecID="default">
+        <!--e_machine value 36 (0x24) taken from: https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html
+        since this is for the V800 family in general. -->
+        <constraint primary="36"   processor="V810"                      size="32" />
+        <constraint primary="36"   processor="V830"                      size="32" />
+        <!--e_machine value 28868 (0x70C4) observed in several ELF files compiled under Metrowerks Codewarrior v2.2.1 for the V831 CPU.-->
+        <constraint primary="28868"  processor="V830"                    size="32" />
+    </constraint>
+</opinions>
diff --git a/Ghidra/Processors/V800/data/languages/V810.cspec b/Ghidra/Processors/V800/data/languages/V810.cspec
new file mode 100644
index 0000000000..2d94728b42
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/V810.cspec
@@ -0,0 +1,68 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<compiler_spec>
+
+  <global>
+    <range space="ram"/>
+    <range space="port"/>
+  </global>
+
+  <stackpointer register="sp" space="ram"/>
+
+  <default_proto>
+    <prototype name="__stdcall" extrapop="0" stackshift="0">
+
+      <input>
+        <pentry minsize="1" maxsize="4">
+          <register name="r6"/>
+        </pentry>
+
+        <pentry minsize="1" maxsize="4">
+          <register name="r7"/>
+        </pentry>
+
+        <pentry minsize="1" maxsize="4">
+          <register name="r8"/>
+        </pentry>
+
+        <pentry minsize="1" maxsize="4">
+          <register name="r9"/>
+        </pentry>
+
+        <pentry minsize="1" maxsize="500" align="4">
+          <addr offset="0" space="stack"/>
+        </pentry>
+      </input>
+
+      <output>
+        <pentry minsize="1" maxsize="4">
+          <register name="r10"/>
+        </pentry>
+
+         <pentry minsize="5" maxsize="8">
+          <addr space="join" piece1="r10" piece2="r11"/>
+        </pentry>
+      </output>
+
+      <unaffected>
+        <register name="r20"/>
+        <register name="r21"/>
+        <register name="r22"/>
+        <register name="r23"/>
+        <register name="r24"/>
+        <register name="r25"/>
+        <register name="r26"/>
+        <register name="r27"/>
+        <register name="r28"/>
+        <register name="r29"/>
+        <register name="r30"/>
+        <register name="lp"/>
+        <register name="sp"/>
+        <register name="gp"/>
+        <register name="tp"/>
+      </unaffected>
+
+    </prototype>
+  </default_proto>
+
+</compiler_spec>
diff --git a/Ghidra/Processors/V800/data/languages/V810.pspec b/Ghidra/Processors/V800/data/languages/V810.pspec
new file mode 100644
index 0000000000..02fa9403d9
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/V810.pspec
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<processor_spec>
+
+  <programcounter register="PC"/>
+
+  <data_space space="ram"/>
+
+  <volatile outputop="write" inputop="read">
+    <range space="ram" first="0x0" last="0x20"/>
+  </volatile>
+
+</processor_spec>
diff --git a/Ghidra/Processors/V800/data/languages/V810.slaspec b/Ghidra/Processors/V800/data/languages/V810.slaspec
new file mode 100644
index 0000000000..d1c6db92ce
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/V810.slaspec
@@ -0,0 +1,39 @@
+#####################################################
+#####						#####
+#####	     V810 Family SLEIGH specification 	#####
+#####						#####
+#####################################################
+
+define endian = little;
+define alignment = 2;
+
+# Size & default are required
+define space  ram       type=ram_space      size=4  default;
+define space  port      type=ram_space      size=4;
+define space  register  type=register_space size=4;
+
+@define V810 1
+
+#####################################################
+#####	     		Helpers 		#####
+#####################################################
+
+@include "./Helpers/Register.sinc"
+@include "./Helpers/Tokens.sinc"
+@include "./Helpers/Variables.sinc"
+@include "./Helpers/Conditions.sinc"
+@include "./Helpers/Macros.sinc"
+@include "./Helpers/Extras.sinc"
+
+
+
+#####################################################
+#####	     	    Instructions		#####
+#####################################################
+
+@include "./Instructions/Arithmetic.sinc"
+@include "./Instructions/Input_Output.sinc"
+@include "./Instructions/Load_Store.sinc"
+@include "./Instructions/Logic.sinc"
+@include "./Instructions/Special.sinc"
+@include "./Instructions/Floats.sinc"
diff --git a/Ghidra/Processors/V800/data/languages/V830.cspec b/Ghidra/Processors/V800/data/languages/V830.cspec
new file mode 100644
index 0000000000..da424de157
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/V830.cspec
@@ -0,0 +1,68 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<compiler_spec>
+
+  <global>
+    <range space="ram"/>
+    <range space="port"/>
+  </global>
+
+  <stackpointer register="sp" space="ram"/>
+
+  <default_proto>
+    <prototype name="__stdcall" extrapop="0" stackshift="0">
+
+      <input>
+        <pentry minsize="1" maxsize="4">
+          <register name="r6"/>
+        </pentry>
+
+        <pentry minsize="1" maxsize="4">
+          <register name="r7"/>
+        </pentry>
+
+        <pentry minsize="1" maxsize="4">
+          <register name="r8"/>
+        </pentry>
+
+        <pentry minsize="1" maxsize="4">
+          <register name="r9"/>
+        </pentry>
+
+        <pentry minsize="1" maxsize="500" align="4">
+          <addr offset="0" space="stack"/>
+        </pentry>
+      </input>
+
+      <output>
+        <pentry minsize="1" maxsize="4">
+          <register name="r10"/>
+        </pentry>
+
+         <pentry minsize="5" maxsize="8">
+          <addr space="join" piece1="r10" piece2="r11"/>
+        </pentry>
+      </output>
+
+      <unaffected>
+        <register name="r20"/>
+        <register name="r21"/>
+        <register name="r22"/>
+        <register name="r23"/>
+        <register name="r24"/>
+        <register name="r25"/>
+        <register name="r26"/>
+        <register name="r27"/>
+        <register name="r28"/>
+        <register name="r29"/>
+        <register name="mp"/>
+        <register name="lp"/>
+        <register name="sp"/>
+        <register name="gp"/>
+        <register name="tp"/>
+      </unaffected>
+
+    </prototype>
+  </default_proto>
+
+</compiler_spec>
diff --git a/Ghidra/Processors/V800/data/languages/V830.pspec b/Ghidra/Processors/V800/data/languages/V830.pspec
new file mode 100644
index 0000000000..02fa9403d9
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/V830.pspec
@@ -0,0 +1,13 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<processor_spec>
+
+  <programcounter register="PC"/>
+
+  <data_space space="ram"/>
+
+  <volatile outputop="write" inputop="read">
+    <range space="ram" first="0x0" last="0x20"/>
+  </volatile>
+
+</processor_spec>
diff --git a/Ghidra/Processors/V800/data/languages/V830.slaspec b/Ghidra/Processors/V800/data/languages/V830.slaspec
new file mode 100644
index 0000000000..66ace67359
--- /dev/null
+++ b/Ghidra/Processors/V800/data/languages/V830.slaspec
@@ -0,0 +1,38 @@
+#####################################################
+#####						#####
+#####	     V830 Family SLEIGH specification 	#####
+#####						#####
+#####################################################
+
+define endian = little;
+define alignment = 2;
+
+# Size & default are required
+define space  ram       type=ram_space      size=4  default;
+define space  port      type=ram_space      size=4;
+define space  register  type=register_space size=4;
+
+@define V830 1
+
+#####################################################
+#####	     		Helpers 		#####
+#####################################################
+
+@include "./Helpers/Register.sinc"
+@include "./Helpers/Tokens.sinc"
+@include "./Helpers/Variables.sinc"
+@include "./Helpers/Conditions.sinc"
+@include "./Helpers/Macros.sinc"
+@include "./Helpers/Extras.sinc"
+
+
+
+#####################################################
+#####	     	    Instructions		#####
+#####################################################
+
+@include "./Instructions/Arithmetic.sinc"
+@include "./Instructions/Input_Output.sinc"
+@include "./Instructions/Load_Store.sinc"
+@include "./Instructions/Logic.sinc"
+@include "./Instructions/Special.sinc"
diff --git a/Ghidra/Processors/V800/data/manuals/v810.idx b/Ghidra/Processors/V800/data/manuals/v810.idx
new file mode 100644
index 0000000000..ba98f80f4e
--- /dev/null
+++ b/Ghidra/Processors/V800/data/manuals/v810.idx
@@ -0,0 +1,66 @@
+@u10082ej1v0um00.pdf [V810 FAMILY Architecture UM]
+
+ADD, 50
+ADDF.S, 51
+ADDI, 53
+AND, 54
+ANDBSU, 55
+ANDI, 56
+ANDNBSU, 57
+Bcond, 58
+CAXI, 60
+CMP, 62
+CMPF.S, 63
+CVT.SW, 64
+CVT.WS, 66
+DIV, 67
+DIVF.S, 68
+DIVU, 70
+HALT, 71
+IN.B, 72
+IN.H, 72
+IN.W, 72
+JAL, 73
+JMP, 74
+JR, 75
+LD.B, 76
+LD.H, 76
+LD.W, 76
+LDSR, 77
+MOV, 78
+MOVBSU, 79
+MOVEA, 80
+MOVHI, 81
+MUL, 82
+MULF.S, 83
+MULU, 85
+NOT, 86
+NOTBSU, 87
+OR, 88
+ORBSU, 89
+ORI, 90
+ORNBSU, 91
+OUT.B, 92
+OUT.H, 92
+OUT.W, 92
+RETI, 93
+SAR, 94
+SCH0BSU, 95
+SCH0BSD, 95
+SCH1BSU, 97
+SCH1BSD, 97
+SETF, 99
+SHL, 101
+SHR, 102
+ST.B, 103
+ST.H, 103
+ST.W, 103
+STSR, 104
+SUB, 105
+SUBF.S, 106
+TRAP, 108
+TRNC.SW, 110
+XOR, 112
+XORBSU, 113
+XORI, 114
+XORNBSU, 115
\ No newline at end of file
diff --git a/Ghidra/Processors/V800/data/manuals/v830.idx b/Ghidra/Processors/V800/data/manuals/v830.idx
new file mode 100644
index 0000000000..2c992d0022
--- /dev/null
+++ b/Ghidra/Processors/V800/data/manuals/v830.idx
@@ -0,0 +1,66 @@
+@REN_U12496EJ4V0UMJ1_MAT_20000801.pdf [V830 Family 32-Bit Microprocessor Architecture UM]
+
+ADD, 49
+ADDI, 50
+AND, 51
+ANDI, 52
+Bcond, 53
+BDLD, 55
+BDST, 56
+BILD, 57
+BIST, 58
+BRKRET, 59
+CAXI, 60
+CMP, 62
+DI, 63
+DIV, 64
+DIVU, 65
+EI, 66
+HALT, 67
+IN.B, 68
+IN.H, 68
+IN.W, 68
+JAL, 70
+JMP, 71
+JR, 72
+LD.B, 73
+LD.H, 73
+LD.W, 73
+LDSR, 75
+MAC3, 76
+MACI, 77
+MACT3, 78
+MAX3, 79
+MIN3, 80
+MOV, 81
+MOVEA, 82
+MOVHI, 83
+MUL, 84
+MUL3, 85
+MULI, 86
+MULT3, 87
+MULU, 88
+NOT, 89
+OR, 90
+ORI, 91
+OUT.B, 92
+OUT.H, 92
+OUT.W, 92
+RETI, 93
+SAR, 94
+SATADD3, 95
+SATSUB3, 96
+SETF, 97
+SHL, 99
+SHLD3, 100
+SHR, 101
+SHRD3, 102
+ST.B, 103
+ST.H, 103
+ST.W, 103
+STBY, 104
+STSR, 105
+SUB, 106
+TRAP, 107
+XOR, 109
+XORI, 110
\ No newline at end of file
-- 
2.45.1

