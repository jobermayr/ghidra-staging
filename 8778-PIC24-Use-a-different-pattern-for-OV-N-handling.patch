From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Michael Karcher <github@mkarcher.dialup.fu-berlin.de>
Date: Sun, 14 Dec 2025 21:50:06 +0100
Subject: [PATCH] 8778: PIC24: Use a different pattern for OV/N handling on
 signed compare

GP-8777 For PIC-24, use a different pattern for OV/N
 handling on signed compare

This allows the decompiler to detect signed compare operations correctly.

Add datatest for PIC ge comparison improvement
---
 .../src/decompile/datatests/pic_branch_ge.xml  | 18 ++++++++++++++++++
 .../Processors/PIC/data/languages/PIC24.sinc   |  6 +++---
 2 files changed, 21 insertions(+), 3 deletions(-)
 create mode 100644 Ghidra/Features/Decompiler/src/decompile/datatests/pic_branch_ge.xml

diff --git a/Ghidra/Features/Decompiler/src/decompile/datatests/pic_branch_ge.xml b/Ghidra/Features/Decompiler/src/decompile/datatests/pic_branch_ge.xml
new file mode 100644
index 0000000000..3ecec34ef9
--- /dev/null
+++ b/Ghidra/Features/Decompiler/src/decompile/datatests/pic_branch_ge.xml
@@ -0,0 +1,18 @@
+<decompilertest>
+<binaryimage arch="PIC-24F:LE:24:default">
+<bytechunk space="rom" offset="0">
+02002000730020000306510004003D00
+000020000004880061014100FAFF3700
+00000600
+</bytechunk>
+<symbol space="rom" offset="0" name="f"/>
+</binaryimage>
+<script>
+<com>lo fu f</com>
+<com>dec</com>
+<com>print C</com>
+<com>quit</com>
+</script>
+<stringmatch name="PIC greater-or-equal recognized #1" min="1" max="1">&lt; 7;</stringmatch>
+<stringmatch name="PiC greater-or-equal recognized #2" min="0" max="0">SBORROW</stringmatch>
+</decompilertest>
diff --git a/Ghidra/Processors/PIC/data/languages/PIC24.sinc b/Ghidra/Processors/PIC/data/languages/PIC24.sinc
index c31fcbf81e..af1c8f77cd 100644
--- a/Ghidra/Processors/PIC/data/languages/PIC24.sinc
+++ b/Ghidra/Processors/PIC/data/languages/PIC24.sinc
@@ -2044,16 +2044,16 @@ define pcodeop bootswap;
 
 
 cond1: "c" is  TOK_CCCC=0x1 { tmpBool:1 = SRL_C; export tmpBool; }
-cond1: "ge" is  TOK_CCCC=0xD { tmpBool:1 = ((SRL_N && SRL_OV) || (!SRL_N && !SRL_OV)); export tmpBool; }
+cond1: "ge" is  TOK_CCCC=0xD { tmpBool:1 = SRL_N == SRL_OV; export tmpBool; }
 #Note: same as branch C, not supported in disassembly
 # cond1: "geu" is  TOK_CCCC=0x1 { tmpBool:1 = SRL_C ); export tmpBool; }
 cond1: "gt" is  TOK_CCCC=0xC
-                { tmpBool:1 = ((!SRL_Z && SRL_N && SRL_OV) || (!SRL_Z && !SRL_N && !SRL_OV)); export tmpBool; }
+                { tmpBool:1 = (!SRL_Z && (SRL_N == SRL_OV)); export tmpBool; }
 cond1: "gtu" is  TOK_CCCC=0xE { tmpBool:1 = SRL_C && !SRL_Z; export tmpBool; }
 cond1: "le" is  TOK_CCCC=0x4
                 { tmpBool:1 = (SRL_Z || (SRL_N != SRL_OV)); export tmpBool; }
 cond1: "leu" is  TOK_CCCC=0x6 { tmpBool:1 = (!SRL_C || SRL_Z); export tmpBool; }
-cond1: "lt" is  TOK_CCCC=0x5 { tmpBool:1 = ((SRL_N && !SRL_OV) || (!SRL_N && SRL_OV)); export tmpBool; }
+cond1: "lt" is  TOK_CCCC=0x5 { tmpBool:1 = SRL_N != SRL_OV; export tmpBool; }
 cond1: "n" is  TOK_CCCC=0x3 { tmpBool:1 = (SRL_N); export tmpBool; }
 cond1: "nc" is  TOK_CCCC=0x9 { tmpBool:1 = (!SRL_C); export tmpBool; }
 cond1: "nn" is  TOK_CCCC=0xB { tmpBool:1 = (!SRL_N); export tmpBool; }
-- 
2.45.1

