From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: liushuyu <liushuyu011@gmail.com>
Date: Sat, 2 Aug 2025 09:31:45 +0800
Subject: [PATCH] 8444: Add Loongarch64 SIMD and PLT analysis

Loongarch: add Loongarch64 PLT analysis

Loongarch: add Loongarch64 LSX load/store instructions modelling

Loongarch: add LSX SIMD immediate load modelling
---
 Ghidra/Processors/Loongarch/build.gradle      |   1 +
 .../Loongarch/certification.manifest          |   1 +
 .../languages/loongarch32_instructions.sinc   |   5 +
 .../data/languages/loongarch_main.sinc        |  20 +-
 .../Loongarch/data/languages/lsx.sinc         | 275 ++++++++++++-----
 .../Loongarch/data/loongarch-pltThunks.xml    |  14 +
 .../data/patterns/loongarch_patterns.xml      |  13 +-
 .../analysis/LoongArchCallStubAnalyzer.java   | 283 ++++++++++++++++++
 8 files changed, 530 insertions(+), 82 deletions(-)
 create mode 100644 Ghidra/Processors/Loongarch/data/loongarch-pltThunks.xml
 create mode 100644 Ghidra/Processors/Loongarch/src/main/java/ghidra/app/plugin/core/analysis/LoongArchCallStubAnalyzer.java

diff --git a/Ghidra/Processors/Loongarch/build.gradle b/Ghidra/Processors/Loongarch/build.gradle
index 4c3d1333b5..a76e47a759 100644
--- a/Ghidra/Processors/Loongarch/build.gradle
+++ b/Ghidra/Processors/Loongarch/build.gradle
@@ -24,4 +24,5 @@ eclipse.project.name = 'Processors Loongarch'
 
 dependencies {
 	api project(':Base')
+	api project(':BytePatterns')
 }
diff --git a/Ghidra/Processors/Loongarch/certification.manifest b/Ghidra/Processors/Loongarch/certification.manifest
index 4d37fb78cd..3e221b7590 100644
--- a/Ghidra/Processors/Loongarch/certification.manifest
+++ b/Ghidra/Processors/Loongarch/certification.manifest
@@ -1,6 +1,7 @@
 ##VERSION: 2.0
 Module.manifest||GHIDRA||||END|
 README.md||GHIDRA||||END|
+data/loongarch-pltThunks.xml||GHIDRA||||END|
 data/languages/ilp32d.cspec||GHIDRA||||END|
 data/languages/ilp32f.cspec||GHIDRA||||END|
 data/languages/lasx.sinc||GHIDRA||||END|
diff --git a/Ghidra/Processors/Loongarch/data/languages/loongarch32_instructions.sinc b/Ghidra/Processors/Loongarch/data/languages/loongarch32_instructions.sinc
index 5d18bee31d..dc44235bde 100644
--- a/Ghidra/Processors/Loongarch/data/languages/loongarch32_instructions.sinc
+++ b/Ghidra/Processors/Loongarch/data/languages/loongarch32_instructions.sinc
@@ -656,6 +656,11 @@
 #0x4c000000	0xfc000000	r0:5,r5:5,so10:16<<2	['reg0_5_s0', 'reg5_5_s0', 'soffs10_16_s0']
 :jirl  RD, RelJ16              is op26_31=0x13 & RD & RJsrc & RelJ16 {
 	RD = inst_next;
+	if (RD != 1) goto <label1>;
+	<label1>
+	goto [RelJ16];
+	if (RD == 1) goto <label2>;
+	<label2>
 	call [RelJ16];
 }
 
diff --git a/Ghidra/Processors/Loongarch/data/languages/loongarch_main.sinc b/Ghidra/Processors/Loongarch/data/languages/loongarch_main.sinc
index 1827d43817..4f413c9a55 100644
--- a/Ghidra/Processors/Loongarch/data/languages/loongarch_main.sinc
+++ b/Ghidra/Processors/Loongarch/data/languages/loongarch_main.sinc
@@ -114,7 +114,7 @@ define register offset=0x1000 size=8 [
 
 @endif #FREGSIZE == 32
 
-# SIMD eXtension 256-bit registers (lsx)
+# SIMD eXtension 128-bit registers (lsx)
 # overlaps the floating point registers above
 define register offset=0x1000 size=16 [
 	v0  _   v1  _   v2  _   v3  _   v4  _   v5  _   v6  _   v7  _
@@ -469,6 +469,16 @@ simm32i: immed  is simm5_20  [immed = simm5_20  << 32; ] { export *[const]:$(REG
 
 simm52i: immed  is simm10_12 [immed = simm10_12 << 52; ] { export *[const]:$(REGSIZE) immed; }
 
+vrD.B.imm18_4: vrD, val is vrD & imm18_4 [ val = 0x1000 + 32*vrD + imm18_4; ] { export *[register]:1 val; }
+vrD.H.imm18_3: vrD, val is vrD & imm18_3 [ val = 0x1000 + 32*vrD + 2*imm18_3; ] { export *[register]:2 val; }
+vrD.W.imm18_2: vrD, val is vrD & imm18_2 [ val = 0x1000 + 32*vrD + 4*imm18_2; ] { export *[register]:4 val; }
+vrD.D.imm18_1: vrD, val is vrD & imm18_1 [ val = 0x1000 + 32*vrD + 8*imm18_1; ] { export *[register]:8 val; }
+
+vrJ.B.imm18_4: vrJ, val is vrJ & imm18_4 [ val = 0x1000 + 32*vrJ + imm18_4; ] { export *[register]:1 val; }
+vrJ.H.imm18_3: vrJ, val is vrJ & imm18_3 [ val = 0x1000 + 32*vrJ + 2*imm18_3; ] { export *[register]:2 val; }
+vrJ.W.imm18_2: vrJ, val is vrJ & imm18_2 [ val = 0x1000 + 32*vrJ + 4*imm18_2; ] { export *[register]:4 val; }
+vrJ.D.imm18_1: vrJ, val is vrJ & imm18_1 [ val = 0x1000 + 32*vrJ + 8*imm18_1; ] { export *[register]:8 val; }
+
 # general pcodeops
 define pcodeop break;
 define pcodeop cpucfg;
@@ -576,3 +586,11 @@ macro tzcount64(input, count) {
 	count = count -  1 * zext((v & 0x5555555555555555) != 0);
 }
 
+macro select_value(cond, a, b, value) {
+	if (cond == 0) goto <l1>;
+	goto <l2>;
+	<l1>
+	value = b;
+	<l2>
+	value = a;
+}
diff --git a/Ghidra/Processors/Loongarch/data/languages/lsx.sinc b/Ghidra/Processors/Loongarch/data/languages/lsx.sinc
index 936d63a24b..17e3d8914a 100644
--- a/Ghidra/Processors/Loongarch/data/languages/lsx.sinc
+++ b/Ghidra/Processors/Loongarch/data/languages/lsx.sinc
@@ -430,100 +430,110 @@ define pcodeop vshuf.b;
 	vrD = vshuf.b(vrD, vrJ, vrK, vrA);
 }
 
-define pcodeop vld;
-
 #lsx.txt vld mask=0x2c000000	
 #0x2c000000	0xffc00000	v0:5, r5:5, so10:12	['vreg0_5_s0', 'reg5_5_s0', 'soffs10_12_s0']
-:vld vrD, RJsrc, simm10_12            is op22_31=0xb0 & vrD & RJsrc & simm10_12 {
-	vrD = vld(vrD, RJsrc, simm10_12:$(REGSIZE));
+:vld vrD, ldst_addr                   is op22_31=0xb0 & vrD & RJsrc & ldst_addr {
+	vrD = *[ram]:16 ldst_addr;
 }
 
-define pcodeop vst;
-
 #lsx.txt vst mask=0x2c400000	
 #0x2c400000	0xffc00000	v0:5, r5:5, so10:12	['vreg0_5_s0', 'reg5_5_s0', 'soffs10_12_s0']
-:vst vrD, RJsrc, simm10_12            is op22_31=0xb1 & vrD & RJsrc & simm10_12 {
-	vrD = vst(vrD, RJsrc, simm10_12:$(REGSIZE));
+:vst vrD, ldst_addr                   is op22_31=0xb1 & vrD & RJsrc & ldst_addr {
+	*[ram]:16 ldst_addr = vrD;
 }
 
-define pcodeop vldrepl.d;
-
 #lsx.txt vldrepl.d mask=0x30100000	[@orig_fmt=VdJSk9ps3]
 #0x30100000	0xfff80000	v0:5, r5:5, so10:9<<3	['vreg0_5_s0', 'reg5_5_s0', 'soffs10_9_s0']
-:vldrepl.d vrD, RJsrc, simm10_9       is op19_31=0x602 & vrD & RJsrc & simm10_9 {
-	vrD = vldrepl.d(vrD, RJsrc, simm10_9:$(REGSIZE));
+:vldrepl.d vrD, ldst_addr             is op19_31=0x602 & vrD & RJsrc & ldst_addr {
+	local TMPD1:8 = *[ram]:8 ldst_addr;
+	vrD[0,64] = TMPD1;
+	vrD[64,64] = TMPD1;
 }
 
-define pcodeop vldrepl.w;
-
 #lsx.txt vldrepl.w mask=0x30200000	[@orig_fmt=VdJSk10ps2]
 #0x30200000	0xfff00000	v0:5, r5:5, so10:10<<2	['vreg0_5_s0', 'reg5_5_s0', 'soffs10_10_s0']
-:vldrepl.w vrD, RJsrc, simm10_10      is op20_31=0x302 & vrD & RJsrc & simm10_10 {
-	vrD = vldrepl.w(vrD, RJsrc, simm10_10:$(REGSIZE));
+:vldrepl.w vrD, ldst_addr             is op20_31=0x302 & vrD & RJsrc & ldst_addr {
+	local TMPW1:4 = *[ram]:4 ldst_addr;
+	vrD[0,32] = TMPW1;
+	vrD[32,32] = TMPW1;
+	vrD[64,32] = TMPW1;
+	vrD[96,32] = TMPW1;
 }
 
-define pcodeop vldrepl.h;
-
 #lsx.txt vldrepl.h mask=0x30400000	[@orig_fmt=VdJSk11ps1]
 #0x30400000	0xffe00000	v0:5, r5:5, so10:11<<1	['vreg0_5_s0', 'reg5_5_s0', 'soffs10_11_s0']
-:vldrepl.h vrD, RJsrc, simm10_11      is op21_31=0x182 & vrD & RJsrc & simm10_11 {
-	vrD = vldrepl.h(vrD, RJsrc, simm10_11:$(REGSIZE));
-}
-
-define pcodeop vldrepl.b;
-
-#lsx.txt vldrepl.b mask=0x30800000	
+:vldrepl.h vrD, ldst_addr             is op21_31=0x182 & vrD & RJsrc & ldst_addr {
+	local TMPH1:2 = *[ram]:2 ldst_addr;
+	vrD[0,16] = TMPH1;
+	vrD[16,16] = TMPH1;
+	vrD[32,16] = TMPH1;
+	vrD[48,16] = TMPH1;
+	vrD[64,16] = TMPH1;
+	vrD[80,16] = TMPH1;
+	vrD[96,16] = TMPH1;
+	vrD[112,16] = TMPH1;
+}
+
+#lsx.txt vldrepl.b mask=0x30800000
 #0x30800000	0xffc00000	v0:5, r5:5, so10:12	['vreg0_5_s0', 'reg5_5_s0', 'soffs10_12_s0']
-:vldrepl.b vrD, RJsrc, simm10_12      is op22_31=0xc2 & vrD & RJsrc & simm10_12 {
-	vrD = vldrepl.b(vrD, RJsrc, simm10_12:$(REGSIZE));
+:vldrepl.b vrD, ldst_addr             is op22_31=0xc2 & vrD & RJsrc & ldst_addr {
+	local TMPB1:1 = *[ram]:1 ldst_addr;
+	vrD[0,8] = TMPB1;
+	vrD[8,8] = TMPB1;
+	vrD[16,8] = TMPB1;
+	vrD[24,8] = TMPB1;
+	vrD[32,8] = TMPB1;
+	vrD[40,8] = TMPB1;
+	vrD[48,8] = TMPB1;
+	vrD[56,8] = TMPB1;
+	vrD[64,8] = TMPB1;
+	vrD[72,8] = TMPB1;
+	vrD[80,8] = TMPB1;
+	vrD[88,8] = TMPB1;
+	vrD[96,8] = TMPB1;
+	vrD[104,8] = TMPB1;
+	vrD[112,8] = TMPB1;
+	vrD[120,8] = TMPB1;
 }
 
-define pcodeop vstelm.d;
-
 #lsx.txt vstelm.d mask=0x31100000	[@orig_fmt=VdJSk8ps3Un1]
 #0x31100000	0xfff80000	v0:5, r5:5, so10:8<<3,u18:1	['vreg0_5_s0', 'reg5_5_s0', 'soffs10_8_s0', 'imm18_1_s0']
-:vstelm.d vrD, RJsrc, simm10_8, imm18_1  is op19_31=0x622 & vrD & RJsrc & simm10_8 & imm18_1 {
-	vrD = vstelm.d(vrD, RJsrc, simm10_8:$(REGSIZE), imm18_1:$(REGSIZE));
+:vstelm.d vrD.D.imm18_1, ldst_addr   is op19_31=0x622 & vrD.D.imm18_1 & RJsrc & ldst_addr {
+	local tmp1:8 = vrD.D.imm18_1;
+	*[ram]:8 ldst_addr = tmp1;
 }
 
-define pcodeop vstelm.w;
-
 #lsx.txt vstelm.w mask=0x31200000	[@orig_fmt=VdJSk8ps2Un2]
 #0x31200000	0xfff00000	v0:5, r5:5, so10:8<<2,u18:2	['vreg0_5_s0', 'reg5_5_s0', 'soffs10_8_s0', 'imm18_2_s0']
-:vstelm.w vrD, RJsrc, simm10_8, imm18_2  is op20_31=0x312 & vrD & RJsrc & simm10_8 & imm18_2 {
-	vrD = vstelm.w(vrD, RJsrc, simm10_8:$(REGSIZE), imm18_2:$(REGSIZE));
+:vstelm.w vrD.W.imm18_2, ldst_addr   is op20_31=0x312 & vrD.W.imm18_2 & RJsrc & ldst_addr {
+	local tmp1:4 = vrD.W.imm18_2;
+    *[ram]:4 ldst_addr = tmp1;
 }
 
-define pcodeop vstelm.h;
-
 #lsx.txt vstelm.h mask=0x31400000	[@orig_fmt=VdJSk8ps1Un3]
 #0x31400000	0xffe00000	v0:5, r5:5, so10:8<<1,u18:3	['vreg0_5_s0', 'reg5_5_s0', 'soffs10_8_s0', 'imm18_3_s0']
-:vstelm.h vrD, RJsrc, simm10_8, imm18_3  is op21_31=0x18a & vrD & RJsrc & simm10_8 & imm18_3 {
-	vrD = vstelm.h(vrD, RJsrc, simm10_8:$(REGSIZE), imm18_3:$(REGSIZE));
+:vstelm.h vrD.H.imm18_3, ldst_addr   is op21_31=0x18a & vrD.H.imm18_3 & RJsrc & ldst_addr {
+	local tmp1:2 = vrD.H.imm18_3;
+    *[ram]:2 ldst_addr = tmp1;
 }
 
-define pcodeop vstelm.b;
-
-#lsx.txt vstelm.b mask=0x31800000	
+#lsx.txt vstelm.b mask=0x31800000
 #0x31800000	0xffc00000	v0:5, r5:5, so10:8,u18:4	['vreg0_5_s0', 'reg5_5_s0', 'soffs10_8_s0', 'imm18_4_s0']
-:vstelm.b vrD, RJsrc, simm10_8, imm18_4  is op22_31=0xc6 & vrD & RJsrc & simm10_8 & imm18_4 {
-	vrD = vstelm.b(vrD, RJsrc, simm10_8:$(REGSIZE), imm18_4:$(REGSIZE));
+:vstelm.b vrD.B.imm18_4, ldst_addr    is op22_31=0xc6 & vrD.B.imm18_4 & RJsrc & ldst_addr {
+	local tmp1:1 = vrD.B.imm18_4;
+    *[ram]:1 ldst_addr = tmp1;
 }
 
-define pcodeop vldx;
-
-#lsx.txt vldx mask=0x38400000	
+#lsx.txt vldx mask=0x38400000
 #0x38400000	0xffff8000	v0:5, r5:5, r10:5	['vreg0_5_s0', 'reg5_5_s0', 'reg10_5_s0']
-:vldx vrD, RJsrc, RKsrc               is op15_31=0x7080 & vrD & RJsrc & RKsrc {
-	vrD = vldx(vrD, RJsrc, RKsrc);
+:vldx vrD, ldstx_addr               is op15_31=0x7080 & vrD & RJsrc & RKsrc & ldstx_addr {
+	vrD = *[ram]:16 ldstx_addr;
 }
 
-define pcodeop vstx;
-
 #lsx.txt vstx mask=0x38440000	
 #0x38440000	0xffff8000	v0:5, r5:5, r10:5	['vreg0_5_s0', 'reg5_5_s0', 'reg10_5_s0']
-:vstx vrD, RJsrc, RKsrc               is op15_31=0x7088 & vrD & RJsrc & RKsrc {
-	vrD = vstx(vrD, RJsrc, RKsrc);
+:vstx vrD, ldstx_addr               is op15_31=0x7088 & vrD & RJsrc & RKsrc & ldstx_addr {
+	*[ram]:16 ldstx_addr = vrD;
 }
 
 define pcodeop vseq.b;
@@ -4555,7 +4565,14 @@ define pcodeop vexth.h.b;
 #lsx.txt vexth.h.b mask=0x729ee000	
 #0x729ee000	0xfffffc00	v0:5,v5:5	['vreg0_5_s0', 'vreg5_5_s0']
 :vexth.h.b vrD, vrJ                   is op10_31=0x1ca7b8 & vrD & vrJ {
-	vrD = vexth.h.b(vrD, vrJ);
+	vrD[0,16] = sext(vrJ[64,8]);
+	vrD[16,16] = sext(vrJ[72,8]);
+	vrD[32,16] = sext(vrJ[80,8]);
+	vrD[48,16] = sext(vrJ[88,8]);
+	vrD[64,16] = sext(vrJ[96,8]);
+	vrD[80,16] = sext(vrJ[104,8]);
+	vrD[96,16] = sext(vrJ[112,8]);
+	vrD[112,16] = sext(vrJ[120,8]);
 }
 
 define pcodeop vexth.w.h;
@@ -4774,36 +4791,33 @@ define pcodeop vinsgr2vr.d;
 	vrD = vinsgr2vr.d(vrD, RJsrc, imm10_1:$(REGSIZE));
 }
 
-define pcodeop vpickve2gr.b;
-
-#lsx.txt vpickve2gr.b mask=0x72ef8000	
+#lsx.txt vpickve2gr.b mask=0x72ef8000
 #0x72ef8000	0xffffc000	r0:5,v5:5,u10:4	['reg0_5_s0', 'vreg5_5_s0', 'imm10_4_s0']
-:vpickve2gr.b RD, vrJ, imm10_4        is op14_31=0x1cbbe & RD & vrJ & imm10_4 {
-	RD = vpickve2gr.b(RD, vrJ, imm10_4:$(REGSIZE));
+:vpickve2gr.b RD, vrJ.B.imm18_4       is op14_31=0x1cbbe & RD & vrJ.B.imm18_4 & vrJ & imm10_4 {
+	RD = sext(vrJ.B.imm18_4);
 }
 
-define pcodeop vpickve2gr.h;
-
-#lsx.txt vpickve2gr.h mask=0x72efc000	
+#lsx.txt vpickve2gr.h mask=0x72efc000
 #0x72efc000	0xffffe000	r0:5,v5:5,u10:3	['reg0_5_s0', 'vreg5_5_s0', 'imm10_3_s0']
-:vpickve2gr.h RD, vrJ, imm10_3        is op13_31=0x3977e & RD & vrJ & imm10_3 {
-	RD = vpickve2gr.h(RD, vrJ, imm10_3:$(REGSIZE));
+:vpickve2gr.h RD, vrJ.H.imm18_3       is op13_31=0x3977e & RD & vrJ.H.imm18_3 & vrJ & imm10_3 {
+	RD = sext(vrJ.H.imm18_3);
 }
 
-define pcodeop vpickve2gr.w;
-
-#lsx.txt vpickve2gr.w mask=0x72efe000	
+#lsx.txt vpickve2gr.w mask=0x72efe000
 #0x72efe000	0xfffff000	r0:5,v5:5,u10:2	['reg0_5_s0', 'vreg5_5_s0', 'imm10_2_s0']
-:vpickve2gr.w RD, vrJ, imm10_2        is op12_31=0x72efe & RD & vrJ & imm10_2 {
-	RD = vpickve2gr.w(RD, vrJ, imm10_2:$(REGSIZE));
+:vpickve2gr.w RD, vrJ.W.imm18_2        is op12_31=0x72efe & RD & vrJ.W.imm18_2 & vrJ & imm10_2 {
+	RD = sext(vrJ.W.imm18_2);
 }
 
 define pcodeop vpickve2gr.d;
-
-#lsx.txt vpickve2gr.d mask=0x72eff000	
+#lsx.txt vpickve2gr.d mask=0x72eff000
 #0x72eff000	0xfffff800	r0:5,v5:5,u10:1	['reg0_5_s0', 'vreg5_5_s0', 'imm10_1_s0']
-:vpickve2gr.d RD, vrJ, imm10_1        is op11_31=0xe5dfe & RD & vrJ & imm10_1 {
+:vpickve2gr.d RD, vrJ.D.imm18_1        is op11_31=0xe5dfe & RD & vrJ.D.imm18_1 & vrJ & imm10_1 {
+@ifdef LA64
+	RD = sext(vrJ.D.imm18_1);
+@else
 	RD = vpickve2gr.d(RD, vrJ, imm10_1:$(REGSIZE));
+@endif
 }
 
 define pcodeop vpickve2gr.bu;
@@ -5678,19 +5692,122 @@ define pcodeop vnori.b;
 	vrD = vnori.b(vrD, vrJ, imm10_8:$(REGSIZE));
 }
 
-define pcodeop vldi;
-
 #lsx.txt vldi mask=0x73e00000	
 #0x73e00000	0xfffc0000	v0:5, s5:13	['vreg0_5_s0', 'simm5_13_s0']
 :vldi vrD, simm5_13                   is op18_31=0x1cf8 & vrD & simm5_13 {
-	vrD = vldi(vrD, simm5_13:$(REGSIZE));
+	local tmp2:8 = simm5_13:8;
+	local tmp3:4 = 0;
+	local tmp4:8 = 0;
+	local tmp5:8 = 0;
+	local tmp6:8 = 0;
+	local tmp7:8 = 0;
+	local tmp8:8 = 0;
+	vrD[0,64] = 0x0;
+	tmp4 = zext(tmp2);
+	vrD[64,64] = 0x0;
+	tmp5 = ((tmp4 << 0x36) s>> 0x36);
+	local tmp9:8 = (tmp2 >> 10) & 7;
+	if (tmp9 == 0) goto <block_8>;
+	if (tmp9 == 1) goto <block_10>;
+	if (tmp9 == 2) goto <block_12>;
+	if (tmp9 == 3) goto <block_14>;
+	goto <block_0>;
+	<block_0>
+	tmp6 = (tmp2 << 24);
+	tmp7 = zext(tmp2 & 63);
+	tmp5 = zext(tmp2 & 255);
+	tmp8 = zext((tmp2 >> 6) & 1);
+	local tmp10:8 = ((tmp2 >> 8) & 31) - 17;
+	if (tmp10 == 0) goto <block_11>;
+	if (tmp10 == 1) goto <block_1>;
+	if (tmp10 == 2) goto <block_2>;
+	if (tmp10 == 3) goto <block_10>;
+	if (tmp10 == 4) goto <block_9>;
+	if (tmp10 == 5) goto <block_3>;
+	if (tmp10 == 6) goto <block_4>;
+	if (tmp10 == 7) goto <block_8>;
+	if (tmp10 == 8) goto <block_13>;
+	if (tmp10 == 9) goto <block_5>;
+	if (tmp10 == 10) goto <block_6>;
+	if (tmp10 == 11) goto <block_7>;
+	goto <block_12>;
+	<block_1>
+	tmp5 = tmp5 << 0x10;
+	goto <block_12>;
+	<block_2>
+	tmp5 = tmp5 << 0x18;
+	goto <block_12>;
+	<block_3>
+	tmp5 = (tmp5 << 0x8) | 0xff;
+	goto <block_12>;
+	<block_4>
+	tmp5 = (tmp5 << 0x10) | 0xffff;
+	goto <block_12>;
+	<block_5>
+	tmp5 = ((tmp8 * 0x3e000000) | zext(((tmp6 & 0xc0000000) ^ 0x40000000))) | (tmp7 << 0x13);
+	goto <block_12>;
+	<block_6>
+	tmp5 = ((tmp8 * 0x3e000000) | zext(((tmp6 & 0xc0000000) ^ 0x40000000))) | (tmp7 << 0x13);
+	goto <block_14>;
+	<block_7>
+	tmp5 = (((tmp8 * 0x3fc0000000000000) | ((tmp4 << 0x38) & 0xc000000000000000)) | (tmp7 << 0x30)) ^ 0x4000000000000000;
+	goto <block_14>;
+	<block_8>
+	tmp5 = (tmp4 & 0xff) * 0x101010101010101;
+	vrD[64,64] = tmp5;
+	vrD[0,64] = tmp5;
+	goto <end>;
+	<block_9>
+	tmp5 = (tmp5 << 0x8);
+	<block_10>
+	tmp2 = tmp5;
+	vrD[112,16] = tmp2:2;
+	vrD[96,16] = tmp2:2;
+	vrD[80,16] = tmp2:2;
+	vrD[64,16] = tmp2:2;
+	vrD[48,16] = tmp2:2;
+	vrD[32,16] = tmp2:2;
+	vrD[16,16] = tmp2:2;
+	vrD[0,16] = tmp2:2;
+	goto <end>;
+	<block_11>
+	tmp5 = (tmp5 << 0x8);
+	<block_12>
+	tmp2 = tmp5;
+	vrD[96,32] = tmp2:4;
+	vrD[64,32] = tmp2:4;
+	vrD[32,32] = tmp2:4;
+	vrD[0,32] = tmp2:4;
+	goto <end>;
+	<block_13>
+	local b0:8 = 0;
+	local b1:8 = 0;
+	local b2:8 = 0;
+	select_value((tmp2 & 1), 0xff, 0x0, b0);
+	select_value((tmp2 & 2), 0xff00, 0x0, b1);
+	select_value((tmp2 & 4), 0xff0000, 0x0, b2);
+	tmp5 = ((((b1 | b0 | b2 | zext(((tmp2 << 28) s>> 7) & 0xff000000)) | (zext((tmp2 >> 4) & 1) * 0xff00000000)) | (zext(((tmp2 >> 5) & 1)) * 0xff0000000000)) | (tmp8 * 0xff000000000000)) + (zext(tmp6 s>> 31) << 0x38);
+	<block_14>
+	vrD[64,64] = tmp5;
+	vrD[0,64] = tmp5;
+	<end>
 }
 
-define pcodeop vpermi.w;
-
 #lsx.txt vpermi.w mask=0x73e40000	
 #0x73e40000	0xfffc0000	v0:5,v5:5,u10:8	['vreg0_5_s0', 'vreg5_5_s0', 'imm10_8_s0']
-:vpermi.w vrD, vrJ, imm10_8           is op18_31=0x1cf9 & vrD & vrJ & imm10_8 {
-	vrD = vpermi.w(vrD, vrJ, imm10_8:$(REGSIZE));
+:vpermi.w vrD, vrJ, imm10_8, vrDN, vrJN
+is op18_31=0x1cf9 & vrD & vrJ & imm10_8 [ vrDN = 0x1000 + 32*vrD; vrJN = 0x1000 + 32*vrJ; ] {
+    local tmp1_idx:4 = imm10_8 & 3;
+    local tmp2_idx:4 = (imm10_8 >> 2) & 3;
+    local tmp3_idx:4 = (imm10_8 >> 4) & 3;
+    local tmp4_idx:4 = (imm10_8 >> 6) & 3;
+    local tmp1:4 = *[register]:4 (vrJN + 4*tmp1_idx);
+    local tmp2:4 = *[register]:4 (vrJN + 4*tmp2_idx);
+    local tmp3:4 = *[register]:4 (vrDN + 4*tmp3_idx);
+    local tmp4:4 = *[register]:4 (vrDN + 4*tmp4_idx);
+	vrD[0,32] = tmp1;
+	vrD[32,32] = tmp2;
+	vrD[64,32] = tmp3;
+	vrD[96,32] = tmp4;
 }
 
diff --git a/Ghidra/Processors/Loongarch/data/loongarch-pltThunks.xml b/Ghidra/Processors/Loongarch/data/loongarch-pltThunks.xml
new file mode 100644
index 0000000000..4d81692ce9
--- /dev/null
+++ b/Ghidra/Processors/Loongarch/data/loongarch-pltThunks.xml
@@ -0,0 +1,14 @@
+<patternlist>
+    <!--
+    This file contains all known call stub (i.e., thunk) patterns which
+    utilize t1 and t3 register values in determining the thunked function
+    to which any given call stub branches.
+    -->
+<pattern> <!-- .plt entry thunk -->
+    <data>
+        ...01111 ........ ........ 0001110. # pcaddu12i t3, x
+        0xef ......01 11...... 0x28         # ld.ld t3, t3(x)
+        0xed 0x01 0x00 0x4c                 # jirl t1, t3, 0
+    </data>
+</pattern>
+</patternlist>
diff --git a/Ghidra/Processors/Loongarch/data/patterns/loongarch_patterns.xml b/Ghidra/Processors/Loongarch/data/patterns/loongarch_patterns.xml
index b96f9c6a32..e5b5db6633 100644
--- a/Ghidra/Processors/Loongarch/data/patterns/loongarch_patterns.xml
+++ b/Ghidra/Processors/Loongarch/data/patterns/loongarch_patterns.xml
@@ -34,5 +34,14 @@
       <possiblefuncstart/>
     </postpatterns>
   </patternpairs>
-  
-</patternlist>
\ No newline at end of file
+
+  <pattern> <!-- .plt entry thunk -->
+      <data>
+          ...01111 ........ ........ 0001110. <!-- pcaddu12i t3, x -->
+              0xef ......01 11...... 0x28     <!-- ld.ld t3, t3(x) -->
+              0xed 0x01 0x00 0x4c             <!-- jirl t1, t3, 0 -->
+      </data>
+    <codeboundary />  <!-- definitely code -->
+    <funcstart validcode="function" thunk="true"/>
+  </pattern>
+</patternlist>
diff --git a/Ghidra/Processors/Loongarch/src/main/java/ghidra/app/plugin/core/analysis/LoongArchCallStubAnalyzer.java b/Ghidra/Processors/Loongarch/src/main/java/ghidra/app/plugin/core/analysis/LoongArchCallStubAnalyzer.java
new file mode 100644
index 0000000000..9c996e0de3
--- /dev/null
+++ b/Ghidra/Processors/Loongarch/src/main/java/ghidra/app/plugin/core/analysis/LoongArchCallStubAnalyzer.java
@@ -0,0 +1,283 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.plugin.core.analysis;
+
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.ArrayList;
+
+import ghidra.program.model.scalar.Scalar;
+import org.xml.sax.SAXException;
+
+import generic.jar.ResourceFile;
+import ghidra.app.cmd.disassemble.DisassembleCommand;
+import ghidra.app.cmd.function.CreateFunctionCmd;
+import ghidra.app.cmd.function.CreateThunkFunctionCmd;
+import ghidra.app.services.*;
+import ghidra.app.util.importer.MessageLog;
+import ghidra.framework.Application;
+import ghidra.program.model.address.*;
+import ghidra.program.model.data.DataType;
+import ghidra.program.model.lang.*;
+import ghidra.program.model.listing.*;
+import ghidra.program.model.mem.*;
+import ghidra.program.model.symbol.RefType;
+import ghidra.program.util.*;
+import ghidra.util.Msg;
+import ghidra.util.bytesearch.*;
+import ghidra.util.exception.AssertException;
+import ghidra.util.exception.CancelledException;
+import ghidra.util.task.TaskMonitor;
+
+public class LoongArchCallStubAnalyzer extends AbstractAnalyzer {
+
+	private static final String NAME = "Loongarch ELF PLT Thunks";
+	private static final String DESCRIPTION = "Create Loongarch ELF PLT thunk functions";
+	private static final String PROCESSOR_NAME = "Loongarch";
+
+	private static final String PLT_THUNK_PATTERN_FILE = "loongarch-pltThunks.xml";
+
+	private static boolean patternLoadFailed;
+	private static ArrayList<Pattern> leThunkPatterns;
+	private static int maxPatternLength;
+
+	private Register t3Reg;
+
+	public LoongArchCallStubAnalyzer() {
+		super(NAME, DESCRIPTION, AnalyzerType.BYTE_ANALYZER); // assumes ELF Loader disassembled PLT section
+		setDefaultEnablement(true);
+		setPriority(AnalysisPriority.FORMAT_ANALYSIS);
+	}
+
+	@Override
+	public boolean canAnalyze(Program program) {
+		Language language = program.getLanguage();
+		// TODO: what about 32/64 hybrid case?
+		if (PROCESSOR_NAME.equals(language.getProcessor().toString()) &&
+				patternsLoaded(language.isBigEndian())) {
+			t3Reg = program.getRegister("t3");
+			return t3Reg != null;
+		}
+		return false;
+	}
+
+	private static synchronized boolean patternsLoaded(boolean bigEndian) {
+		if (patternLoadFailed) {
+			return false;
+		}
+		if (leThunkPatterns != null) {
+			return true;
+		}
+
+		try {
+			ResourceFile patternFile = Application.getModuleDataFile(PLT_THUNK_PATTERN_FILE);
+
+			leThunkPatterns = new ArrayList<>();
+			Pattern.readPatterns(patternFile, leThunkPatterns, null);
+
+			maxPatternLength = 0;
+			for (Pattern pattern : leThunkPatterns) {
+				int len = pattern.getSize();
+				if ((len % 4) != 0) {
+					throw new SAXException("pattern must contain multiple of 4-bytes");
+				}
+				if (len > maxPatternLength) {
+					maxPatternLength = len;
+				}
+			}
+
+		} catch (FileNotFoundException e) {
+			Msg.error(LoongArchCallStubAnalyzer.class, "Loongarch resource file not found: " + PLT_THUNK_PATTERN_FILE);
+			patternLoadFailed = true;
+			return false;
+		} catch (SAXException | IOException e) {
+			Msg.error(LoongArchCallStubAnalyzer.class, "Failed to parse byte pattern file: " + PLT_THUNK_PATTERN_FILE, e);
+			patternLoadFailed = true;
+			return false;
+		}
+
+		return true;
+	}
+
+	@Override
+	public boolean added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log)
+			throws CancelledException {
+
+		Memory memory = program.getMemory();
+		MemoryBlock block = memory.getBlock(".plt");
+		if (block == null) {
+			return true;
+		}
+
+		set = set.intersectRange(block.getStart(), block.getEnd());
+		set = removeFunctionBodies(program, set, monitor);
+		if (set.isEmpty()) {
+			return true;
+		}
+
+		SequenceSearchState sequenceSearchState = SequenceSearchState.buildStateMachine(
+				leThunkPatterns);
+
+		monitor.setIndeterminate(true);
+		monitor.setProgress(0);
+
+		ArrayList<Match> matches = new ArrayList<>();
+
+		try {
+			for (AddressRange range : set.getAddressRanges()) {
+
+				byte[] bytes = new byte[(int)range.getLength()];
+				if (block.getBytes(range.getMinAddress(), bytes, 0, bytes.length) != bytes.length) {
+					log.appendMsg("Expected initialized .plt section block");
+					return false;
+				}
+
+				matches.clear();
+				sequenceSearchState.apply(bytes, matches);
+
+				for (Match match : matches) {
+					Address addr = range.getMinAddress().add(match.getMarkOffset());
+					analyzePltThunk(program, addr, match.getSequenceSize(), monitor);
+				}
+
+			}
+		} catch (MemoryAccessException | AddressOutOfBoundsException e) {
+			log.appendMsg("Expected initialized .plt section block: " + e.getMessage());
+		}
+
+		return true;
+	}
+
+	private AddressSetView removeFunctionBodies(Program program, AddressSetView set, TaskMonitor monitor) throws CancelledException {
+		if (set.isEmpty()) {
+			return set;
+		}
+		// Only processing importer disassembly not yet claimed by function bodies
+		for (Function f : program.getFunctionManager().getFunctions(set, true)) {
+			monitor.checkCancelled();
+			set = set.subtract(f.getBody());
+		}
+		return set;
+	}
+
+	private void analyzePltThunk(Program program, Address entryAddr, int thunkSize, TaskMonitor monitor)
+			throws CancelledException {
+
+		SymbolicPropogator symEval = new SymbolicPropogator(program, false);
+		symEval.setParamRefCheck(false);
+		symEval.setReturnRefCheck(false);
+		symEval.setStoredRefCheck(false);
+
+		AddressSet thunkBody = new AddressSet(entryAddr, entryAddr.add(thunkSize - 1));
+
+		ContextEvaluator eval = new ContextEvaluatorAdapter() {
+
+			@Override
+			public boolean followFalseConditionalBranches() {
+				return false; // should never happen - just in case
+			}
+
+			@Override
+			public boolean evaluateReference(VarnodeContext context, Instruction instr, int pcodeop, Address address,
+											 int size, DataType dataType, RefType refType) {
+				return true;
+			}
+
+			@Override
+			public boolean evaluateDestination(VarnodeContext context, Instruction instruction) {
+
+				// We only handle indirect branch
+				if (!"jirl".equals(instruction.getMnemonicString())) {
+					return true;
+				}
+
+				// Change jirl flow to call-return
+				instruction.setFlowOverride(FlowOverride.CALL_RETURN);
+				Object[] opObjects = instruction.getOpObjects(1);
+				assert (opObjects.length == 2) : "jirl should have two input registers!";
+				Register targetReg = (Register) opObjects[0];
+				Scalar scalar = (Scalar) opObjects[1];
+				assert (targetReg != null);
+				assert (scalar != null) : "jirl should have an offset!";
+
+				RegisterValue targetValue = context.getRegisterValue(targetReg);
+				if (targetValue != null && targetValue.hasValue()) {
+					Address destAddr = entryAddr.getNewAddress(targetValue.getUnsignedValue().longValue() + scalar.getUnsignedValue());
+					Function thunkedFunction = createDestinationFunction(program, destAddr, instruction.getAddress(),
+							monitor);
+					if (thunkedFunction != null) {
+						CreateThunkFunctionCmd cmd = new CreateThunkFunctionCmd(entryAddr, thunkBody,
+								thunkedFunction.getEntryPoint());
+						cmd.applyTo(program);
+					}
+				}
+
+				return true;
+			}
+
+			@Override
+			public boolean allowAccess(VarnodeContext context, Address address) {
+				return true;
+			}
+		};
+
+		symEval.flowConstants(entryAddr, thunkBody, eval, false, monitor);
+	}
+
+	private Function createDestinationFunction(Program program, Address addr, Address flowFromAddr, TaskMonitor monitor) {
+
+		Listing listing = program.getListing();
+		BookmarkManager bookmarkMgr = program.getBookmarkManager();
+
+		if (!program.getMemory().contains(addr)) {
+			bookmarkMgr.setBookmark(flowFromAddr, BookmarkType.ERROR, "Bad Reference", "No memory for PLT Thunk destination at " + addr);
+			return null;
+		}
+
+		Function function = listing.getFunctionAt(addr);
+		if (function != null) {
+			return function;
+		}
+
+		CodeUnit cu = listing.getCodeUnitContaining(addr);
+		if (cu == null) {
+			throw new AssertException("expected code unit in memory");
+		}
+		if (!addr.equals(cu.getMinAddress())) {
+			bookmarkMgr.setBookmark(cu.getMinAddress(), BookmarkType.ERROR, "Code Unit Conflict",
+					"Expected function entry at " + addr + " referenced by PLT Thunk at " + flowFromAddr);
+			return null;
+		}
+		if (cu instanceof Data) {
+			Data d = (Data)cu;
+			if (d.isDefined()) {
+				bookmarkMgr.setBookmark(addr, BookmarkType.ERROR, "Code Unit Conflict", "Expected function entry referenced by PLT Thunk at " + flowFromAddr);
+				return null;
+			}
+			DisassembleCommand cmd = new DisassembleCommand(addr, null, true);
+			if (!cmd.applyTo(program, monitor)) {
+				return null;
+			}
+		}
+
+		CreateFunctionCmd cmd = new CreateFunctionCmd(addr);
+		if (cmd.applyTo(program, monitor)) {
+			return cmd.getFunction();
+		}
+		return null;
+	}
+
+}
-- 
2.45.1

