From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: plucia <plucia@mitre.org>
Date: Tue, 12 Sep 2023 16:28:19 -0400
Subject: [PATCH] 5801: Initial nearly-minimal changes to assembler for Pickled
 Canary

This starts to address issue #5800.

Remove developer docs from this branch

First naive pass at refactoring to a "WildcardedInstruction" interface rather than depending on querylanguage.
---
 .../SoftwareModeling/certification.manifest   |   1 +
 .../app/plugin/assembler/Assembler.java       |   8 +
 .../assembler/sleigh/SleighAssembler.java     |  38 ++
 .../assembler/sleigh/WildcardMetadata.java    |  17 +
 .../sleigh/WildcardedInstruction.java         |  13 +
 .../sleigh/expr/MultExpressionSolver.java     |   1 +
 .../sleigh/expr/OrExpressionSolver.java       |   8 +-
 .../sleigh/parse/AssemblyParseMachine.java    |   1 +
 .../parse/AssemblyParseMachineWild.java       | 458 ++++++++++++++
 .../sleigh/parse/AssemblyParser.java          |  29 +
 .../sleigh/sem/AssemblyOperandData.java       | 590 ++++++++++++++++++
 .../sleigh/sem/AssemblyOperandState.java      |  27 +
 .../sleigh/sem/AssemblyResolution.java        |  21 +
 .../sleigh/sem/AssemblyResolvedBackfill.java  |  14 +-
 .../sleigh/sem/AssemblyResolvedPatterns.java  |  54 +-
 .../sleigh/sem/AssemblyTreeResolver.java      |  35 +-
 .../assembler/sleigh/symbol/AssemblyEOI.java  |   8 +
 .../symbol/AssemblyNumericTerminal.java       | 134 ++++
 .../symbol/AssemblyStringMapTerminal.java     |  11 +
 .../sleigh/symbol/AssemblyStringTerminal.java |   6 +
 .../sleigh/symbol/AssemblyTerminal.java       |  10 +
 .../symbol/AssemblyWildcardTerminal.java      | 109 ++++
 .../sleigh/tree/AssemblyParseTreeNode.java    |  10 +
 .../assembler/sleigh/util/TableEntryKey.java  |   7 +-
 24 files changed, 1583 insertions(+), 27 deletions(-)
 create mode 100644 Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/WildcardMetadata.java
 create mode 100644 Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/WildcardedInstruction.java
 create mode 100644 Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/parse/AssemblyParseMachineWild.java
 create mode 100644 Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyOperandData.java
 create mode 100644 Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyWildcardTerminal.java

diff --git a/Ghidra/Framework/SoftwareModeling/certification.manifest b/Ghidra/Framework/SoftwareModeling/certification.manifest
index 167764640..66f649cfd 100644
--- a/Ghidra/Framework/SoftwareModeling/certification.manifest
+++ b/Ghidra/Framework/SoftwareModeling/certification.manifest
@@ -24,6 +24,7 @@ src/main/antlr/ghidra/sleigh/grammar/SleighCompiler.g||GHIDRA||||END|
 src/main/antlr/ghidra/sleigh/grammar/SleighEcho.g||GHIDRA||||END|
 src/main/antlr/ghidra/sleigh/grammar/SleighLexer.g||GHIDRA||||END|
 src/main/antlr/ghidra/sleigh/grammar/SleighParser.g||GHIDRA||||END|
+src/main/java/ghidra/app/plugin/assembler/README.md||GHIDRA||||END|
 src/main/java/ghidra/program/database/databaseTables.txt||GHIDRA||||END|
 src/main/java/ghidra/program/database/package.html||GHIDRA||||END|
 src/main/java/ghidra/program/model/address/package.html||GHIDRA||||END|
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/Assembler.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/Assembler.java
index 0c0e30d50..7793a7c31 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/Assembler.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/Assembler.java
@@ -19,11 +19,14 @@ import java.util.Collection;
 
 import ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseResult;
 import ghidra.app.plugin.assembler.sleigh.sem.*;
+import ghidra.app.plugin.assembler.sleigh.WildcardedInstruction;
+
 import ghidra.program.model.address.Address;
 import ghidra.program.model.address.AddressOverflowException;
 import ghidra.program.model.listing.Instruction;
 import ghidra.program.model.listing.InstructionIterator;
 import ghidra.program.model.mem.MemoryAccessException;
+import ghidra.util.task.TaskMonitor;
 
 /**
  * The primary interface for performing assembly in Ghidra.
@@ -111,6 +114,8 @@ public interface Assembler {
 	 */
 	public Collection<AssemblyParseResult> parseLine(String line);
 
+	public Collection<AssemblyParseResult> parseLine(WildcardedInstruction node, TaskMonitor monitor);
+
 	/**
 	 * Resolve a given parse tree at the given address, assuming the given context
 	 * 
@@ -164,6 +169,9 @@ public interface Assembler {
 	public AssemblyResolutionResults resolveLine(Address at, String line)
 			throws AssemblySyntaxException;
 
+	public AssemblyResolutionResults resolveLine(Address at, WildcardedInstruction line,
+			AssemblyPatternBlock ctx, TaskMonitor monitor) throws AssemblySyntaxException;
+
 	/**
 	 * Assemble a line instruction at the given address, assuming the given context.
 	 * 
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/SleighAssembler.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/SleighAssembler.java
index 25f8c8356..b5b7455f4 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/SleighAssembler.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/SleighAssembler.java
@@ -182,6 +182,12 @@ public class SleighAssembler implements Assembler {
 		return parser.parse(line, getNumericSymbols());
 	}
 
+	@Override
+	public Collection<AssemblyParseResult> parseLine(WildcardedInstruction line, TaskMonitor monitor) {
+		return parser.parse(line, getNumericSymbols(), monitor);
+	}
+
+
 	@Override
 	public AssemblyResolutionResults resolveTree(AssemblyParseResult parse, Address at) {
 		AssemblyPatternBlock ctx = getContextAt(at);
@@ -237,6 +243,38 @@ public class SleighAssembler implements Assembler {
 		return results;
 	}
 
+	@Override
+	public AssemblyResolutionResults resolveLine(Address at, WildcardedInstruction line,
+			AssemblyPatternBlock ctx, TaskMonitor monitor) throws AssemblySyntaxException {
+
+		if (!ctx.isFullMask()) {
+			throw new AssemblyError(
+				"Context must be fully-specified (full length, no shift, no unknowns)");
+		}
+		if (lang.getContextBaseRegister() != null &&
+			ctx.length() < lang.getContextBaseRegister().getMinimumByteSize()) {
+			throw new AssemblyError(
+				"Context must be fully-specified (full length, no shift, no unknowns)");
+		}
+		Collection<AssemblyParseResult> parse = parseLine(line, monitor);
+		if (monitor.isCancelled()) {
+			return new AssemblyResolutionResults();
+		}
+		parse = selector.filterParse(parse);
+		if (!parse.iterator().hasNext()) { // Iterator.isEmpty()???
+			throw new AssemblySelectionError(
+				"Must select at least one parse result. Report errors via AssemblySyntaxError");
+		}
+		AssemblyResolutionResults results = new AssemblyResolutionResults();
+		for (AssemblyParseResult p : parse) {
+			if (monitor.isCancelled()) {
+				return new AssemblyResolutionResults();
+			}
+			results.absorb(resolveTree(p, at, ctx));
+		}
+		return results;
+	}
+
 	@Override
 	public byte[] assembleLine(Address at, String line, AssemblyPatternBlock ctx)
 			throws AssemblySemanticException, AssemblySyntaxException {
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/WildcardMetadata.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/WildcardMetadata.java
new file mode 100644
index 000000000..3aad86a34
--- /dev/null
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/WildcardMetadata.java
@@ -0,0 +1,17 @@
+/* ###
+ * IP: GHIDRA
+ **/
+// Copyright (C) 2023 The MITRE Corporation All Rights Reserved
+
+package ghidra.app.plugin.assembler.sleigh;
+
+import java.util.Optional;
+
+import ghidra.program.model.address.Address;
+
+public interface WildcardMetadata {
+	public Address getAnticipatedAddress();
+	public int getInstanceId();
+	public String getName();
+	public Optional<String> getInitiator();
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/WildcardedInstruction.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/WildcardedInstruction.java
new file mode 100644
index 000000000..5d198d0ae
--- /dev/null
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/WildcardedInstruction.java
@@ -0,0 +1,13 @@
+/* ###
+ * IP: GHIDRA
+ **/
+// Copyright (C) 2023 The MITRE Corporation All Rights Reserved
+
+package ghidra.app.plugin.assembler.sleigh;
+
+import java.util.Map;
+
+
+public interface WildcardedInstruction {
+	public Map<Integer, WildcardMetadata> getWildcardMap();
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/expr/MultExpressionSolver.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/expr/MultExpressionSolver.java
index 7e7e435ad..80c896e8a 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/expr/MultExpressionSolver.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/expr/MultExpressionSolver.java
@@ -20,6 +20,7 @@ import java.util.Set;
 
 import ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolution;
 import ghidra.app.plugin.assembler.sleigh.sem.AssemblyResolvedPatterns;
+
 import ghidra.app.plugin.processors.sleigh.expression.MultExpression;
 import ghidra.app.plugin.processors.sleigh.expression.PatternExpression;
 
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/expr/OrExpressionSolver.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/expr/OrExpressionSolver.java
index 84955d359..65f11aab5 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/expr/OrExpressionSolver.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/expr/OrExpressionSolver.java
@@ -28,11 +28,11 @@ import ghidra.util.Msg;
  */
 public class OrExpressionSolver extends AbstractBinaryExpressionSolver<OrExpression> {
 	protected static class Matchers implements ExpressionMatcher.Context {
-		protected ExpressionMatcher<ConstantValue> val = var(ConstantValue.class);
-		protected ExpressionMatcher<ConstantValue> size = var(ConstantValue.class);
-		protected ExpressionMatcher<PatternValue> fld = fldSz(size);
+		protected final ExpressionMatcher<ConstantValue> val = var(ConstantValue.class);
+		protected final ExpressionMatcher<ConstantValue> size = var(ConstantValue.class);
+		protected final ExpressionMatcher<PatternValue> fld = fldSz(size);
 
-		protected ExpressionMatcher<?> neqConst = or(
+		protected final ExpressionMatcher<?> neqConst = or(
 			and(shr(sub(opnd(fld), val), size), cv(1)),
 			and(shr(sub(val, opnd(fld)), size), cv(1)));
 	}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/parse/AssemblyParseMachine.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/parse/AssemblyParseMachine.java
index d2d5e5f16..657ec3498 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/parse/AssemblyParseMachine.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/parse/AssemblyParseMachine.java
@@ -18,6 +18,7 @@ package ghidra.app.plugin.assembler.sleigh.parse;
 import java.util.*;
 
 import generic.util.DequePush;
+
 import ghidra.app.plugin.assembler.sleigh.grammars.AssemblyProduction;
 import ghidra.app.plugin.assembler.sleigh.grammars.AssemblySentential;
 import ghidra.app.plugin.assembler.sleigh.grammars.AssemblySentential.TruncatedWhiteSpaceParseToken;
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/parse/AssemblyParseMachineWild.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/parse/AssemblyParseMachineWild.java
new file mode 100644
index 000000000..dec60843a
--- /dev/null
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/parse/AssemblyParseMachineWild.java
@@ -0,0 +1,458 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.plugin.assembler.sleigh.parse;
+
+import java.util.*;
+import java.util.regex.Pattern;
+
+import generic.util.DequePush;
+import ghidra.util.task.TaskMonitor;
+import ghidra.app.plugin.assembler.sleigh.WildcardMetadata;
+import ghidra.app.plugin.assembler.sleigh.WildcardedInstruction;
+import ghidra.app.plugin.assembler.sleigh.grammars.AssemblyProduction;
+import ghidra.app.plugin.assembler.sleigh.grammars.AssemblySentential;
+import ghidra.app.plugin.assembler.sleigh.grammars.AssemblySentential.TruncatedWhiteSpaceParseToken;
+import ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseActionGotoTable.*;
+import ghidra.app.plugin.assembler.sleigh.symbol.*;
+import ghidra.app.plugin.assembler.sleigh.tree.*;
+import ghidra.app.plugin.assembler.sleigh.util.AsmUtil;
+import ghidra.app.plugin.assembler.sleigh.util.DbgTimer;
+import ghidra.app.plugin.assembler.sleigh.util.DbgTimer.DbgCtx;
+
+/**
+ * This is the same as an AssemblyParseMachine BUT it takes an InstructionNode
+ * instead of a String
+ * <p>
+ * This InstructionNode may contain one or more wildcards.
+ */
+public class AssemblyParseMachineWild implements Comparable<AssemblyParseMachineWild> {
+	private static final int ERROR_NONE = 0;
+	private static final int ERROR_SYNTAX = 1;
+
+	// The parser, containing the Action/Goto table
+	protected final AssemblyParser parser;
+
+	// The formal output of the parser
+	protected final List<Integer> output = new ArrayList<>(); // for checking, debugging...?
+	// The format stack of the parser
+	protected final Stack<Integer> stack = new Stack<>();
+	// The stack of trees actually used by the assembler
+	protected final Stack<AssemblyParseTreeNode> treeStack = new Stack<>();
+	// The instruction this parse machine is going to parse
+	protected final WildcardedInstruction inputInstruction;
+	// The formal input buffer of the parser
+	protected final String buffer;
+	// The position in the buffer where we are parsing.
+	protected int pos;
+	// The last token we consumed (i.e., last terminal pushed to the stack)
+	protected AssemblyParseToken lastTok;
+
+	protected final AssemblyNumericSymbols symbols; // used for symbol -> number substitution
+
+	protected boolean accepted = false; // the machine is in the accepted state
+	protected int error = ERROR_NONE; // non-zero if the machine is in an error state
+	protected String got; // if in error, provides the remaining characters in the buffer
+	protected Collection<AssemblyTerminal> expected; // if in error, provides suggestions
+
+	protected final int id; // convenient ID for debug printing
+
+	protected final TaskMonitor monitor;
+
+	static int nextMachineId = 0;
+
+	static final DbgTimer DBG = DbgTimer.INACTIVE;
+
+	/**
+	 * Construct a new parse state
+	 * @param parser the parser driving this machine
+	 * @param input the full input line
+	 * @param pos the position in the line identifying the next characters to parse
+	 * @param symbols a map of valid tokens to number for numeric terminals
+	 * @param monitor the monitor to check if user cancelled
+	 */
+	public AssemblyParseMachineWild(AssemblyParser parser, WildcardedInstruction input, int pos,
+			AssemblyParseToken lastTok, AssemblyNumericSymbols symbols, TaskMonitor monitor) {
+		this.parser = parser;
+		this.stack.push(0);
+		this.inputInstruction = input;
+		this.buffer = input.toString();
+		this.pos = pos;
+		this.lastTok = lastTok;
+		this.id = nextMachineId++;
+		this.symbols = symbols;
+		this.monitor = monitor;
+	}
+
+	/* ********************************************************************************************
+	 * Equality, comparison, etc.
+	 */
+	// NOTE: Buffer is ignored. Machines parsing different buffers should NEVER be in the same
+	// collection.
+
+	@Override
+	public int hashCode() {
+		int result = pos;
+		for (int s : output) {
+			result *= 31;
+			result += s;
+		}
+		/*for (int s : stack) {
+			result *= 31;
+			result += s;
+		}*/ // Does not distinguish among multiple matches on a single terminal
+		for (AssemblyParseTreeNode s : treeStack) {
+			result *= 31;
+			result += s.hashCode();
+		}
+		result *= 31;
+		result += accepted ? 1 : 0;
+		result *= 31;
+		result += error;
+		return result;
+	}
+
+	@Override
+	public boolean equals(Object that) {
+		if (!(that instanceof AssemblyParseMachineWild)) {
+			return false;
+		}
+		AssemblyParseMachineWild apm = (AssemblyParseMachineWild) that;
+		if (this.pos != apm.pos) {
+			return false;
+		}
+		if (!this.output.equals(apm.output)) {
+			return false;
+		}
+		if (!this.stack.equals(apm.stack)) {
+			return false;
+		}
+		if (this.accepted != apm.accepted) {
+			return false;
+		}
+		if (this.error != apm.error) {
+			return false;
+		}
+		return true;
+	}
+
+	@Override
+	public int compareTo(AssemblyParseMachineWild that) {
+		int result;
+
+		result = this.pos - that.pos;
+		if (result != 0) {
+			return result;
+		}
+
+		result = AsmUtil.compareInOrder(this.stack, that.stack);
+		if (result != 0) {
+			return result;
+		}
+
+		result = AsmUtil.compareInOrder(this.output, that.output);
+		if (result != 0) {
+			return result;
+		}
+		if (this.accepted & !that.accepted) {
+			return 1;
+		}
+		if (!this.accepted & that.accepted) {
+			return -1;
+		}
+		result = (this.error - that.error);
+		if (result != 0) {
+			return result;
+		}
+		return 0;
+	}
+
+	/* *******************************************************************************************/
+
+	/**
+	 * Duplicate this machine state
+	 *
+	 * <p>
+	 * This is used extensively when branching
+	 *
+	 * @return the duplicate
+	 */
+	public AssemblyParseMachineWild copy() {
+		AssemblyParseMachineWild c = new AssemblyParseMachineWild(parser, inputInstruction, pos, lastTok, symbols, monitor);
+		// leave labels copied by reference
+
+		c.output.clear();
+		c.output.addAll(output);
+
+		c.stack.clear();
+		c.stack.addAll(stack);
+
+		c.treeStack.clear();
+		c.treeStack.addAll(treeStack);
+
+		c.accepted = accepted;
+		c.error = error;
+
+		DBG.println("Copied " + id + " to " + c.id);
+		return c;
+	}
+
+	/**
+	 * Perform a given action and continue parsing, exhausting all results after the action
+	 *
+	 * <p>
+	 * The visited list prevents infinite loops or stack overflows resulting from consuming epsilon
+	 * and going to the same state. Such loops may involve many states.
+	 *
+	 * @param a the action
+	 * @param tok the token given by the terminal (column) of the entry containing this action
+	 * @param consumeAmount the amount to increment pos by (e.g. the length of tok OR the length of the wildcard's name if tok is a wildcard)
+	 * @param results a place to store all the parsing results (each must be accept or error state)
+	 * @param visited a collection of machine states already visited
+	 */
+	protected void doAction(Action a, AssemblyParseToken tok, int consumeAmount, Set<AssemblyParseMachineWild> results,
+			Deque<AssemblyParseMachineWild> visited) {
+		try (DbgCtx dc = DBG.start("Action: " + a)) {
+			if (a instanceof ShiftAction) {
+				AssemblyParseMachineWild m = copy();
+				m.stack.push(((ShiftAction) a).newStateNum);
+				m.treeStack.push(tok);
+				m.lastTok = tok;
+				m.pos += consumeAmount;
+				m.exhaust(results, visited);
+			}
+			else if (a instanceof ReduceAction) {
+				AssemblyProduction prod = ((ReduceAction) a).prod;
+				AssemblyParseBranch branch = new AssemblyParseBranch(parser.grammar, prod);
+				AssemblyParseMachineWild m = copy();
+				m.output.add(prod.getIndex());
+				DBG.println("Prod: " + prod);
+				for (@SuppressWarnings("unused")
+				AssemblySymbol sym : prod.getRHS()) {
+					m.stack.pop();
+					branch.addChild(m.treeStack.pop());
+				}
+				for (Action aa : m.parser.actions.get(m.stack.peek(), prod.getLHS())) {
+					GotoAction ga = (GotoAction) aa;
+					DBG.println("Goto: " + ga);
+					AssemblyParseMachineWild n = m.copy();
+					n.stack.push(ga.newStateNum);
+					n.treeStack.push(branch);
+					n.exhaust(results, visited);
+				}
+			}
+			else if (a instanceof AcceptAction) {
+				AssemblyParseMachineWild m = copy();
+				m.accepted = true;
+				results.add(m);
+			}
+		}
+	}
+
+	/**
+	 * Consume a given terminal (and corresponding token) and continue parsing
+	 *
+	 * @param t the terminal
+	 * @param tok the corresponding token
+	 * @param results a place to store all the parsing results
+	 * @param visited a collection of machine states already visited
+	 */
+	protected void consume(AssemblyTerminal t, AssemblyParseToken tok,
+			Set<AssemblyParseMachineWild> results, Deque<AssemblyParseMachineWild> visited) {
+		try (DbgCtx dc = DBG.start("Matched " + t + " " + tok)) {
+			int consumeAmount = tok.getString().length();
+			WildcardMetadata currentWildcard = inputInstruction.getWildcardMap().get(pos);
+			if (currentWildcard != null && termIsValidForWildcard(t)) {
+				consumeAmount = currentWildcard.getName().length();
+			}
+
+			Collection<Action> as = parser.actions.get(stack.peek(), t);
+			assert !as.isEmpty();
+			DBG.println("Actions: " + as);
+			for (Action a : as) {
+				doAction(a, tok, consumeAmount, results, visited);
+			}
+		}
+	}
+
+	/**
+	 * Look for previous machine states having the same stack and position
+	 *
+	 * <p>
+	 * This would imply we have gone in a loop without consuming anything. We need to prune.
+	 *
+	 * @param machine the machine state to check
+	 * @param visited the stack of previous machine states
+	 * @return if there is a loop, the machine state proving it, null otherwise
+	 */
+	protected static AssemblyParseMachineWild findLoop(AssemblyParseMachineWild machine,
+			Collection<AssemblyParseMachineWild> visited) {
+		for (AssemblyParseMachineWild v : visited) {
+			if (v == machine) {
+				continue;
+			}
+			if (v.pos != machine.pos) {
+				continue;
+			}
+			if (!v.stack.equals(machine.stack)) {
+				continue;
+			}
+			return v;
+		}
+		return null;
+	}
+
+	@Override
+	public String toString() {
+		return stack + ":" + treeStack + ":" + buffer + " (" + pos + ")";
+	}
+
+	/**
+	 * Returns true if the given AssemblyTerminal is not a AssemblySentential$WhiteSpace
+	 */
+	private boolean termIsValidForWildcard(AssemblyTerminal t) {
+		return !t.getClass().getName().equals("ghidra.app.plugin.assembler.sleigh.grammars.AssemblySentential$WhiteSpace");
+	}
+
+	/**
+	 * Parse (or continue parsing) all possible trees from this machine state
+	 *
+	 * @param results a place to store all the parsing results
+	 * @param visited a collection of machine states already visited
+	 */
+	protected void exhaust(Set<AssemblyParseMachineWild> results, Deque<AssemblyParseMachineWild> visited) {
+		if (monitor.isCancelled()) {
+			return;
+		}
+		try (DbgCtx dc = DBG.start("Exhausting machine " + id)) {
+			DBG.println("Machine: " + this);
+			AssemblyParseMachineWild loop = findLoop(this, visited);
+			if (loop != null) {
+				DBG.println("Pruned. Loop of " + loop.id);
+				return;
+			}
+			try (DequePush<?> push = DequePush.push(visited, this)) {
+				if (error != ERROR_NONE) {
+					throw new AssertionError("INTERNAL: Tried to step a machine with errors");
+				}
+				if (accepted) {
+					// Gratuitous inputs should be detected by getTree
+					throw new AssertionError("INTERNAL: Tried to step an accepted machine");
+				}
+				Collection<AssemblyTerminal> terms = parser.actions.getExpected(stack.peek());
+				if (terms.isEmpty()) {
+					throw new RuntimeException("Encountered a state with no actions");
+				}
+
+				// See if our current character is part of a wildcard
+				WildcardMetadata currentWildcard = inputInstruction.getWildcardMap().get(pos);
+				Pattern filter = null;
+				if (currentWildcard != null) {
+					// It is: wrap all our (non-whitespace) possible terms in AssemblyWildcardTerminals
+					Collection<AssemblyTerminal> new_terms = new ArrayList<>();
+					int wildcard_id = currentWildcard.getInstanceId();
+					String wildcard_name = currentWildcard.getName();
+					for (AssemblyTerminal old : terms) {
+						if (termIsValidForWildcard(old)) {
+							new_terms.add(new AssemblyWildcardTerminal(old, wildcard_name, wildcard_id,
+									currentWildcard.getAnticipatedAddress()));
+						} else {
+							new_terms.add(old);
+						}
+					}
+					terms = new_terms;
+
+					// Compile this wildcard node's filter regex:
+					filter = Pattern.compile(currentWildcard.getInitiator().orElse(".*"));
+				}
+
+				Set<AssemblyTerminal> unmatched = new TreeSet<>(terms);
+				for (AssemblyTerminal t : terms) {
+					for (AssemblyParseToken tok : t.match(buffer, pos, parser.grammar, symbols)) {
+						if (currentWildcard != null && termIsValidForWildcard(t)) {
+
+							// Make sure what we just matched passes our filter check
+							if (!filter.matcher(tok.getString()).matches()) {
+								// If not, continue on to trying other tokens
+								continue;
+							}
+							// We can't really assert that the wildcard value matches, so let's at least make sure the name matches what we expect it to
+							assert buffer.regionMatches(pos,  currentWildcard.getName(), 0,
+								currentWildcard.getName().length());
+						} else {
+							assert buffer.regionMatches(pos, tok.getString(), 0,
+								tok.getString().length());
+						}
+						unmatched.remove(t);
+						consume(t, tok, results, visited);
+					}
+				}
+				if (!unmatched.isEmpty()) {
+					AssemblyParseMachineWild m = copy();
+					final Collection<AssemblyTerminal> newExpected;
+					if (m.lastTok == null ||
+						!(m.lastTok instanceof TruncatedWhiteSpaceParseToken)) {
+						newExpected = unmatched;
+					}
+					else {
+						newExpected = new TreeSet<>();
+						newExpected.add(AssemblySentential.WHITE_SPACE);
+					}
+					DBG.println("Syntax Error: ");
+					DBG.println("  Expected: " + newExpected);
+					DBG.println("  Got: " + buffer.substring(pos));
+					m.error = ERROR_SYNTAX;
+					m.got = buffer.substring(pos);
+					m.expected = newExpected;
+					results.add(m);
+					return;
+				}
+			}
+		}
+	}
+
+	/**
+	 * Parse (or continue parsing) all possible trees from this machine state
+	 *
+	 * @return the set of all possible trees and errors
+	 */
+	public Set<AssemblyParseMachineWild> exhaust() {
+		Set<AssemblyParseMachineWild> results = new LinkedHashSet<>();
+		Deque<AssemblyParseMachineWild> visited = new LinkedList<>();
+		exhaust(results, visited);
+		return results;
+	}
+
+	/**
+	 * If in the accepted state, get the resulting parse tree for this machine
+	 *
+	 * @return the parse tree
+	 */
+	public AssemblyParseBranch getTree() {
+		if (!accepted) {
+			throw new AssertionError("INTERNAL: Machine has not accepted its buffer");
+		}
+		if (pos != buffer.length()) {
+			throw new AssertionError("INTERNAL: Machine has not emptied its buffer");
+		}
+		if (!treeStack.pop().getSym().equals(AssemblyEOI.EOI)) {
+			throw new AssertionError("INTERNAL: Machine has not encountered end of input marker");
+		}
+		if (treeStack.size() != 1) {
+			throw new AssertionError("INTERNAL: More than root branch remains on machine stack");
+		}
+		return (AssemblyParseBranch) treeStack.pop();
+	}
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/parse/AssemblyParser.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/parse/AssemblyParser.java
index c0a65ad26..0fa276308 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/parse/AssemblyParser.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/parse/AssemblyParser.java
@@ -22,12 +22,15 @@ import java.util.function.Consumer;
 import org.apache.commons.collections4.map.LazyMap;
 import org.apache.commons.lang3.StringUtils;
 
+import ghidra.app.plugin.assembler.sleigh.WildcardedInstruction;
 import ghidra.app.plugin.assembler.sleigh.grammars.*;
 import ghidra.app.plugin.assembler.sleigh.symbol.*;
 import ghidra.app.plugin.assembler.sleigh.util.DbgTimer;
 import ghidra.app.plugin.assembler.sleigh.util.DbgTimer.DbgCtx;
 import ghidra.app.plugin.assembler.sleigh.util.TableEntry;
 
+import ghidra.util.task.TaskMonitor;
+
 /**
  * A class to encapsulate LALR(1) parsing for a given grammar
  * 
@@ -390,6 +393,32 @@ public class AssemblyParser {
 		return ret;
 	}
 
+	public Collection<AssemblyParseResult> parse(final WildcardedInstruction input, AssemblyNumericSymbols symbols, TaskMonitor monitor) {
+		AssemblyParseMachineWild init = new AssemblyParseMachineWild(this, input, 0, null, symbols, monitor);
+		Set<AssemblyParseMachineWild> results = init.exhaust();
+
+		Set<AssemblyParseResult> ret = new LinkedHashSet<>();
+		for (AssemblyParseMachineWild m : results) {
+			if (monitor.isCancelled()) {
+				return new LinkedHashSet<>();
+			}
+			if (m.accepted) {
+				ret.add(AssemblyParseResult.accept(m.getTree()));
+			}
+			else if (m.error != 0) {
+				Set<String> suggestions = new TreeSet<>();
+				for (AssemblyTerminal t : m.expected) {
+					suggestions.addAll(t.getSuggestions(m.got, symbols));
+				}
+				ret.add(AssemblyParseResult.error(m.got, suggestions));
+			}
+			else {
+				throw new AssertionError("INTERNAL: Unfinished machine was returned");
+			}
+		}
+		return ret;
+	}
+
 	/**
 	 * For debugging
 	 */
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyOperandData.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyOperandData.java
new file mode 100644
index 000000000..73c8cf732
--- /dev/null
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyOperandData.java
@@ -0,0 +1,590 @@
+/* ###
+ * IP: GHIDRA
+ **/
+// Copyright (C) 2023 The MITRE Corporation All Rights Reserved
+
+package ghidra.app.plugin.assembler.sleigh.sem;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import ghidra.app.plugin.assembler.sleigh.tree.AssemblyParseBranch;
+import ghidra.app.plugin.assembler.sleigh.tree.AssemblyParseNumericToken;
+import ghidra.app.plugin.assembler.sleigh.tree.AssemblyParseToken;
+import ghidra.app.plugin.assembler.sleigh.tree.AssemblyParseTreeNode;
+
+import ghidra.app.plugin.processors.sleigh.expression.PatternExpression;
+
+/**
+ * Holds data about operands and suboperands from the assembler that Ghidra does
+ * not currently provide. Most importantly, this class allows users to access
+ * mask and value information about suboperands (Ghidra provides the masks and
+ * values for top-level operands only).
+ * <p>
+ * Note, what is referred to as "suboperands" here is what Ghidra seems to refer
+ * as "subtable operands".
+ * <p>
+ * An instance of this class is a node in a tree of AssemblyOperandData. For
+ * example, the instruction
+ * <code>MOV RAX, qword ptr [ R10 + R12 * 2 + 1 ]</code>, we have the tree:
+ * <p>
+ * <code>
+ *              instruction
+ *       ____________|____________________
+ *       |                               |
+ *     Reg64                           rm64
+ *       |                               |
+ *  reg64_x (RAX)                       Mem
+ *                      _________________|___________
+ *                      |                           |
+ *                   segWide                      addr64
+ *                            ______________________|_____________________
+ *                            |               |               |          |
+ *                         Base64          Index64          ss (2)   simm32_64
+ *                            |               |                          |
+ *                      base64_x (R10)  index64_x (R12)         simm32_64:simm32 (1)
+ * </code>
+ * <p>
+ * Each node (which is labeled with the code name) represents a node in the
+ * AssemblyOperandData tree.
+ */
+public class AssemblyOperandData {
+	/**
+	 * The wildcard symbol; e.g. Q1.
+	 */
+	private String wildcardName;
+
+	/**
+	 * The zero-based index of the wildcard in the assembly instruction. For
+	 * example, in <code>MOV Q1, Q2</code>, <code>Q1</code> receives an index of 0,
+	 * and <code>Q2</code> receives an index of 1.
+	 */
+	private int wildcardIdx;
+
+	/**
+	 * The operand type, as defined by OperandType. It is saved as an
+	 * <code>int</code> here, but the OperandType class can be used to retrieve the
+	 * type the integer represents.
+	 */
+	private int operandType;
+
+	/**
+	 * e.g. EAX
+	 */
+	private String operandName;
+
+	/**
+	 * The name that the assembler uses to represent a branch, e.g. index64.
+	 */
+	private String codeName;
+
+	/**
+	 * The mask of the (sub)operand.
+	 */
+	private byte[] mask;
+
+	/**
+	 * The value of the (sub)operand.
+	 */
+	private byte[] val;
+
+	/**
+	 * The number of leading bytes that should be added to the mask and value.
+	 */
+	private int byteShift;
+
+	/**
+	 * The expression that helps in shifting (in some cases) and is useful in
+	 * determining where labels are located in jump instructions.
+	 */
+	private PatternExpression expression;
+
+	/**
+	 * The child nodes, which contain (sub)operands.
+	 */
+	private final List<AssemblyOperandData> children;
+
+	/**
+	 * Used to find operand data for backfills, since code name (which is what is
+	 * usually used) is not available.
+	 */
+	private String description;
+
+	/**
+	 * True if this operand was assembled via backfill; false otherwise
+	 */
+	private boolean isBackfill;
+
+	/**
+	 * AssemblyOperandData constructor.
+	 *
+	 * @param wildcardName operand variable name
+	 * @param wildcardIdx  operand index in the instruction
+	 * @param operandType  see <a href=
+	 *                     "https://ghidra.re/ghidra_docs/api/ghidra/program/model/lang/OperandType.html">...</a>
+	 */
+	public AssemblyOperandData(String wildcardName, int wildcardIdx, int operandType) {
+		this.wildcardName = wildcardName;
+		this.wildcardIdx = wildcardIdx;
+		this.operandType = operandType;
+		this.byteShift = 0;
+		this.children = new ArrayList<>();
+		this.isBackfill = false;
+	}
+
+	public AssemblyOperandData() {
+		this.children = new ArrayList<>();
+		this.isBackfill = false;
+	}
+
+	/**
+	 * Build the operand data tree that will contain the suboperand info and be
+	 * returned to the user as a field of each {@code AssemblyResolution} object.
+	 * <p>
+	 * The substitutions of the parse tree gives a hierarchy of the suboperands.
+	 * This hierarchy is used for this operand data tree. A pointer to this tree
+	 * will exist in every {@code AssemblyResolution} object, allowing the entire
+	 * tree to be accessed from each operand of each result.
+	 *
+	 * @param node pass in the root node of the parse tree
+	 * @return skeleton of an operand data tree
+	 */
+	protected static AssemblyOperandData buildAssemblyOperandDataTree(AssemblyParseTreeNode node) {
+		if (node instanceof AssemblyParseBranch) {
+			// branch of the tree that contains one or more sub(operands)
+			AssemblyOperandData operandData = new AssemblyOperandData();
+			AssemblyParseBranch tree = (AssemblyParseBranch) node;
+			// code name is how we find the node we want in this tree
+			operandData.setCodeName(tree.getProduction().getLHS().getName());
+			for (AssemblyParseTreeNode token : tree.getSubstitutions()) {
+				AssemblyOperandData childOperandData = buildAssemblyOperandDataTree(token);
+				if (childOperandData != null) {
+					operandData.addChild(childOperandData);
+				}
+			}
+			return operandData;
+		} else if (node instanceof AssemblyParseNumericToken
+				|| (node instanceof AssemblyParseToken && node.getOperandData() != null)) {
+			// leaf of the tree - consists of a sub(operand)
+			AssemblyOperandData operandData = new AssemblyOperandData();
+			AssemblyParseToken token = (AssemblyParseToken) node;
+
+			// fill in some fields of the AssemblyOperandData that will be returned in the
+			// results to the user
+			operandData.setCodeName(token.getSym().getName());
+			operandData.setOperandName(token.generateString());
+			AssemblyOperandData operandDataTarget = token.getOperandData();
+			if (operandDataTarget != null) {
+				operandData.setWildcardName(operandDataTarget.getWildcardName());
+				operandData.setWildcardIdx(operandDataTarget.getWildcardIdx());
+				operandData.setOperandType(operandDataTarget.getOperandType());
+			}
+			return operandData;
+		}
+		return null;
+	}
+
+	/**
+	 * Get the variable name of the operand.
+	 *
+	 * @return wildcard name
+	 */
+	public String getWildcardName() {
+		return wildcardName;
+	}
+
+	/**
+	 * Set the variable name of the operand.
+	 *
+	 * @param wildcardName variable name (e.g. Q1)
+	 */
+	public void setWildcardName(String wildcardName) {
+		this.wildcardName = wildcardName;
+	}
+
+	/**
+	 * Get the index of the wildcard in the instruction.
+	 *
+	 * @return wildcard index
+	 */
+	public int getWildcardIdx() {
+		return wildcardIdx;
+	}
+
+	/**
+	 * Set the index of the wildcard in the instruction.
+	 *
+	 * @param wildcardIdx index
+	 */
+	public void setWildcardIdx(int wildcardIdx) {
+		this.wildcardIdx = wildcardIdx;
+	}
+
+	/**
+	 * Get the operand type. See <a href=
+	 * "https://ghidra.re/ghidra_docs/api/ghidra/program/model/lang/OperandType.html">...</a>.
+	 *
+	 * @return operand type
+	 */
+	public int getOperandType() {
+		return operandType;
+	}
+
+	/**
+	 * Set the operand type.
+	 *
+	 * @param operandType the operand type, as defined by <a href=
+	 *                    "https://ghidra.re/ghidra_docs/api/ghidra/program/model/lang/OperandType.html">...</a>
+	 */
+	public void setOperandType(int operandType) {
+		this.operandType = operandType;
+	}
+
+	/**
+	 * Get the name of the operand.
+	 *
+	 * @return operand name
+	 */
+	public String getOperandName() {
+		return operandName;
+	}
+
+	/**
+	 * Set the operand name.
+	 *
+	 * @param operandName operand name
+	 */
+	public void setOperandName(String operandName) {
+		this.operandName = operandName;
+	}
+
+	/**
+	 * Get the name from Ghidra's assembler that represents the branch that this
+	 * operand is the root node of.
+	 *
+	 * @return branch name
+	 */
+	public String getCodeName() {
+		return codeName;
+	}
+
+	/**
+	 * Set the branch name that this operand is the root node of.
+	 *
+	 * @param codeName branch name
+	 */
+	public void setCodeName(String codeName) {
+		this.codeName = codeName;
+	}
+
+	/**
+	 * Get the mask of this sub(operand) within the instruction.
+	 *
+	 * @return mask
+	 */
+	public byte[] getMask() {
+		return mask;
+	}
+
+	/**
+	 * Set the mask of this sub(operand).
+	 *
+	 * @param mask mask
+	 */
+	public void setMask(byte[] mask) {
+		this.mask = mask;
+	}
+
+	/**
+	 * Get the value of this sub(operand) within the instruction.
+	 *
+	 * @return value
+	 */
+	public byte[] getVal() {
+		return val;
+	}
+
+	/**
+	 * Set the value of this sub(operand).
+	 *
+	 * @param val value
+	 */
+	public void setVal(byte[] val) {
+		this.val = val;
+	}
+
+	/**
+	 * Get the number of bytes the mask/value should be shifted within the
+	 * instruction.
+	 *
+	 * @return number of bytes to shift right
+	 */
+	public int getByteShift() {
+		return byteShift;
+	}
+
+	/**
+	 * Add to the number of bytes to shift the mask/value.
+	 *
+	 * @param amt number of bytes to shift right
+	 */
+	public void addByteShift(int amt) {
+		this.byteShift += amt;
+	}
+
+	/**
+	 * Get the expression that defines the mask/value within a byte.
+	 *
+	 * @return expression
+	 */
+	public PatternExpression getExpression() {
+		return this.expression;
+	}
+
+	/**
+	 * Set the expression.
+	 *
+	 * @param e expression
+	 */
+	public void setExpression(PatternExpression e) {
+		this.expression = e;
+	}
+
+	/**
+	 * Get all child operands of this operand.
+	 *
+	 * @return list of child operands
+	 */
+	public List<AssemblyOperandData> getChildren() {
+		return children;
+	}
+
+	/**
+	 * Add child operands of this operand.
+	 *
+	 * @param operandData child operand
+	 */
+	public void addChild(AssemblyOperandData operandData) {
+		this.children.add(operandData);
+	}
+
+	/**
+	 * Set the description of this operand.
+	 *
+	 * @param description description
+	 */
+	public void setDescription(String description) {
+		this.description = description;
+	}
+
+	/**
+	 * True if the operand was assembled via backfill; false otherwise.
+	 */
+	public void makeBackfill() {
+		this.isBackfill = true;
+	}
+
+	/**
+	 * Get only the operand data that contain wildcards.
+	 *
+	 * @return list of operand data that contain wildcards
+	 */
+	public List<AssemblyOperandData> getWildcardOperandData() {
+		return getWildcardOperandData(this);
+	}
+
+	/**
+	 * Extract the AssemblyOperandData objects that are wildcarded.
+	 *
+	 * @param operandData the AssemblyOperandData object to check if it should be
+	 *                    returned
+	 * @return a list of AssemblyOperandData nodes that are wildcarded
+	 */
+	private List<AssemblyOperandData> getWildcardOperandData(AssemblyOperandData operandData) {
+		List<AssemblyOperandData> results = new ArrayList<>();
+		if (operandData.wildcardName != null) {
+			results.add(operandData);
+		}
+		for (AssemblyOperandData childOperandData : operandData.children) {
+			results.addAll(childOperandData.getWildcardOperandData(childOperandData));
+		}
+		return results;
+	}
+
+	/**
+	 * Given the code name, find the corresponding operand data node.
+	 *
+	 * @param codename code name of the node to find
+	 * @return operand data of the code name, null if node could not be found
+	 */
+	protected AssemblyOperandData findOperandData(String codename) {
+		if (this.codeName.equals(codename)) {
+			return this;
+		}
+
+		for (AssemblyOperandData operandData : children) {
+			AssemblyOperandData result = operandData.findOperandData(codename);
+			if (result != null) {
+				return result;
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Give a description, find the corresponding operand data node.
+	 *
+	 * @param descriptionToFind description of the node to find
+	 * @return operand data of the description, null if node could not be found
+	 */
+	protected AssemblyOperandData findDescription(String descriptionToFind) {
+		if (this.description != null && this.description.equals(descriptionToFind)) {
+			return this;
+		}
+
+		for (AssemblyOperandData operandData : children) {
+			AssemblyOperandData result = operandData.findDescription(descriptionToFind);
+			if (result != null) {
+				return result;
+			}
+		}
+		return null;
+	}
+
+	/**
+	 * Some operands don't have a mask and value (instead, these operands seem to
+	 * influence bits in the opcode). These operands are AssemblyParseTokens instead
+	 * of the usual AssemblyParseNumericToken, which means the assembler does not
+	 * fill in the mask and value field of the AssemblyOperandData. To solve this
+	 * problem, this method searches for wildcarded AssemblyOperandData that have
+	 * null masks and values and fills it in with empty byte arrays.
+	 *
+	 * @param totalBytes total number of bytes in the instruction, used to determine
+	 *                   length of the empty byte array
+	 */
+	protected void fillMissingMasksVals(int totalBytes) {
+		if (wildcardName != null && mask == null && val == null) {
+			setMask(new byte[totalBytes]);
+			setVal(new byte[totalBytes]);
+		}
+		for (AssemblyOperandData child : children) {
+			child.fillMissingMasksVals(totalBytes);
+		}
+	}
+
+	/**
+	 * Add leading and trailing bytes to mask and value, so that they have the same
+	 * number of bytes as the instruction.
+	 * <p>
+	 * When the mask and value of the sub(operand) is retrieved from the assembler,
+	 * the leading and trailing bytes are not returned. Using the shifts that are
+	 * provided by the assembler, the leading and trailing bytes are reassembled
+	 * here.
+	 *
+	 * @param totalBytes length of the instruction, in number of bytes
+	 */
+	protected void applyShifts(int totalBytes) {
+		applyShifts(0, totalBytes);
+	}
+
+	/**
+	 * Add leading and trailing bytes to mask and value.
+	 * <p>
+	 * |-------------------------totalBytes------------------------------|
+	 * |---amt---|---current mask/val len---|---implied trailing bytes---|
+	 *
+	 * @param amt        number of leading bytes to add
+	 * @param totalBytes total number of bytes in the instruction
+	 */
+	private void applyShifts(int amt, int totalBytes) {
+		amt += byteShift;
+		// amt is the sum of this operand's shift and all the shifts in the levels
+		// above.
+		// byteShift in backfill operands already contain the sum of all the levels
+		// above since backfills are shifted into place after the entire instruction is
+		// put together.
+		// using amt in a backfill would double count shifts.
+		int shiftAmt = isBackfill ? byteShift : amt;
+		if (mask != null && val != null && (shiftAmt > 0 || totalBytes > mask.length)) {
+			// make new arrays that are as long as the instruction
+			byte[] newMask = new byte[totalBytes];
+			byte[] newVal = new byte[totalBytes];
+			// find when the current mask/val would go in the new arrays and populate them
+			for (int i = shiftAmt; i < mask.length + shiftAmt; i++) {
+				try {
+					newMask[i] = mask[i - shiftAmt];
+					newVal[i] = val[i - shiftAmt];
+				} catch (ArrayIndexOutOfBoundsException e) {
+					throw new RuntimeException("Shifting failure:\n\tTotal instruction bytes (new mask/value length): "
+							+ totalBytes + "\n\tCurrent mask/value length: " + mask.length + "\n\tShift amount: "
+							+ shiftAmt
+							+ "\nSum of current length and shift amount should be less than or equal to total bytes.\nAttempting to shift byte "
+							+ (i - shiftAmt) + " of current mask/value into byte " + i + " of new mask/value.");
+				}
+			}
+
+			this.mask = newMask;
+			this.val = newVal;
+		}
+
+		for (AssemblyOperandData operandData : children) {
+			operandData.applyShifts(amt, totalBytes);
+		}
+	}
+
+	@Override
+	public String toString() {
+		StringBuilder sb = new StringBuilder();
+		sb.append("NAME: ").append(wildcardName);
+		sb.append("\nOPNM: ").append(operandName);
+		sb.append("\nCODE: ").append(codeName);
+		if (expression == null) {
+			sb.append("\nExpression: null");
+		} else {
+			sb.append("\nExpression: ").append(expression);
+		}
+		sb.append("\nSHMT: ").append(byteShift);
+		if (mask == null) {
+			sb.append("\nMASK: null");
+		} else {
+			sb.append("\nMASK: [");
+			for (byte b : mask) {
+				sb.append(b).append(", ");
+			}
+			sb.delete(sb.length() - 2, sb.length()).append(']');
+		}
+		if (val == null) {
+			sb.append("\nVAL:  null");
+		} else {
+			sb.append("\nVAL:  [");
+			for (byte b : val) {
+				sb.append(b).append(", ");
+			}
+			sb.delete(sb.length() - 2, sb.length());
+			sb.append(']');
+		}
+		return sb.toString();
+	}
+
+	/**
+	 * Make a deep copy of this object.
+	 *
+	 * @return a new copy of this AssemblyOperandData object
+	 */
+	public AssemblyOperandData copy() {
+		AssemblyOperandData newOperandData = new AssemblyOperandData(wildcardName, wildcardIdx, operandType);
+		newOperandData.setOperandName(operandName);
+		newOperandData.setCodeName(codeName);
+		newOperandData.setExpression(getExpression());
+		newOperandData.addByteShift(getByteShift());
+		newOperandData.setMask(getMask());
+		newOperandData.setVal(getVal());
+		newOperandData.setDescription(description);
+		newOperandData.isBackfill = this.isBackfill;
+		for (AssemblyOperandData child : children) {
+			newOperandData.addChild(child.copy());
+		}
+		return newOperandData;
+	}
+
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyOperandState.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyOperandState.java
index c96ff4cac..1e3a55198 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyOperandState.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyOperandState.java
@@ -136,6 +136,18 @@ public class AssemblyOperandState extends AbstractAssemblyState {
 				errors.add((AssemblyResolvedError) sol);
 				return Stream.of();
 			}
+
+			fromRight.operandData = fromRight.operandData.copy();
+
+			// get the operand data structure of the operand we want to populate info with
+			// find this structure using the code name (e.g. reg64 or simm32)
+			AssemblyOperandData operandData = fromRight.operandData.findOperandData(terminal.getName());
+
+			// when we populate backfills, we won't have the code name to find the correct
+			// operand data to populate, so we use description of the AssemblyResolution
+			// instead
+			operandData.setDescription(sol.description);
+
 			if (sol.isBackfill()) {
 				AssemblyResolvedPatterns combined =
 					fromRight.combine((AssemblyResolvedBackfill) sol);
@@ -147,6 +159,21 @@ public class AssemblyOperandState extends AbstractAssemblyState {
 					AssemblyResolution.error("Pattern/operand conflict", "Resolving " + terminal));
 				return Stream.of();
 			}
+
+			AssemblyResolvedPatterns solResolved = (AssemblyResolvedPatterns) sol;
+
+			// populate operand data node with mask, value, shift, and expression for normal
+			// operands this is similar to the code for backfill shifts for normal operands
+			// in OperandValueSolver
+			operandData.setMask(solResolved.ins.getMask());
+			operandData.setVal(solResolved.ins.getVals());
+			operandData.addByteShift(solResolved.ins.getOffset());
+			PatternExpression symExp = opSym.getDefiningExpression();
+			if (symExp == null) {
+				symExp = opSym.getDefiningSymbol().getPatternExpression();
+			}
+			operandData.setExpression(symExp);
+
 			AssemblyResolvedPatterns pats = (AssemblyResolvedPatterns) combined;
 			// Do not take constructor from right
 			return Stream.of(pats.withRight(fromRight).withConstructor(null));
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyResolution.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyResolution.java
index c7d9baabf..587ecdba3 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyResolution.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyResolution.java
@@ -40,6 +40,9 @@ public abstract class AssemblyResolution implements Comparable<AssemblyResolutio
 	private boolean hashed = false;
 	private int hash;
 
+	// operand data tree
+	protected AssemblyOperandData operandData = null;
+
 	@Override
 	public int hashCode() {
 		if (!hashed) {
@@ -347,4 +350,22 @@ public abstract class AssemblyResolution implements Comparable<AssemblyResolutio
 	 * Get this same resolution, pushing its right siblings down to its children
 	 */
 	public abstract AssemblyResolution parent(String description, int opCount);
+
+	public void setOperandData(AssemblyOperandData operandData) {
+		this.operandData = operandData;
+	}
+
+	public AssemblyOperandData getOperandData() {
+		return operandData;
+	}
+
+	// for debug
+	public void printOperandData() {
+		if (operandData != null) {
+			System.out.println(operandData);
+		}
+		for (AssemblyResolution ar : children) {
+			ar.printOperandData();
+		}
+	}
 }
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyResolvedBackfill.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyResolvedBackfill.java
index 47fe59b02..e2b3c4012 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyResolvedBackfill.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyResolvedBackfill.java
@@ -139,7 +139,19 @@ public class AssemblyResolvedBackfill extends AssemblyResolution {
 				return ar;
 			}
 			AssemblyResolvedPatterns rc = (AssemblyResolvedPatterns) ar;
-			return rc.shift(offset);
+			AssemblyResolvedPatterns shifted = rc.shift(offset);
+
+			// get the operand data structure of the operand we want to populate info with
+			AssemblyOperandData od = cur.operandData.findDescription(description);
+			// populate operand data node with mask, value, shift, and expression for
+			// backfill operands this is similar code for operand data population for normal
+			// operands in AssemblyOperandState
+			od.setMask(rc.ins.getMask());
+			od.setVal(rc.ins.getVals());
+			od.addByteShift(shifted.ins.getOffset());
+			od.setExpression(exp);
+			od.makeBackfill();
+			return shifted;
 		}
 		catch (NeedsBackfillException e) {
 			return AssemblyResolution.error("Solution still requires backfill", description);
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyResolvedPatterns.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyResolvedPatterns.java
index 84f47c5c6..fa160a0d8 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyResolvedPatterns.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyResolvedPatterns.java
@@ -109,6 +109,20 @@ public class AssemblyResolvedPatterns extends AssemblyResolution {
 		this.forbids = forbids == null ? Set.of() : forbids;
 	}
 
+	AssemblyResolvedPatterns(String description, Constructor cons,
+			List<? extends AssemblyResolution> children, AssemblyResolution right,
+			AssemblyPatternBlock ins, AssemblyPatternBlock ctx,
+			Set<AssemblyResolvedBackfill> backfills, Set<AssemblyResolvedPatterns> forbids,
+			AssemblyOperandData operandData) {
+		super(description, children, right);
+		this.cons = cons;
+		this.ins = ins;
+		this.ctx = ctx;
+		this.backfills = backfills == null ? Set.of() : backfills;
+		this.forbids = forbids == null ? Set.of() : forbids;
+		this.operandData = operandData;
+	}
+
 	/**
 	 * Build a new successful SLEIGH constructor resolution from a string representation
 	 * 
@@ -170,7 +184,8 @@ public class AssemblyResolvedPatterns extends AssemblyResolution {
 			newForbids.add(f.shift(amt));
 		}
 		return new AssemblyResolvedPatterns(description, cons, children, right, newIns, ctx,
-			Collections.unmodifiableSet(newBackfills), Collections.unmodifiableSet(newForbids));
+			Collections.unmodifiableSet(newBackfills), Collections.unmodifiableSet(newForbids),
+			operandData);
 	}
 
 	/**
@@ -189,8 +204,7 @@ public class AssemblyResolvedPatterns extends AssemblyResolution {
 		AssemblyPatternBlock newIns = this.ins.truncate(amt);
 
 		return new AssemblyResolvedPatterns("Truncated: " + description, cons, null, right,
-			newIns, ctx,
-			null, null);
+			newIns, ctx, null, null, operandData);
 	}
 
 	/**
@@ -216,7 +230,7 @@ public class AssemblyResolvedPatterns extends AssemblyResolution {
 			}
 		}
 		return new AssemblyResolvedPatterns(description, cons, children, right, ins, ctx,
-			backfills, Collections.unmodifiableSet(newForbids));
+			backfills, Collections.unmodifiableSet(newForbids), operandData);
 	}
 
 	/**
@@ -276,8 +290,10 @@ public class AssemblyResolvedPatterns extends AssemblyResolution {
 		}
 		Set<AssemblyResolvedPatterns> newForbids = new HashSet<>(this.forbids);
 		newForbids.addAll(that.forbids);
+
+		AssemblyOperandData passOn = this.operandData == null ? that.operandData : this.operandData;
 		return new AssemblyResolvedPatterns(description, cons, children, right, newIns, newCtx,
-			Collections.unmodifiableSet(newBackfills), Collections.unmodifiableSet(newForbids));
+			Collections.unmodifiableSet(newBackfills), Collections.unmodifiableSet(newForbids), passOn);
 	}
 
 	/**
@@ -290,7 +306,7 @@ public class AssemblyResolvedPatterns extends AssemblyResolution {
 		Set<AssemblyResolvedBackfill> newBackfills = new HashSet<>(this.backfills);
 		newBackfills.add(bf);
 		return new AssemblyResolvedPatterns(description, cons, children, right, ins, ctx,
-			Collections.unmodifiableSet(newBackfills), forbids);
+			Collections.unmodifiableSet(newBackfills), forbids, operandData == null ? bf.operandData : operandData);
 	}
 
 	/**
@@ -303,7 +319,7 @@ public class AssemblyResolvedPatterns extends AssemblyResolution {
 		Set<AssemblyResolvedPatterns> combForbids = new HashSet<>(this.forbids);
 		combForbids.addAll(more);
 		return new AssemblyResolvedPatterns(description, cons, children, right, ins, ctx,
-			backfills, Collections.unmodifiableSet(more));
+			backfills, Collections.unmodifiableSet(more), operandData);
 	}
 
 	/**
@@ -314,7 +330,7 @@ public class AssemblyResolvedPatterns extends AssemblyResolution {
 	 */
 	public AssemblyResolvedPatterns withDescription(String desc) {
 		return new AssemblyResolvedPatterns(desc, cons, children, right, ins, ctx, backfills,
-			forbids);
+			forbids, operandData);
 	}
 
 	/**
@@ -325,8 +341,7 @@ public class AssemblyResolvedPatterns extends AssemblyResolution {
 	 */
 	public AssemblyResolvedPatterns withConstructor(Constructor cons) {
 		return new AssemblyResolvedPatterns(description, cons, children, right, ins, ctx,
-			backfills,
-			forbids);
+			backfills, forbids, operandData);
 	}
 
 	/**
@@ -335,14 +350,14 @@ public class AssemblyResolvedPatterns extends AssemblyResolution {
 	 * @param cop the context operation specifying the location of the value to encode
 	 * @param val the masked value to encode
 	 * @return the result
-	 * 
+	 *
 	 *         This is the forward (as in disassembly) direction of applying context operations. The
 	 *         pattern expression is evaluated, and the result is written as specified.
 	 */
 	public AssemblyResolvedPatterns writeContextOp(ContextOp cop, MaskedLong val) {
 		AssemblyPatternBlock newCtx = this.ctx.writeContextOp(cop, val);
 		return new AssemblyResolvedPatterns(description, cons, children, right, ins, newCtx,
-			backfills, forbids);
+			backfills, forbids, operandData);
 	}
 
 	/**
@@ -371,27 +386,28 @@ public class AssemblyResolvedPatterns extends AssemblyResolution {
 	public AssemblyResolvedPatterns copyAppendDescription(String append) {
 		AssemblyResolvedPatterns cp = new AssemblyResolvedPatterns(
 			description + ": " + append, cons, children, right, ins.copy(), ctx.copy(), backfills,
-			forbids);
+			forbids, operandData);
 		return cp;
 	}
 
 	@Override
 	public AssemblyResolvedPatterns withRight(AssemblyResolution right) {
 		AssemblyResolvedPatterns cp = new AssemblyResolvedPatterns(description, cons,
-			children, right, ins.copy(), ctx.copy(), backfills, forbids);
+			children, right, ins.copy(), ctx.copy(), backfills, forbids, operandData);
 		return cp;
 	}
 
 	public AssemblyResolvedPatterns nopLeftSibling() {
 		return new AssemblyResolvedPatterns("nop-left", null, null, this, ins.copy(),
-			ctx.copy(), backfills, forbids);
+			ctx.copy(), backfills, forbids, operandData);
 	}
 
 	@Override
 	public AssemblyResolvedPatterns parent(String description, int opCount) {
 		List<AssemblyResolution> allRight = getAllRight();
 		AssemblyResolvedPatterns cp = new AssemblyResolvedPatterns(description, cons,
-			allRight.subList(0, opCount), allRight.get(opCount), ins, ctx, backfills, forbids);
+			allRight.subList(0, opCount), allRight.get(opCount), ins, ctx, backfills, forbids,
+			operandData);
 		return cp;
 	}
 
@@ -405,7 +421,7 @@ public class AssemblyResolvedPatterns extends AssemblyResolution {
 	public AssemblyResolvedPatterns maskOut(ContextOp cop) {
 		AssemblyPatternBlock newCtx = this.ctx.maskOut(cop);
 		return new AssemblyResolvedPatterns(description, cons, children, right, ins, newCtx,
-			backfills, forbids);
+			backfills, forbids, operandData);
 	}
 
 	/**
@@ -482,7 +498,7 @@ public class AssemblyResolvedPatterns extends AssemblyResolution {
 	 * @param sem the constructor whose context changes to solve
 	 * @param vals any defined symbols
 	 * @return the result
-	 * @see AssemblyConstructorSemantic#solveContextChanges(AssemblyResolvedPatterns, Map)
+	 * @see AssemblyConstructorSemantic#solveContextChanges(AssemblyResolvedPatterns, Map, Map)
 	 */
 	public AssemblyResolvedPatterns solveContextChangesForForbids(
 			AssemblyConstructorSemantic sem, Map<String, Long> vals) {
@@ -499,7 +515,7 @@ public class AssemblyResolvedPatterns extends AssemblyResolution {
 			newForbids.add((AssemblyResolvedPatterns) t);
 		}
 		return new AssemblyResolvedPatterns(description, cons, children, right, ins, ctx,
-			backfills, Collections.unmodifiableSet(newForbids));
+			backfills, Collections.unmodifiableSet(newForbids), operandData);
 	}
 
 	/**
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyTreeResolver.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyTreeResolver.java
index e66b275be..10fc7fd04 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyTreeResolver.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/sem/AssemblyTreeResolver.java
@@ -63,6 +63,7 @@ public class AssemblyTreeResolver {
 	protected final AssemblyGrammar grammar;
 	protected final AssemblyPatternBlock context;
 	protected final AssemblyContextGraph ctxGraph;
+	protected final AssemblyOperandData operandData;
 
 	/**
 	 * Construct a resolver for the given parse tree
@@ -82,6 +83,7 @@ public class AssemblyTreeResolver {
 		this.grammar = tree.getGrammar();
 		this.context = context.fillMask();
 		this.ctxGraph = ctxGraph;
+		this.operandData = AssemblyOperandData.buildAssemblyOperandDataTree(tree);
 	}
 
 	/**
@@ -108,7 +110,11 @@ public class AssemblyTreeResolver {
 		}
 
 		Stream<AssemblyResolvedPatterns> patStream =
-			protStream.map(p -> p.state).distinct().flatMap(s -> s.resolve(empty, errors));
+			protStream.map(p -> p.state).distinct().flatMap(s -> {
+				// add operand data to results structure
+				empty.setOperandData(operandData);
+				return s.resolve(empty, errors);
+			});
 
 		AssemblyResolutionResults results = new AssemblyResolutionResults();
 		patStream.forEach(results::add);
@@ -119,6 +125,7 @@ public class AssemblyTreeResolver {
 		// TODO: Remove this? It's subsumed by filterByDisassembly, and more accurately....
 		results = filterForbidden(results);
 		results = filterByDisassembly(results);
+		results = fillMasksVals(results);
 		results.addAll(errors);
 		return results;
 	}
@@ -276,6 +283,24 @@ public class AssemblyTreeResolver {
 		});
 	}
 
+	/**
+	 * Apply the shifts to the operand data (i.e. add trailing and leading bytes),
+	 * and add masks and vals that are missing.
+	 *
+	 * @param temp the results
+	 * @return results with operand data shifted
+	 */
+	protected AssemblyResolutionResults fillMasksVals(AssemblyResolutionResults temp) {
+		return temp.apply(rc -> {
+			if (!rc.isError()) {
+				int instructionLength = rc.getInstructionLength();
+				rc.operandData.applyShifts(instructionLength);
+				rc.operandData.fillMissingMasksVals(instructionLength);
+			}
+			return rc;
+		});
+	}
+
 	/**
 	 * Get the state generator for a given operand and parse tree node
 	 * 
@@ -440,7 +465,13 @@ public class AssemblyTreeResolver {
 			int offset = opSym.getRelativeOffset();
 			results = parent("Resolving recursive constructor: " + cons.getSourceFile() + ":" +
 				cons.getLineno(), results, 1);
-			results = results.apply(rc -> rc.shift(offset));
+			results = results.apply(rc -> {
+				rc.operandData = rc.operandData.copy();
+				AssemblyResolvedPatterns shifted = rc.shift(offset);
+				// add shift for root node
+				rc.operandData.addByteShift(shifted.ins.getOffset());
+				return shifted;
+			});
 			results = resolvePatterns(sem, 0, results).apply(rc -> rc.withConstructor(cons));
 		}
 		return results;
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyEOI.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyEOI.java
index de8b400ea..a52985aba 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyEOI.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyEOI.java
@@ -45,6 +45,14 @@ public class AssemblyEOI extends AssemblyTerminal {
 		return Collections.emptySet();
 	}
 
+	@Override
+	public Collection<AssemblyParseToken> matchAll(AssemblyGrammar grammar,
+			AssemblyNumericSymbols symbols) {
+
+			return Collections.singleton(new AssemblyParseToken(grammar, this, ""));
+	}
+
+
 	@Override
 	public Collection<String> getSuggestions(String got, AssemblyNumericSymbols symbols) {
 		return Collections.singleton("");
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyNumericTerminal.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyNumericTerminal.java
index 962f37ab2..d2c5d0d2a 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyNumericTerminal.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyNumericTerminal.java
@@ -17,9 +17,14 @@ package ghidra.app.plugin.assembler.sleigh.symbol;
 
 import java.util.*;
 import java.util.stream.Collectors;
+import java.util.stream.LongStream;
+import java.util.stream.Stream;
 
 import ghidra.app.plugin.assembler.sleigh.grammars.AssemblyGrammar;
 import ghidra.app.plugin.assembler.sleigh.tree.AssemblyParseNumericToken;
+
+import ghidra.program.model.address.Address;
+import ghidra.program.model.address.AddressOutOfBoundsException;
 import ghidra.program.model.address.AddressSpace;
 
 /**
@@ -144,6 +149,135 @@ public class AssemblyNumericTerminal extends AssemblyTerminal {
 				.collect(Collectors.toList());
 	}
 
+    @Override
+    public Collection<AssemblyParseNumericToken> matchAll(AssemblyGrammar grammar, AssemblyNumericSymbols labels) {
+        System.out.println("WARNING: Numeric Tokens may not be fully implemented!!!!!!");
+
+        Collection<AssemblyParseNumericToken> out = new ArrayList<>();
+        getInterestingLongs(null)
+                // Now convert each masked value to a token
+                .mapToObj(x -> {
+                    return longToToken(x, grammar);
+                })
+                // Finally add all the tokens to our output
+                .forEach(out::addAll);
+
+        if (labels.languageLabels.size() > 100) {
+            System.out.println(
+                    "WARNING: A large number of labels found! Things will be slow if you don't filter your numeric/address wildcards!!!!!!");
+        }
+
+        labels.languageLabels.forEach((label, addresses) -> {
+            addresses.forEach(
+                    address -> out.add(new AssemblyParseNumericToken(grammar, this, label, address.getOffset())));
+        });
+
+        return out;
+    }
+
+    public Collection<AssemblyParseNumericToken> matchAllWithAddress(AssemblyGrammar grammar,
+            AssemblyNumericSymbols labels, Address anticipatedAddress) {
+        Collection<AssemblyParseNumericToken> out = this.matchAll(grammar, labels);
+
+        getInterestingLongs(anticipatedAddress)
+                // Now convert each masked value to a token
+                .mapToObj(x -> {
+                    return longToToken(x, grammar);
+                })
+                // Finally add all the tokens to our output
+                .forEach(out::addAll);
+
+        return out;
+    }
+
+    /** Return a long with n least significant bits filled in. */
+    public static long fillBits(long n) {
+        return -1L >>> (64 - n);
+    }
+
+    /**
+     * Stream of all longs having only one bit set or one bit not set
+     *
+     * @return
+     */
+    public static LongStream getOneBitLongs() {
+        return LongStream.concat(LongStream.of(0), LongStream.range(0, 32)
+                // get a long for each single bit enabled
+                .flatMap(x -> {
+                    long bitPos = 1 << x;
+                    return LongStream.of(bitPos, -1 * bitPos);
+                }));
+    }
+
+    /**
+     * Returns a stream of longs consisting of all 1-bit-set longs, all
+     * 1-bit-not-set longs, and (optionally) all of these previously described
+     * numbers relative to the given address.
+     *
+     * @param relativeToAddress
+     * @return
+     */
+    public static LongStream getInterestingLongs(Address relativeToAddress) {
+
+        LongStream out = getOneBitLongs();
+        LongStream addressBased = LongStream.of();
+        if (relativeToAddress != null) {
+            addressBased = getOneBitLongs()
+                    // Convert each of these to addresses, adding to the base of the address space
+                    // and by adding to the anticipated address
+                    .mapToObj(x -> {
+                        Address y;
+                        try {
+                            y = relativeToAddress.add(x);
+                        } catch (AddressOutOfBoundsException e) {
+                            y = null;
+                        }
+
+                        Address z;
+                        try {
+                            z = relativeToAddress.getNewAddress(x);
+                        } catch (AddressOutOfBoundsException e) {
+                            z = null;
+                        }
+                        return Stream.of(y, z);
+                    }).flatMap(x -> x)
+
+                    // Get rid of nulls
+                    .filter(xx -> xx != null)
+                    // Convert to longs
+                    .mapToLong(x -> Long.parseUnsignedLong(x.toString(), 16));
+        }
+
+        return LongStream.concat(out, addressBased).distinct()
+                // Mask out the low n bits (for 0 <= n < 32)
+                .flatMap(x -> {
+                    if (x > 0) {
+                        return LongStream.range(0, 32).map(n -> {
+
+                            long mask = Long.MAX_VALUE ^ (fillBits(n));
+                            return x & mask;
+                        });
+
+                    }
+                    return LongStream.of(x);
+                })
+                .distinct();
+    }
+
+    Collection<AssemblyParseNumericToken> longToToken(long x, AssemblyGrammar grammar) {
+        String str;
+        String baseValue;
+        if (x < 0) {
+            baseValue = Long.toHexString(-1 * x);
+            str = String.format("-0x%s", baseValue);
+        } else {
+            baseValue = Long.toHexString(x);
+            str = String.format("0x%s", x);
+        }
+        return makeToken(str, baseValue, 16, x < 0, grammar);
+    }
+
+
 	/**
 	 * Try to match a numeric literal, after the optional sign, encoded in hex, decimal, or octal
 	 * 
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyStringMapTerminal.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyStringMapTerminal.java
index a1f3a89bc..b94bf3b9f 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyStringMapTerminal.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyStringMapTerminal.java
@@ -57,6 +57,17 @@ public class AssemblyStringMapTerminal extends AssemblyTerminal {
 		return result;
 	}
 
+	@Override
+	public Collection<AssemblyParseNumericToken> matchAll(AssemblyGrammar grammar, AssemblyNumericSymbols symbols) {
+		Collection<AssemblyParseNumericToken> result = new LinkedHashSet<>();
+		for (Entry<String, Integer> ent : map.entries()) {
+			String str = ent.getKey();
+			result.add(new AssemblyParseNumericToken(grammar, this, str, ent.getValue()));
+		}
+		return result;
+	}
+
+
 	@Override
 	public Collection<String> getSuggestions(String string, AssemblyNumericSymbols symbols) {
 		return map.keySet();
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyStringTerminal.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyStringTerminal.java
index 25fdaf825..a7e0eb1ef 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyStringTerminal.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyStringTerminal.java
@@ -50,6 +50,12 @@ public class AssemblyStringTerminal extends AssemblyTerminal {
 		return Collections.emptySet();
 	}
 
+	@Override
+	public Collection<AssemblyParseToken> matchAll(AssemblyGrammar grammar,
+			AssemblyNumericSymbols symbols) {
+		return Collections.singleton(new AssemblyParseToken(grammar, this, str));
+	}
+
 	@Override
 	public Collection<String> getSuggestions(String got, AssemblyNumericSymbols symbols) {
 		return Collections.singleton(str);
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyTerminal.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyTerminal.java
index 601f842a6..e1a5c9e95 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyTerminal.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyTerminal.java
@@ -51,6 +51,16 @@ public abstract class AssemblyTerminal extends AssemblySymbol {
 	public abstract Collection<? extends AssemblyParseToken> match(String buffer, int pos,
 			AssemblyGrammar grammar, AssemblyNumericSymbols symbols);
 
+	/**
+	 * Just like "match" but always claims that "buffer" (which isn't even
+	 * passed to this function) is a match with this AssemblyTerminal at pos
+	 * (which, again, isn't even passed)
+	 * @param grammar the grammar containing this terminal
+	 * @param labels the program labels, if applicable
+	 * @return the matched token, or null
+	 */
+	public abstract Collection<? extends AssemblyParseToken> matchAll(AssemblyGrammar grammar, AssemblyNumericSymbols labels);
+
 	/**
 	 * Provide a collection of strings that this terminal would have accepted
 	 * 
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyWildcardTerminal.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyWildcardTerminal.java
new file mode 100644
index 000000000..aaea41c86
--- /dev/null
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/symbol/AssemblyWildcardTerminal.java
@@ -0,0 +1,109 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.plugin.assembler.sleigh.symbol;
+
+import java.util.*;
+
+import ghidra.app.plugin.assembler.sleigh.grammars.AssemblyGrammar;
+import ghidra.app.plugin.assembler.sleigh.sem.AssemblyOperandData;
+import ghidra.app.plugin.assembler.sleigh.tree.AssemblyParseToken;
+
+import ghidra.program.model.address.Address;
+import ghidra.program.model.lang.OperandType;
+
+/**
+ * A terminal that accepts a wildcard.
+ * <p>
+ * This Terminal wraps another "internal" AssemblyTerminal and always ensures
+ * that we claim that our input (which is being parsed) matches the internal
+ * AssemblyTerminal.
+ * <p>
+ * We do this by adding a matchAll method to AssemblyTerminal and calling this
+ * when AssemblyWildcardTerminal.match is called.
+ */
+public class AssemblyWildcardTerminal extends AssemblyTerminal {
+	protected final AssemblyTerminal internal;
+	protected final AssemblyOperandData meta;
+	protected final Address anticipatedAddress;
+
+	/**
+	 * Construct a terminal that accepts only the given string.
+	 */
+	public AssemblyWildcardTerminal(AssemblyTerminal internal, String wildcardName, int id,
+			Address anticipatedAddress) {
+		super("WILD-" + wildcardName + ":" + internal.getName());
+		this.internal = internal;
+		int type;
+		// TODO: Are there other variants we should handle here?
+		if (internal instanceof AssemblyNumericTerminal) {
+			type = OperandType.SCALAR;
+		} else {
+			type = OperandType.REGISTER;
+		}
+		this.meta = new AssemblyOperandData(wildcardName, id, type);
+		this.anticipatedAddress = anticipatedAddress;
+	}
+
+	@Override
+	public String toString() {
+		return "WILD-" + meta.getWildcardName() + ":" + internal.toString();
+	}
+
+	@Override
+	public Collection<? extends AssemblyParseToken> match(String buffer, int pos, AssemblyGrammar grammar,
+			AssemblyNumericSymbols labels) {
+		Collection<? extends AssemblyParseToken> internalResults;
+		if (internal instanceof AssemblyNumericTerminal) {
+			internalResults = ((AssemblyNumericTerminal) internal).matchAllWithAddress(grammar,
+					labels, this.anticipatedAddress);
+		} else {
+			internalResults = internal.matchAll(grammar, labels);
+		}
+		for (AssemblyParseToken t : internalResults) {
+			t.setOperandData(meta);
+		}
+		return internalResults;
+	}
+
+	@Override
+	public Collection<? extends AssemblyParseToken> matchAll(AssemblyGrammar grammar, AssemblyNumericSymbols labels) {
+		Collection<? extends AssemblyParseToken> internalResults;
+		if (internal instanceof AssemblyNumericTerminal) {
+			internalResults = ((AssemblyNumericTerminal) internal).matchAllWithAddress(grammar,
+					labels, this.anticipatedAddress);
+		} else {
+			internalResults = internal.matchAll(grammar, labels);
+		}
+		for (AssemblyParseToken t : internalResults) {
+			t.setOperandData(meta);
+		}
+		return internalResults;
+	}
+
+	public AssemblyTerminal getInternal() {
+		return internal;
+	}
+
+	@Override
+	public Collection<String> getSuggestions(String got, AssemblyNumericSymbols labels) {
+		return internal.getSuggestions(got, labels);
+	}
+
+	@Override
+	public boolean takesOperandIndex() {
+		return internal.takesOperandIndex();
+	}
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/tree/AssemblyParseTreeNode.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/tree/AssemblyParseTreeNode.java
index ca80792d6..dbad0312a 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/tree/AssemblyParseTreeNode.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/tree/AssemblyParseTreeNode.java
@@ -18,6 +18,7 @@ package ghidra.app.plugin.assembler.sleigh.tree;
 import java.io.PrintStream;
 
 import ghidra.app.plugin.assembler.sleigh.grammars.AssemblyGrammar;
+import ghidra.app.plugin.assembler.sleigh.sem.AssemblyOperandData;
 import ghidra.app.plugin.assembler.sleigh.symbol.AssemblySymbol;
 
 /**
@@ -26,6 +27,7 @@ import ghidra.app.plugin.assembler.sleigh.symbol.AssemblySymbol;
 public abstract class AssemblyParseTreeNode {
 	protected AssemblyParseBranch parent = null;
 	protected final AssemblyGrammar grammar;
+	protected AssemblyOperandData operandData = null;
 
 	/**
 	 * Construct a node for a tree parsed by the given grammar
@@ -36,6 +38,14 @@ public abstract class AssemblyParseTreeNode {
 		this.grammar = grammar;
 	}
 
+	public AssemblyOperandData getOperandData() {
+		return operandData;
+	}
+
+	public void setOperandData(AssemblyOperandData operandData) {
+		this.operandData = operandData;
+	}
+
 	/**
 	 * Get the symbol for which this node is substituted
 	 * 
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/util/TableEntryKey.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/util/TableEntryKey.java
index 00da052b3..35db31e4a 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/util/TableEntryKey.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/util/TableEntryKey.java
@@ -18,6 +18,7 @@ package ghidra.app.plugin.assembler.sleigh.util;
 import ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseActionGotoTable;
 import ghidra.app.plugin.assembler.sleigh.parse.AssemblyParseTransitionTable;
 import ghidra.app.plugin.assembler.sleigh.symbol.AssemblySymbol;
+import ghidra.app.plugin.assembler.sleigh.symbol.AssemblyWildcardTerminal;
 
 /**
  * A key in a (sparse) LR(0) transition table or LALR(1) action/goto table
@@ -37,7 +38,11 @@ public class TableEntryKey implements Comparable<TableEntryKey> {
 	 */
 	public TableEntryKey(int state, AssemblySymbol sym) {
 		this.state = state;
-		this.sym = sym;
+		if (sym instanceof AssemblyWildcardTerminal awt) {
+			this.sym = awt.getInternal();
+		} else {
+			this.sym = sym;
+		}
 	}
 
 	@Override
-- 
2.43.0

