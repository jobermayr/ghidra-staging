From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Johannes Obermayr <johannesobermayr@gmx.de>
Date: Fri, 5 May 2023 17:09:48 +0200
Subject: [PATCH] 5333: Add GhidraChatGPT

It is based on the work from https://github.com/likvidera/GhidraChatGPT

commit ec88daad6ad93978780d031ef5e730340c7f00bf
Author: mk <mk@clevcode.org>
Date:   Mon Jan 2 15:11:52 2023 +0100

    Add key bindings and update README

commit adedbd0f4ba6afba7305f4dbc2b397ade538fb13
Author: mk <mk@clevcode.org>
Date:   Mon Jan 2 13:21:47 2023 +0100

    init

As an additional gimmick I added support of answers in different human
languages :)
---
 Ghidra/Features/Decompiler/Module.manifest    |  16 +
 Ghidra/Features/Decompiler/build.gradle       |  18 +
 .../core/analysis/GhidraChatGPTComponent.java | 190 +++++++++
 .../core/analysis/GhidraChatGPTPlugin.java    | 359 ++++++++++++++++++
 build.gradle                                  |   1 +
 5 files changed, 584 insertions(+)
 create mode 100644 Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/analysis/GhidraChatGPTComponent.java
 create mode 100644 Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/analysis/GhidraChatGPTPlugin.java

diff --git a/Ghidra/Features/Decompiler/Module.manifest b/Ghidra/Features/Decompiler/Module.manifest
index 0c8cbd6380..286c7438b0 100644
--- a/Ghidra/Features/Decompiler/Module.manifest
+++ b/Ghidra/Features/Decompiler/Module.manifest
@@ -1 +1,17 @@
 MODULE FILE LICENSE: src/decompile/zlib zlib License
+#for GhidraChatGPT
+MODULE FILE LICENSE: lib/client-0.16.0.jar MIT
+MODULE FILE LICENSE: lib/service-0.16.0.jar MIT
+MODULE FILE LICENSE: lib/adapter-rxjava2-2.9.0.jar Apache License 2.0
+MODULE FILE LICENSE: lib/converter-jackson-2.9.0.jar Apache License 2.0
+MODULE FILE LICENSE: lib/jackson-annotations-2.15.0.jar Apache License 2.0
+MODULE FILE LICENSE: lib/jackson-core-2.15.0.jar Apache License 2.0
+MODULE FILE LICENSE: lib/jackson-databind-2.15.0.jar Apache License 2.0
+MODULE FILE LICENSE: lib/json-20230227.jar Public Domain
+MODULE FILE LICENSE: lib/kotlin-stdlib-1.8.21.jar Apache License 2.0
+MODULE FILE LICENSE: lib/okhttp-3.14.9.jar Apache License 2.0
+MODULE FILE LICENSE: lib/okio-3.3.0.jar Apache License 2.0
+MODULE FILE LICENSE: lib/okio-jvm-3.3.0.jar Apache License 2.0
+MODULE FILE LICENSE: lib/reactive-streams-1.0.3.jar MIT
+MODULE FILE LICENSE: lib/retrofit-2.9.0.jar Apache License 2.0
+MODULE FILE LICENSE: lib/rxjava-2.2.21.jar Apache License 2.0
diff --git a/Ghidra/Features/Decompiler/build.gradle b/Ghidra/Features/Decompiler/build.gradle
index 163125c5a7..ea3de91c74 100644
--- a/Ghidra/Features/Decompiler/build.gradle
+++ b/Ghidra/Features/Decompiler/build.gradle
@@ -31,6 +31,24 @@ ext.xsltproc = "xsltproc --nonet"
 dependencies {
 	api project(':Base')
 	api project(':SoftwareModeling')
+
+	// for GhidraChatGPT
+	implementation 'com.fasterxml.jackson.core:jackson-annotations:2.15.0'
+	implementation 'com.fasterxml.jackson.core:jackson-core:2.15.0'
+	implementation 'com.fasterxml.jackson.core:jackson-databind:2.15.0'
+	implementation 'com.squareup.okhttp3:okhttp:3.14.9'
+	implementation 'com.squareup.okio:okio:3.3.0'
+	implementation 'com.squareup.okio:okio-jvm:3.3.0'
+	implementation 'com.squareup.retrofit2:adapter-rxjava2:2.9.0'
+	implementation 'com.squareup.retrofit2:converter-jackson:2.9.0'
+	implementation 'com.squareup.retrofit2:retrofit:2.9.0'
+	implementation 'com.theokanning.openai-gpt3-java:client:0.16.0'
+	implementation 'com.theokanning.openai-gpt3-java:service:0.16.0'
+	implementation 'io.reactivex.rxjava2:rxjava:2.2.21'
+	implementation 'org.jetbrains.kotlin:kotlin-stdlib:1.8.21'
+	implementation 'org.json:json:20230227'
+	implementation 'org.reactivestreams:reactive-streams:1.0.3'
+
 	// include Base src/test/resources when running decompiler integration tests (uses defaultTools)
 	integrationTestImplementation project(path: ':Base', configuration: 'testArtifacts')
 	integrationTestImplementation project(path: ':SoftwareModeling', configuration: 'testArtifacts')
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/analysis/GhidraChatGPTComponent.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/analysis/GhidraChatGPTComponent.java
new file mode 100644
index 0000000000..576ee0e607
--- /dev/null
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/analysis/GhidraChatGPTComponent.java
@@ -0,0 +1,190 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ghidrachatgpt;
+
+import docking.ActionContext;
+import docking.ComponentProvider;
+import docking.Tool;
+import docking.action.DockingAction;
+import docking.action.KeyBindingData;
+import docking.action.MenuData;
+import docking.action.ToolBarData;
+import docking.tool.ToolConstants;
+import ghidra.app.plugin.ProgramPlugin;
+import ghidra.app.script.AskDialog;
+import ghidra.framework.plugintool.*;
+import ghidra.util.Msg;
+import java.awt.BorderLayout;
+import java.awt.event.InputEvent;
+import java.awt.event.KeyEvent;
+import java.lang.Integer;
+import java.lang.Thread;
+import java.util.List;
+import javax.swing.*;
+import resources.Icons;
+
+public class GhidraChatGPTComponent extends ComponentProvider {
+
+	private JPanel panel;
+	private DockingAction action;
+	private GhidraChatGPTPlugin gcgplugin;
+	static final String FUNCTION_ID_NAME = "GhidraChatGPT";
+
+	public GhidraChatGPTComponent(Plugin plugin, String owner) {
+		super(plugin.getTool(), owner, owner);
+		gcgplugin = (GhidraChatGPTPlugin) plugin;
+		createActions();
+	}
+
+	public String askForOpenAIToken() {
+		AskDialog<String> dialog = new AskDialog<>("OpenAI API token not configured!",
+			"Enter OpenAI API Token:", AskDialog.STRING, gcgplugin.getToken());
+		if (dialog.isCanceled()) {
+			return null;
+		}
+		return dialog.getValueAsString();
+	}
+
+	public String askForOpenAILanguage() {
+		// Asking ChatGPT with "Give me a list of well supported human languages by ChatGPT"
+		List<String> langs = List.of(
+			"Arabic",
+			"Chinese (Simplified)",
+			"Danish",
+			"Dutch",
+			"English",
+			"Finnish",
+			"French",
+			"German",
+			"Hindi",
+			"Indonesian",
+			"Italian",
+			"Japanese",
+			"Korean",
+			"Norwegian",
+			"Polish",
+			"Portuguese",
+			"Russian",
+			"Spanish",
+			"Swedish",
+			"Turkish"
+		);
+		AskDialog<String> dialog = new AskDialog<>(null, "OpenAI Language", "Choose OpenAI Language", AskDialog.STRING, langs, gcgplugin.getOpenAILanguage());
+		if (dialog.isCanceled()) {
+			return null;
+		}
+		return dialog.getValueAsString();
+	}
+
+	private void createActions() {
+		// Identify function
+		action = new DockingAction("GCGIdentifyFunction", getName()) {
+			@Override
+			public void actionPerformed(ActionContext context) { new Thread(() -> { gcgplugin.identifyFunction(); }).start(); }
+		};
+
+		action.setEnabled(true);
+		action.setDescription("Identify the function with the help of ChatGPT");
+		action.setMenuBarData(new MenuData(new String[] { ToolConstants.MENU_TOOLS, FUNCTION_ID_NAME, "Identify Function" }));
+		action.setKeyBindingData(new KeyBindingData(KeyEvent.VK_I, InputEvent.SHIFT_DOWN_MASK | InputEvent.ALT_DOWN_MASK | InputEvent.CTRL_DOWN_MASK));
+		dockingTool.addAction(action);
+
+		// Find vulnerabilities
+		action = new DockingAction("GCGFindVulnerabilities", getName()) {
+			@Override
+			public void actionPerformed(ActionContext context) { new Thread(() -> { gcgplugin.findVulnerabilities(); }).start(); }
+		};
+
+		action.setEnabled(true);
+		action.setDescription("Find vulnerabilities in the function with the help of ChatGPT");
+		action.setMenuBarData(new MenuData(new String[] { ToolConstants.MENU_TOOLS, FUNCTION_ID_NAME, "Find Vulnerabilities" }));
+		action.setKeyBindingData(new KeyBindingData(KeyEvent.VK_V, InputEvent.SHIFT_DOWN_MASK | InputEvent.ALT_DOWN_MASK | InputEvent.CTRL_DOWN_MASK));
+		dockingTool.addAction(action);
+
+		// Beautify function
+		action = new DockingAction("GCGBeautifyFunction", getName()) {
+			@Override
+			public void actionPerformed(ActionContext context) { new Thread(() -> { gcgplugin.beautifyFunction(); }).start(); }
+		};
+
+		action.setEnabled(true);
+		action.setDescription("Beautify the function with the help of ChatGPT");
+		action.setMenuBarData(new MenuData(new String[] { ToolConstants.MENU_TOOLS, FUNCTION_ID_NAME, "Beautify Function" }));
+		action.setKeyBindingData(new KeyBindingData(KeyEvent.VK_B, InputEvent.SHIFT_DOWN_MASK | InputEvent.ALT_DOWN_MASK | InputEvent.CTRL_DOWN_MASK));
+		dockingTool.addAction(action);
+
+		// Update OpenAI Token
+		action = new DockingAction("GCGUpdateOpenAIToken", getName()) {
+			@Override
+			public void actionPerformed(ActionContext context) {
+				if (gcgplugin.setToken(askForOpenAIToken())) {
+					gcgplugin.ok("Updated the current OpenAI API Token");
+				}
+			}
+		};
+
+		action.setEnabled(true);
+		action.setDescription("Update the current OpenAI API Token");
+		action.setMenuBarData(new MenuData(new String[] { ToolConstants.MENU_TOOLS, FUNCTION_ID_NAME, "Settings", "Update OpenAI Token" }));
+		dockingTool.addAction(action);
+
+		// Update OpenAI Language
+		action = new DockingAction("GCGUpdateOpenAILanguage", getName()) {
+			@Override
+			public void actionPerformed(ActionContext context) {
+				if (gcgplugin.setOpenAILanguage(askForOpenAILanguage())) {
+					gcgplugin.ok("Updated the current OpenAI Language");
+				}
+			}
+		};
+
+		action.setEnabled(true);
+		action.setDescription("Update the current OpenAI Language");
+		action.setMenuBarData(new MenuData(new String[] { ToolConstants.MENU_TOOLS, FUNCTION_ID_NAME, "Settings", "Update OpenAI Language" }));
+		dockingTool.addAction(action);
+
+		// Update the Model used
+		String[] models = {
+			"gpt-5",
+			"gpt-5-mini",
+			"gpt-5-nano",
+			"gpt-4.1",
+			"gpt-4.1-mini",
+			"gpt-4.1-nano",
+			"o3",
+			"o4-mini",
+			"gpt-4o"
+		};
+
+		for (String model : models) {
+			DockingAction action = new DockingAction("Model - " + model, "Model Category") {
+				@Override
+				public void actionPerformed(ActionContext context) {
+					gcgplugin.setModel(model);
+					gcgplugin.ok(String.format("Updated model to %s", model));
+				}
+			};
+			action.setMenuBarData(new MenuData(new String[] { ToolConstants.MENU_TOOLS, FUNCTION_ID_NAME, "Model", model}));
+			dockingTool.addAction(action);
+		}
+	}
+
+	@Override
+	public JComponent getComponent() {
+		return panel;
+	}
+}
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/analysis/GhidraChatGPTPlugin.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/analysis/GhidraChatGPTPlugin.java
new file mode 100644
index 0000000000..496f02953a
--- /dev/null
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/plugin/core/analysis/GhidraChatGPTPlugin.java
@@ -0,0 +1,359 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ghidrachatgpt;
+
+import com.theokanning.openai.completion.chat.ChatCompletionRequest;
+import com.theokanning.openai.completion.chat.ChatMessage;
+import com.theokanning.openai.completion.chat.ChatMessageRole;
+import com.theokanning.openai.service.OpenAiService;
+import docking.Tool;
+import ghidra.app.CorePluginPackage;
+import ghidra.app.ExamplesPluginPackage;
+import ghidra.app.decompiler.flatapi.FlatDecompilerAPI;
+import ghidra.app.plugin.PluginCategoryNames;
+import ghidra.app.plugin.ProgramPlugin;
+import ghidra.app.services.CodeViewerService;
+import ghidra.app.services.ConsoleService;
+import ghidra.framework.plugintool.*;
+import ghidra.framework.plugintool.util.PluginStatus;
+import ghidra.framework.preferences.Preferences;
+import ghidra.program.flatapi.FlatProgramAPI;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.listing.Function;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.listing.Variable;
+import ghidra.program.model.symbol.SourceType;
+import ghidra.program.util.ProgramLocation;
+import ghidra.util.HelpLocation;
+import java.lang.Integer;
+import java.time.Duration;
+import java.util.List;
+import org.json.JSONObject;
+
+//@formatter:off
+@PluginInfo(
+	status = PluginStatus.RELEASED,
+	packageName = CorePluginPackage.NAME,
+	category = PluginCategoryNames.ANALYSIS,
+	shortDescription = "ChatGPT Plugin for Ghidra",
+	description = "Brings the power of ChatGPT to Ghidra!",
+	servicesRequired = {
+		ConsoleService.class,
+		CodeViewerService.class
+	}
+)
+
+//@formatter:on
+public class GhidraChatGPTPlugin extends ProgramPlugin {
+	ConsoleService cs;
+	CodeViewerService cvs;
+	private GhidraChatGPTComponent uiComponent;
+	private String apiToken;
+	private String lang;
+	private String openAiModel;
+	private int OPENAI_TIMEOUT = 120;
+	private static final String GCG_IDENTIFY_STRING = "Describe the function with as much detail as possible and include a link to an open source version if there is one\n%s\nAnswer in %s";
+	private static final String GCG_VULNERABILITY_STRING = "Describe all vulnerabilities in this function with as much detail as possible\n%s\nAnswer in %s";
+	private static final String GCG_BEAUTIFY_STRING = "Analyze the function and suggest function and variable names in a json format where the key is the previous name and the value is the suggested name\n%s\nAnswer in %s";
+
+	/**
+	 * Plugin constructor.
+	 *
+	 * @param tool The plugin tool that this plugin is added to.
+	 */
+	public GhidraChatGPTPlugin(PluginTool tool) {
+		super(tool);
+
+		String pluginName = getName();
+		uiComponent = new GhidraChatGPTComponent(this, pluginName);
+
+		String topicName = this.getClass().getPackage().getName();
+		String anchorName = "HelpAnchor";
+		uiComponent.setHelpLocation(new HelpLocation(topicName, anchorName));
+	}
+
+	@Override
+	public void init() {
+		super.init();
+		cs = tool.getService(ConsoleService.class);
+		cvs = tool.getService(CodeViewerService.class);
+		apiToken = System.getenv("OPENAI_TOKEN");
+		if (apiToken == null) {
+			apiToken = System.getenv("OPENAI_TOKEN");
+		}
+		if (apiToken != null) {
+			ok(String.format("Loaded OpenAI Token: %s", censorToken(apiToken)));
+		}
+		lang = Preferences.getProperty("OPENAI_LANG");
+		if (lang == null)
+			lang = "English";
+		ok(String.format("Language is: %s", lang));
+		openAiModel = Preferences.getProperty("OPENAI_MODEL");
+		if (openAiModel == null)
+			openAiModel = "gpt-4.1";
+		ok(String.format("Model is: %s", openAiModel));
+	}
+
+	private static String censorToken(String token) {
+		StringBuilder censoredBuilder = new StringBuilder(token.length());
+		censoredBuilder.append(token.substring(0, 2));
+
+		for (int i = 2; i < token.length(); i++) {
+			censoredBuilder.append('*');
+		}
+		return censoredBuilder.toString();
+	}
+
+	public Boolean setToken(String token) {
+		if (token == null)
+			return false;
+
+		apiToken = token;
+		Preferences.setProperty("OPENAI_TOKEN",token);
+		Preferences.store();
+
+		return true;
+	}
+
+	public String getToken() {
+		return apiToken;
+	}
+
+	public void setModel(String model) {
+		if (model == null)
+			model = "gpt-4.1";
+		openAiModel = model;
+		Preferences.setProperty("OPENAI_MODEL",openAiModel);
+		Preferences.store();
+	}
+
+
+	public Boolean setOpenAILanguage(String newLang) {
+		if (newLang == null)
+			newLang = "English";
+		lang = newLang;
+		Preferences.setProperty("OPENAI_LANG",lang);
+		Preferences.store();
+		return true;
+	}
+
+	public String getOpenAILanguage () {
+		return lang;
+	}
+
+	public void identifyFunction() {
+		String result;
+		DecompilerResults decResult = decompileCurrentFunc();
+		if (decResult == null)
+			return;
+
+		log(String.format("Identifying the current function: %s", decResult.func.getName()));
+		result = askChatGPT(String.format(GCG_IDENTIFY_STRING, decResult.decompiledFunc, lang));
+		if (result == null)
+			return;
+
+		addComment(decResult.prog, decResult.func, result, "[GhidraChatGPT] - Identify Function");
+	}
+
+	public void findVulnerabilities() {
+		String result;
+		DecompilerResults decResult = decompileCurrentFunc();
+		if (decResult == null)
+			return;
+
+		log(String.format("Finding vulnerabilities in the current function: %s", decResult.func.getName()));
+		result = askChatGPT(String.format(GCG_VULNERABILITY_STRING, decResult.decompiledFunc, lang));
+		if (result == null)
+			return;
+
+		addComment(decResult.prog, decResult.func, result, "[GhidraChatGPT] - Find Vulnerabilities");
+	}
+
+	public void beautifyFunction() {
+		String result;
+		DecompilerResults decResult = decompileCurrentFunc();
+		if (decResult == null)
+			return;
+
+		log(String.format("Beautifying the function: %s", decResult.func.getName()));
+		result = askChatGPT(String.format(GCG_BEAUTIFY_STRING, decResult.decompiledFunc, lang));
+		if (result == null)
+			return;
+
+		updateVariables(decResult.prog, decResult, result);
+		ok(String.format("Beautified the function: %s", decResult.func.getName()));
+	}
+
+	private Boolean checkOpenAIToken() {
+		if (apiToken != null)
+			return true;
+
+		if (!setToken(uiComponent.askForOpenAIToken())) {
+			error("Failed to update the OpenAI API token");
+			return false;
+		}
+		return true;
+    }
+
+	private class DecompilerResults {
+		public Program prog;
+		public Function func;
+		public String decompiledFunc;
+
+		public DecompilerResults(Program prog, Function func, String decompiledFunc){
+			this.prog = prog;
+			this.func = func;
+			this.decompiledFunc = decompiledFunc;
+		}
+	}
+
+	private DecompilerResults decompileCurrentFunc() {
+		String decompiledFunc;
+
+		ProgramLocation progLoc = cvs.getCurrentLocation();
+		Program prog = progLoc.getProgram();
+		FlatProgramAPI programApi = new FlatProgramAPI(prog);
+		FlatDecompilerAPI decompiler = new FlatDecompilerAPI(programApi);
+		Function func = programApi.getFunctionContaining(progLoc.getAddress());
+		if (func == null) {
+			error("Failed to find the current function");
+			return null;
+		}
+
+		try {
+			decompiledFunc = decompiler.decompile(func);
+		} catch (Exception e) {
+			error(String.format("Failed to decompile the function: %s with the error %s", func.getName(), e));
+			return null;
+		}
+
+		return new DecompilerResults(prog, func, decompiledFunc);
+	}
+
+	private void updateVariables(Program prog, DecompilerResults decResult, String result) {
+		JSONObject jsonObj;
+
+		try {
+			jsonObj = new JSONObject(result);
+		} catch (Exception e) {
+			error("Failed to parse beautify JSON");
+			return;
+		}
+
+		Variable[] vars = decResult.func.getAllVariables();
+		if (vars == null) {
+			log("Nothing to beautify");
+			return;
+		}
+
+		var id = prog.startTransaction("GhidraChatGPT");
+		for (Variable var : vars) {
+			if (jsonObj.has(var.getName())) {
+				String val = jsonObj.getString(var.getName());
+				try {
+					var.setName(val, SourceType.USER_DEFINED);
+					ok(String.format("Beautified %s => %s", var.getName(), val));
+				} catch (Exception e) {
+					error(String.format("Failed to beautify %s => %s", var.getName(), val));
+				}
+			}
+		};
+
+		if (jsonObj.has(decResult.func.getName())) {
+			String val = jsonObj.getString(decResult.func.getName());
+			try {
+				decResult.func.setName(val, SourceType.USER_DEFINED);
+				ok(String.format("Beautified %s => %s", decResult.func.getName(), val));
+			} catch (Exception e) {
+				error(String.format("Failed to beautify %s => %s", decResult.func.getName(), val));
+			}
+		}
+
+		prog.endTransaction(id, true);
+	}
+
+	private void addComment(Program prog, Function func, String comment, String commentHeader) {
+		var id = prog.startTransaction("GhidraChatGPT");
+		String currentComment = func.getComment();
+		if (currentComment != null) {
+			currentComment = String.format("%s\n%s\n\n%s", commentHeader, comment, currentComment);
+		} else {
+			currentComment = String.format("%s\n%s", commentHeader, comment);
+		}
+
+		func.setComment(currentComment);
+		prog.endTransaction(id, true);
+		ok(String.format("Added the ChatGPT response as a comment to the function: %s", func.getName()));
+	}
+
+	private String askChatGPT(String prompt) {
+		String response = sendOpenAIRequest(prompt);
+		if (response == null) {
+			error("The ChatGPT response was empty, try again!");
+			return null;
+		}
+
+		return response;
+	}
+
+	private String sendOpenAIRequest(String prompt) {
+		StringBuilder response = new StringBuilder();
+		if (!checkOpenAIToken())
+			return null;
+
+		OpenAiService openAIService = new OpenAiService(apiToken, Duration.ofSeconds(OPENAI_TIMEOUT));
+		if (openAIService == null) {
+			error("Faild to start the OpenAI service, try again!");
+			return null;
+		}
+
+		ChatCompletionRequest chatCompletionRequest = ChatCompletionRequest
+			.builder()
+			.model(openAiModel)
+			.temperature(0.8)
+			.messages(List.of(
+				new ChatMessage(
+					ChatMessageRole.SYSTEM.value(),
+					"You are an assistant helping out with reverse engineering and vulnerability research"),
+					new ChatMessage(ChatMessageRole.USER.value(), prompt)))
+			.build();
+
+		try {
+			StringBuilder builder = new StringBuilder();
+			openAIService.createChatCompletion(chatCompletionRequest)
+				.getChoices()
+				.forEach(choice -> { builder.append(choice.getMessage().getContent()); });
+			return builder.toString();
+		} catch (Exception e) {
+			error(String.format("Asking ChatGPT failed with the error %s", e));
+			return null;
+		}
+	}
+
+	public void log(String message) {
+		cs.println(String.format("%s [>] %s", getName(), message));
+	}
+
+	public void error(String message) {
+		cs.println(String.format("%s [-] %s", getName(), message));
+	}
+
+	public void ok(String message) {
+		cs.println(String.format("%s [+] %s", getName(), message));
+	}
+
+}
diff --git a/build.gradle b/build.gradle
index da978cca88..e357fe4afd 100644
--- a/build.gradle
+++ b/build.gradle
@@ -78,6 +78,7 @@ if (flatRepo.isDirectory()) {
 			mavenLocal()
 			mavenCentral()
 			flatDir name: "flat", dirs:["$flatRepo"]
+			maven { url "https://repo1.maven.org/maven2" }
 		}
 	}
 }
-- 
2.45.1

