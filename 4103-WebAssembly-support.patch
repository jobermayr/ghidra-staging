From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Robert Xiao <brx@cs.ubc.ca>
Date: Fri, 25 Mar 2022 11:13:53 -0700
Subject: [PATCH] 4103: WebAssembly support.

Merged from https://github.com/nneonneo/ghidra-wasm-plugin/.

Closes #2937.

WebAssembly: add a help page to explain the finer points of the extension.

I was hoping to add this to a Processors help submenu, but it doesn't exist,
so I put it in the Appendix instead for now.

WebAssembly: make funcref/externref 32 bits in size.

The use of 64 bits was mostly a debugging feature to ensure we didn't accidentally
mix references with normal types. 64 bit addresses cause some problems, though,
such as 64-bit immediates (e.g. from ref.func) not always being treated as addresses
in the decompiler.

WebAssembly: reduce dependency on Program class.

Using Program throughout is rather lazy, and in many cases totally unnecessary.
Using finer-grained interfaces and classes like AddressFactory allows usage of
the code in non-Program contexts, such as emulation.

WebAssembly: load .module directly to 0x8000000 in RAM

This allows the whole module to be loaded in memory and eliminates the previous
duplication of the .code bytes in the .module and the .function bytes in RAM.

WebAssembly: extend regs to 16 bytes to prepare for vector insts

Vector instructions will require 128-bit values, so prepare for that change by
widening all registers to 128 bits.

WebAssembly: Emulation support

This patch implements a EmulateInstructionStateModifier for Wasm which provides
support for emulating Wasm instructions.

The memory contents must contain a full module for this to work, because
instruction semantics still depend on module details (e.g. the type of certain
operations depends on metadata like the types of imports or globals).

WebAssembly: correctly handle u32 opcodes.

0xFC (and 0xFD) have a u32 as the second operand, so we need to handle this
correctly.

WebAssembly: SIMD support.

Disassembly and verification are implemented, but almost all of the SIMD opcodes
are just stubbed out with pcodeops for now, so semantics aren't implemented. This
is probably good enough for now.

WebAssembly: create code length data to avoid undefined bytes

WebAssembly: update help stylesheet to recommended style

WebAssembly: remove now-deleted DataTypeConflictException

WebAssembly: update to use standard LEB128 utilities

WebAssembly: disable 2+ output vars for pos-stack as it is unsupported.

Without this, we get the error "<pentry> tags within a group must be
distinguished by size or type" when attempting to load the pos-stack compiler
spec. This will break functions that have multiple output arguments, but those
are expected to be rare (and they are not well-supported by Ghidra anyway).

WebAssembly: Add a new script to handle "flat" dyncall namespaces.

It seems like LLVM, for instance, uses table indices as function pointers, so
this script is likely to be useful for anything compiled with LLVM. As a guess,
analyze_dyncalls is probably only useful for programs compiled using the
Emscripten fastcomp backend.

WebAssembly: Mark __wasm prototypes as register strategies

WebAssembly: Add a stack analyzer which creates C stack variables for Wasm.

The traditional stack analyzer, StackVariableAnalyzer
(NewFunctionStackAnalysisCmd) depends on having registers that contain stack
addresses visible as assembly operands. However, due to the Wasm disassembler
design, which hides the Wasm stack registers from the disassembly, this stack
analysis cannot automatically extract stack variables.

As a fix, adapt FunctionStackAnalysisCmd to operate on the hidden Wasm stack
register operands to detect operations that interact with C stack addresses.

This helps with cross references to C stack variables, as well as allowing C
stack variables to be properly interacted with in the decompiler.

WebAssembly: update ConstantExpression comment

WebAssembly: add wasm build instructions to pcodetest

This successfully builds a working binary with Clang 15.

- `mem*` definitions in `misc_BODY.c` and new `main` definition in `tpp.py`
  are for C99 compatibility
- `encoding='utf8'` in build.py produces a more readable log
- `TestInfo_force` in pcode_test.c ensures that the entire `MainInfo` structure
  is included in the binary

WebAssembly: implement pcodetest tests.

We pass almost every test with -O0 and -O3, with the exception of pcode_conversions_Main.

There's a rather ugly hack needed to convert certain function pointers from
table indices (used by the actual code) to byte addresses (used by the emulator
to set PC). The way this is implemented is decidedly not ideal; a much better
solution would be to somehow hook readCodePointer in the
ProcessorEmulatorTestAdapter subclass; this would also enable the "procedure
descriptor indirection" fix to be moved into a processor-specific
implementation.

Changing the structs to protected in `ProcessorEmulatorTestAdapter` is for
convenience, so that the subclass does not need to go look those up again.

The zero-size check added to `BytesPcodeExecutorStateSpace#read` fixes a bug
which caused an exception when reading 0 bytes (`offset + size - 1` is not a
valid calculation in that case).

WebAssembly: Fix pcode_conversions_Main test.

This is fixed by implementing unsigned-to-float conversions properly.

WebAssembly: add a SIMD pcodetest.

Similarly to the x86 AVX2 test, this will allow us to do (basic) testing of Wasm
SIMD opcodes via autovectorization. Only the -O3 binary is expected to contain
SIMD opcodes.

WebAssembly: Simplify laneidx vector operands.

laneidx is actually just a byte, not a LEB128. Attempting to use 16 arguments in
a pcodeop hits a hardcoded limit of 8 args in PcodeEmit, so switch i8x16.shuffle
to using 4 32-bit arguments instead. This is the same syntax as used by
wasm-objdump by default.

WebAssembly: fix load32/load64, simplify some SIMD pcode

load32/load64 were incorrectly taking a laneidx, causing disassembly failures.
Also, take this opportunity to implement some of the SIMD operations using
common pcodeops. This will reduce emulation burden, as well as making loads and
stores explicit for dataflow analysis.

WebAssembly: minor updates to sync to master

Remove helpPath task - not needed after a7668c7f8

SIMD refactoring: implement splat in P-code

SIMD refactoring: implement extract and replace in P-code

SIMD refactoring: implement shuffle in P-code

SIMD refactoring: implement some bitwise and arith ops in P-code

spectest bugfix: do not use float2float on constants

float2float may modify the floating point value, but f{32,64}.const instructions
are supposed to load the raw constant value. Fixes test failures on
float_literals.

spectest bugfix: don't crash when jumping to no-context addresses

The VM may jump to an uninitialized address such as 0x00000000. If no context is
available at that address, this would crash the emulator before the instruction
can even be hit (e.g. for a breakpoint).

spectest bugfix: initialize tables and element segments with 0x00

Tables and element segments apparently default to holding null refs, and since
we're using 0x00000000 for null (`ref.null`, `ref.is_null`), we need to ensure
that they are initialized appropriately.

In the future, we may want to revisit whether zero is the right value for null -
e.g. can zero be a valid value for some reference type?

spectest bugfix: avoid crash on parsing select after br

After a br, the remaining code in the block is unreachable and types are no
longer tracked on the stack. Thus, multiple null types can creep in, which was
causing (among other things) crashes when analyzing a select instruction after a
br.

spectest bugfix: fix table.grow semantics

table.grow produces an i32 (the old table size); this was incorrectly omitted
and caused validation failures on modules containing that instruction.

spectest bugfix: fix br_table semantics when unreachable

When unreachable, br_table may underflow the stack, which is ok. However,
br_table needs to push Unknown types back on the stack, rather than the expected
types. This subtlety was caught by the unreached-valid meet-bottom testcase.

spectest bugfix: fix copysign to work with nans, etc.

Fixes test failures in f{32,64}_bitwise and float_misc.

spectest bugfix: zero out locals when emulating

This fixes some failures from call_indirect, among others. Instead of using an
uponentry injection, this new implementation hijacks the ".locals" directive to
add a CallOther pcodeop, which is usable from both the decompiler and emulator.

Provide a simulateCall convenience function to set up a simulated call frame

spectest bugfix: element section type param ("flags") is actually LEB128

This is tested by binary-leb128, and previously was failing to load the module
when the element section type parameter was encoded as a multi-byte LEB128.
However, since we weren't checking to see whether the modules loaded
successfully, this failed silently. The addition of WasmAnalysis forces us to
check whether the Wasm module parses correctly.

Don't create empty segments; this avoids angry warnings in the log

spectest bugfix: be careful about zero-sized chunks.

`readNextByteArray` may still throw an EOFError even if the read size is zero,
which can happen if we're decoding the very last object in the file.

spectest bugfix: escape custom section names to ensure valid datatype/memory block names

custom section names can have arbitrary Unicode content, so we should use
escapeJava to clean them.

Add the spectest script

spectest bugfix: fix implementation of float max/min/trunc

max and min weren't handling NaNs correctly, and trunc was just not correct at
all (it was limited to i32/i64 range). This fixes a bunch of failures in
f32/f64.wast.

spectest bugfix: encode externref as nonzero integers

(ref.extern 0) is non-null, so we need to encode externrefs in order to pass
a test in ref_is_null.

spectest bugfix: fix parsing of `select funcref`

Parsing of `select funcref` (1C 01 70) was failing because SLEIGH was committing
to one of the select forms (in this case, `select valtype_64`) using a
rudimentary mask check before going on to fully check the final byte. The LEB128
parsing mixed with the `bytev` checking resulted in a very simplistic mask check
for `select valtype_64`, which passed for 0x70, and resulted in a parsing
failure when `0x70` later failed to match `0x7e` or `0x7c`. The
DebugSleighInstructionParse script was instrumental in identifying this
behaviour.

Instead, the better solution is to check for the 0x01 LEB128 count as early as
possible, and only then examine the final type byte.

This change also improves the display of "ref.null t" and "select t*"
instructions by using symbolic type names.

spectest bugfix: disable C stack detection for wast tests

Some of the tests (e.g. global.wast) were triggering the C stack detection
logic, which was causing problems for the test.

implement clz, ctz, popcnt

Eliminate a few warnings about laneidx* tables

Fix build with Ghidra 11.0

Remove unneeded import, fix copy paste error
---
 .../SleighDevTools/pcodetest/build.py         |    2 +-
 .../pcodetest/c_src/misc_BODY.c               |    7 +
 .../pcodetest/c_src/pcode_test.c              |    5 +
 .../SleighDevTools/pcodetest/pcode_defs.py    |   18 +
 .../SleighDevTools/pcodetest/pcodetest.py     |   51 +
 .../SleighDevTools/pcodetest/tpp.py           |    2 +-
 .../support/ProcessorEmulatorTestAdapter.java |    4 +-
 .../exec/BytesPcodeExecutorStateSpace.java    |    3 +
 Ghidra/Processors/WebAssembly/Module.manifest |    0
 Ghidra/Processors/WebAssembly/build.gradle    |   27 +
 .../WebAssembly/certification.manifest        |   20 +
 .../WebAssembly/data/languages/BasicOps.sinc  |  522 +++++
 .../WebAssembly/data/languages/Leb128.sinc    |   60 +
 .../data/languages/Leb128_opc2.sinc           | 1152 ++++++++++
 .../data/languages/Leb128_opc2_1b.sinc        |    5 +
 .../data/languages/Leb128_opc2_2b.sinc        |    4 +
 .../data/languages/Leb128_u32.sinc            |   30 +
 .../WebAssembly/data/languages/VectorOps.sinc | 1646 ++++++++++++++
 .../languages/WebAssembly-pos-stack.cspec     |  836 +++++++
 .../data/languages/WebAssembly.cspec          |   67 +
 .../data/languages/WebAssembly.dwarf          |    6 +
 .../data/languages/WebAssembly.ldefs          |   18 +
 .../data/languages/WebAssembly.opinion        |    5 +
 .../data/languages/WebAssembly.pspec          |   17 +
 .../data/languages/WebAssembly.sinc           |  503 +++++
 .../data/languages/WebAssembly.slaspec        | 1923 +++++++++++++++++
 .../ghidra_scripts/analyze_dyncalls.py        |  120 +
 .../ghidra_scripts/emulate_writev.py          |   57 +
 .../ghidra_scripts/rename_table_funcs.py      |   47 +
 .../WebAssembly/ghidra_scripts/spectest.py    |  400 ++++
 .../src/main/help/help/TOC_Source.xml         |    7 +
 .../help/help/topics/WebAssembly/help.html    |  111 +
 .../main/help/help/topics/WebAssembly/help.md |  104 +
 .../WasmEmulateInstructionStateModifier.java  |  375 ++++
 .../emulation/WasmEmulationHelper.java        |  191 ++
 .../src/main/java/wasm/WasmLoader.java        |  708 ++++++
 .../wasm/analysis/ValidationException.java    |   32 +
 .../main/java/wasm/analysis/WasmAnalysis.java |  151 ++
 .../java/wasm/analysis/WasmDWARFAnalyzer.java |   36 +
 .../java/wasm/analysis/WasmFuncSignature.java |   80 +
 .../wasm/analysis/WasmFunctionAnalysis.java   | 1525 +++++++++++++
 .../java/wasm/analysis/WasmPreAnalyzer.java   |  194 ++
 .../wasm/analysis/WasmSignatureAnalyzer.java  |  118 +
 .../analysis/WasmStackVariableAnalyzer.java   |  264 +++
 .../java/wasm/format/StructureBuilder.java    |  135 ++
 .../main/java/wasm/format/WasmConstants.java  |   21 +
 .../src/main/java/wasm/format/WasmEnums.java  |  108 +
 .../src/main/java/wasm/format/WasmHeader.java |   54 +
 .../src/main/java/wasm/format/WasmModule.java |  273 +++
 .../wasm/format/sections/WasmCodeSection.java |   57 +
 .../format/sections/WasmCustomSection.java    |   64 +
 .../wasm/format/sections/WasmDataSection.java |   58 +
 .../format/sections/WasmElementSection.java   |   58 +
 .../format/sections/WasmExportSection.java    |   77 +
 .../format/sections/WasmFunctionSection.java  |   60 +
 .../format/sections/WasmGlobalSection.java    |   58 +
 .../format/sections/WasmImportSection.java    |   68 +
 .../sections/WasmLinearMemorySection.java     |   58 +
 .../wasm/format/sections/WasmNameSection.java |   97 +
 .../wasm/format/sections/WasmSection.java     |  123 ++
 .../format/sections/WasmStartSection.java     |   47 +
 .../format/sections/WasmTableSection.java     |   58 +
 .../wasm/format/sections/WasmTypeSection.java |   61 +
 .../sections/WasmUnknownCustomSection.java    |   58 +
 .../structures/ConstantExpression.java        |  223 ++
 .../sections/structures/WasmCodeEntry.java    |   87 +
 .../sections/structures/WasmDataSegment.java  |  109 +
 .../structures/WasmElementSegment.java        |  215 ++
 .../sections/structures/WasmExportEntry.java  |   60 +
 .../sections/structures/WasmFuncType.java     |   81 +
 .../sections/structures/WasmGlobalEntry.java  |   62 +
 .../sections/structures/WasmGlobalType.java   |   52 +
 .../sections/structures/WasmImportEntry.java  |  139 ++
 .../sections/structures/WasmLocalEntry.java   |   52 +
 .../format/sections/structures/WasmName.java  |   57 +
 .../structures/WasmNameIndirectMap.java       |   71 +
 .../structures/WasmNameLocalSubsection.java   |   46 +
 .../sections/structures/WasmNameMap.java      |   73 +
 .../structures/WasmNameMapSubsection.java     |   52 +
 .../structures/WasmNameModuleSubsection.java  |   46 +
 .../structures/WasmNameSubsection.java        |  123 ++
 .../structures/WasmNameUnknownSubsection.java |   45 +
 .../structures/WasmResizableLimits.java       |   62 +
 .../sections/structures/WasmTableType.java    |   56 +
 .../wasm/pcode/InjectPayloadWasmEntry.java    |   62 +
 .../java/wasm/pcode/InjectPayloadWasmPop.java |   74 +
 .../wasm/pcode/InjectPayloadWasmPush.java     |   73 +
 .../wasm/pcode/PcodeInjectLibraryWasm.java    |   53 +
 .../main/java/wasm/pcode/PcodeOpEmitter.java  |   70 +
 .../processors/WasmEmulatorTestAdapter.java   |  150 ++
 .../WebAssembly_O0_EmulatorTest.java          |   38 +
 .../WebAssembly_O3_EmulatorTest.java          |   38 +
 .../WebAssembly_SIMD_O0_EmulatorTest.java     |   38 +
 .../WebAssembly_SIMD_O3_EmulatorTest.java     |   38 +
 94 files changed, 15387 insertions(+), 4 deletions(-)
 create mode 100644 Ghidra/Processors/WebAssembly/Module.manifest
 create mode 100644 Ghidra/Processors/WebAssembly/build.gradle
 create mode 100644 Ghidra/Processors/WebAssembly/certification.manifest
 create mode 100644 Ghidra/Processors/WebAssembly/data/languages/BasicOps.sinc
 create mode 100644 Ghidra/Processors/WebAssembly/data/languages/Leb128.sinc
 create mode 100644 Ghidra/Processors/WebAssembly/data/languages/Leb128_opc2.sinc
 create mode 100644 Ghidra/Processors/WebAssembly/data/languages/Leb128_opc2_1b.sinc
 create mode 100644 Ghidra/Processors/WebAssembly/data/languages/Leb128_opc2_2b.sinc
 create mode 100644 Ghidra/Processors/WebAssembly/data/languages/Leb128_u32.sinc
 create mode 100644 Ghidra/Processors/WebAssembly/data/languages/VectorOps.sinc
 create mode 100644 Ghidra/Processors/WebAssembly/data/languages/WebAssembly-pos-stack.cspec
 create mode 100644 Ghidra/Processors/WebAssembly/data/languages/WebAssembly.cspec
 create mode 100644 Ghidra/Processors/WebAssembly/data/languages/WebAssembly.dwarf
 create mode 100644 Ghidra/Processors/WebAssembly/data/languages/WebAssembly.ldefs
 create mode 100644 Ghidra/Processors/WebAssembly/data/languages/WebAssembly.opinion
 create mode 100644 Ghidra/Processors/WebAssembly/data/languages/WebAssembly.pspec
 create mode 100644 Ghidra/Processors/WebAssembly/data/languages/WebAssembly.sinc
 create mode 100644 Ghidra/Processors/WebAssembly/data/languages/WebAssembly.slaspec
 create mode 100644 Ghidra/Processors/WebAssembly/ghidra_scripts/analyze_dyncalls.py
 create mode 100644 Ghidra/Processors/WebAssembly/ghidra_scripts/emulate_writev.py
 create mode 100644 Ghidra/Processors/WebAssembly/ghidra_scripts/rename_table_funcs.py
 create mode 100644 Ghidra/Processors/WebAssembly/ghidra_scripts/spectest.py
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/help/help/TOC_Source.xml
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/help/help/topics/WebAssembly/help.html
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/help/help/topics/WebAssembly/help.md
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/ghidra/program/emulation/WasmEmulateInstructionStateModifier.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/ghidra/program/emulation/WasmEmulationHelper.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/WasmLoader.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/ValidationException.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmAnalysis.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmDWARFAnalyzer.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmFuncSignature.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmFunctionAnalysis.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmPreAnalyzer.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmSignatureAnalyzer.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmStackVariableAnalyzer.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/StructureBuilder.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/WasmConstants.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/WasmEnums.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/WasmHeader.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/WasmModule.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmCodeSection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmCustomSection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmDataSection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmElementSection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmExportSection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmFunctionSection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmGlobalSection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmImportSection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmLinearMemorySection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmNameSection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmSection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmStartSection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmTableSection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmTypeSection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmUnknownCustomSection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/ConstantExpression.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmCodeEntry.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmDataSegment.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmElementSegment.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmExportEntry.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmFuncType.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmGlobalEntry.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmGlobalType.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmImportEntry.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmLocalEntry.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmName.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameIndirectMap.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameLocalSubsection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameMap.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameMapSubsection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameModuleSubsection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameSubsection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameUnknownSubsection.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmResizableLimits.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmTableType.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/InjectPayloadWasmEntry.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/InjectPayloadWasmPop.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/InjectPayloadWasmPush.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/PcodeInjectLibraryWasm.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/PcodeOpEmitter.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WasmEmulatorTestAdapter.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WebAssembly_O0_EmulatorTest.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WebAssembly_O3_EmulatorTest.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WebAssembly_SIMD_O0_EmulatorTest.java
 create mode 100644 Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WebAssembly_SIMD_O3_EmulatorTest.java

diff --git a/Ghidra/Extensions/SleighDevTools/pcodetest/build.py b/Ghidra/Extensions/SleighDevTools/pcodetest/build.py
index 00023bfcc5..3e5cbb1a2f 100644
--- a/Ghidra/Extensions/SleighDevTools/pcodetest/build.py
+++ b/Ghidra/Extensions/SleighDevTools/pcodetest/build.py
@@ -48,7 +48,7 @@ class BuildUtil:
                 f = subprocess.PIPE
             if verbose: self.log_info(string)
             try:
-                sp = subprocess.Popen(cmd, stdout=f, stderr=subprocess.PIPE)
+                sp = subprocess.Popen(cmd, stdout=f, stderr=subprocess.PIPE, encoding="utf8")
             except OSError as e:
                 self.log_err("Command: " + string)
                 self.log_err(e.strerror)
diff --git a/Ghidra/Extensions/SleighDevTools/pcodetest/c_src/misc_BODY.c b/Ghidra/Extensions/SleighDevTools/pcodetest/c_src/misc_BODY.c
index 131404c87f..e089e34f97 100644
--- a/Ghidra/Extensions/SleighDevTools/pcodetest/c_src/misc_BODY.c
+++ b/Ghidra/Extensions/SleighDevTools/pcodetest/c_src/misc_BODY.c
@@ -15,6 +15,13 @@
  */
 #include "pcode_test.h"
 #include "big_struct.h"
+#ifdef HAS_LIBC
+#include <string.h>
+#else
+void *memset(void *b, int c, size_t len);
+void *memcpy(void *dst, const void *src, size_t n);
+int memcmp(const void *s1, const void *s2, size_t n);
+#endif
 
 static i4 int_expectedValue;
 static i4 int_actualValue;
diff --git a/Ghidra/Extensions/SleighDevTools/pcodetest/c_src/pcode_test.c b/Ghidra/Extensions/SleighDevTools/pcodetest/c_src/pcode_test.c
index e31d9fccdb..a011ddaba3 100644
--- a/Ghidra/Extensions/SleighDevTools/pcodetest/c_src/pcode_test.c
+++ b/Ghidra/Extensions/SleighDevTools/pcodetest/c_src/pcode_test.c
@@ -72,6 +72,11 @@ static TestInfo MainInfo = {
 	mainFunctionInfoTable,		/* function table */
 };
 
+NOINLINE TestInfo TestInfo_force(void)
+{
+	return MainInfo;
+}
+
 NOINLINE void TestInfo_reset(void)
 {
 	MainInfo.numpass = 0;
diff --git a/Ghidra/Extensions/SleighDevTools/pcodetest/pcode_defs.py b/Ghidra/Extensions/SleighDevTools/pcodetest/pcode_defs.py
index a2e25f6c64..592be6f290 100644
--- a/Ghidra/Extensions/SleighDevTools/pcodetest/pcode_defs.py
+++ b/Ghidra/Extensions/SleighDevTools/pcodetest/pcode_defs.py
@@ -813,3 +813,21 @@ PCodeTest({
     'language_id': 'ARCompact:LE:32:default',
     'ccflags': '-mcpu=arc700 -lgcc',
 })
+
+PCodeTest({
+    'name': 'WebAssembly',
+    'compile_exe': 'bin/clang',
+    'toolchain': 'LLVM/llvm',
+    'toolchain_type': 'llvm',
+    'ccflags': '-std=c99 --target=wasm32 -Wl,--export-dynamic -Wl,--no-gc-sections -Wl,--no-entry',
+    'language_id': 'Wasm:LE:32:default',
+})
+
+PCodeTest({
+    'name': 'WebAssembly_SIMD',
+    'compile_exe': 'bin/clang',
+    'toolchain': 'LLVM/llvm',
+    'toolchain_type': 'llvm',
+    'ccflags': '-std=c99 --target=wasm32 -msimd128 -Wl,--export-dynamic -Wl,--no-gc-sections -Wl,--no-entry',
+    'language_id': 'Wasm:LE:32:default',
+})
diff --git a/Ghidra/Extensions/SleighDevTools/pcodetest/pcodetest.py b/Ghidra/Extensions/SleighDevTools/pcodetest/pcodetest.py
index ab1a87a7cd..31523a10e5 100644
--- a/Ghidra/Extensions/SleighDevTools/pcodetest/pcodetest.py
+++ b/Ghidra/Extensions/SleighDevTools/pcodetest/pcodetest.py
@@ -78,6 +78,8 @@ class PCodeTestBuild(BuildUtil):
             return PCodeBuildCCS(pcode_test)
         elif pcode_test.config.toolchain_type == 'sdcc':
             return PCodeBuildSDCC(pcode_test)
+        elif pcode_test.config.toolchain_type == 'llvm':
+            return PCodeBuildLLVM(pcode_test)
         else:
             raise Exception(pcode_test.config.format('Toolchain type %(toolchain_type)s not known'))
 
@@ -330,6 +332,55 @@ class PCodeBuildCCS(PCodeTestBuild):
             self.log_err('output not created %s' % output_file)
             return
 
+class PCodeBuildLLVM(PCodeTestBuild):
+
+    def __init__(self, PCodeTest):
+        super(PCodeBuildLLVM, self).__init__(PCodeTest)
+
+    # Set options for compiler depending on needs.
+    def cflags(self, output_file):
+        f = []
+        f += ['-DHAS_FLOAT=1' if self.config.has_float else '-DHAS_FLOAT_OVERRIDE=1']
+        f += ['-DHAS_DOUBLE=1' if self.config.has_double else '-DHAS_DOUBLE_OVERRIDE=1']
+        f += ['-DHAS_LONGLONG=1' if self.config.has_longlong else '-DHAS_LONGLONG_OVERRIDE=1']
+        if self.config.has_shortfloat: f += ['-DHAS_SHORTFLOAT=1']
+        if self.config.has_vector: f += ['-DHAS_VECTOR=1']
+        if self.config.has_decimal128: f += ['-DHAS_DECIMAL128=1']
+        if self.config.has_decimal32: f += ['-DHAS_DECIMAL32=1']
+        if self.config.has_decimal64: f += ['-DHAS_DECIMAL64=1']
+
+        f += ['-DNAME=NAME:%s' % output_file]
+
+        f += ['-static', '-Wno-unused-macros', '-nodefaultlibs', '-nostartfiles', '-fno-builtin']
+
+        f += self.config.ccflags.split()
+        f += self.config.add_ccflags.split()
+
+        return f
+
+    def compile(self, input_files, opt_cflag, output_base):
+
+        # Name the output file, and delete it if it exists
+
+        output_file = '%s.out' % (output_base)
+        self.remove(output_file)
+
+        # Construct the compile command line and execute it
+
+        cmp = self.which('compile_exe')
+        cmd = [cmp] + input_files + self.cflags(output_file) + [opt_cflag, "-o", output_file]
+        out, err = self.run(cmd)
+        if out: self.log_info(out)
+
+        # print error messages, which may just be warnings
+        if err: self.log_warn(err)
+
+        # return now if the error preempted the binary
+
+        if not self.is_readable_file(output_file):
+            self.log_err('output not created %s' % output_file)
+            return
+
 class PCodeBuildGCC(PCodeTestBuild):
 
     def __init__(self, PCodeTest):
diff --git a/Ghidra/Extensions/SleighDevTools/pcodetest/tpp.py b/Ghidra/Extensions/SleighDevTools/pcodetest/tpp.py
index c796388b51..96a202ab1e 100644
--- a/Ghidra/Extensions/SleighDevTools/pcodetest/tpp.py
+++ b/Ghidra/Extensions/SleighDevTools/pcodetest/tpp.py
@@ -198,7 +198,7 @@ void %(main)s(TestInfo* not_used) {
         self.c_write('')
         #for l in extern_lines:
         #    self.c_write(l)
-        self.c_write('void main(void) {')
+        self.c_write('int main(int argc, char **argv) {')
         self.c_write('\tTestInfo info;')
         #for l in main_lines:
         #    self.c_write(l)
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/test/processors/support/ProcessorEmulatorTestAdapter.java b/Ghidra/Features/Base/src/main/java/ghidra/test/processors/support/ProcessorEmulatorTestAdapter.java
index 86b95be77d..4a91c44388 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/test/processors/support/ProcessorEmulatorTestAdapter.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/test/processors/support/ProcessorEmulatorTestAdapter.java
@@ -209,8 +209,8 @@ public abstract class ProcessorEmulatorTestAdapter extends TestCase implements E
 	private File resourcesTestDataDir;
 
 	private FileDataTypeManager archiveDtMgr;
-	private Structure testInfoStruct;
-	private Structure groupInfoStruct;
+	protected Structure testInfoStruct;
+	protected Structure groupInfoStruct;
 
 	private ParallelInstructionLanguageHelper parallelHelper;
 
diff --git a/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/exec/BytesPcodeExecutorStateSpace.java b/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/exec/BytesPcodeExecutorStateSpace.java
index 9905227b50..3119175404 100644
--- a/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/exec/BytesPcodeExecutorStateSpace.java
+++ b/Ghidra/Framework/Emulation/src/main/java/ghidra/pcode/exec/BytesPcodeExecutorStateSpace.java
@@ -174,6 +174,9 @@ public class BytesPcodeExecutorStateSpace<B> {
 	 * @return the bytes read
 	 */
 	public byte[] read(long offset, int size, Reason reason) {
+		if (size == 0) {
+			return new byte[0];
+		}
 		ULongSpanSet uninitialized = bytes.getUninitialized(offset, offset + size - 1);
 		if (uninitialized.isEmpty()) {
 			return readBytes(offset, size, reason);
diff --git a/Ghidra/Processors/WebAssembly/Module.manifest b/Ghidra/Processors/WebAssembly/Module.manifest
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/Ghidra/Processors/WebAssembly/build.gradle b/Ghidra/Processors/WebAssembly/build.gradle
new file mode 100644
index 0000000000..f3aae981c7
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/build.gradle
@@ -0,0 +1,27 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+apply from: "$rootProject.projectDir/gradle/distributableGhidraModule.gradle"
+apply from: "$rootProject.projectDir/gradle/javaProject.gradle"
+apply from: "$rootProject.projectDir/gradle/processorProject.gradle"
+apply from: "$rootProject.projectDir/gradle/jacocoProject.gradle"
+apply from: "$rootProject.projectDir/gradle/javaTestProject.gradle"
+apply from: "$rootProject.projectDir/gradle/helpProject.gradle"
+apply plugin: 'eclipse'
+eclipse.project.name = 'Processors WebAssembly'
+
+dependencies {
+	api project(':Base')
+}
diff --git a/Ghidra/Processors/WebAssembly/certification.manifest b/Ghidra/Processors/WebAssembly/certification.manifest
new file mode 100644
index 0000000000..63d922004e
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/certification.manifest
@@ -0,0 +1,20 @@
+##VERSION: 2.0
+Module.manifest||GHIDRA||||END|
+src/main/help/help/TOC_Source.xml||GHIDRA||||END|
+src/main/help/help/topics/WebAssembly/help.html||GHIDRA||||END|
+src/main/help/help/topics/WebAssembly/help.md||GHIDRA||||END|
+data/languages/BasicOps.sinc||GHIDRA||||END|
+data/languages/Leb128.sinc||GHIDRA||||END|
+data/languages/Leb128_opc2.sinc||GHIDRA||||END|
+data/languages/Leb128_opc2_1b.sinc||GHIDRA||||END|
+data/languages/Leb128_opc2_2b.sinc||GHIDRA||||END|
+data/languages/Leb128_u32.sinc||GHIDRA||||END|
+data/languages/VectorOps.sinc||GHIDRA||||END|
+data/languages/WebAssembly-pos-stack.cspec||GHIDRA||||END|
+data/languages/WebAssembly.cspec||GHIDRA||||END|
+data/languages/WebAssembly.dwarf||GHIDRA||||END|
+data/languages/WebAssembly.ldefs||GHIDRA||||END|
+data/languages/WebAssembly.opinion||GHIDRA||||END|
+data/languages/WebAssembly.pspec||GHIDRA||||END|
+data/languages/WebAssembly.sinc||GHIDRA||||END|
+data/languages/WebAssembly.slaspec||GHIDRA||||END|
diff --git a/Ghidra/Processors/WebAssembly/data/languages/BasicOps.sinc b/Ghidra/Processors/WebAssembly/data/languages/BasicOps.sinc
new file mode 100644
index 0000000000..e436352915
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/data/languages/BasicOps.sinc
@@ -0,0 +1,522 @@
+## Memory Instructions
+memalign: "align="^ULeb128 is ULeb128 {
+	export ULeb128;
+}
+
+memoffset: "offset="^ULeb128 is ULeb128 {
+	export ULeb128;
+}
+
+loadaddr: memalign memoffset is memalign; memoffset; sp1_32 {
+	addr:4 = memoffset:4 + sp1_32;
+	export addr;
+}
+
+storeaddr: memalign memoffset is memalign; memoffset; sp2_32 {
+	addr:4 = memoffset:4 + sp2_32;
+	export addr;
+}
+
+:i32.load loadaddr is opc=0x28; loadaddr; sp1_32; ctx_is_directive=0 {
+	sp1_32 = *:4 loadaddr;
+}
+:i64.load loadaddr is opc=0x29; loadaddr; sp1_64; ctx_is_directive=0 {
+	sp1_64 = *:8 loadaddr;
+}
+:f32.load loadaddr is opc=0x2A; loadaddr; sp1_32; ctx_is_directive=0 {
+	sp1_32 = *:4 loadaddr;
+}
+:f64.load loadaddr is opc=0x2B; loadaddr; sp1_64; ctx_is_directive=0 {
+	sp1_64 = *:8 loadaddr;
+}
+:i32.load8_s loadaddr is opc=0x2C; loadaddr; sp1_32; ctx_is_directive=0 {
+	sp1_32 = sext(*:1 loadaddr);
+}
+:i32.load8_u loadaddr is opc=0x2D; loadaddr; sp1_32; ctx_is_directive=0 {
+	sp1_32 = zext(*:1 loadaddr);
+}
+:i32.load16_s loadaddr is opc=0x2E; loadaddr; sp1_32; ctx_is_directive=0 {
+	sp1_32 = sext(*:2 loadaddr);
+}
+:i32.load16_u loadaddr is opc=0x2F; loadaddr; sp1_32; ctx_is_directive=0 {
+	sp1_32 = zext(*:2 loadaddr);
+}
+:i64.load8_s loadaddr is opc=0x30; loadaddr; sp1_64; ctx_is_directive=0 {
+	sp1_64 = sext(*:1 loadaddr);
+}
+:i64.load8_u loadaddr is opc=0x31; loadaddr; sp1_64; ctx_is_directive=0 {
+	sp1_64 = zext(*:1 loadaddr);
+}
+:i64.load16_s loadaddr is opc=0x32; loadaddr; sp1_64; ctx_is_directive=0 {
+	sp1_64 = sext(*:2 loadaddr);
+}
+:i64.load16_u loadaddr is opc=0x33; loadaddr; sp1_64; ctx_is_directive=0 {
+	sp1_64 = zext(*:2 loadaddr);
+}
+:i64.load32_s loadaddr is opc=0x34; loadaddr; sp1_64; ctx_is_directive=0 {
+	sp1_64 = sext(*:4 loadaddr);
+}
+:i64.load32_u loadaddr is opc=0x35; loadaddr; sp1_64; ctx_is_directive=0 {
+	sp1_64 = zext(*:4 loadaddr);
+}
+
+:i32.store storeaddr is opc=0x36; storeaddr; sp1_32; ctx_is_directive=0 {
+	*:4 storeaddr = sp1_32;
+}
+:i64.store storeaddr is opc=0x37; storeaddr; sp1_64; ctx_is_directive=0 {
+	*:8 storeaddr = sp1_64;
+}
+:f32.store storeaddr is opc=0x38; storeaddr; sp1_32; ctx_is_directive=0 {
+	*:4 storeaddr = sp1_32;
+}
+:f64.store storeaddr is opc=0x39; storeaddr; sp1_64; ctx_is_directive=0 {
+	*:8 storeaddr = sp1_64;
+}
+:i32.store8 storeaddr is opc=0x3A; storeaddr; sp1_32; ctx_is_directive=0 {
+	*:1 storeaddr = sp1_32:1;
+}
+:i32.store16 storeaddr is opc=0x3B; storeaddr; sp1_32; ctx_is_directive=0 {
+	*:2 storeaddr = sp1_32:2;
+}
+:i64.store8 storeaddr is opc=0x3C; storeaddr; sp1_64; ctx_is_directive=0 {
+	*:1 storeaddr = sp1_64:1;
+}
+:i64.store16 storeaddr is opc=0x3D; storeaddr; sp1_64; ctx_is_directive=0 {
+	*:2 storeaddr = sp1_64:2;
+}
+:i64.store32 storeaddr is opc=0x3E; storeaddr; sp1_64; ctx_is_directive=0 {
+	*:4 storeaddr = sp1_64:4;
+}
+
+## Numeric Instructions
+:i32.eqz  is opc=0x45; sp1_32; ctx_is_directive=0 {
+	sp1_32 = zext(sp1_32 == 0);
+}
+:i32.eq  is opc=0x46; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_32 == sp1_32);
+}
+:i32.ne  is opc=0x47; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_32 != sp1_32);
+}
+:i32.lt_s  is opc=0x48; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_32 s< sp1_32);
+}
+:i32.lt_u  is opc=0x49; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_32 < sp1_32);
+}
+:i32.gt_s  is opc=0x4A; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_32 s> sp1_32);
+}
+:i32.gt_u  is opc=0x4B; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_32 > sp1_32);
+}
+:i32.le_s  is opc=0x4C; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_32 s<= sp1_32);
+}
+:i32.le_u  is opc=0x4D; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_32 <= sp1_32);
+}
+:i32.ge_s  is opc=0x4E; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_32 s>= sp1_32);
+}
+:i32.ge_u  is opc=0x4F; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_32 >= sp1_32);
+}
+:i64.eqz  is opc=0x50; sp1_32; sp1_64; ctx_is_directive=0 {
+	sp1_32 = zext(sp1_64 == 0);
+}
+:i64.eq  is opc=0x51; sp1_64; sp2_32; sp2_64; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_64 == sp1_64);
+}
+:i64.ne  is opc=0x52; sp1_64; sp2_32; sp2_64; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_64 != sp1_64);
+}
+:i64.lt_s  is opc=0x53; sp1_64; sp2_32; sp2_64; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_64 s< sp1_64);
+}
+:i64.lt_u  is opc=0x54; sp1_64; sp2_32; sp2_64; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_64 < sp1_64);
+}
+:i64.gt_s  is opc=0x55; sp1_64; sp2_32; sp2_64; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_64 s> sp1_64);
+}
+:i64.gt_u  is opc=0x56; sp1_64; sp2_32; sp2_64; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_64 > sp1_64);
+}
+:i64.le_s  is opc=0x57; sp1_64; sp2_32; sp2_64; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_64 s<= sp1_64);
+}
+:i64.le_u  is opc=0x58; sp1_64; sp2_32; sp2_64; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_64 <= sp1_64);
+}
+:i64.ge_s  is opc=0x59; sp1_64; sp2_32; sp2_64; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_64 s>= sp1_64);
+}
+:i64.ge_u  is opc=0x5A; sp1_64; sp2_32; sp2_64; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_64 >= sp1_64);
+}
+:f32.eq  is opc=0x5B; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_32 f== sp1_32);
+}
+:f32.ne  is opc=0x5C; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_32 f!= sp1_32);
+}
+:f32.lt  is opc=0x5D; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_32 f< sp1_32);
+}
+:f32.gt  is opc=0x5E; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_32 f> sp1_32);
+}
+:f32.le  is opc=0x5F; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_32 f<= sp1_32);
+}
+:f32.ge  is opc=0x60; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_32 f>= sp1_32);
+}
+:f64.eq  is opc=0x61; sp1_64; sp2_32; sp2_64; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_64 f== sp1_64);
+}
+:f64.ne  is opc=0x62; sp1_64; sp2_32; sp2_64; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_64 f!= sp1_64);
+}
+:f64.lt  is opc=0x63; sp1_64; sp2_32; sp2_64; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_64 f< sp1_64);
+}
+:f64.gt  is opc=0x64; sp1_64; sp2_32; sp2_64; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_64 f> sp1_64);
+}
+:f64.le  is opc=0x65; sp1_64; sp2_32; sp2_64; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_64 f<= sp1_64);
+}
+:f64.ge  is opc=0x66; sp1_64; sp2_32; sp2_64; ctx_is_directive=0 {
+	sp2_32 = zext(sp2_64 f>= sp1_64);
+}
+:i32.clz  is opc=0x67; sp1_32; ctx_is_directive=0 {
+	sp1_32 = clz(sp1_32);
+}
+:i32.ctz  is opc=0x68; sp1_32; ctx_is_directive=0 {
+	sp1_32 = ctz(sp1_32);
+}
+:i32.popcnt  is opc=0x69; sp1_32; ctx_is_directive=0 {
+	sp1_32 = popcnt(sp1_32);
+}
+:i32.add  is opc=0x6A; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = sp2_32 + sp1_32;
+}
+:i32.sub  is opc=0x6B; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = sp2_32 - sp1_32;
+}
+:i32.mul  is opc=0x6C; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = sp2_32 * sp1_32;
+}
+:i32.div_s  is opc=0x6D; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = sp2_32 s/ sp1_32;
+}
+:i32.div_u  is opc=0x6E; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = sp2_32 / sp1_32;
+}
+:i32.rem_s  is opc=0x6F; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = sp2_32 s% sp1_32;
+}
+:i32.rem_u  is opc=0x70; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = sp2_32 % sp1_32;
+}
+:i32.and  is opc=0x71; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = sp2_32 & sp1_32;
+}
+:i32.or  is opc=0x72; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = sp2_32 | sp1_32;
+}
+:i32.xor  is opc=0x73; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = sp2_32 ^ sp1_32;
+}
+:i32.shl  is opc=0x74; sp1_32; sp2_32; ctx_is_directive=0 {
+	cnt:4 = (sp1_32 & 31);
+	sp2_32 = sp2_32 << cnt;
+}
+:i32.shr_s  is opc=0x75; sp1_32; sp2_32; ctx_is_directive=0 {
+	cnt:4 = (sp1_32 & 31);
+	sp2_32 = sp2_32 s>> cnt;
+}
+:i32.shr_u  is opc=0x76; sp1_32; sp2_32; ctx_is_directive=0 {
+	cnt:4 = (sp1_32 & 31);
+	sp2_32 = sp2_32 >> cnt;
+}
+:i32.rotl  is opc=0x77; sp1_32; sp2_32; ctx_is_directive=0 {
+	cnt:4 = (sp1_32 & 31);
+	sp2_32 = ((sp2_32 << cnt) | (sp2_32 >> (32 - cnt)));
+}
+:i32.rotr  is opc=0x78; sp1_32; sp2_32; ctx_is_directive=0 {
+	cnt:4 = (sp1_32 & 31);
+	sp2_32 = ((sp2_32 >> cnt) | (sp2_32 << (32 - cnt)));
+}
+:i64.clz  is opc=0x79; sp1_64; ctx_is_directive=0 {
+	sp1_64 = clz(sp1_64);
+}
+:i64.ctz  is opc=0x7A; sp1_64; ctx_is_directive=0 {
+	sp1_64 = ctz(sp1_64);
+}
+:i64.popcnt  is opc=0x7B; sp1_64; ctx_is_directive=0 {
+	sp1_64 = popcnt(sp1_64);
+}
+:i64.add  is opc=0x7C; sp1_64; sp2_64; ctx_is_directive=0 {
+	sp2_64 = sp2_64 + sp1_64;
+}
+:i64.sub  is opc=0x7D; sp1_64; sp2_64; ctx_is_directive=0 {
+	sp2_64 = sp2_64 - sp1_64;
+}
+:i64.mul  is opc=0x7E; sp1_64; sp2_64; ctx_is_directive=0 {
+	sp2_64 = sp2_64 * sp1_64;
+}
+:i64.div_s  is opc=0x7F; sp1_64; sp2_64; ctx_is_directive=0 {
+	sp2_64 = sp2_64 s/ sp1_64;
+}
+:i64.div_u  is opc=0x80; sp1_64; sp2_64; ctx_is_directive=0 {
+	sp2_64 = sp2_64 / sp1_64;
+}
+:i64.rem_s  is opc=0x81; sp1_64; sp2_64; ctx_is_directive=0 {
+	sp2_64 = sp2_64 s% sp1_64;
+}
+:i64.rem_u  is opc=0x82; sp1_64; sp2_64; ctx_is_directive=0 {
+	sp2_64 = sp2_64 % sp1_64;
+}
+:i64.and  is opc=0x83; sp1_64; sp2_64; ctx_is_directive=0 {
+	sp2_64 = sp2_64 & sp1_64;
+}
+:i64.or  is opc=0x84; sp1_64; sp2_64; ctx_is_directive=0 {
+	sp2_64 = sp2_64 | sp1_64;
+}
+:i64.xor  is opc=0x85; sp1_64; sp2_64; ctx_is_directive=0 {
+	sp2_64 = sp2_64 ^ sp1_64;
+}
+:i64.shl  is opc=0x86; sp1_64; sp2_64; ctx_is_directive=0 {
+	cnt:8 = (sp1_64 & 63);
+	sp2_64 = sp2_64 << cnt;
+}
+:i64.shr_s  is opc=0x87; sp1_64; sp2_64; ctx_is_directive=0 {
+	cnt:8 = (sp1_64 & 63);
+	sp2_64 = sp2_64 s>> cnt;
+}
+:i64.shr_u  is opc=0x88; sp1_64; sp2_64; ctx_is_directive=0 {
+	cnt:8 = (sp1_64 & 63);
+	sp2_64 = sp2_64 >> cnt;
+}
+:i64.rotl  is opc=0x89; sp1_64; sp2_64; ctx_is_directive=0 {
+	cnt:8 = (sp1_64 & 63);
+	sp2_64 = (sp2_64 << cnt) | (sp2_64 >> (64 - cnt));
+}
+:i64.rotr  is opc=0x8A; sp1_64; sp2_64; ctx_is_directive=0 {
+	cnt:8 = (sp1_64 & 63);
+	sp2_64 = (sp2_64 >> cnt) | (sp2_64 << (64 - cnt));
+}
+:f32.abs  is opc=0x8B; sp1_32; ctx_is_directive=0 {
+	sp1_32 = abs(sp1_32);
+}
+:f32.neg  is opc=0x8C; sp1_32; ctx_is_directive=0 {
+	sp1_32 = f- sp1_32;
+}
+:f32.ceil  is opc=0x8D; sp1_32; ctx_is_directive=0 {
+	sp1_32 = ceil(sp1_32);
+}
+:f32.floor  is opc=0x8E; sp1_32; ctx_is_directive=0 {
+	sp1_32 = floor(sp1_32);
+}
+:f32.trunc  is opc=0x8F; sp1_32; ctx_is_directive=0 {
+	if (sp1_32 f>= 0) goto <pos>;
+	sp1_32 = ceil(sp1_32);
+	goto inst_next;
+<pos>
+	sp1_32 = floor(sp1_32);
+}
+:f32.nearest  is opc=0x90; sp1_32; ctx_is_directive=0 {
+	sp1_32 = round(sp1_32);
+}
+:f32.sqrt  is opc=0x91; sp1_32; ctx_is_directive=0 {
+	sp1_32 = sqrt(sp1_32);
+}
+:f32.add  is opc=0x92; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = sp2_32 f+ sp1_32;
+}
+:f32.sub  is opc=0x93; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = sp2_32 f- sp1_32;
+}
+:f32.mul  is opc=0x94; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = sp2_32 f* sp1_32;
+}
+:f32.div  is opc=0x95; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = sp2_32 f/ sp1_32;
+}
+:f32.min  is opc=0x96; sp1_32; sp2_32; ctx_is_directive=0 {
+	if(sp1_32 f> sp2_32 || nan(sp2_32)) goto inst_next;
+	sp2_32 = sp1_32;
+}
+:f32.max  is opc=0x97; sp1_32; sp2_32; ctx_is_directive=0 {
+	if(sp1_32 f< sp2_32 || nan(sp2_32)) goto inst_next;
+	sp2_32 = sp1_32;
+}
+:f32.copysign  is opc=0x98; sp1_32; sp2_32; ctx_is_directive=0 {
+	sp2_32 = (sp2_32 & 0x7fffffff) | (sp1_32 & 0x80000000);
+}
+:f64.abs  is opc=0x99; sp1_64; ctx_is_directive=0 {
+	sp1_64 = abs(sp1_64);
+}
+:f64.neg  is opc=0x9A; sp1_64; ctx_is_directive=0 {
+	sp1_64 = f- sp1_64;
+}
+:f64.ceil  is opc=0x9B; sp1_64; ctx_is_directive=0 {
+	sp1_64 = ceil(sp1_64);
+}
+:f64.floor  is opc=0x9C; sp1_64; ctx_is_directive=0 {
+	sp1_64 = floor(sp1_64);
+}
+:f64.trunc  is opc=0x9D; sp1_64; ctx_is_directive=0 {
+	if (sp1_64 f>= 0) goto <pos>;
+	sp1_64 = ceil(sp1_64);
+	goto inst_next;
+<pos>
+	sp1_64 = floor(sp1_64);
+}
+:f64.nearest  is opc=0x9E; sp1_64; ctx_is_directive=0 {
+	sp1_64 = round(sp1_64);
+}
+:f64.sqrt  is opc=0x9F; sp1_64; ctx_is_directive=0 {
+	sp1_64 = sqrt(sp1_64);
+}
+:f64.add  is opc=0xA0; sp1_64; sp2_64; ctx_is_directive=0 {
+	sp2_64 = sp2_64 f+ sp1_64;
+}
+:f64.sub  is opc=0xA1; sp1_64; sp2_64; ctx_is_directive=0 {
+	sp2_64 = sp2_64 f- sp1_64;
+}
+:f64.mul  is opc=0xA2; sp1_64; sp2_64; ctx_is_directive=0 {
+	sp2_64 = sp2_64 f* sp1_64;
+}
+:f64.div  is opc=0xA3; sp1_64; sp2_64; ctx_is_directive=0 {
+	sp2_64 = sp2_64 f/ sp1_64;
+}
+:f64.min  is opc=0xA4; sp1_64; sp2_64; ctx_is_directive=0 {
+	if(sp1_64 f> sp2_64 || nan(sp2_64)) goto inst_next;
+	sp2_64 = sp1_64;
+}
+:f64.max  is opc=0xA5; sp1_64; sp2_64; ctx_is_directive=0 {
+	if(sp1_64 f< sp2_64 || nan(sp2_64)) goto inst_next;
+	sp2_64 = sp1_64;
+}
+:f64.copysign  is opc=0xA6; sp1_64; sp2_64; ctx_is_directive=0 {
+	sp2_64 = (sp2_64 & 0x7fffffffffffffff) | (sp1_64 & 0x8000000000000000);
+}
+:i32.wrap_i64  is opc=0xA7; sp1_32; sp1_64; ctx_is_directive=0 {
+	sp1_32 = sp1_64:4;
+}
+:i32.trunc_f32_s  is opc=0xA8; sp1_32; ctx_is_directive=0 {
+	sp1_32 = trunc(sp1_32);
+}
+# TODO: Can we do an unsigned trunc?
+:i32.trunc_f32_u  is opc=0xA9; sp1_32; ctx_is_directive=0 {
+	sp1_32 = trunc(sp1_32);
+}
+:i32.trunc_f64_s  is opc=0xAA; sp1_32; sp1_64; ctx_is_directive=0 {
+	sp1_32 = trunc(sp1_64);
+}
+:i32.trunc_f64_u  is opc=0xAB; sp1_32; sp1_64; ctx_is_directive=0 {
+	sp1_32 = trunc(sp1_64);
+}
+:i64.extend_i32_s  is opc=0xAC; sp1_32; sp1_64; ctx_is_directive=0 {
+	sp1_64 = sext(sp1_32);
+}
+:i64.extend_i32_u  is opc=0xAD; sp1_32; sp1_64; ctx_is_directive=0 {
+	sp1_64 = zext(sp1_32);
+}
+:i64.trunc_f32_s  is opc=0xAE; sp1_32; sp1_64; ctx_is_directive=0 {
+	sp1_64 = trunc(sp1_32);
+}
+:i64.trunc_f32_u  is opc=0xAF; sp1_32; sp1_64; ctx_is_directive=0 {
+	sp1_64 = trunc(sp1_32);
+}
+:i64.trunc_f64_s  is opc=0xB0; sp1_64; ctx_is_directive=0 {
+	sp1_64 = trunc(sp1_64);
+}
+:i64.trunc_f64_u  is opc=0xB1; sp1_64; ctx_is_directive=0 {
+	sp1_64 = trunc(sp1_64);
+}
+:f32.convert_i32_s  is opc=0xB2; sp1_32; ctx_is_directive=0 {
+	sp1_32 = int2float(sp1_32);
+}
+:f32.convert_i32_u  is opc=0xB3; sp1_32; ctx_is_directive=0 {
+	local tmp:8 = zext(sp1_32);
+	sp1_32 = int2float(tmp);
+}
+:f32.convert_i64_s  is opc=0xB4; sp1_32; sp1_64; ctx_is_directive=0 {
+	sp1_32 = int2float(sp1_64);
+}
+:f32.convert_i64_u  is opc=0xB5; sp1_32; sp1_64; ctx_is_directive=0 {
+	local tmp:9 = zext(sp1_64);
+	sp1_32 = int2float(tmp);
+}
+:f32.demote_f64  is opc=0xB6; sp1_32; sp1_64; ctx_is_directive=0 {
+	sp1_32 = float2float(sp1_64);
+}
+:f64.convert_i32_s  is opc=0xB7; sp1_32; sp1_64; ctx_is_directive=0 {
+	sp1_64 = int2float(sp1_32);
+}
+:f64.convert_i32_u  is opc=0xB8; sp1_32; sp1_64; ctx_is_directive=0 {
+	local tmp:8 = zext(sp1_32);
+	sp1_64 = int2float(tmp);
+}
+:f64.convert_i64_s  is opc=0xB9; sp1_64; ctx_is_directive=0 {
+	sp1_64 = int2float(sp1_64);
+}
+:f64.convert_i64_u  is opc=0xBA; sp1_64; ctx_is_directive=0 {
+	local tmp:9 = zext(sp1_64);
+	sp1_64 = int2float(tmp);
+}
+:f64.promote_f32  is opc=0xBB; sp1_32; sp1_64; ctx_is_directive=0 {
+	sp1_64 = float2float(sp1_32);
+}
+# No need to do anything since our stack is untyped
+:i32.reinterpret_f32  is opc=0xBC; ctx_is_directive=0 {}
+:i64.reinterpret_f64  is opc=0xBD; ctx_is_directive=0 {}
+:f32.reinterpret_i32  is opc=0xBE; ctx_is_directive=0 {}
+:f64.reinterpret_i64  is opc=0xBF; ctx_is_directive=0 {}
+:i32.extend8_s  is opc=0xC0; sp1_32; ctx_is_directive=0 {
+	sp1_32 = sext(sp1_32:1);
+}
+:i32.extend16_s  is opc=0xC1; sp1_32; ctx_is_directive=0 {
+	sp1_32 = sext(sp1_32:2);
+}
+:i64.extend8_s  is opc=0xC2; sp1_64; ctx_is_directive=0 {
+	sp1_64 = sext(sp1_64:1);
+}
+:i64.extend16_s  is opc=0xC3; sp1_64; ctx_is_directive=0 {
+	sp1_64 = sext(sp1_64:2);
+}
+:i64.extend32_s  is opc=0xC4; sp1_64; ctx_is_directive=0 {
+	sp1_64 = sext(sp1_64:4);
+}
+
+# TODO: actually handle saturation, or express semantics via pcodeop?
+:i32.trunc_sat_f32_s  is opc=0xFC; opc2_0; sp1_32; ctx_is_directive=0 {
+	sp1_32 = trunc(sp1_32);
+}
+# TODO: Can we do an unsigned trunc?
+:i32.trunc_sat_f32_u  is opc=0xFC; opc2_1; sp1_32; ctx_is_directive=0 {
+	sp1_32 = trunc(sp1_32);
+}
+:i32.trunc_sat_f64_s  is opc=0xFC; opc2_2; sp1_32; sp1_64; ctx_is_directive=0 {
+	sp1_32 = trunc(sp1_64);
+}
+:i32.trunc_sat_f64_u  is opc=0xFC; opc2_3; sp1_32; sp1_64; ctx_is_directive=0 {
+	sp1_32 = trunc(sp1_64);
+}
+:i64.trunc_sat_f32_s  is opc=0xFC; opc2_4; sp1_32; sp1_64; ctx_is_directive=0 {
+	sp1_64 = trunc(sp1_32);
+}
+:i64.trunc_sat_f32_u  is opc=0xFC; opc2_5; sp1_32; sp1_64; ctx_is_directive=0 {
+	sp1_64 = trunc(sp1_32);
+}
+:i64.trunc_sat_f64_s  is opc=0xFC; opc2_6; sp1_64; ctx_is_directive=0 {
+	sp1_64 = trunc(sp1_64);
+}
+:i64.trunc_sat_f64_u  is opc=0xFC; opc2_7; sp1_64; ctx_is_directive=0 {
+	sp1_64 = trunc(sp1_64);
+}
diff --git a/Ghidra/Processors/WebAssembly/data/languages/Leb128.sinc b/Ghidra/Processors/WebAssembly/data/languages/Leb128.sinc
new file mode 100644
index 0000000000..6e5a3ea1f8
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/data/languages/Leb128.sinc
@@ -0,0 +1,60 @@
+ULeb128: val is topbit = 0 & v0
+	[ val = 0 | v0 ; ]
+{ export *[const]:8 val; }
+ULeb128: val is topbit = 1 & v0; topbit = 0 & v1
+	[ val = 0 | v0 | ( v1 << 7 ) ; ]
+{ export *[const]:8 val; }
+ULeb128: val is topbit = 1 & v0; topbit = 1 & v1; topbit = 0 & v2
+	[ val = 0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) ; ]
+{ export *[const]:8 val; }
+ULeb128: val is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 0 & v3
+	[ val = 0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) ; ]
+{ export *[const]:8 val; }
+ULeb128: val is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 0 & v4
+	[ val = 0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 ) ; ]
+{ export *[const]:8 val; }
+ULeb128: val is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 1 & v4; topbit = 0 & v5
+	[ val = 0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 ) | ( v5 << 35 ) ; ]
+{ export *[const]:8 val; }
+ULeb128: val is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 1 & v4; topbit = 1 & v5; topbit = 0 & v6
+	[ val = 0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 ) | ( v5 << 35 ) | ( v6 << 42 ) ; ]
+{ export *[const]:8 val; }
+ULeb128: val is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 1 & v4; topbit = 1 & v5; topbit = 1 & v6; topbit = 0 & v7
+	[ val = 0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 ) | ( v5 << 35 ) | ( v6 << 42 ) | ( v7 << 49 ) ; ]
+{ export *[const]:8 val; }
+ULeb128: val is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 1 & v4; topbit = 1 & v5; topbit = 1 & v6; topbit = 1 & v7; topbit = 0 & v8
+	[ val = 0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 ) | ( v5 << 35 ) | ( v6 << 42 ) | ( v7 << 49 ) | ( v8 << 56 ) ; ]
+{ export *[const]:8 val; }
+ULeb128: val is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 1 & v4; topbit = 1 & v5; topbit = 1 & v6; topbit = 1 & v7; topbit = 1 & v8; topbit = 0 & v9
+	[ val = 0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 ) | ( v5 << 35 ) | ( v6 << 42 ) | ( v7 << 49 ) | ( v8 << 56 ) | ( v9 << 63 ) ; ]
+{ export *[const]:8 val; }
+SLeb128: val is topbit = 0 & v0
+	[ val = ((0 | v0 ) ^ (1 << 6)) - (1 << 6); ]
+{ export *[const]:8 val; }
+SLeb128: val is topbit = 1 & v0; topbit = 0 & v1
+	[ val = ((0 | v0 | ( v1 << 7 ) ) ^ (1 << 13)) - (1 << 13); ]
+{ export *[const]:8 val; }
+SLeb128: val is topbit = 1 & v0; topbit = 1 & v1; topbit = 0 & v2
+	[ val = ((0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) ) ^ (1 << 20)) - (1 << 20); ]
+{ export *[const]:8 val; }
+SLeb128: val is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 0 & v3
+	[ val = ((0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) ) ^ (1 << 27)) - (1 << 27); ]
+{ export *[const]:8 val; }
+SLeb128: val is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 0 & v4
+	[ val = ((0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 ) ) ^ (1 << 34)) - (1 << 34); ]
+{ export *[const]:8 val; }
+SLeb128: val is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 1 & v4; topbit = 0 & v5
+	[ val = ((0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 ) | ( v5 << 35 ) ) ^ (1 << 41)) - (1 << 41); ]
+{ export *[const]:8 val; }
+SLeb128: val is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 1 & v4; topbit = 1 & v5; topbit = 0 & v6
+	[ val = ((0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 ) | ( v5 << 35 ) | ( v6 << 42 ) ) ^ (1 << 48)) - (1 << 48); ]
+{ export *[const]:8 val; }
+SLeb128: val is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 1 & v4; topbit = 1 & v5; topbit = 1 & v6; topbit = 0 & v7
+	[ val = ((0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 ) | ( v5 << 35 ) | ( v6 << 42 ) | ( v7 << 49 ) ) ^ (1 << 55)) - (1 << 55); ]
+{ export *[const]:8 val; }
+SLeb128: val is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 1 & v4; topbit = 1 & v5; topbit = 1 & v6; topbit = 1 & v7; topbit = 0 & v8
+	[ val = ((0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 ) | ( v5 << 35 ) | ( v6 << 42 ) | ( v7 << 49 ) | ( v8 << 56 ) ) ^ (1 << 62)) - (1 << 62); ]
+{ export *[const]:8 val; }
+SLeb128: val is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 1 & v4; topbit = 1 & v5; topbit = 1 & v6; topbit = 1 & v7; topbit = 1 & v8; topbit = 0 & v9
+	[ val = ((0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 ) | ( v5 << 35 ) | ( v6 << 42 ) | ( v7 << 49 ) | ( v8 << 56 ) | ( v9 << 63 ) ) ^ 0) - 0; ]
+{ export *[const]:8 val; }
diff --git a/Ghidra/Processors/WebAssembly/data/languages/Leb128_opc2.sinc b/Ghidra/Processors/WebAssembly/data/languages/Leb128_opc2.sinc
new file mode 100644
index 0000000000..1b175ac003
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/data/languages/Leb128_opc2.sinc
@@ -0,0 +1,1152 @@
+@define NAME "opc2_0"
+@define N 0
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_1"
+@define N 1
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_2"
+@define N 2
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_3"
+@define N 3
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_4"
+@define N 4
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_5"
+@define N 5
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_6"
+@define N 6
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_7"
+@define N 7
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_8"
+@define N 8
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_9"
+@define N 9
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_10"
+@define N 10
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_11"
+@define N 11
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_12"
+@define N 12
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_13"
+@define N 13
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_14"
+@define N 14
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_15"
+@define N 15
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_16"
+@define N 16
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_17"
+@define N 17
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_18"
+@define N 18
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_19"
+@define N 19
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_20"
+@define N 20
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_21"
+@define N 21
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_22"
+@define N 22
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_23"
+@define N 23
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_24"
+@define N 24
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_25"
+@define N 25
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_26"
+@define N 26
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_27"
+@define N 27
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_28"
+@define N 28
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_29"
+@define N 29
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_30"
+@define N 30
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_31"
+@define N 31
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_32"
+@define N 32
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_33"
+@define N 33
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_34"
+@define N 34
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_35"
+@define N 35
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_36"
+@define N 36
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_37"
+@define N 37
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_38"
+@define N 38
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_39"
+@define N 39
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_40"
+@define N 40
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_41"
+@define N 41
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_42"
+@define N 42
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_43"
+@define N 43
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_44"
+@define N 44
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_45"
+@define N 45
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_46"
+@define N 46
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_47"
+@define N 47
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_48"
+@define N 48
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_49"
+@define N 49
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_50"
+@define N 50
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_51"
+@define N 51
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_52"
+@define N 52
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_53"
+@define N 53
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_54"
+@define N 54
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_55"
+@define N 55
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_56"
+@define N 56
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_57"
+@define N 57
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_58"
+@define N 58
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_59"
+@define N 59
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_60"
+@define N 60
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_61"
+@define N 61
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_62"
+@define N 62
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_63"
+@define N 63
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_64"
+@define N 64
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_65"
+@define N 65
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_66"
+@define N 66
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_67"
+@define N 67
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_68"
+@define N 68
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_69"
+@define N 69
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_70"
+@define N 70
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_71"
+@define N 71
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_72"
+@define N 72
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_73"
+@define N 73
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_74"
+@define N 74
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_75"
+@define N 75
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_76"
+@define N 76
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_77"
+@define N 77
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_78"
+@define N 78
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_79"
+@define N 79
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_80"
+@define N 80
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_81"
+@define N 81
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_82"
+@define N 82
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_83"
+@define N 83
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_84"
+@define N 84
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_85"
+@define N 85
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_86"
+@define N 86
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_87"
+@define N 87
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_88"
+@define N 88
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_89"
+@define N 89
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_90"
+@define N 90
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_91"
+@define N 91
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_92"
+@define N 92
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_93"
+@define N 93
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_94"
+@define N 94
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_95"
+@define N 95
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_96"
+@define N 96
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_97"
+@define N 97
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_98"
+@define N 98
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_99"
+@define N 99
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_100"
+@define N 100
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_101"
+@define N 101
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_102"
+@define N 102
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_103"
+@define N 103
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_104"
+@define N 104
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_105"
+@define N 105
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_106"
+@define N 106
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_107"
+@define N 107
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_108"
+@define N 108
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_109"
+@define N 109
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_110"
+@define N 110
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_111"
+@define N 111
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_112"
+@define N 112
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_113"
+@define N 113
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_114"
+@define N 114
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_115"
+@define N 115
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_116"
+@define N 116
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_117"
+@define N 117
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_118"
+@define N 118
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_119"
+@define N 119
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_120"
+@define N 120
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_121"
+@define N 121
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_122"
+@define N 122
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_123"
+@define N 123
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_124"
+@define N 124
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_125"
+@define N 125
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_126"
+@define N 126
+@include "Leb128_opc2_1b.sinc"
+
+@define NAME "opc2_127"
+@define N 127
+@include "Leb128_opc2_1b.sinc"
+
+
+@define NAME "opc2_128"
+@define N0 0
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_129"
+@define N0 1
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_130"
+@define N0 2
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_131"
+@define N0 3
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_132"
+@define N0 4
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_133"
+@define N0 5
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_134"
+@define N0 6
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_135"
+@define N0 7
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_136"
+@define N0 8
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_137"
+@define N0 9
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_138"
+@define N0 10
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_139"
+@define N0 11
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_140"
+@define N0 12
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_141"
+@define N0 13
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_142"
+@define N0 14
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_143"
+@define N0 15
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_144"
+@define N0 16
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_145"
+@define N0 17
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_146"
+@define N0 18
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_147"
+@define N0 19
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_148"
+@define N0 20
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_149"
+@define N0 21
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_150"
+@define N0 22
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_151"
+@define N0 23
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_152"
+@define N0 24
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_153"
+@define N0 25
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_154"
+@define N0 26
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_155"
+@define N0 27
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_156"
+@define N0 28
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_157"
+@define N0 29
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_158"
+@define N0 30
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_159"
+@define N0 31
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_160"
+@define N0 32
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_161"
+@define N0 33
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_162"
+@define N0 34
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_163"
+@define N0 35
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_164"
+@define N0 36
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_165"
+@define N0 37
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_166"
+@define N0 38
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_167"
+@define N0 39
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_168"
+@define N0 40
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_169"
+@define N0 41
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_170"
+@define N0 42
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_171"
+@define N0 43
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_172"
+@define N0 44
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_173"
+@define N0 45
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_174"
+@define N0 46
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_175"
+@define N0 47
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_176"
+@define N0 48
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_177"
+@define N0 49
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_178"
+@define N0 50
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_179"
+@define N0 51
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_180"
+@define N0 52
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_181"
+@define N0 53
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_182"
+@define N0 54
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_183"
+@define N0 55
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_184"
+@define N0 56
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_185"
+@define N0 57
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_186"
+@define N0 58
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_187"
+@define N0 59
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_188"
+@define N0 60
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_189"
+@define N0 61
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_190"
+@define N0 62
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_191"
+@define N0 63
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_192"
+@define N0 64
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_193"
+@define N0 65
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_194"
+@define N0 66
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_195"
+@define N0 67
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_196"
+@define N0 68
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_197"
+@define N0 69
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_198"
+@define N0 70
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_199"
+@define N0 71
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_200"
+@define N0 72
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_201"
+@define N0 73
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_202"
+@define N0 74
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_203"
+@define N0 75
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_204"
+@define N0 76
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_205"
+@define N0 77
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_206"
+@define N0 78
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_207"
+@define N0 79
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_208"
+@define N0 80
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_209"
+@define N0 81
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_210"
+@define N0 82
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_211"
+@define N0 83
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_212"
+@define N0 84
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_213"
+@define N0 85
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_214"
+@define N0 86
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_215"
+@define N0 87
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_216"
+@define N0 88
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_217"
+@define N0 89
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_218"
+@define N0 90
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_219"
+@define N0 91
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_220"
+@define N0 92
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_221"
+@define N0 93
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_222"
+@define N0 94
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_223"
+@define N0 95
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_224"
+@define N0 96
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_225"
+@define N0 97
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_226"
+@define N0 98
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_227"
+@define N0 99
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_228"
+@define N0 100
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_229"
+@define N0 101
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_230"
+@define N0 102
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_231"
+@define N0 103
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_232"
+@define N0 104
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_233"
+@define N0 105
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_234"
+@define N0 106
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_235"
+@define N0 107
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_236"
+@define N0 108
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_237"
+@define N0 109
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_238"
+@define N0 110
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_239"
+@define N0 111
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_240"
+@define N0 112
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_241"
+@define N0 113
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_242"
+@define N0 114
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_243"
+@define N0 115
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_244"
+@define N0 116
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_245"
+@define N0 117
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_246"
+@define N0 118
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_247"
+@define N0 119
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_248"
+@define N0 120
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_249"
+@define N0 121
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_250"
+@define N0 122
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_251"
+@define N0 123
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_252"
+@define N0 124
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_253"
+@define N0 125
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_254"
+@define N0 126
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
+
+@define NAME "opc2_255"
+@define N0 127
+@define N1 1
+@include "Leb128_opc2_2b.sinc"
diff --git a/Ghidra/Processors/WebAssembly/data/languages/Leb128_opc2_1b.sinc b/Ghidra/Processors/WebAssembly/data/languages/Leb128_opc2_1b.sinc
new file mode 100644
index 0000000000..fc3f82c849
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/data/languages/Leb128_opc2_1b.sinc
@@ -0,0 +1,5 @@
+$(NAME): is topbit = 0 & v0 = $(N) {}
+$(NAME): is topbit = 1 & v0 = $(N); topbit = 0 & v1 = 0 {}
+$(NAME): is topbit = 1 & v0 = $(N); topbit = 1 & v1 = 0; topbit = 0 & v2 = 0 {}
+$(NAME): is topbit = 1 & v0 = $(N); topbit = 1 & v1 = 0; topbit = 1 & v2 = 0; topbit = 0 & v3 = 0 {}
+$(NAME): is topbit = 1 & v0 = $(N); topbit = 1 & v1 = 0; topbit = 1 & v2 = 0; topbit = 1 & v3 = 0; topbit = 0 & v4 = 0 {}
diff --git a/Ghidra/Processors/WebAssembly/data/languages/Leb128_opc2_2b.sinc b/Ghidra/Processors/WebAssembly/data/languages/Leb128_opc2_2b.sinc
new file mode 100644
index 0000000000..6f878f2023
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/data/languages/Leb128_opc2_2b.sinc
@@ -0,0 +1,4 @@
+$(NAME): is topbit = 1 & v0 = $(N0); topbit = 0 & v1 = $(N1) {}
+$(NAME): is topbit = 1 & v0 = $(N0); topbit = 1 & v1 = $(N1); topbit = 0 & v2 = 0 {}
+$(NAME): is topbit = 1 & v0 = $(N0); topbit = 1 & v1 = $(N1); topbit = 1 & v2 = 0; topbit = 0 & v3 = 0 {}
+$(NAME): is topbit = 1 & v0 = $(N0); topbit = 1 & v1 = $(N1); topbit = 1 & v2 = 0; topbit = 1 & v3 = 0; topbit = 0 & v4 = 0 {}
diff --git a/Ghidra/Processors/WebAssembly/data/languages/Leb128_u32.sinc b/Ghidra/Processors/WebAssembly/data/languages/Leb128_u32.sinc
new file mode 100644
index 0000000000..a98eb4c722
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/data/languages/Leb128_u32.sinc
@@ -0,0 +1,30 @@
+$(SYMBOL): dest is topbit = 0 & v0
+	[ dest = $(DEST_EXPR) (0 | v0) ; ]
+{ $(EXPORT_EXPR) }
+$(SYMBOL): dest is topbit = 1 & v0; topbit = 0 & v1
+	[ dest = $(DEST_EXPR) (0 | v0 | ( v1 << 7 )) ; ]
+{ $(EXPORT_EXPR) }
+$(SYMBOL): dest is topbit = 1 & v0; topbit = 1 & v1; topbit = 0 & v2
+	[ dest = $(DEST_EXPR) (0 | v0 | ( v1 << 7 ) | ( v2 << 14 )) ; ]
+{ $(EXPORT_EXPR) }
+$(SYMBOL): dest is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 0 & v3
+	[ dest = $(DEST_EXPR) (0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 )) ; ]
+{ $(EXPORT_EXPR) }
+$(SYMBOL): dest is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 0 & v4
+	[ dest = $(DEST_EXPR) (0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 )) ; ]
+{ $(EXPORT_EXPR) }
+$(SYMBOL): dest is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 1 & v4; topbit = 0 & v5
+	[ dest = $(DEST_EXPR) (0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 ) | ( v5 << 35 )) ; ]
+{ $(EXPORT_EXPR) }
+$(SYMBOL): dest is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 1 & v4; topbit = 1 & v5; topbit = 0 & v6
+	[ dest = $(DEST_EXPR) (0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 ) | ( v5 << 35 ) | ( v6 << 42 )) ; ]
+{ $(EXPORT_EXPR) }
+$(SYMBOL): dest is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 1 & v4; topbit = 1 & v5; topbit = 1 & v6; topbit = 0 & v7
+	[ dest = $(DEST_EXPR) (0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 ) | ( v5 << 35 ) | ( v6 << 42 ) | ( v7 << 49 )) ; ]
+{ $(EXPORT_EXPR) }
+$(SYMBOL): dest is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 1 & v4; topbit = 1 & v5; topbit = 1 & v6; topbit = 1 & v7; topbit = 0 & v8
+	[ dest = $(DEST_EXPR) (0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 ) | ( v5 << 35 ) | ( v6 << 42 ) | ( v7 << 49 ) | ( v8 << 56 )) ; ]
+{ $(EXPORT_EXPR) }
+$(SYMBOL): dest is topbit = 1 & v0; topbit = 1 & v1; topbit = 1 & v2; topbit = 1 & v3; topbit = 1 & v4; topbit = 1 & v5; topbit = 1 & v6; topbit = 1 & v7; topbit = 1 & v8; topbit = 0 & v9
+	[ dest = $(DEST_EXPR) (0 | v0 | ( v1 << 7 ) | ( v2 << 14 ) | ( v3 << 21 ) | ( v4 << 28 ) | ( v5 << 35 ) | ( v6 << 42 ) | ( v7 << 49 ) | ( v8 << 56 ) | ( v9 << 63 )) ; ]
+{ $(EXPORT_EXPR) }
diff --git a/Ghidra/Processors/WebAssembly/data/languages/VectorOps.sinc b/Ghidra/Processors/WebAssembly/data/languages/VectorOps.sinc
new file mode 100644
index 0000000000..8b4653fde4
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/data/languages/VectorOps.sinc
@@ -0,0 +1,1646 @@
+# Ghidra only supports scalars up to 64 bits
+define token I128 (64)
+	f128_0 = (0, 63) hex
+	f128_1 = (0, 63) hex
+;
+
+define token laneidx_1 (8)
+    laneidx = (0, 7) dec
+    laneidx0 = (0, 7)
+    laneidx1 = (0, 7)
+    laneidx2 = (0, 7)
+    laneidx3 = (0, 7)
+;
+
+loadaddr2: memalign memoffset is memalign; memoffset; sp2_32 {
+	addr:4 = memoffset:4 + sp2_32;
+	export addr;
+}
+
+sp1_lane8_val: tmp_sp is ctx_sp; laneidx [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 1) * $(REG_SIZE) + laneidx * 1;] {
+	export *[register]:1 tmp_sp;
+}
+
+sp1_lane16_val: tmp_sp is ctx_sp; laneidx [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 1) * $(REG_SIZE) + laneidx * 2;] {
+	export *[register]:2 tmp_sp;
+}
+
+sp1_lane32_val: tmp_sp is ctx_sp; laneidx [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 1) * $(REG_SIZE) + laneidx * 4;] {
+	export *[register]:4 tmp_sp;
+}
+
+sp1_lane64_val: tmp_sp is ctx_sp; laneidx [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 1) * $(REG_SIZE) + laneidx * 8;] {
+	export *[register]:8 tmp_sp;
+}
+
+sp2_lane8_val: tmp_sp is ctx_sp; laneidx [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 2) * $(REG_SIZE) + laneidx * 1;] {
+	export *[register]:1 tmp_sp;
+}
+
+sp2_lane16_val: tmp_sp is ctx_sp; laneidx [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 2) * $(REG_SIZE) + laneidx * 2;] {
+	export *[register]:2 tmp_sp;
+}
+
+sp2_lane32_val: tmp_sp is ctx_sp; laneidx [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 2) * $(REG_SIZE) + laneidx * 4;] {
+	export *[register]:4 tmp_sp;
+}
+
+sp2_lane64_val: tmp_sp is ctx_sp; laneidx [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 2) * $(REG_SIZE) + laneidx * 8;] {
+	export *[register]:8 tmp_sp;
+}
+
+# Hack to show only the lane index in the disassembly
+sp1_lane8: laneidx is sp1_lane8_val & laneidx { export sp1_lane8_val; }
+sp1_lane16: laneidx is sp1_lane16_val & laneidx { export sp1_lane16_val; }
+sp1_lane32: laneidx is sp1_lane32_val & laneidx { export sp1_lane32_val; }
+sp1_lane64: laneidx is sp1_lane64_val & laneidx { export sp1_lane64_val; }
+sp2_lane8: laneidx is sp2_lane8_val & laneidx { export sp2_lane8_val; }
+sp2_lane16: laneidx is sp2_lane16_val & laneidx { export sp2_lane16_val; }
+sp2_lane32: laneidx is sp2_lane32_val & laneidx { export sp2_lane32_val; }
+sp2_lane64: laneidx is sp2_lane64_val & laneidx { export sp2_lane64_val; }
+
+# Hack: take advantage of the fact that sp1 is immediately after sp2 in memory,
+# such that lanes 16-31 overflow into sp1.
+# (For some reason, conditioning on bit (4, 4) of the laneidx did not work - sp2 was always selected)
+shuf0: is sp2_lane8_val { export sp2_lane8_val; }
+shuf1: is sp2_lane8_val { export sp2_lane8_val; }
+shuf2: is sp2_lane8_val { export sp2_lane8_val; }
+shuf3: is sp2_lane8_val { export sp2_lane8_val; }
+shuf4: is sp2_lane8_val { export sp2_lane8_val; }
+shuf5: is sp2_lane8_val { export sp2_lane8_val; }
+shuf6: is sp2_lane8_val { export sp2_lane8_val; }
+shuf7: is sp2_lane8_val { export sp2_lane8_val; }
+shuf8: is sp2_lane8_val { export sp2_lane8_val; }
+shuf9: is sp2_lane8_val { export sp2_lane8_val; }
+shuf10: is sp2_lane8_val { export sp2_lane8_val; }
+shuf11: is sp2_lane8_val { export sp2_lane8_val; }
+shuf12: is sp2_lane8_val { export sp2_lane8_val; }
+shuf13: is sp2_lane8_val { export sp2_lane8_val; }
+shuf14: is sp2_lane8_val { export sp2_lane8_val; }
+shuf15: is sp2_lane8_val { export sp2_lane8_val; }
+
+shuf_impl: is shuf0 ; shuf1 ; shuf2 ; shuf3 ; shuf4 ; shuf5 ; shuf6 ; shuf7 ; shuf8 ; shuf9 ; shuf10 ; shuf11 ; shuf12 ; shuf13 ; shuf14 ; shuf15 {
+    t0o[0,8] = shuf0;
+    t0o[8,8] = shuf1;
+    t0o[16,8] = shuf2;
+    t0o[24,8] = shuf3;
+    t0o[32,8] = shuf4;
+    t0o[40,8] = shuf5;
+    t0o[48,8] = shuf6;
+    t0o[56,8] = shuf7;
+    t0o[64,8] = shuf8;
+    t0o[72,8] = shuf9;
+    t0o[80,8] = shuf10;
+    t0o[88,8] = shuf11;
+    t0o[96,8] = shuf12;
+    t0o[104,8] = shuf13;
+    t0o[112,8] = shuf14;
+    t0o[120,8] = shuf15;
+}
+
+laneidx0_3: laneidx_disp is laneidx0; laneidx1; laneidx2; laneidx3 [ laneidx_disp = (laneidx3 << 24) | (laneidx2 << 16) | (laneidx1 << 8) | laneidx0; ] {}
+laneidx4_7: laneidx_disp is laneidx0; laneidx1; laneidx2; laneidx3 [ laneidx_disp = (laneidx3 << 24) | (laneidx2 << 16) | (laneidx1 << 8) | laneidx0; ] {}
+laneidx8_11: laneidx_disp is laneidx0; laneidx1; laneidx2; laneidx3 [ laneidx_disp = (laneidx3 << 24) | (laneidx2 << 16) | (laneidx1 << 8) | laneidx0; ] {}
+laneidx12_15: laneidx_disp is laneidx0; laneidx1; laneidx2; laneidx3 [ laneidx_disp = (laneidx3 << 24) | (laneidx2 << 16) | (laneidx1 << 8) | laneidx0; ] {}
+
+shuf_disp: laneidx0_3 laneidx4_7 laneidx8_11 laneidx12_15 is laneidx0_3 ; laneidx4_7 ; laneidx8_11 ; laneidx12_15 {
+}
+
+## Vector instructions
+# [i32] -> [v128]
+:v128.load loadaddr is opc=0xFD; opc2_0; loadaddr; sp1_128; ctx_is_directive=0 {
+    sp1_128 = *:16 loadaddr;
+}
+
+# [i32] -> [v128]
+:v128.load8x8_s loadaddr is opc=0xFD; opc2_1; loadaddr; sp1_128; ctx_is_directive=0 {
+    sp1_128[0,16] = sext(*:1 loadaddr);
+    sp1_128[16,16] = sext(*:1 (loadaddr + 1));
+    sp1_128[32,16] = sext(*:1 (loadaddr + 2));
+    sp1_128[48,16] = sext(*:1 (loadaddr + 3));
+    sp1_128[64,16] = sext(*:1 (loadaddr + 4));
+    sp1_128[80,16] = sext(*:1 (loadaddr + 5));
+    sp1_128[96,16] = sext(*:1 (loadaddr + 6));
+    sp1_128[112,16] = sext(*:1 (loadaddr + 7));
+}
+
+# [i32] -> [v128]
+:v128.load8x8_u loadaddr is opc=0xFD; opc2_2; loadaddr; sp1_128; ctx_is_directive=0 {
+    sp1_128[0,16] = zext(*:1 loadaddr);
+    sp1_128[16,16] = zext(*:1 (loadaddr + 1));
+    sp1_128[32,16] = zext(*:1 (loadaddr + 2));
+    sp1_128[48,16] = zext(*:1 (loadaddr + 3));
+    sp1_128[64,16] = zext(*:1 (loadaddr + 4));
+    sp1_128[80,16] = zext(*:1 (loadaddr + 5));
+    sp1_128[96,16] = zext(*:1 (loadaddr + 6));
+    sp1_128[112,16] = zext(*:1 (loadaddr + 7));
+}
+
+# [i32] -> [v128]
+:v128.load16x4_s loadaddr is opc=0xFD; opc2_3; loadaddr; sp1_128; ctx_is_directive=0 {
+    sp1_128[0,32] = sext(*:2 loadaddr);
+    sp1_128[32,32] = sext(*:2 (loadaddr + 2));
+    sp1_128[64,32] = sext(*:2 (loadaddr + 4));
+    sp1_128[96,32] = sext(*:2 (loadaddr + 6));
+}
+
+# [i32] -> [v128]
+:v128.load16x4_u loadaddr is opc=0xFD; opc2_4; loadaddr; sp1_128; ctx_is_directive=0 {
+    sp1_128[0,32] = zext(*:2 loadaddr);
+    sp1_128[32,32] = zext(*:2 (loadaddr + 2));
+    sp1_128[64,32] = zext(*:2 (loadaddr + 4));
+    sp1_128[96,32] = zext(*:2 (loadaddr + 6));
+}
+
+# [i32] -> [v128]
+:v128.load32x2_s loadaddr is opc=0xFD; opc2_5; loadaddr; sp1_128; ctx_is_directive=0 {
+    sp1_128[0,64] = sext(*:4 loadaddr);
+    sp1_128[64,64] = sext(*:4 (loadaddr + 4));
+}
+
+# [i32] -> [v128]
+:v128.load32x2_u loadaddr is opc=0xFD; opc2_6; loadaddr; sp1_128; ctx_is_directive=0 {
+    sp1_128[0,64] = zext(*:4 loadaddr);
+    sp1_128[64,64] = zext(*:4 (loadaddr + 4));
+}
+
+# [i32] -> [v128]
+:v128.load8_splat loadaddr is opc=0xFD; opc2_7; loadaddr; sp1_128; ctx_is_directive=0 {
+    local tmp:1 = *:1 loadaddr;
+    sp1_128[0,8] = tmp;
+    sp1_128[8,8] = tmp;
+    sp1_128[16,8] = tmp;
+    sp1_128[24,8] = tmp;
+    sp1_128[32,8] = tmp;
+    sp1_128[40,8] = tmp;
+    sp1_128[48,8] = tmp;
+    sp1_128[56,8] = tmp;
+    sp1_128[64,8] = tmp;
+    sp1_128[72,8] = tmp;
+    sp1_128[80,8] = tmp;
+    sp1_128[88,8] = tmp;
+    sp1_128[96,8] = tmp;
+    sp1_128[104,8] = tmp;
+    sp1_128[112,8] = tmp;
+    sp1_128[120,8] = tmp;
+}
+
+# [i32] -> [v128]
+:v128.load16_splat loadaddr is opc=0xFD; opc2_8; loadaddr; sp1_128; ctx_is_directive=0 {
+    local tmp:2 = *:2 loadaddr;
+    sp1_128[0,16] = tmp;
+    sp1_128[16,16] = tmp;
+    sp1_128[32,16] = tmp;
+    sp1_128[48,16] = tmp;
+    sp1_128[64,16] = tmp;
+    sp1_128[80,16] = tmp;
+    sp1_128[96,16] = tmp;
+    sp1_128[112,16] = tmp;
+}
+
+# [i32] -> [v128]
+:v128.load32_splat loadaddr is opc=0xFD; opc2_9; loadaddr; sp1_128; ctx_is_directive=0 {
+    local tmp:4 = *:4 loadaddr;
+    sp1_128[0,32] = tmp;
+    sp1_128[32,32] = tmp;
+    sp1_128[64,32] = tmp;
+    sp1_128[96,32] = tmp;
+}
+
+# [i32] -> [v128]
+:v128.load64_splat loadaddr is opc=0xFD; opc2_10; loadaddr; sp1_128; ctx_is_directive=0 {
+    local tmp:8 = *:8 loadaddr;
+    sp1_128[0,64] = tmp;
+    sp1_128[64,64] = tmp;
+}
+
+# [i32 v128] -> []
+:v128.store storeaddr is opc=0xFD; opc2_11; storeaddr; sp1_128; ctx_is_directive=0 {
+    *:16 storeaddr = sp1_128;
+}
+
+# [] -> [v128]
+:v128.const "i64x2" f128_0 f128_1 is opc=0xFD; opc2_12; f128_0; f128_1; sp0_128; ctx_is_directive=0 {
+    sp0_128[0,64] = f128_0;
+    sp0_128[64,64] = f128_1;
+}
+
+# [v128 v128] -> [v128]
+:i8x16.shuffle shuf_disp is opc=0xFD; opc2_13; ( shuf_impl & shuf_disp ) ; sp2_128; ctx_is_directive=0 {
+    sp2_128 = t0o;
+}
+
+define pcodeop i8x16_swizzle;
+# [v128 v128] -> [v128]
+:i8x16.swizzle is opc=0xFD; opc2_14; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_swizzle(sp1_128, sp2_128);
+}
+
+# [i32] -> [v128]
+:i8x16.splat is opc=0xFD; opc2_15; sp1_128; sp1_32; ctx_is_directive=0 {
+    local tmp:1 = sp1_32:1;
+    sp1_128[0,8] = tmp;
+    sp1_128[8,8] = tmp;
+    sp1_128[16,8] = tmp;
+    sp1_128[24,8] = tmp;
+    sp1_128[32,8] = tmp;
+    sp1_128[40,8] = tmp;
+    sp1_128[48,8] = tmp;
+    sp1_128[56,8] = tmp;
+    sp1_128[64,8] = tmp;
+    sp1_128[72,8] = tmp;
+    sp1_128[80,8] = tmp;
+    sp1_128[88,8] = tmp;
+    sp1_128[96,8] = tmp;
+    sp1_128[104,8] = tmp;
+    sp1_128[112,8] = tmp;
+    sp1_128[120,8] = tmp;
+}
+
+# [i32] -> [v128]
+:i16x8.splat is opc=0xFD; opc2_16; sp1_128; sp1_32; ctx_is_directive=0 {
+    local tmp:2 = sp1_32:2;
+    sp1_128[0,16] = tmp;
+    sp1_128[16,16] = tmp;
+    sp1_128[32,16] = tmp;
+    sp1_128[48,16] = tmp;
+    sp1_128[64,16] = tmp;
+    sp1_128[80,16] = tmp;
+    sp1_128[96,16] = tmp;
+    sp1_128[112,16] = tmp;
+}
+
+# [i32] -> [v128]
+:i32x4.splat is opc=0xFD; opc2_17; sp1_128; sp1_32; ctx_is_directive=0 {
+    local tmp:4 = sp1_32:4;
+    sp1_128[0,32] = tmp;
+    sp1_128[32,32] = tmp;
+    sp1_128[64,32] = tmp;
+    sp1_128[96,32] = tmp;
+}
+
+# [i64] -> [v128]
+:i64x2.splat is opc=0xFD; opc2_18; sp1_128; sp1_64; ctx_is_directive=0 {
+    local tmp:8 = sp1_64:8;
+    sp1_128[0,64] = tmp;
+    sp1_128[64,64] = tmp;
+}
+
+# [f32] -> [v128]
+:f32x4.splat is opc=0xFD; opc2_19; sp1_128; sp1_32; ctx_is_directive=0 {
+    local tmp:4 = sp1_32:4;
+    sp1_128[0,32] = tmp;
+    sp1_128[32,32] = tmp;
+    sp1_128[64,32] = tmp;
+    sp1_128[96,32] = tmp;
+}
+
+# [f64] -> [v128]
+:f64x2.splat is opc=0xFD; opc2_20; sp1_128; sp1_64; ctx_is_directive=0 {
+    local tmp:8 = sp1_64:8;
+    sp1_128[0,64] = tmp;
+    sp1_128[64,64] = tmp;
+}
+
+# [v128] -> [i32]
+:i8x16.extract_lane_s sp1_lane8 is opc=0xFD; opc2_21; sp1_lane8; sp1_32; ctx_is_directive=0 {
+    sp1_32 = sext(sp1_lane8);
+}
+
+# [v128] -> [i32]
+:i8x16.extract_lane_u sp1_lane8 is opc=0xFD; opc2_22; sp1_lane8; sp1_32; ctx_is_directive=0 {
+    sp1_32 = zext(sp1_lane8);
+}
+
+# [v128 i32] -> [v128]
+:i8x16.replace_lane sp2_lane8 is opc=0xFD; opc2_23; sp1_32; sp2_lane8; ctx_is_directive=0 {
+    sp2_lane8 = sp1_32:1;
+}
+
+# [v128] -> [i32]
+:i16x8.extract_lane_s sp1_lane16 is opc=0xFD; opc2_24; sp1_lane16; sp1_32; ctx_is_directive=0 {
+    sp1_32 = sext(sp1_lane16);
+}
+
+# [v128] -> [i32]
+:i16x8.extract_lane_u sp1_lane16 is opc=0xFD; opc2_25; sp1_lane16; sp1_32; ctx_is_directive=0 {
+    sp1_32 = zext(sp1_lane16);
+}
+
+# [v128 i32] -> [v128]
+:i16x8.replace_lane sp2_lane16 is opc=0xFD; opc2_26; sp1_32; sp2_lane16; ctx_is_directive=0 {
+    sp2_lane16 = sp1_32:2;
+}
+
+# [v128] -> [i32]
+:i32x4.extract_lane sp1_lane32 is opc=0xFD; opc2_27; sp1_lane32; sp1_32; ctx_is_directive=0 {
+    sp1_32 = sp1_lane32;
+}
+
+# [v128 i32] -> [v128]
+:i32x4.replace_lane sp2_lane32 is opc=0xFD; opc2_28; sp1_32; sp2_lane32; ctx_is_directive=0 {
+    sp2_lane32 = sp1_32;
+}
+
+# [v128] -> [i64]
+:i64x2.extract_lane sp1_lane64 is opc=0xFD; opc2_29; sp1_lane64; sp1_64; ctx_is_directive=0 {
+    sp1_64 = sp1_lane64;
+}
+
+# [v128 i64] -> [v128]
+:i64x2.replace_lane sp2_lane64 is opc=0xFD; opc2_30; sp1_64; sp2_lane64; ctx_is_directive=0 {
+    sp2_lane64 = sp1_64;
+}
+
+# [v128] -> [f32]
+:f32x4.extract_lane sp1_lane32 is opc=0xFD; opc2_31; sp1_lane32; sp1_32; ctx_is_directive=0 {
+    sp1_32 = sp1_lane32;
+}
+
+# [v128 f32] -> [v128]
+:f32x4.replace_lane sp2_lane32 is opc=0xFD; opc2_32; sp1_32; sp2_lane32; ctx_is_directive=0 {
+    sp2_lane32 = sp1_32;
+}
+
+# [v128] -> [f64]
+:f64x2.extract_lane sp1_lane64 is opc=0xFD; opc2_33; sp1_lane64; sp1_64; ctx_is_directive=0 {
+    sp1_64 = sp1_lane64;
+}
+
+# [v128 f64] -> [v128]
+:f64x2.replace_lane sp2_lane64 is opc=0xFD; opc2_34; sp1_64; sp2_lane64; ctx_is_directive=0 {
+    sp2_lane64 = sp1_64;
+}
+
+define pcodeop i8x16_eq;
+# [v128 v128] -> [v128]
+:i8x16.eq is opc=0xFD; opc2_35; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_eq(sp1_128, sp2_128);
+}
+
+define pcodeop i8x16_ne;
+# [v128 v128] -> [v128]
+:i8x16.ne is opc=0xFD; opc2_36; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_ne(sp1_128, sp2_128);
+}
+
+define pcodeop i8x16_lt_s;
+# [v128 v128] -> [v128]
+:i8x16.lt_s is opc=0xFD; opc2_37; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_lt_s(sp1_128, sp2_128);
+}
+
+define pcodeop i8x16_lt_u;
+# [v128 v128] -> [v128]
+:i8x16.lt_u is opc=0xFD; opc2_38; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_lt_u(sp1_128, sp2_128);
+}
+
+define pcodeop i8x16_gt_s;
+# [v128 v128] -> [v128]
+:i8x16.gt_s is opc=0xFD; opc2_39; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_gt_s(sp1_128, sp2_128);
+}
+
+define pcodeop i8x16_gt_u;
+# [v128 v128] -> [v128]
+:i8x16.gt_u is opc=0xFD; opc2_40; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_gt_u(sp1_128, sp2_128);
+}
+
+define pcodeop i8x16_le_s;
+# [v128 v128] -> [v128]
+:i8x16.le_s is opc=0xFD; opc2_41; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_le_s(sp1_128, sp2_128);
+}
+
+define pcodeop i8x16_le_u;
+# [v128 v128] -> [v128]
+:i8x16.le_u is opc=0xFD; opc2_42; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_le_u(sp1_128, sp2_128);
+}
+
+define pcodeop i8x16_ge_s;
+# [v128 v128] -> [v128]
+:i8x16.ge_s is opc=0xFD; opc2_43; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_ge_s(sp1_128, sp2_128);
+}
+
+define pcodeop i8x16_ge_u;
+# [v128 v128] -> [v128]
+:i8x16.ge_u is opc=0xFD; opc2_44; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_ge_u(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_eq;
+# [v128 v128] -> [v128]
+:i16x8.eq is opc=0xFD; opc2_45; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_eq(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_ne;
+# [v128 v128] -> [v128]
+:i16x8.ne is opc=0xFD; opc2_46; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_ne(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_lt_s;
+# [v128 v128] -> [v128]
+:i16x8.lt_s is opc=0xFD; opc2_47; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_lt_s(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_lt_u;
+# [v128 v128] -> [v128]
+:i16x8.lt_u is opc=0xFD; opc2_48; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_lt_u(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_gt_s;
+# [v128 v128] -> [v128]
+:i16x8.gt_s is opc=0xFD; opc2_49; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_gt_s(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_gt_u;
+# [v128 v128] -> [v128]
+:i16x8.gt_u is opc=0xFD; opc2_50; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_gt_u(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_le_s;
+# [v128 v128] -> [v128]
+:i16x8.le_s is opc=0xFD; opc2_51; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_le_s(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_le_u;
+# [v128 v128] -> [v128]
+:i16x8.le_u is opc=0xFD; opc2_52; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_le_u(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_ge_s;
+# [v128 v128] -> [v128]
+:i16x8.ge_s is opc=0xFD; opc2_53; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_ge_s(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_ge_u;
+# [v128 v128] -> [v128]
+:i16x8.ge_u is opc=0xFD; opc2_54; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_ge_u(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_eq;
+# [v128 v128] -> [v128]
+:i32x4.eq is opc=0xFD; opc2_55; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_eq(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_ne;
+# [v128 v128] -> [v128]
+:i32x4.ne is opc=0xFD; opc2_56; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_ne(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_lt_s;
+# [v128 v128] -> [v128]
+:i32x4.lt_s is opc=0xFD; opc2_57; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_lt_s(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_lt_u;
+# [v128 v128] -> [v128]
+:i32x4.lt_u is opc=0xFD; opc2_58; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_lt_u(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_gt_s;
+# [v128 v128] -> [v128]
+:i32x4.gt_s is opc=0xFD; opc2_59; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_gt_s(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_gt_u;
+# [v128 v128] -> [v128]
+:i32x4.gt_u is opc=0xFD; opc2_60; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_gt_u(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_le_s;
+# [v128 v128] -> [v128]
+:i32x4.le_s is opc=0xFD; opc2_61; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_le_s(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_le_u;
+# [v128 v128] -> [v128]
+:i32x4.le_u is opc=0xFD; opc2_62; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_le_u(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_ge_s;
+# [v128 v128] -> [v128]
+:i32x4.ge_s is opc=0xFD; opc2_63; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_ge_s(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_ge_u;
+# [v128 v128] -> [v128]
+:i32x4.ge_u is opc=0xFD; opc2_64; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_ge_u(sp1_128, sp2_128);
+}
+
+define pcodeop f32x4_eq;
+# [v128 v128] -> [v128]
+:f32x4.eq is opc=0xFD; opc2_65; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f32x4_eq(sp1_128, sp2_128);
+}
+
+define pcodeop f32x4_ne;
+# [v128 v128] -> [v128]
+:f32x4.ne is opc=0xFD; opc2_66; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f32x4_ne(sp1_128, sp2_128);
+}
+
+define pcodeop f32x4_lt;
+# [v128 v128] -> [v128]
+:f32x4.lt is opc=0xFD; opc2_67; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f32x4_lt(sp1_128, sp2_128);
+}
+
+define pcodeop f32x4_gt;
+# [v128 v128] -> [v128]
+:f32x4.gt is opc=0xFD; opc2_68; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f32x4_gt(sp1_128, sp2_128);
+}
+
+define pcodeop f32x4_le;
+# [v128 v128] -> [v128]
+:f32x4.le is opc=0xFD; opc2_69; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f32x4_le(sp1_128, sp2_128);
+}
+
+define pcodeop f32x4_ge;
+# [v128 v128] -> [v128]
+:f32x4.ge is opc=0xFD; opc2_70; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f32x4_ge(sp1_128, sp2_128);
+}
+
+define pcodeop f64x2_eq;
+# [v128 v128] -> [v128]
+:f64x2.eq is opc=0xFD; opc2_71; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f64x2_eq(sp1_128, sp2_128);
+}
+
+define pcodeop f64x2_ne;
+# [v128 v128] -> [v128]
+:f64x2.ne is opc=0xFD; opc2_72; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f64x2_ne(sp1_128, sp2_128);
+}
+
+define pcodeop f64x2_lt;
+# [v128 v128] -> [v128]
+:f64x2.lt is opc=0xFD; opc2_73; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f64x2_lt(sp1_128, sp2_128);
+}
+
+define pcodeop f64x2_gt;
+# [v128 v128] -> [v128]
+:f64x2.gt is opc=0xFD; opc2_74; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f64x2_gt(sp1_128, sp2_128);
+}
+
+define pcodeop f64x2_le;
+# [v128 v128] -> [v128]
+:f64x2.le is opc=0xFD; opc2_75; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f64x2_le(sp1_128, sp2_128);
+}
+
+define pcodeop f64x2_ge;
+# [v128 v128] -> [v128]
+:f64x2.ge is opc=0xFD; opc2_76; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f64x2_ge(sp1_128, sp2_128);
+}
+
+# [v128] -> [v128]
+:v128.not is opc=0xFD; opc2_77; sp1_128; ctx_is_directive=0 {
+    sp1_128 = ~sp1_128;
+}
+
+# [v128 v128] -> [v128]
+:v128.and is opc=0xFD; opc2_78; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = sp2_128 & sp1_128;
+}
+
+# [v128 v128] -> [v128]
+:v128.andnot is opc=0xFD; opc2_79; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = sp2_128 & ~sp1_128;
+}
+
+# [v128 v128] -> [v128]
+:v128.or is opc=0xFD; opc2_80; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = sp2_128 | sp1_128;
+}
+
+# [v128 v128] -> [v128]
+:v128.xor is opc=0xFD; opc2_81; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = sp2_128 ^ sp1_128;
+}
+
+define pcodeop v128_bitselect;
+# [v128 v128 v128] -> [v128]
+:v128.bitselect is opc=0xFD; opc2_82; sp1_128; sp2_128; sp3_128; ctx_is_directive=0 {
+    sp3_128 = v128_bitselect(sp1_128, sp2_128, sp3_128);
+}
+
+# [v128] -> [i32]
+:v128.any_true is opc=0xFD; opc2_83; sp1_128; sp1_32; ctx_is_directive=0 {
+    sp1_32 = zext(sp1_128 != 0);
+}
+
+# [i32 v128] -> [v128]
+:v128.load8_lane loadaddr2 sp2_lane8 is opc=0xFD; opc2_84; loadaddr2; sp1_128; sp2_128; sp2_lane8; ctx_is_directive=0 {
+    sp2_128 = sp1_128;
+    sp2_lane8 = *:1 loadaddr2;
+}
+
+# [i32 v128] -> [v128]
+:v128.load16_lane loadaddr2 sp2_lane16 is opc=0xFD; opc2_85; loadaddr2; sp1_128; sp2_128; sp2_lane16; ctx_is_directive=0 {
+    sp2_128 = sp1_128;
+    sp2_lane16 = *:2 loadaddr2;
+}
+
+# [i32 v128] -> [v128]
+:v128.load32_lane loadaddr2 sp2_lane32 is opc=0xFD; opc2_86; loadaddr2; sp1_128; sp2_128; sp2_lane32; ctx_is_directive=0 {
+    sp2_128 = sp1_128;
+    sp2_lane32 = *:4 loadaddr2;
+}
+
+# [i32 v128] -> [v128]
+:v128.load64_lane loadaddr2 sp2_lane64 is opc=0xFD; opc2_87; loadaddr2; sp1_128; sp2_128; sp2_lane64; ctx_is_directive=0 {
+    sp2_128 = sp1_128;
+    sp2_lane64 = *:8 loadaddr2;
+}
+
+# [i32 v128] -> []
+:v128.store8_lane storeaddr sp1_lane8 is opc=0xFD; opc2_88; storeaddr; sp1_lane8; ctx_is_directive=0 {
+    *:1 storeaddr = sp1_lane8;
+}
+
+# [i32 v128] -> []
+:v128.store16_lane storeaddr sp1_lane16 is opc=0xFD; opc2_89; storeaddr; sp1_lane16; ctx_is_directive=0 {
+    *:2 storeaddr = sp1_lane16;
+}
+
+# [i32 v128] -> []
+:v128.store32_lane storeaddr sp1_lane32 is opc=0xFD; opc2_90; storeaddr; sp1_lane32; ctx_is_directive=0 {
+    *:4 storeaddr = sp1_lane32;
+}
+
+# [i32 v128] -> []
+:v128.store64_lane storeaddr sp1_lane64 is opc=0xFD; opc2_91; storeaddr; sp1_lane64; ctx_is_directive=0 {
+    *:8 storeaddr = sp1_lane64;
+}
+
+# [i32] -> [v128]
+:v128.load32_zero loadaddr is opc=0xFD; opc2_92; loadaddr; sp1_128; ctx_is_directive=0 {
+    sp1_128 = zext(*:4 loadaddr);
+}
+
+# [i32] -> [v128]
+:v128.load64_zero loadaddr is opc=0xFD; opc2_93; loadaddr; sp1_128; ctx_is_directive=0 {
+    sp1_128 = zext(*:8 loadaddr);
+}
+
+# [v128] -> [v128]
+:f32x4.demote_f64x2_zero is opc=0xFD; opc2_94; sp1_128; ctx_is_directive=0 {
+    t0o = 0;
+    t0o[0, 32] = float2float(sp1_128[0, 64]);
+    t0o[32, 32] = float2float(sp1_128[64, 64]);
+    sp1_128 = t0o;
+}
+
+# [v128] -> [v128]
+:f64x2.promote_low_f32x4 is opc=0xFD; opc2_95; sp1_128; ctx_is_directive=0 {
+    t0o[0, 64] = float2float(sp1_128[0, 32]);
+    t0o[64, 64] = float2float(sp1_128[32, 32]);
+    sp1_128 = t0o;
+}
+
+define pcodeop i8x16_abs;
+# [v128] -> [v128]
+:i8x16.abs is opc=0xFD; opc2_96; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i8x16_abs(sp1_128);
+}
+
+# [v128] -> [v128]
+:i8x16.neg is opc=0xFD; opc2_97; sp1_128; ctx_is_directive=0 {
+    sp1_128[  0,8] = -sp1_128[  0,8];
+    sp1_128[  8,8] = -sp1_128[  8,8];
+    sp1_128[ 16,8] = -sp1_128[ 16,8];
+    sp1_128[ 24,8] = -sp1_128[ 24,8];
+    sp1_128[ 32,8] = -sp1_128[ 32,8];
+    sp1_128[ 40,8] = -sp1_128[ 40,8];
+    sp1_128[ 48,8] = -sp1_128[ 48,8];
+    sp1_128[ 56,8] = -sp1_128[ 56,8];
+    sp1_128[ 64,8] = -sp1_128[ 64,8];
+    sp1_128[ 72,8] = -sp1_128[ 72,8];
+    sp1_128[ 80,8] = -sp1_128[ 80,8];
+    sp1_128[ 88,8] = -sp1_128[ 88,8];
+    sp1_128[ 96,8] = -sp1_128[ 96,8];
+    sp1_128[104,8] = -sp1_128[104,8];
+    sp1_128[112,8] = -sp1_128[112,8];
+    sp1_128[120,8] = -sp1_128[120,8];
+}
+
+define pcodeop i8x16_popcnt;
+# [v128] -> [v128]
+:i8x16.popcnt is opc=0xFD; opc2_98; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i8x16_popcnt(sp1_128);
+}
+
+define pcodeop i8x16_all_true;
+# [v128] -> [i32]
+:i8x16.all_true is opc=0xFD; opc2_99; sp1_128; sp1_32; ctx_is_directive=0 {
+    sp1_32 = i8x16_all_true(sp1_128);
+}
+
+define pcodeop i8x16_bitmask;
+# [v128] -> [i32]
+:i8x16.bitmask is opc=0xFD; opc2_100; sp1_128; sp1_32; ctx_is_directive=0 {
+    sp1_32 = i8x16_bitmask(sp1_128);
+}
+
+define pcodeop i8x16_narrow_i16x8_s;
+# [v128 v128] -> [v128]
+:i8x16.narrow_i16x8_s is opc=0xFD; opc2_101; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_narrow_i16x8_s(sp1_128, sp2_128);
+}
+
+define pcodeop i8x16_narrow_i16x8_u;
+# [v128 v128] -> [v128]
+:i8x16.narrow_i16x8_u is opc=0xFD; opc2_102; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_narrow_i16x8_u(sp1_128, sp2_128);
+}
+
+define pcodeop f32x4_ceil;
+# [v128] -> [v128]
+:f32x4.ceil is opc=0xFD; opc2_103; sp1_128; ctx_is_directive=0 {
+    sp1_128 = f32x4_ceil(sp1_128);
+}
+
+define pcodeop f32x4_floor;
+# [v128] -> [v128]
+:f32x4.floor is opc=0xFD; opc2_104; sp1_128; ctx_is_directive=0 {
+    sp1_128 = f32x4_floor(sp1_128);
+}
+
+define pcodeop f32x4_trunc;
+# [v128] -> [v128]
+:f32x4.trunc is opc=0xFD; opc2_105; sp1_128; ctx_is_directive=0 {
+    sp1_128 = f32x4_trunc(sp1_128);
+}
+
+define pcodeop f32x4_nearest;
+# [v128] -> [v128]
+:f32x4.nearest is opc=0xFD; opc2_106; sp1_128; ctx_is_directive=0 {
+    sp1_128 = f32x4_nearest(sp1_128);
+}
+
+define pcodeop i8x16_shl;
+# [v128 i32] -> [v128]
+:i8x16.shl is opc=0xFD; opc2_107; sp1_32; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_shl(sp1_32, sp2_128);
+}
+
+define pcodeop i8x16_shr_s;
+# [v128 i32] -> [v128]
+:i8x16.shr_s is opc=0xFD; opc2_108; sp1_32; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_shr_s(sp1_32, sp2_128);
+}
+
+define pcodeop i8x16_shr_u;
+# [v128 i32] -> [v128]
+:i8x16.shr_u is opc=0xFD; opc2_109; sp1_32; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_shr_u(sp1_32, sp2_128);
+}
+
+# [v128 v128] -> [v128]
+:i8x16.add is opc=0xFD; opc2_110; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128[  0,8] = sp2_128[  0,8] + sp1_128[  0,8];
+    sp2_128[  8,8] = sp2_128[  8,8] + sp1_128[  8,8];
+    sp2_128[ 16,8] = sp2_128[ 16,8] + sp1_128[ 16,8];
+    sp2_128[ 24,8] = sp2_128[ 24,8] + sp1_128[ 24,8];
+    sp2_128[ 32,8] = sp2_128[ 32,8] + sp1_128[ 32,8];
+    sp2_128[ 40,8] = sp2_128[ 40,8] + sp1_128[ 40,8];
+    sp2_128[ 48,8] = sp2_128[ 48,8] + sp1_128[ 48,8];
+    sp2_128[ 56,8] = sp2_128[ 56,8] + sp1_128[ 56,8];
+    sp2_128[ 64,8] = sp2_128[ 64,8] + sp1_128[ 64,8];
+    sp2_128[ 72,8] = sp2_128[ 72,8] + sp1_128[ 72,8];
+    sp2_128[ 80,8] = sp2_128[ 80,8] + sp1_128[ 80,8];
+    sp2_128[ 88,8] = sp2_128[ 88,8] + sp1_128[ 88,8];
+    sp2_128[ 96,8] = sp2_128[ 96,8] + sp1_128[ 96,8];
+    sp2_128[104,8] = sp2_128[104,8] + sp1_128[104,8];
+    sp2_128[112,8] = sp2_128[112,8] + sp1_128[112,8];
+    sp2_128[120,8] = sp2_128[120,8] + sp1_128[120,8];
+}
+
+define pcodeop i8x16_add_sat_s;
+# [v128 v128] -> [v128]
+:i8x16.add_sat_s is opc=0xFD; opc2_111; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_add_sat_s(sp1_128, sp2_128);
+}
+
+define pcodeop i8x16_add_sat_u;
+# [v128 v128] -> [v128]
+:i8x16.add_sat_u is opc=0xFD; opc2_112; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_add_sat_u(sp1_128, sp2_128);
+}
+
+# [v128 v128] -> [v128]
+:i8x16.sub is opc=0xFD; opc2_113; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128[  0,8] = sp2_128[  0,8] - sp1_128[  0,8];
+    sp2_128[  8,8] = sp2_128[  8,8] - sp1_128[  8,8];
+    sp2_128[ 16,8] = sp2_128[ 16,8] - sp1_128[ 16,8];
+    sp2_128[ 24,8] = sp2_128[ 24,8] - sp1_128[ 24,8];
+    sp2_128[ 32,8] = sp2_128[ 32,8] - sp1_128[ 32,8];
+    sp2_128[ 40,8] = sp2_128[ 40,8] - sp1_128[ 40,8];
+    sp2_128[ 48,8] = sp2_128[ 48,8] - sp1_128[ 48,8];
+    sp2_128[ 56,8] = sp2_128[ 56,8] - sp1_128[ 56,8];
+    sp2_128[ 64,8] = sp2_128[ 64,8] - sp1_128[ 64,8];
+    sp2_128[ 72,8] = sp2_128[ 72,8] - sp1_128[ 72,8];
+    sp2_128[ 80,8] = sp2_128[ 80,8] - sp1_128[ 80,8];
+    sp2_128[ 88,8] = sp2_128[ 88,8] - sp1_128[ 88,8];
+    sp2_128[ 96,8] = sp2_128[ 96,8] - sp1_128[ 96,8];
+    sp2_128[104,8] = sp2_128[104,8] - sp1_128[104,8];
+    sp2_128[112,8] = sp2_128[112,8] - sp1_128[112,8];
+    sp2_128[120,8] = sp2_128[120,8] - sp1_128[120,8];
+}
+
+define pcodeop i8x16_sub_sat_s;
+# [v128 v128] -> [v128]
+:i8x16.sub_sat_s is opc=0xFD; opc2_114; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_sub_sat_s(sp1_128, sp2_128);
+}
+
+define pcodeop i8x16_sub_sat_u;
+# [v128 v128] -> [v128]
+:i8x16.sub_sat_u is opc=0xFD; opc2_115; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_sub_sat_u(sp1_128, sp2_128);
+}
+
+define pcodeop f64x2_ceil;
+# [v128] -> [v128]
+:f64x2.ceil is opc=0xFD; opc2_116; sp1_128; ctx_is_directive=0 {
+    sp1_128 = f64x2_ceil(sp1_128);
+}
+
+define pcodeop f64x2_floor;
+# [v128] -> [v128]
+:f64x2.floor is opc=0xFD; opc2_117; sp1_128; ctx_is_directive=0 {
+    sp1_128 = f64x2_floor(sp1_128);
+}
+
+define pcodeop i8x16_min_s;
+# [v128 v128] -> [v128]
+:i8x16.min_s is opc=0xFD; opc2_118; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_min_s(sp1_128, sp2_128);
+}
+
+define pcodeop i8x16_min_u;
+# [v128 v128] -> [v128]
+:i8x16.min_u is opc=0xFD; opc2_119; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_min_u(sp1_128, sp2_128);
+}
+
+define pcodeop i8x16_max_s;
+# [v128 v128] -> [v128]
+:i8x16.max_s is opc=0xFD; opc2_120; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_max_s(sp1_128, sp2_128);
+}
+
+define pcodeop i8x16_max_u;
+# [v128 v128] -> [v128]
+:i8x16.max_u is opc=0xFD; opc2_121; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_max_u(sp1_128, sp2_128);
+}
+
+define pcodeop f64x2_trunc;
+# [v128] -> [v128]
+:f64x2.trunc is opc=0xFD; opc2_122; sp1_128; ctx_is_directive=0 {
+    sp1_128 = f64x2_trunc(sp1_128);
+}
+
+define pcodeop i8x16_avgr_u;
+# [v128 v128] -> [v128]
+:i8x16.avgr_u is opc=0xFD; opc2_123; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i8x16_avgr_u(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_extadd_pairwise_i8x16_s;
+# [v128] -> [v128]
+:i16x8.extadd_pairwise_i8x16_s is opc=0xFD; opc2_124; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i16x8_extadd_pairwise_i8x16_s(sp1_128);
+}
+
+define pcodeop i16x8_extadd_pairwise_i8x16_u;
+# [v128] -> [v128]
+:i16x8.extadd_pairwise_i8x16_u is opc=0xFD; opc2_125; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i16x8_extadd_pairwise_i8x16_u(sp1_128);
+}
+
+define pcodeop i32x4_extadd_pairwise_i16x8_s;
+# [v128] -> [v128]
+:i32x4.extadd_pairwise_i16x8_s is opc=0xFD; opc2_126; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i32x4_extadd_pairwise_i16x8_s(sp1_128);
+}
+
+define pcodeop i32x4_extadd_pairwise_i16x8_u;
+# [v128] -> [v128]
+:i32x4.extadd_pairwise_i16x8_u is opc=0xFD; opc2_127; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i32x4_extadd_pairwise_i16x8_u(sp1_128);
+}
+
+define pcodeop i16x8_abs;
+# [v128] -> [v128]
+:i16x8.abs is opc=0xFD; opc2_128; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i16x8_abs(sp1_128);
+}
+
+# [v128] -> [v128]
+:i16x8.neg is opc=0xFD; opc2_129; sp1_128; ctx_is_directive=0 {
+    sp1_128[  0,16] = -sp1_128[  0,16];
+    sp1_128[ 16,16] = -sp1_128[ 16,16];
+    sp1_128[ 32,16] = -sp1_128[ 32,16];
+    sp1_128[ 48,16] = -sp1_128[ 48,16];
+    sp1_128[ 64,16] = -sp1_128[ 64,16];
+    sp1_128[ 80,16] = -sp1_128[ 80,16];
+    sp1_128[ 96,16] = -sp1_128[ 96,16];
+    sp1_128[112,16] = -sp1_128[112,16];
+}
+
+define pcodeop i16x8_q15mulr_sat_s;
+# [v128 v128] -> [v128]
+:i16x8.q15mulr_sat_s is opc=0xFD; opc2_130; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_q15mulr_sat_s(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_all_true;
+# [v128] -> [i32]
+:i16x8.all_true is opc=0xFD; opc2_131; sp1_128; sp1_32; ctx_is_directive=0 {
+    sp1_32 = i16x8_all_true(sp1_128);
+}
+
+define pcodeop i16x8_bitmask;
+# [v128] -> [i32]
+:i16x8.bitmask is opc=0xFD; opc2_132; sp1_128; sp1_32; ctx_is_directive=0 {
+    sp1_32 = i16x8_bitmask(sp1_128);
+}
+
+define pcodeop i16x8_narrow_i32x4_s;
+# [v128 v128] -> [v128]
+:i16x8.narrow_i32x4_s is opc=0xFD; opc2_133; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_narrow_i32x4_s(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_narrow_i32x4_u;
+# [v128 v128] -> [v128]
+:i16x8.narrow_i32x4_u is opc=0xFD; opc2_134; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_narrow_i32x4_u(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_extend_low_i8x16_s;
+# [v128] -> [v128]
+:i16x8.extend_low_i8x16_s is opc=0xFD; opc2_135; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i16x8_extend_low_i8x16_s(sp1_128);
+}
+
+define pcodeop i16x8_extend_high_i8x16_s;
+# [v128] -> [v128]
+:i16x8.extend_high_i8x16_s is opc=0xFD; opc2_136; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i16x8_extend_high_i8x16_s(sp1_128);
+}
+
+define pcodeop i16x8_extend_low_i8x16_u;
+# [v128] -> [v128]
+:i16x8.extend_low_i8x16_u is opc=0xFD; opc2_137; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i16x8_extend_low_i8x16_u(sp1_128);
+}
+
+define pcodeop i16x8_extend_high_i8x16_u;
+# [v128] -> [v128]
+:i16x8.extend_high_i8x16_u is opc=0xFD; opc2_138; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i16x8_extend_high_i8x16_u(sp1_128);
+}
+
+define pcodeop i16x8_shl;
+# [v128 i32] -> [v128]
+:i16x8.shl is opc=0xFD; opc2_139; sp1_32; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_shl(sp1_32, sp2_128);
+}
+
+define pcodeop i16x8_shr_s;
+# [v128 i32] -> [v128]
+:i16x8.shr_s is opc=0xFD; opc2_140; sp1_32; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_shr_s(sp1_32, sp2_128);
+}
+
+define pcodeop i16x8_shr_u;
+# [v128 i32] -> [v128]
+:i16x8.shr_u is opc=0xFD; opc2_141; sp1_32; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_shr_u(sp1_32, sp2_128);
+}
+
+# [v128 v128] -> [v128]
+:i16x8.add is opc=0xFD; opc2_142; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128[  0,16] = sp2_128[  0,16] + sp1_128[  0,16];
+    sp2_128[ 16,16] = sp2_128[ 16,16] + sp1_128[ 16,16];
+    sp2_128[ 32,16] = sp2_128[ 32,16] + sp1_128[ 32,16];
+    sp2_128[ 48,16] = sp2_128[ 48,16] + sp1_128[ 48,16];
+    sp2_128[ 64,16] = sp2_128[ 64,16] + sp1_128[ 64,16];
+    sp2_128[ 80,16] = sp2_128[ 80,16] + sp1_128[ 80,16];
+    sp2_128[ 96,16] = sp2_128[ 96,16] + sp1_128[ 96,16];
+    sp2_128[112,16] = sp2_128[112,16] + sp1_128[112,16];
+}
+
+define pcodeop i16x8_add_sat_s;
+# [v128 v128] -> [v128]
+:i16x8.add_sat_s is opc=0xFD; opc2_143; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_add_sat_s(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_add_sat_u;
+# [v128 v128] -> [v128]
+:i16x8.add_sat_u is opc=0xFD; opc2_144; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_add_sat_u(sp1_128, sp2_128);
+}
+
+# [v128 v128] -> [v128]
+:i16x8.sub is opc=0xFD; opc2_145; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128[  0,16] = sp2_128[  0,16] - sp1_128[  0,16];
+    sp2_128[ 16,16] = sp2_128[ 16,16] - sp1_128[ 16,16];
+    sp2_128[ 32,16] = sp2_128[ 32,16] - sp1_128[ 32,16];
+    sp2_128[ 48,16] = sp2_128[ 48,16] - sp1_128[ 48,16];
+    sp2_128[ 64,16] = sp2_128[ 64,16] - sp1_128[ 64,16];
+    sp2_128[ 80,16] = sp2_128[ 80,16] - sp1_128[ 80,16];
+    sp2_128[ 96,16] = sp2_128[ 96,16] - sp1_128[ 96,16];
+    sp2_128[112,16] = sp2_128[112,16] - sp1_128[112,16];
+}
+
+define pcodeop i16x8_sub_sat_s;
+# [v128 v128] -> [v128]
+:i16x8.sub_sat_s is opc=0xFD; opc2_146; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_sub_sat_s(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_sub_sat_u;
+# [v128 v128] -> [v128]
+:i16x8.sub_sat_u is opc=0xFD; opc2_147; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_sub_sat_u(sp1_128, sp2_128);
+}
+
+define pcodeop f64x2_nearest;
+# [v128] -> [v128]
+:f64x2.nearest is opc=0xFD; opc2_148; sp1_128; ctx_is_directive=0 {
+    sp1_128 = f64x2_nearest(sp1_128);
+}
+
+define pcodeop i16x8_mul;
+# [v128 v128] -> [v128]
+:i16x8.mul is opc=0xFD; opc2_149; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_mul(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_min_s;
+# [v128 v128] -> [v128]
+:i16x8.min_s is opc=0xFD; opc2_150; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_min_s(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_min_u;
+# [v128 v128] -> [v128]
+:i16x8.min_u is opc=0xFD; opc2_151; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_min_u(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_max_s;
+# [v128 v128] -> [v128]
+:i16x8.max_s is opc=0xFD; opc2_152; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_max_s(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_max_u;
+# [v128 v128] -> [v128]
+:i16x8.max_u is opc=0xFD; opc2_153; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_max_u(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_avgr_u;
+# [v128 v128] -> [v128]
+:i16x8.avgr_u is opc=0xFD; opc2_155; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_avgr_u(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_extmul_low_i8x16_s;
+# [v128 v128] -> [v128]
+:i16x8.extmul_low_i8x16_s is opc=0xFD; opc2_156; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_extmul_low_i8x16_s(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_extmul_high_i8x16_s;
+# [v128 v128] -> [v128]
+:i16x8.extmul_high_i8x16_s is opc=0xFD; opc2_157; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_extmul_high_i8x16_s(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_extmul_low_i8x16_u;
+# [v128 v128] -> [v128]
+:i16x8.extmul_low_i8x16_u is opc=0xFD; opc2_158; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_extmul_low_i8x16_u(sp1_128, sp2_128);
+}
+
+define pcodeop i16x8_extmul_high_i8x16_u;
+# [v128 v128] -> [v128]
+:i16x8.extmul_high_i8x16_u is opc=0xFD; opc2_159; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i16x8_extmul_high_i8x16_u(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_abs;
+# [v128] -> [v128]
+:i32x4.abs is opc=0xFD; opc2_160; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i32x4_abs(sp1_128);
+}
+
+# [v128] -> [v128]
+:i32x4.neg is opc=0xFD; opc2_161; sp1_128; ctx_is_directive=0 {
+    sp1_128[  0,32] = -sp1_128[  0,32];
+    sp1_128[ 32,32] = -sp1_128[ 32,32];
+    sp1_128[ 64,32] = -sp1_128[ 64,32];
+    sp1_128[ 96,32] = -sp1_128[ 96,32];
+}
+
+define pcodeop i32x4_all_true;
+# [v128] -> [i32]
+:i32x4.all_true is opc=0xFD; opc2_163; sp1_128; sp1_32; ctx_is_directive=0 {
+    sp1_32 = i32x4_all_true(sp1_128);
+}
+
+define pcodeop i32x4_bitmask;
+# [v128] -> [i32]
+:i32x4.bitmask is opc=0xFD; opc2_164; sp1_128; sp1_32; ctx_is_directive=0 {
+    sp1_32 = i32x4_bitmask(sp1_128);
+}
+
+define pcodeop i32x4_extend_low_i16x8_s;
+# [v128] -> [v128]
+:i32x4.extend_low_i16x8_s is opc=0xFD; opc2_167; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i32x4_extend_low_i16x8_s(sp1_128);
+}
+
+define pcodeop i32x4_extend_high_i16x8_s;
+# [v128] -> [v128]
+:i32x4.extend_high_i16x8_s is opc=0xFD; opc2_168; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i32x4_extend_high_i16x8_s(sp1_128);
+}
+
+define pcodeop i32x4_extend_low_i16x8_u;
+# [v128] -> [v128]
+:i32x4.extend_low_i16x8_u is opc=0xFD; opc2_169; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i32x4_extend_low_i16x8_u(sp1_128);
+}
+
+define pcodeop i32x4_extend_high_i16x8_u;
+# [v128] -> [v128]
+:i32x4.extend_high_i16x8_u is opc=0xFD; opc2_170; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i32x4_extend_high_i16x8_u(sp1_128);
+}
+
+define pcodeop i32x4_shl;
+# [v128 i32] -> [v128]
+:i32x4.shl is opc=0xFD; opc2_171; sp1_32; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_shl(sp1_32, sp2_128);
+}
+
+define pcodeop i32x4_shr_s;
+# [v128 i32] -> [v128]
+:i32x4.shr_s is opc=0xFD; opc2_172; sp1_32; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_shr_s(sp1_32, sp2_128);
+}
+
+define pcodeop i32x4_shr_u;
+# [v128 i32] -> [v128]
+:i32x4.shr_u is opc=0xFD; opc2_173; sp1_32; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_shr_u(sp1_32, sp2_128);
+}
+
+# [v128 v128] -> [v128]
+:i32x4.add is opc=0xFD; opc2_174; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128[  0,32] = sp2_128[  0,32] + sp1_128[  0,32];
+    sp2_128[ 32,32] = sp2_128[ 32,32] + sp1_128[ 32,32];
+    sp2_128[ 64,32] = sp2_128[ 64,32] + sp1_128[ 64,32];
+    sp2_128[ 96,32] = sp2_128[ 96,32] + sp1_128[ 96,32];
+}
+
+# [v128 v128] -> [v128]
+:i32x4.sub is opc=0xFD; opc2_177; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128[  0,32] = sp2_128[  0,32] - sp1_128[  0,32];
+    sp2_128[ 32,32] = sp2_128[ 32,32] - sp1_128[ 32,32];
+    sp2_128[ 64,32] = sp2_128[ 64,32] - sp1_128[ 64,32];
+    sp2_128[ 96,32] = sp2_128[ 96,32] - sp1_128[ 96,32];
+}
+
+define pcodeop i32x4_mul;
+# [v128 v128] -> [v128]
+:i32x4.mul is opc=0xFD; opc2_181; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_mul(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_min_s;
+# [v128 v128] -> [v128]
+:i32x4.min_s is opc=0xFD; opc2_182; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_min_s(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_min_u;
+# [v128 v128] -> [v128]
+:i32x4.min_u is opc=0xFD; opc2_183; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_min_u(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_max_s;
+# [v128 v128] -> [v128]
+:i32x4.max_s is opc=0xFD; opc2_184; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_max_s(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_max_u;
+# [v128 v128] -> [v128]
+:i32x4.max_u is opc=0xFD; opc2_185; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_max_u(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_dot_i16x8_s;
+# [v128 v128] -> [v128]
+:i32x4.dot_i16x8_s is opc=0xFD; opc2_186; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_dot_i16x8_s(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_extmul_low_i16x8_s;
+# [v128 v128] -> [v128]
+:i32x4.extmul_low_i16x8_s is opc=0xFD; opc2_188; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_extmul_low_i16x8_s(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_extmul_high_i16x8_s;
+# [v128 v128] -> [v128]
+:i32x4.extmul_high_i16x8_s is opc=0xFD; opc2_189; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_extmul_high_i16x8_s(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_extmul_low_i16x8_u;
+# [v128 v128] -> [v128]
+:i32x4.extmul_low_i16x8_u is opc=0xFD; opc2_190; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_extmul_low_i16x8_u(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_extmul_high_i16x8_u;
+# [v128 v128] -> [v128]
+:i32x4.extmul_high_i16x8_u is opc=0xFD; opc2_191; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i32x4_extmul_high_i16x8_u(sp1_128, sp2_128);
+}
+
+define pcodeop i64x2_abs;
+# [v128] -> [v128]
+:i64x2.abs is opc=0xFD; opc2_192; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i64x2_abs(sp1_128);
+}
+
+# [v128] -> [v128]
+:i64x2.neg is opc=0xFD; opc2_193; sp1_128; ctx_is_directive=0 {
+    sp1_128[  0,64] = -sp1_128[  0,64];
+    sp1_128[ 64,64] = -sp1_128[ 64,64];
+}
+
+define pcodeop i64x2_all_true;
+# [v128] -> [i32]
+:i64x2.all_true is opc=0xFD; opc2_195; sp1_128; sp1_32; ctx_is_directive=0 {
+    sp1_32 = i64x2_all_true(sp1_128);
+}
+
+define pcodeop i64x2_bitmask;
+# [v128] -> [i32]
+:i64x2.bitmask is opc=0xFD; opc2_196; sp1_128; sp1_32; ctx_is_directive=0 {
+    sp1_32 = i64x2_bitmask(sp1_128);
+}
+
+define pcodeop i64x2_extend_low_i32x4_s;
+# [v128] -> [v128]
+:i64x2.extend_low_i32x4_s is opc=0xFD; opc2_199; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i64x2_extend_low_i32x4_s(sp1_128);
+}
+
+define pcodeop i64x2_extend_high_i32x4_s;
+# [v128] -> [v128]
+:i64x2.extend_high_i32x4_s is opc=0xFD; opc2_200; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i64x2_extend_high_i32x4_s(sp1_128);
+}
+
+define pcodeop i64x2_extend_low_i32x4_u;
+# [v128] -> [v128]
+:i64x2.extend_low_i32x4_u is opc=0xFD; opc2_201; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i64x2_extend_low_i32x4_u(sp1_128);
+}
+
+define pcodeop i64x2_extend_high_i32x4_u;
+# [v128] -> [v128]
+:i64x2.extend_high_i32x4_u is opc=0xFD; opc2_202; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i64x2_extend_high_i32x4_u(sp1_128);
+}
+
+define pcodeop i64x2_shl;
+# [v128 i32] -> [v128]
+:i64x2.shl is opc=0xFD; opc2_203; sp1_32; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i64x2_shl(sp1_32, sp2_128);
+}
+
+define pcodeop i64x2_shr_s;
+# [v128 i32] -> [v128]
+:i64x2.shr_s is opc=0xFD; opc2_204; sp1_32; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i64x2_shr_s(sp1_32, sp2_128);
+}
+
+define pcodeop i64x2_shr_u;
+# [v128 i32] -> [v128]
+:i64x2.shr_u is opc=0xFD; opc2_205; sp1_32; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i64x2_shr_u(sp1_32, sp2_128);
+}
+
+# [v128 v128] -> [v128]
+:i64x2.add is opc=0xFD; opc2_206; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128[  0,64] = sp2_128[  0,64] + sp1_128[  0,64];
+    sp2_128[ 64,64] = sp2_128[ 64,64] + sp1_128[ 64,64];
+}
+
+# [v128 v128] -> [v128]
+:i64x2.sub is opc=0xFD; opc2_209; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128[  0,64] = sp2_128[  0,64] - sp1_128[  0,64];
+    sp2_128[ 64,64] = sp2_128[ 64,64] - sp1_128[ 64,64];
+}
+
+define pcodeop i64x2_mul;
+# [v128 v128] -> [v128]
+:i64x2.mul is opc=0xFD; opc2_213; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i64x2_mul(sp1_128, sp2_128);
+}
+
+define pcodeop i64x2_eq;
+# [v128 v128] -> [v128]
+:i64x2.eq is opc=0xFD; opc2_214; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i64x2_eq(sp1_128, sp2_128);
+}
+
+define pcodeop i64x2_ne;
+# [v128 v128] -> [v128]
+:i64x2.ne is opc=0xFD; opc2_215; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i64x2_ne(sp1_128, sp2_128);
+}
+
+define pcodeop i64x2_lt_s;
+# [v128 v128] -> [v128]
+:i64x2.lt_s is opc=0xFD; opc2_216; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i64x2_lt_s(sp1_128, sp2_128);
+}
+
+define pcodeop i64x2_gt_s;
+# [v128 v128] -> [v128]
+:i64x2.gt_s is opc=0xFD; opc2_217; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i64x2_gt_s(sp1_128, sp2_128);
+}
+
+define pcodeop i64x2_le_s;
+# [v128 v128] -> [v128]
+:i64x2.le_s is opc=0xFD; opc2_218; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i64x2_le_s(sp1_128, sp2_128);
+}
+
+define pcodeop i64x2_ge_s;
+# [v128 v128] -> [v128]
+:i64x2.ge_s is opc=0xFD; opc2_219; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i64x2_ge_s(sp1_128, sp2_128);
+}
+
+define pcodeop i64x2_extmul_low_i32x4_s;
+# [v128 v128] -> [v128]
+:i64x2.extmul_low_i32x4_s is opc=0xFD; opc2_220; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i64x2_extmul_low_i32x4_s(sp1_128, sp2_128);
+}
+
+define pcodeop i64x2_extmul_high_i32x4_s;
+# [v128 v128] -> [v128]
+:i64x2.extmul_high_i32x4_s is opc=0xFD; opc2_221; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i64x2_extmul_high_i32x4_s(sp1_128, sp2_128);
+}
+
+define pcodeop i64x2_extmul_low_i32x4_u;
+# [v128 v128] -> [v128]
+:i64x2.extmul_low_i32x4_u is opc=0xFD; opc2_222; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i64x2_extmul_low_i32x4_u(sp1_128, sp2_128);
+}
+
+define pcodeop i64x2_extmul_high_i32x4_u;
+# [v128 v128] -> [v128]
+:i64x2.extmul_high_i32x4_u is opc=0xFD; opc2_223; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = i64x2_extmul_high_i32x4_u(sp1_128, sp2_128);
+}
+
+define pcodeop f32x4_abs;
+# [v128] -> [v128]
+:f32x4.abs is opc=0xFD; opc2_224; sp1_128; ctx_is_directive=0 {
+    sp1_128 = f32x4_abs(sp1_128);
+}
+
+# [v128] -> [v128]
+:f32x4.neg is opc=0xFD; opc2_225; sp1_128; ctx_is_directive=0 {
+    sp1_128[  0,32] = f- sp1_128[  0,32];
+    sp1_128[ 32,32] = f- sp1_128[ 32,32];
+    sp1_128[ 64,32] = f- sp1_128[ 64,32];
+    sp1_128[ 96,32] = f- sp1_128[ 96,32];
+}
+
+define pcodeop f32x4_sqrt;
+# [v128] -> [v128]
+:f32x4.sqrt is opc=0xFD; opc2_227; sp1_128; ctx_is_directive=0 {
+    sp1_128 = f32x4_sqrt(sp1_128);
+}
+
+# [v128 v128] -> [v128]
+:f32x4.add is opc=0xFD; opc2_228; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128[  0,32] = sp2_128[  0,32] f+ sp1_128[  0,32];
+    sp2_128[ 32,32] = sp2_128[ 32,32] f+ sp1_128[ 32,32];
+    sp2_128[ 64,32] = sp2_128[ 64,32] f+ sp1_128[ 64,32];
+    sp2_128[ 96,32] = sp2_128[ 96,32] f+ sp1_128[ 96,32];
+}
+
+# [v128 v128] -> [v128]
+:f32x4.sub is opc=0xFD; opc2_229; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128[  0,32] = sp2_128[  0,32] f- sp1_128[  0,32];
+    sp2_128[ 32,32] = sp2_128[ 32,32] f- sp1_128[ 32,32];
+    sp2_128[ 64,32] = sp2_128[ 64,32] f- sp1_128[ 64,32];
+    sp2_128[ 96,32] = sp2_128[ 96,32] f- sp1_128[ 96,32];
+}
+
+# [v128 v128] -> [v128]
+:f32x4.mul is opc=0xFD; opc2_230; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128[  0,32] = sp2_128[  0,32] f* sp1_128[  0,32];
+    sp2_128[ 32,32] = sp2_128[ 32,32] f* sp1_128[ 32,32];
+    sp2_128[ 64,32] = sp2_128[ 64,32] f* sp1_128[ 64,32];
+    sp2_128[ 96,32] = sp2_128[ 96,32] f* sp1_128[ 96,32];
+}
+
+# [v128 v128] -> [v128]
+:f32x4.div is opc=0xFD; opc2_231; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128[  0,32] = sp2_128[  0,32] f/ sp1_128[  0,32];
+    sp2_128[ 32,32] = sp2_128[ 32,32] f/ sp1_128[ 32,32];
+    sp2_128[ 64,32] = sp2_128[ 64,32] f/ sp1_128[ 64,32];
+    sp2_128[ 96,32] = sp2_128[ 96,32] f/ sp1_128[ 96,32];
+}
+
+define pcodeop f32x4_min;
+# [v128 v128] -> [v128]
+:f32x4.min is opc=0xFD; opc2_232; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f32x4_min(sp1_128, sp2_128);
+}
+
+define pcodeop f32x4_max;
+# [v128 v128] -> [v128]
+:f32x4.max is opc=0xFD; opc2_233; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f32x4_max(sp1_128, sp2_128);
+}
+
+define pcodeop f32x4_pmin;
+# [v128 v128] -> [v128]
+:f32x4.pmin is opc=0xFD; opc2_234; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f32x4_pmin(sp1_128, sp2_128);
+}
+
+define pcodeop f32x4_pmax;
+# [v128 v128] -> [v128]
+:f32x4.pmax is opc=0xFD; opc2_235; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f32x4_pmax(sp1_128, sp2_128);
+}
+
+define pcodeop f64x2_abs;
+# [v128] -> [v128]
+:f64x2.abs is opc=0xFD; opc2_236; sp1_128; ctx_is_directive=0 {
+    sp1_128 = f64x2_abs(sp1_128);
+}
+
+# [v128] -> [v128]
+:f64x2.neg is opc=0xFD; opc2_237; sp1_128; ctx_is_directive=0 {
+    sp1_128[  0,64] = f- sp1_128[  0,64];
+    sp1_128[ 64,64] = f- sp1_128[ 64,64];
+}
+
+define pcodeop f64x2_sqrt;
+# [v128] -> [v128]
+:f64x2.sqrt is opc=0xFD; opc2_239; sp1_128; ctx_is_directive=0 {
+    sp1_128 = f64x2_sqrt(sp1_128);
+}
+
+# [v128 v128] -> [v128]
+:f64x2.add is opc=0xFD; opc2_240; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128[  0,64] = sp2_128[  0,64] f+ sp1_128[  0,64];
+    sp2_128[ 64,64] = sp2_128[ 64,64] f+ sp1_128[ 64,64];
+}
+
+# [v128 v128] -> [v128]
+:f64x2.sub is opc=0xFD; opc2_241; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128[  0,64] = sp2_128[  0,64] f- sp1_128[  0,64];
+    sp2_128[ 64,64] = sp2_128[ 64,64] f- sp1_128[ 64,64];
+}
+
+# [v128 v128] -> [v128]
+:f64x2.mul is opc=0xFD; opc2_242; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128[  0,64] = sp2_128[  0,64] f* sp1_128[  0,64];
+    sp2_128[ 64,64] = sp2_128[ 64,64] f* sp1_128[ 64,64];
+}
+
+# [v128 v128] -> [v128]
+:f64x2.div is opc=0xFD; opc2_243; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128[  0,64] = sp2_128[  0,64] f/ sp1_128[  0,64];
+    sp2_128[ 64,64] = sp2_128[ 64,64] f/ sp1_128[ 64,64];
+}
+
+define pcodeop f64x2_min;
+# [v128 v128] -> [v128]
+:f64x2.min is opc=0xFD; opc2_244; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f64x2_min(sp1_128, sp2_128);
+}
+
+define pcodeop f64x2_max;
+# [v128 v128] -> [v128]
+:f64x2.max is opc=0xFD; opc2_245; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f64x2_max(sp1_128, sp2_128);
+}
+
+define pcodeop f64x2_pmin;
+# [v128 v128] -> [v128]
+:f64x2.pmin is opc=0xFD; opc2_246; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f64x2_pmin(sp1_128, sp2_128);
+}
+
+define pcodeop f64x2_pmax;
+# [v128 v128] -> [v128]
+:f64x2.pmax is opc=0xFD; opc2_247; sp1_128; sp2_128; ctx_is_directive=0 {
+    sp2_128 = f64x2_pmax(sp1_128, sp2_128);
+}
+
+define pcodeop i32x4_trunc_sat_f32x4_s;
+# [v128] -> [v128]
+:i32x4.trunc_sat_f32x4_s is opc=0xFD; opc2_248; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i32x4_trunc_sat_f32x4_s(sp1_128);
+}
+
+define pcodeop i32x4_trunc_sat_f32x4_u;
+# [v128] -> [v128]
+:i32x4.trunc_sat_f32x4_u is opc=0xFD; opc2_249; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i32x4_trunc_sat_f32x4_u(sp1_128);
+}
+
+define pcodeop f32x4_convert_i32x4_s;
+# [v128] -> [v128]
+:f32x4.convert_i32x4_s is opc=0xFD; opc2_250; sp1_128; ctx_is_directive=0 {
+    sp1_128 = f32x4_convert_i32x4_s(sp1_128);
+}
+
+define pcodeop f32x4_convert_i32x4_u;
+# [v128] -> [v128]
+:f32x4.convert_i32x4_u is opc=0xFD; opc2_251; sp1_128; ctx_is_directive=0 {
+    sp1_128 = f32x4_convert_i32x4_u(sp1_128);
+}
+
+define pcodeop i32x4_trunc_sat_f64x2_s_zero;
+# [v128] -> [v128]
+:i32x4.trunc_sat_f64x2_s_zero is opc=0xFD; opc2_252; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i32x4_trunc_sat_f64x2_s_zero(sp1_128);
+}
+
+define pcodeop i32x4_trunc_sat_f64x2_u_zero;
+# [v128] -> [v128]
+:i32x4.trunc_sat_f64x2_u_zero is opc=0xFD; opc2_253; sp1_128; ctx_is_directive=0 {
+    sp1_128 = i32x4_trunc_sat_f64x2_u_zero(sp1_128);
+}
+
+define pcodeop f64x2_convert_low_i32x4_s;
+# [v128] -> [v128]
+:f64x2.convert_low_i32x4_s is opc=0xFD; opc2_254; sp1_128; ctx_is_directive=0 {
+    sp1_128 = f64x2_convert_low_i32x4_s(sp1_128);
+}
+
+define pcodeop f64x2_convert_low_i32x4_u;
+# [v128] -> [v128]
+:f64x2.convert_low_i32x4_u is opc=0xFD; opc2_255; sp1_128; ctx_is_directive=0 {
+    sp1_128 = f64x2_convert_low_i32x4_u(sp1_128);
+}
diff --git a/Ghidra/Processors/WebAssembly/data/languages/WebAssembly-pos-stack.cspec b/Ghidra/Processors/WebAssembly/data/languages/WebAssembly-pos-stack.cspec
new file mode 100644
index 0000000000..642db5c8e8
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/data/languages/WebAssembly-pos-stack.cspec
@@ -0,0 +1,836 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!-- See Relax specification: Ghidra/Framework/SoftwareModeling/data/languages/compiler_spec.rxg -->
+
+<compiler_spec>
+   <data_organization>
+    <char_type signed="true" />
+    <char_size value="1" />
+    <short_size value="2" />
+    <pointer_size value="4"/>
+    <integer_size value = "4"/>
+    <float_size value="4" />
+    <long_size value="4" />
+    <double_size value="8" />
+  </data_organization>
+  <global>
+    <range space="global"/>
+    <range space="table"/>
+    <range space="ram"/>
+  </global>
+  <stackpointer register="SP" space="ram" growth="positive"/>
+  <default_proto>
+    <prototype name="__wasm" extrapop="0" stackshift="0" strategy="register">
+      <input>
+        <!-- With the positive stack direction, Ghidra will allocate
+        starting at the highest addresses in any <addr> pentry, which is
+        not what we want. Instead, fall back to manually specifying the
+        registers in the correct order. -->
+        <pentry minsize="1" maxsize="16">
+          <register name="i0o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i1o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i2o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i3o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i4o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i5o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i6o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i7o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i8o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i9o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i10o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i11o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i12o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i13o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i14o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i15o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i16o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i17o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i18o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i19o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i20o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i21o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i22o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i23o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i24o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i25o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i26o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i27o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i28o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i29o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i30o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i31o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i32o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i33o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i34o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i35o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i36o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i37o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i38o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i39o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i40o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i41o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i42o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i43o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i44o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i45o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i46o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i47o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i48o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i49o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i50o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i51o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i52o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i53o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i54o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i55o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i56o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i57o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i58o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i59o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i60o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i61o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i62o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i63o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i64o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i65o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i66o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i67o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i68o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i69o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i70o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i71o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i72o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i73o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i74o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i75o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i76o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i77o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i78o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i79o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i80o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i81o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i82o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i83o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i84o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i85o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i86o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i87o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i88o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i89o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i90o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i91o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i92o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i93o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i94o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i95o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i96o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i97o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i98o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i99o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i100o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i101o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i102o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i103o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i104o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i105o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i106o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i107o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i108o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i109o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i110o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i111o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i112o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i113o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i114o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i115o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i116o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i117o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i118o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i119o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i120o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i121o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i122o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i123o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i124o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i125o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i126o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i127o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i128o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i129o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i130o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i131o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i132o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i133o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i134o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i135o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i136o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i137o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i138o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i139o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i140o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i141o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i142o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i143o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i144o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i145o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i146o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i147o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i148o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i149o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i150o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i151o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i152o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i153o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i154o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i155o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i156o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i157o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i158o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i159o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i160o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i161o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i162o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i163o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i164o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i165o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i166o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i167o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i168o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i169o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i170o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i171o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i172o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i173o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i174o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i175o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i176o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i177o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i178o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i179o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i180o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i181o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i182o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i183o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i184o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i185o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i186o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i187o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i188o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i189o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i190o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i191o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i192o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i193o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i194o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i195o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i196o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i197o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i198o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i199o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i200o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i201o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i202o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i203o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i204o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i205o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i206o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i207o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i208o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i209o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i210o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i211o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i212o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i213o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i214o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i215o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i216o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i217o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i218o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i219o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i220o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i221o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i222o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i223o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i224o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i225o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i226o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i227o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i228o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i229o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i230o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i231o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i232o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i233o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i234o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i235o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i236o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i237o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i238o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i239o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i240o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i241o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i242o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i243o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i244o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i245o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i246o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i247o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i248o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i249o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i250o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i251o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i252o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i253o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i254o"/>
+        </pentry>
+        <pentry minsize="1" maxsize="16">
+          <register name="i255o"/>
+        </pentry>
+      </input>
+      <output>
+        <pentry minsize="1" maxsize="16">
+          <register name="o0o"/>
+        </pentry>
+      </output>
+      <unaffected>
+        <varnode space="register" offset="0x10000000" size="0x10000000"/>
+        <varnode space="register" offset="0x50000000" size="0x10000000"/>
+        <register name="SP"/>
+      </unaffected>
+    </prototype>
+  </default_proto>
+  <callotherfixup targetop="funcEntryCallOther">
+    <pcode dynamic="true">
+      <input name="in_offset" />
+      <input name="locals_offset" />
+    </pcode>
+  </callotherfixup>
+  <callotherfixup targetop="popCallOther">
+    <pcode dynamic="true">
+      <input name="regoffset" />
+    </pcode>
+  </callotherfixup>
+  <callotherfixup targetop="pushCallOther">
+    <pcode dynamic="true">
+      <input name="regoffset" />
+    </pcode>
+  </callotherfixup>
+  <callotherfixup targetop="callPrologueCallOther">
+    <pcode dynamic="true">
+      <input name="regoffset" />
+    </pcode>
+  </callotherfixup>
+  <callotherfixup targetop="callEpilogueCallOther">
+    <pcode dynamic="true">
+      <input name="regoffset" />
+    </pcode>
+  </callotherfixup>
+</compiler_spec>
diff --git a/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.cspec b/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.cspec
new file mode 100644
index 0000000000..0ffabb966d
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.cspec
@@ -0,0 +1,67 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!-- See Relax specification: Ghidra/Framework/SoftwareModeling/data/languages/compiler_spec.rxg -->
+
+<compiler_spec>
+   <data_organization>
+    <char_type signed="true" />
+    <char_size value="1" />
+    <short_size value="2" />
+    <pointer_size value="4"/>
+    <integer_size value = "4"/>
+    <float_size value="4" />
+    <long_size value="4" />
+    <double_size value="8" />
+  </data_organization>
+  <global>
+    <range space="global"/>
+    <range space="table"/>
+    <range space="ram"/>
+  </global>
+  <stackpointer register="SP" space="ram"/>
+  <default_proto>
+    <prototype name="__wasm" extrapop="0" stackshift="0" strategy="register">
+      <input>
+        <pentry minsize="1" maxsize="500" align="16">
+          <addr offset="0x20000000" space="register"/>
+        </pentry>
+      </input>
+      <output>
+        <pentry minsize="1" maxsize="500" align="16">
+          <addr offset="0x30000000" space="register"/>
+        </pentry>
+      </output>
+      <unaffected>
+        <varnode space="register" offset="0x10000000" size="0x10000000"/>
+        <varnode space="register" offset="0x50000000" size="0x10000000"/>
+        <register name="SP"/>
+      </unaffected>
+    </prototype>
+  </default_proto>
+  <callotherfixup targetop="funcEntryCallOther">
+    <pcode dynamic="true">
+      <input name="in_offset" />
+      <input name="locals_offset" />
+    </pcode>
+  </callotherfixup>
+  <callotherfixup targetop="popCallOther">
+    <pcode dynamic="true">
+      <input name="regoffset" />
+    </pcode>
+  </callotherfixup>
+  <callotherfixup targetop="pushCallOther">
+    <pcode dynamic="true">
+      <input name="regoffset" />
+    </pcode>
+  </callotherfixup>
+  <callotherfixup targetop="callPrologueCallOther">
+    <pcode dynamic="true">
+      <input name="regoffset" />
+    </pcode>
+  </callotherfixup>
+  <callotherfixup targetop="callEpilogueCallOther">
+    <pcode dynamic="true">
+      <input name="regoffset" />
+    </pcode>
+  </callotherfixup>
+</compiler_spec>
diff --git a/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.dwarf b/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.dwarf
new file mode 100644
index 0000000000..2df3b9b8bc
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.dwarf
@@ -0,0 +1,6 @@
+<dwarf>
+	<register_mappings>
+		<!-- This is a dummy file to prevent "No DWARF to Ghidra register mappings" error-->
+		<register_mapping dwarf="3000" ghidra="SP" stackpointer="true"/>
+	</register_mappings>
+</dwarf>
\ No newline at end of file
diff --git a/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.ldefs b/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.ldefs
new file mode 100644
index 0000000000..7ae72dc86d
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.ldefs
@@ -0,0 +1,18 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!-- See Relax specification: Ghidra/Framework/SoftwareModeling/data/languages/language_definitions.rxg -->
+<language_definitions>
+   <language processor="WebAssembly"
+            endian="little"
+            size="32"
+            variant="default"
+            version="1.0"
+            slafile="WebAssembly.sla"
+            processorspec="WebAssembly.pspec"
+            id="Wasm:LE:32:default">
+    <description>WebAssembly Language Module</description>
+    <compiler name="default" spec="WebAssembly.cspec" id="default"/>
+    <compiler name="pos-stack" spec="WebAssembly-pos-stack.cspec" id="pos-stack"/>
+    <external_name tool="DWARF.register.mapping.file" name="WebAssembly.dwarf"/>
+  </language>
+</language_definitions>
diff --git a/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.opinion b/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.opinion
new file mode 100644
index 0000000000..43d630d161
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.opinion
@@ -0,0 +1,5 @@
+<opinions>
+    <constraint loader="WebAssembly" compilerSpecID="default">
+        <constraint primary="1"       processor="WebAssembly"   endian="little"    size="32" />
+    </constraint>
+</opinions>
\ No newline at end of file
diff --git a/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.pspec b/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.pspec
new file mode 100644
index 0000000000..f4898dd965
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.pspec
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!-- See Relax specification: Ghidra/Framework/SoftwareModeling/data/languages/processor_spec.rxg -->
+
+<processor_spec>
+  <properties>
+    <property key="pcodeInjectLibraryClass" value="wasm.pcode.PcodeInjectLibraryWasm"/>
+    <property key="emulateInstructionStateModifierClass" value="ghidra.program.emulation.WasmEmulateInstructionStateModifier"/>
+  </properties>
+  <inferptrbounds>
+    <range space="ram" first="0x400" last="0xffffffff"/>
+  </inferptrbounds>
+  <programcounter register="PC"/>
+  <register_data>
+    <register name="SP" group="Alt"/>
+  </register_data>
+</processor_spec>
diff --git a/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.sinc b/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.sinc
new file mode 100644
index 0000000000..9193244e13
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.sinc
@@ -0,0 +1,503 @@
+# sleigh include file for WebAssembly language instructions
+
+define token opbyte (8)
+	opc = (0, 7)
+	valtype = (0, 7)
+	bytev = (0, 7)
+
+	topbit = (7, 7)
+	v0 = (0, 6)
+	v1 = (0, 6)
+	v2 = (0, 6)
+	v3 = (0, 6)
+	v4 = (0, 6)
+	v5 = (0, 6)
+	v6 = (0, 6)
+	v7 = (0, 6)
+	v8 = (0, 6)
+	v9 = (0, 6)
+;
+
+define token I32 (32)
+	f32 = (0,31)
+;
+
+define token I64 (64)
+	f64 = (0,63)
+;
+
+attach names valtype [
+  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # 0x0
+  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # 0x10
+  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # 0x20
+  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # 0x30
+  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # 0x40
+  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # 0x50
+  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ externref # 0x60
+  funcref _ _ _ _ _ _ _ _ _ _ v128 f64 f32 i64 i32 # 0x70
+  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # 0x80
+  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # 0x90
+  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # 0xa0
+  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # 0xb0
+  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # 0xc0
+  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # 0xd0
+  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # 0xe0
+  _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ # 0xf0
+];
+
+################################################################
+
+define pcodeop funcEntryCallOther;
+define pcodeop popCallOther;
+define pcodeop pushCallOther;
+define pcodeop callPrologueCallOther;
+define pcodeop callEpilogueCallOther;
+define pcodeop halt_trap;
+define pcodeop popcnt;
+define pcodeop clz;
+define pcodeop ctz;
+# TODO: define some of these in terms of a more generic "memcpy"/"memset" operation
+define pcodeop table_init;
+define pcodeop elem_drop;
+define pcodeop table_copy;
+define pcodeop table_grow;
+define pcodeop table_size;
+define pcodeop table_fill;
+define pcodeop memory_size;
+define pcodeop memory_grow;
+define pcodeop memory_init;
+define pcodeop data_drop;
+define pcodeop memory_copy;
+define pcodeop memory_fill;
+
+@include "Leb128.sinc"
+
+# This is a silly hack because I couldn't work out how to use Leb128 itself
+# in the disassembly actions section of another constructor...
+# NOTE: Recursive expansion doesn't seem to work, so we hardcode REG_SIZE and REG_LOCALS_BASE here.
+@define SYMBOL local4
+@define DEST_EXPR "0x10000000 + 16 * "
+@define EXPORT_EXPR "export *[register]:4 dest;"
+@include "Leb128_u32.sinc"
+
+@define SYMBOL local8
+@define DEST_EXPR "0x10000000 + 16 * "
+@define EXPORT_EXPR "export *[register]:8 dest;"
+@include "Leb128_u32.sinc"
+
+@define SYMBOL local16
+@define DEST_EXPR "0x10000000 + 16 * "
+@define EXPORT_EXPR "export *[register]:16 dest;"
+@include "Leb128_u32.sinc"
+
+@define SYMBOL global4
+@define DEST_EXPR "16 * "
+@define EXPORT_EXPR "export *[global]:4 dest;"
+@include "Leb128_u32.sinc"
+
+@define SYMBOL global8
+@define DEST_EXPR "16 * "
+@define EXPORT_EXPR "export *[global]:8 dest;"
+@include "Leb128_u32.sinc"
+
+@define SYMBOL global16
+@define DEST_EXPR "16 * "
+@define EXPORT_EXPR "export *[global]:16 dest;"
+@include "Leb128_u32.sinc"
+
+@define SYMBOL tableref
+@define DEST_EXPR "(1<<32) * "
+@define EXPORT_EXPR "export *[table]:4 dest;"
+@include "Leb128_u32.sinc"
+
+@include "Leb128_opc2.sinc"
+
+sp0_32: tmp_sp is ctx_sp [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 0) * $(REG_SIZE);] {
+	export *[register]:4 tmp_sp;
+}
+
+sp0_64: tmp_sp is ctx_sp [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 0) * $(REG_SIZE);] {
+	export *[register]:8 tmp_sp;
+}
+
+sp0_128: tmp_sp is ctx_sp [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 0) * $(REG_SIZE);] {
+	export *[register]:16 tmp_sp;
+}
+
+sp1_32: tmp_sp is ctx_sp [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 1) * $(REG_SIZE);] {
+	export *[register]:4 tmp_sp;
+}
+
+sp1_64: tmp_sp is ctx_sp [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 1) * $(REG_SIZE);] {
+	export *[register]:8 tmp_sp;
+}
+
+sp1_128: tmp_sp is ctx_sp [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 1) * $(REG_SIZE);] {
+	export *[register]:16 tmp_sp;
+}
+
+sp2_32: tmp_sp is ctx_sp [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 2) * $(REG_SIZE);] {
+	export *[register]:4 tmp_sp;
+}
+
+sp2_64: tmp_sp is ctx_sp [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 2) * $(REG_SIZE);] {
+	export *[register]:8 tmp_sp;
+}
+
+sp2_128: tmp_sp is ctx_sp [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 2) * $(REG_SIZE);] {
+	export *[register]:16 tmp_sp;
+}
+
+sp3_32: tmp_sp is ctx_sp [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 3) * $(REG_SIZE);] {
+	export *[register]:4 tmp_sp;
+}
+
+sp3_64: tmp_sp is ctx_sp [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 3) * $(REG_SIZE);] {
+	export *[register]:8 tmp_sp;
+}
+
+sp3_128: tmp_sp is ctx_sp [tmp_sp = $(REG_STACK_BASE) + (ctx_sp - 3) * $(REG_SIZE);] {
+	export *[register]:16 tmp_sp;
+}
+
+br_target: ctx_br_target is ctx_br_target {
+	export *[ram]:4 ctx_br_target;
+}
+
+funcidx: ULeb128 is ULeb128 {
+	export ULeb128;
+}
+
+typeidx: ULeb128 is ULeb128 {
+	export ULeb128;
+}
+
+elemidx: ULeb128 is ULeb128 {
+	export ULeb128;
+}
+
+tableidx: ULeb128 is ULeb128 {
+	export ULeb128;
+}
+
+tableidx2: ULeb128 is ULeb128 {
+	export ULeb128;
+}
+
+dataidx: ULeb128 is ULeb128 {
+	export ULeb128;
+}
+
+memidx: ULeb128 is ULeb128 {
+	export ULeb128;
+}
+
+memidx2: ULeb128 is ULeb128 {
+	export ULeb128;
+}
+
+count: ULeb128 is ULeb128 {
+	export ULeb128;
+}
+
+# An explicit no-op operation, to be used before
+# callother instructions to work around Ghidra issue #3390
+# (which causes incorrect decompilation if the first pcodeop
+# in a branch target instruction is a callother)
+macro nop() {
+	LR = LR;
+}
+
+macro trap() {
+<trap_loop>
+	halt_trap();
+	goto <trap_loop>;
+}
+
+macro doBranch(br_target) {
+	nop();
+	popCallOther(&t0);
+	pushCallOther(&t0);
+	goto br_target;
+}
+
+################################################################
+
+## Locals directives at the start of the function
+:.locals is count; ctx_is_directive=1; ctx_directive_type=$(DIRECTIVE_LOCALS) {
+	nop();
+	funcEntryCallOther(&i0, &l0);
+}
+
+:.local "count="^count "type="^typeidx is count; typeidx; ctx_is_directive=1; ctx_directive_type=$(DIRECTIVE_LOCAL) {
+}
+
+## Control instructions
+:unreachable is opc=0x00; ctx_is_directive=0 {
+	trap();
+}
+
+:nop is opc=0x01; ctx_is_directive=0 {
+}
+
+:block "blocktype="^ULeb128 is opc=0x02; ULeb128; ctx_is_directive=0 {
+}
+:loop "blocktype="^ULeb128 is opc=0x03; ULeb128; ctx_is_directive=0 {
+}
+:if "blocktype="^ULeb128 is opc=0x04; ULeb128; br_target; sp1_32; ctx_is_directive=0 {
+	if(sp1_32 != 0) goto inst_next;
+	doBranch(br_target);
+}
+:else is opc=0x05; br_target; ctx_is_directive=0 {
+	doBranch(br_target);
+}
+
+:end is opc=0x0b; ctx_is_return=1; ctx_is_directive=0 {
+	nop();
+	callEpilogueCallOther(&o0);
+	return [LR];
+}
+:end is opc=0x0b; ctx_is_return=0; ctx_is_directive=0 {
+}
+
+:br br_target is opc=0x0c; ULeb128; br_target; ctx_is_directive=0 {
+	doBranch(br_target);
+}
+:br_if br_target is opc=0x0d; ULeb128; br_target; sp1_32; ctx_is_directive=0 {
+	if(sp1_32 == 0) goto inst_next;
+	doBranch(br_target);
+}
+
+:.case ctx_case_index br_target is ULeb128; br_target; ctx_case_index; ctx_is_directive=1; ctx_directive_type=$(DIRECTIVE_CASE) {
+	if(BRTableInput != ctx_case_index) goto inst_next;
+	doBranch(br_target);
+}
+
+:.default br_target is ULeb128; br_target; ctx_is_directive=1; ctx_directive_type=$(DIRECTIVE_DEFAULT) {
+	doBranch(br_target);
+}
+
+:br_table is opc=0x0e; ULeb128; sp1_32; ctx_is_directive=0 {
+	BRTableInput = sp1_32;
+}
+
+:return is opc=0x0f; ctx_is_directive=0 {
+	nop();
+	callEpilogueCallOther(&o0);
+	return [LR];
+}
+# note: anything following the call doesn't happen in emulation mode
+# the movement of outputs is handled by callEpilogueCallOther in emulation mode
+:call br_target is opc=0x10; ULeb128; br_target; ctx_is_directive=0 {
+	LR = inst_next;
+	callPrologueCallOther(&i0);
+	call br_target;
+	pushCallOther(&o0);
+}
+:call_indirect "type="^typeidx tableref is opc=0x11; typeidx; tableref; sp1_32; ctx_is_directive=0 {
+	addr:8 = &tableref + zext(sp1_32) * 4;
+	val:4 = *[table] addr;
+	LR = inst_next;
+	callPrologueCallOther(&i0);
+	call [val];
+	pushCallOther(&o0);
+}
+
+## Reference Instructions
+:ref.null valtype is opc=0xd0; valtype; sp0_32; ctx_is_directive=0 {
+	sp0_32 = 0;
+}
+:ref.is_null is opc=0xd1; sp1_32; ctx_is_directive=0 {
+	res:4 = zext(sp1_32 == 0);
+	sp1_32 = res;
+}
+:ref.func br_target is opc=0xd2; funcidx; br_target; sp0_32; ctx_is_directive=0 {
+	sp0_32 = &br_target;
+}
+
+## Parametric Instructions
+:drop is opc=0x1a; ctx_is_directive=0 {
+	# stack adjustment is handled by preanalyzer
+}
+
+macro select32(sp1_32, sp2_32, sp3_32) {
+	if (sp1_32 != 0) goto inst_next;
+	sp3_32 = sp2_32;
+}
+
+macro select64(sp1_32, sp2_64, sp3_64) {
+	if (sp1_32 != 0) goto inst_next;
+	sp3_64 = sp2_64;
+}
+
+macro select128(sp1_32, sp2_128, sp3_128) {
+	if (sp1_32 != 0) goto inst_next;
+	sp3_128 = sp2_128;
+}
+
+:select is opc=0x1b; sp1_32; sp2_32; sp3_32; ctx_is_directive=0; ctx_operand_size=4 {
+	select32(sp1_32, sp2_32, sp3_32);
+}
+:select is opc=0x1b; sp1_32; sp2_64; sp3_64; ctx_is_directive=0; ctx_operand_size=8 {
+	select64(sp1_32, sp2_64, sp3_64);
+}
+:select is opc=0x1b; sp1_32; sp2_128; sp3_128; ctx_is_directive=0; ctx_operand_size=16 {
+	select128(sp1_32, sp2_128, sp3_128);
+}
+
+# In the current version of Wasm, only one type index is permitted in select t*.
+# This is functionally identical to regular select.
+select_valtype: valtype is valtype; sp1_32; sp2_32; sp3_32 {
+	# i32, f32, funcref, externref
+	select32(sp1_32, sp2_32, sp3_32);
+}
+select_valtype: valtype is valtype & (bytev=0x7e | bytev=0x7c); sp1_32; sp2_64; sp3_64 {
+	# i64, f64
+	select64(sp1_32, sp2_64, sp3_64);
+}
+select_valtype: valtype is valtype & bytev=0x7b; sp1_32; sp2_128; sp3_128 {
+	# v128
+	select128(sp1_32, sp2_128, sp3_128);
+}
+
+# opc2_1 is used here to check that the LEB128 length of the type vector is 1.
+:select select_valtype is opc=0x1c; opc2_1; select_valtype; ctx_is_directive=0 {
+}
+
+## Variable Instructions
+:local.get local4 is opc=0x20; local4; sp0_32; ctx_is_directive=0; ctx_operand_size=4 {
+	sp0_32 = local4;
+}
+:local.get local8 is opc=0x20; local8; sp0_64; ctx_is_directive=0; ctx_operand_size=8 {
+	sp0_64 = local8;
+}
+:local.get local16 is opc=0x20; local16; sp0_128; ctx_is_directive=0; ctx_operand_size=16 {
+	sp0_128 = local16;
+}
+
+:local.set local4 is opc=0x21; local4; sp1_32; ctx_is_directive=0; ctx_operand_size=4 {
+	local4 = sp1_32;
+}
+:local.set local8 is opc=0x21; local8; sp1_64; ctx_is_directive=0; ctx_operand_size=8 {
+	local8 = sp1_64;
+}
+:local.set local16 is opc=0x21; local16; sp1_128; ctx_is_directive=0; ctx_operand_size=16 {
+	local16 = sp1_128;
+}
+
+:local.tee local4 is opc=0x22; local4; sp1_32; ctx_is_directive=0; ctx_operand_size=4 {
+	local4 = sp1_32;
+}
+:local.tee local8 is opc=0x22; local8; sp1_64; ctx_is_directive=0; ctx_operand_size=8 {
+	local8 = sp1_64;
+}
+:local.tee local16 is opc=0x22; local16; sp1_128; ctx_is_directive=0; ctx_operand_size=16 {
+	local16 = sp1_128;
+}
+
+:global.get global4 is opc=0x23; global4; sp0_32; ctx_is_directive=0; ctx_operand_size=4; ctx_is_global_sp=0 {
+	sp0_32 = global4;
+}
+:global.get global4 is opc=0x23; global4; sp0_32; ctx_is_directive=0; ctx_operand_size=4; ctx_is_global_sp=1 {
+	sp0_32 = SP;
+}
+:global.get global8 is opc=0x23; global8; sp0_64; ctx_is_directive=0; ctx_operand_size=8 {
+	sp0_64 = global8;
+}
+:global.get global16 is opc=0x23; global16; sp0_128; ctx_is_directive=0; ctx_operand_size=16 {
+	sp0_128 = global16;
+}
+
+:global.set global4 is opc=0x24; global4; sp1_32; ctx_is_directive=0; ctx_operand_size=4; ctx_is_global_sp=0 {
+	global4 = sp1_32;
+}
+:global.set global4 is opc=0x24; global4; sp1_32; ctx_is_directive=0; ctx_operand_size=4; ctx_is_global_sp=1 {
+	SP = sp1_32;
+}
+:global.set global8 is opc=0x24; global8; sp1_64; ctx_is_directive=0; ctx_operand_size=8 {
+	global8 = sp1_64;
+}
+:global.set global16 is opc=0x24; global16; sp1_128; ctx_is_directive=0; ctx_operand_size=16 {
+	global16 = sp1_128;
+}
+
+## Table Instructions
+:table.get tableref is opc=0x25; tableref; sp1_32; ctx_is_directive=0 {
+	addr:8 = &tableref + zext(sp1_32) * 4;
+	sp1_32 = *[table] addr;
+}
+
+:table.set tableref is opc=0x26; tableref; sp1_32; sp2_32; ctx_is_directive=0 {
+	addr:8 = &tableref + zext(sp2_32) * 4;
+	*[table] addr = sp1_32;
+}
+
+:table.init elemidx tableidx is opc=0xfc; opc2_12; elemidx; tableidx; sp1_32; sp2_32; sp3_32; ctx_is_directive=0 {
+	table_init(elemidx:4, tableidx:4, sp1_32, sp2_32, sp3_32);
+}
+
+:elem.drop elemidx is opc=0xfc; opc2_13; elemidx; ctx_is_directive=0 {
+	elem_drop(elemidx:4);
+}
+
+:table.copy tableidx tableidx2 is opc=0xfc; opc2_14; tableidx; tableidx2; sp1_32; sp2_32; sp3_32; ctx_is_directive=0 {
+	table_copy(tableidx:4, tableidx2:4, sp1_32, sp2_32, sp3_32);
+}
+
+:table.grow tableidx is opc=0xfc; opc2_15; tableidx; sp1_32; ctx_is_directive=0 {
+	sp1_32 = table_grow(tableidx:4, sp1_32);
+}
+
+:table.size tableidx is opc=0xfc; opc2_16; tableidx; sp0_32; ctx_is_directive=0 {
+	sp0_32 = table_size(tableidx:4);
+}
+
+:table.fill tableidx is opc=0xfc; opc2_17; tableidx; sp1_32; sp2_32; sp3_32; ctx_is_directive=0 {
+	table_fill(tableidx:4, sp1_32, sp2_32, sp3_32);
+}
+
+
+## Memory Instructions
+:memory.size memidx is opc=0x3f; memidx; sp0_32; ctx_is_directive=0 {
+	sp0_32 = memory_size(memidx:4);
+}
+
+:memory.grow memidx is opc=0x40; memidx; sp1_32; ctx_is_directive=0 {
+	sp1_32 = memory_grow(memidx:4, sp1_32);
+}
+
+:memory.init dataidx memidx is opc=0xfc; opc2_8; dataidx; memidx; sp1_32; sp2_32; sp3_32; ctx_is_directive=0 {
+	memory_init(dataidx, memidx:4, sp1_32, sp2_32, sp3_32);
+}
+
+:data.drop dataidx is opc=0xfc; opc2_9; dataidx; ctx_is_directive=0 {
+	data_drop(dataidx);
+}
+
+:memory.copy memidx memidx2 is opc=0xfc; opc2_10; memidx; memidx2; sp1_32; sp2_32; sp3_32; ctx_is_directive=0 {
+	memory_copy(memidx:4, memidx2:4, sp1_32, sp2_32, sp3_32);
+}
+
+:memory.fill memidx is opc=0xfc; opc2_11; memidx; sp1_32; sp2_32; sp3_32; ctx_is_directive=0 {
+	memory_fill(memidx:4, sp1_32, sp2_32, sp3_32);
+}
+
+## Numeric Instructions: const
+:i32.const SLeb128 is opc=0x41; SLeb128; sp0_32; ctx_is_directive=0 {
+	sp0_32 = SLeb128:4;
+}
+
+:i64.const SLeb128 is opc=0x42; SLeb128; sp0_64; ctx_is_directive=0 {
+	sp0_64 = SLeb128:8;
+}
+
+:f32.const f32 is opc=0x43; f32; sp0_32; ctx_is_directive=0 {
+	sp0_32 = f32:4;
+}
+
+:f64.const f64 is opc=0x44; f64; sp0_64; ctx_is_directive=0 {
+	sp0_64 = f64:8;
+}
+
+@include "BasicOps.sinc"
+@include "VectorOps.sinc"
diff --git a/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.slaspec b/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.slaspec
new file mode 100644
index 0000000000..6b745f5190
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/data/languages/WebAssembly.slaspec
@@ -0,0 +1,1923 @@
+# sleigh specification file for WebAssembly Processor
+
+## Constants
+# support 128-bit registers for SSE
+@define REG_SIZE 16
+# Base addresses for various register groups in the register space.
+# Keep these in sync with the cspec files!
+# function locals (lN)
+@define REG_LOCALS_BASE 0x10000000
+# function inputs (iN)
+@define REG_INPUTS_BASE 0x20000000
+# function outputs (oN)
+@define REG_OUTPUTS_BASE 0x30000000
+# temporary registers used to hold block arguments during branches (tN)
+@define REG_TEMP_BASE 0x40000000
+# Wasm stack within a function (sN)
+@define REG_STACK_BASE 0x50000000
+# shadow stack space used during emulation (ssN)
+@define REG_SSTACK_BASE 0x80000000
+
+
+define endian=little;
+define alignment=1;
+
+define space ram    type=ram_space      size=4 default;
+define space table   type=ram_space		 size=8;
+define space global  type=ram_space		 size=4;
+define space register type=register_space size=4;
+
+# PC is the program counter
+# SP is the C stack pointer if present
+# SSP is the shadow stack pointer for the ss* register block, only for emulation
+# LR is the return address register, only really used during emulation
+# BRTableInput is a temporary register used to hold the value for br_table
+define register offset=0 size=4 [ _  PC SP SSP LR BRTableInput];
+
+# Define context bits (if defined, size must be multiple of 4-bytes)
+define register offset=0x1000 size=16   contextreg;
+
+# Wasm stack within a function
+define register offset=$(REG_STACK_BASE) size=16 [
+      s0o   s1o   s2o   s3o   s4o   s5o   s6o   s7o
+      s8o   s9o  s10o  s11o  s12o  s13o  s14o  s15o
+     s16o  s17o  s18o  s19o  s20o  s21o  s22o  s23o
+     s24o  s25o  s26o  s27o  s28o  s29o  s30o  s31o
+     s32o  s33o  s34o  s35o  s36o  s37o  s38o  s39o
+     s40o  s41o  s42o  s43o  s44o  s45o  s46o  s47o
+     s48o  s49o  s50o  s51o  s52o  s53o  s54o  s55o
+     s56o  s57o  s58o  s59o  s60o  s61o  s62o  s63o
+     s64o  s65o  s66o  s67o  s68o  s69o  s70o  s71o
+     s72o  s73o  s74o  s75o  s76o  s77o  s78o  s79o
+     s80o  s81o  s82o  s83o  s84o  s85o  s86o  s87o
+     s88o  s89o  s90o  s91o  s92o  s93o  s94o  s95o
+     s96o  s97o  s98o  s99o s100o s101o s102o s103o
+    s104o s105o s106o s107o s108o s109o s110o s111o
+    s112o s113o s114o s115o s116o s117o s118o s119o
+    s120o s121o s122o s123o s124o s125o s126o s127o
+    s128o s129o s130o s131o s132o s133o s134o s135o
+    s136o s137o s138o s139o s140o s141o s142o s143o
+    s144o s145o s146o s147o s148o s149o s150o s151o
+    s152o s153o s154o s155o s156o s157o s158o s159o
+    s160o s161o s162o s163o s164o s165o s166o s167o
+    s168o s169o s170o s171o s172o s173o s174o s175o
+    s176o s177o s178o s179o s180o s181o s182o s183o
+    s184o s185o s186o s187o s188o s189o s190o s191o
+    s192o s193o s194o s195o s196o s197o s198o s199o
+    s200o s201o s202o s203o s204o s205o s206o s207o
+    s208o s209o s210o s211o s212o s213o s214o s215o
+    s216o s217o s218o s219o s220o s221o s222o s223o
+    s224o s225o s226o s227o s228o s229o s230o s231o
+    s232o s233o s234o s235o s236o s237o s238o s239o
+    s240o s241o s242o s243o s244o s245o s246o s247o
+    s248o s249o s250o s251o s252o s253o s254o s255o
+];
+define register offset=$(REG_STACK_BASE) size=8 [
+      s0q _   s1q _   s2q _   s3q _   s4q _   s5q _   s6q _   s7q _
+      s8q _   s9q _  s10q _  s11q _  s12q _  s13q _  s14q _  s15q _
+     s16q _  s17q _  s18q _  s19q _  s20q _  s21q _  s22q _  s23q _
+     s24q _  s25q _  s26q _  s27q _  s28q _  s29q _  s30q _  s31q _
+     s32q _  s33q _  s34q _  s35q _  s36q _  s37q _  s38q _  s39q _
+     s40q _  s41q _  s42q _  s43q _  s44q _  s45q _  s46q _  s47q _
+     s48q _  s49q _  s50q _  s51q _  s52q _  s53q _  s54q _  s55q _
+     s56q _  s57q _  s58q _  s59q _  s60q _  s61q _  s62q _  s63q _
+     s64q _  s65q _  s66q _  s67q _  s68q _  s69q _  s70q _  s71q _
+     s72q _  s73q _  s74q _  s75q _  s76q _  s77q _  s78q _  s79q _
+     s80q _  s81q _  s82q _  s83q _  s84q _  s85q _  s86q _  s87q _
+     s88q _  s89q _  s90q _  s91q _  s92q _  s93q _  s94q _  s95q _
+     s96q _  s97q _  s98q _  s99q _ s100q _ s101q _ s102q _ s103q _
+    s104q _ s105q _ s106q _ s107q _ s108q _ s109q _ s110q _ s111q _
+    s112q _ s113q _ s114q _ s115q _ s116q _ s117q _ s118q _ s119q _
+    s120q _ s121q _ s122q _ s123q _ s124q _ s125q _ s126q _ s127q _
+    s128q _ s129q _ s130q _ s131q _ s132q _ s133q _ s134q _ s135q _
+    s136q _ s137q _ s138q _ s139q _ s140q _ s141q _ s142q _ s143q _
+    s144q _ s145q _ s146q _ s147q _ s148q _ s149q _ s150q _ s151q _
+    s152q _ s153q _ s154q _ s155q _ s156q _ s157q _ s158q _ s159q _
+    s160q _ s161q _ s162q _ s163q _ s164q _ s165q _ s166q _ s167q _
+    s168q _ s169q _ s170q _ s171q _ s172q _ s173q _ s174q _ s175q _
+    s176q _ s177q _ s178q _ s179q _ s180q _ s181q _ s182q _ s183q _
+    s184q _ s185q _ s186q _ s187q _ s188q _ s189q _ s190q _ s191q _
+    s192q _ s193q _ s194q _ s195q _ s196q _ s197q _ s198q _ s199q _
+    s200q _ s201q _ s202q _ s203q _ s204q _ s205q _ s206q _ s207q _
+    s208q _ s209q _ s210q _ s211q _ s212q _ s213q _ s214q _ s215q _
+    s216q _ s217q _ s218q _ s219q _ s220q _ s221q _ s222q _ s223q _
+    s224q _ s225q _ s226q _ s227q _ s228q _ s229q _ s230q _ s231q _
+    s232q _ s233q _ s234q _ s235q _ s236q _ s237q _ s238q _ s239q _
+    s240q _ s241q _ s242q _ s243q _ s244q _ s245q _ s246q _ s247q _
+    s248q _ s249q _ s250q _ s251q _ s252q _ s253q _ s254q _ s255q _
+];
+define register offset=$(REG_STACK_BASE) size=4 [
+      s0 _ _ _   s1 _ _ _   s2 _ _ _   s3 _ _ _   s4 _ _ _   s5 _ _ _   s6 _ _ _   s7 _ _ _
+      s8 _ _ _   s9 _ _ _  s10 _ _ _  s11 _ _ _  s12 _ _ _  s13 _ _ _  s14 _ _ _  s15 _ _ _
+     s16 _ _ _  s17 _ _ _  s18 _ _ _  s19 _ _ _  s20 _ _ _  s21 _ _ _  s22 _ _ _  s23 _ _ _
+     s24 _ _ _  s25 _ _ _  s26 _ _ _  s27 _ _ _  s28 _ _ _  s29 _ _ _  s30 _ _ _  s31 _ _ _
+     s32 _ _ _  s33 _ _ _  s34 _ _ _  s35 _ _ _  s36 _ _ _  s37 _ _ _  s38 _ _ _  s39 _ _ _
+     s40 _ _ _  s41 _ _ _  s42 _ _ _  s43 _ _ _  s44 _ _ _  s45 _ _ _  s46 _ _ _  s47 _ _ _
+     s48 _ _ _  s49 _ _ _  s50 _ _ _  s51 _ _ _  s52 _ _ _  s53 _ _ _  s54 _ _ _  s55 _ _ _
+     s56 _ _ _  s57 _ _ _  s58 _ _ _  s59 _ _ _  s60 _ _ _  s61 _ _ _  s62 _ _ _  s63 _ _ _
+     s64 _ _ _  s65 _ _ _  s66 _ _ _  s67 _ _ _  s68 _ _ _  s69 _ _ _  s70 _ _ _  s71 _ _ _
+     s72 _ _ _  s73 _ _ _  s74 _ _ _  s75 _ _ _  s76 _ _ _  s77 _ _ _  s78 _ _ _  s79 _ _ _
+     s80 _ _ _  s81 _ _ _  s82 _ _ _  s83 _ _ _  s84 _ _ _  s85 _ _ _  s86 _ _ _  s87 _ _ _
+     s88 _ _ _  s89 _ _ _  s90 _ _ _  s91 _ _ _  s92 _ _ _  s93 _ _ _  s94 _ _ _  s95 _ _ _
+     s96 _ _ _  s97 _ _ _  s98 _ _ _  s99 _ _ _ s100 _ _ _ s101 _ _ _ s102 _ _ _ s103 _ _ _
+    s104 _ _ _ s105 _ _ _ s106 _ _ _ s107 _ _ _ s108 _ _ _ s109 _ _ _ s110 _ _ _ s111 _ _ _
+    s112 _ _ _ s113 _ _ _ s114 _ _ _ s115 _ _ _ s116 _ _ _ s117 _ _ _ s118 _ _ _ s119 _ _ _
+    s120 _ _ _ s121 _ _ _ s122 _ _ _ s123 _ _ _ s124 _ _ _ s125 _ _ _ s126 _ _ _ s127 _ _ _
+    s128 _ _ _ s129 _ _ _ s130 _ _ _ s131 _ _ _ s132 _ _ _ s133 _ _ _ s134 _ _ _ s135 _ _ _
+    s136 _ _ _ s137 _ _ _ s138 _ _ _ s139 _ _ _ s140 _ _ _ s141 _ _ _ s142 _ _ _ s143 _ _ _
+    s144 _ _ _ s145 _ _ _ s146 _ _ _ s147 _ _ _ s148 _ _ _ s149 _ _ _ s150 _ _ _ s151 _ _ _
+    s152 _ _ _ s153 _ _ _ s154 _ _ _ s155 _ _ _ s156 _ _ _ s157 _ _ _ s158 _ _ _ s159 _ _ _
+    s160 _ _ _ s161 _ _ _ s162 _ _ _ s163 _ _ _ s164 _ _ _ s165 _ _ _ s166 _ _ _ s167 _ _ _
+    s168 _ _ _ s169 _ _ _ s170 _ _ _ s171 _ _ _ s172 _ _ _ s173 _ _ _ s174 _ _ _ s175 _ _ _
+    s176 _ _ _ s177 _ _ _ s178 _ _ _ s179 _ _ _ s180 _ _ _ s181 _ _ _ s182 _ _ _ s183 _ _ _
+    s184 _ _ _ s185 _ _ _ s186 _ _ _ s187 _ _ _ s188 _ _ _ s189 _ _ _ s190 _ _ _ s191 _ _ _
+    s192 _ _ _ s193 _ _ _ s194 _ _ _ s195 _ _ _ s196 _ _ _ s197 _ _ _ s198 _ _ _ s199 _ _ _
+    s200 _ _ _ s201 _ _ _ s202 _ _ _ s203 _ _ _ s204 _ _ _ s205 _ _ _ s206 _ _ _ s207 _ _ _
+    s208 _ _ _ s209 _ _ _ s210 _ _ _ s211 _ _ _ s212 _ _ _ s213 _ _ _ s214 _ _ _ s215 _ _ _
+    s216 _ _ _ s217 _ _ _ s218 _ _ _ s219 _ _ _ s220 _ _ _ s221 _ _ _ s222 _ _ _ s223 _ _ _
+    s224 _ _ _ s225 _ _ _ s226 _ _ _ s227 _ _ _ s228 _ _ _ s229 _ _ _ s230 _ _ _ s231 _ _ _
+    s232 _ _ _ s233 _ _ _ s234 _ _ _ s235 _ _ _ s236 _ _ _ s237 _ _ _ s238 _ _ _ s239 _ _ _
+    s240 _ _ _ s241 _ _ _ s242 _ _ _ s243 _ _ _ s244 _ _ _ s245 _ _ _ s246 _ _ _ s247 _ _ _
+    s248 _ _ _ s249 _ _ _ s250 _ _ _ s251 _ _ _ s252 _ _ _ s253 _ _ _ s254 _ _ _ s255 _ _ _
+];
+
+# Locals within a function
+define register offset=$(REG_LOCALS_BASE) size=16 [
+       l0o    l1o    l2o    l3o    l4o    l5o    l6o    l7o
+       l8o    l9o   l10o   l11o   l12o   l13o   l14o   l15o
+      l16o   l17o   l18o   l19o   l20o   l21o   l22o   l23o
+      l24o   l25o   l26o   l27o   l28o   l29o   l30o   l31o
+      l32o   l33o   l34o   l35o   l36o   l37o   l38o   l39o
+      l40o   l41o   l42o   l43o   l44o   l45o   l46o   l47o
+      l48o   l49o   l50o   l51o   l52o   l53o   l54o   l55o
+      l56o   l57o   l58o   l59o   l60o   l61o   l62o   l63o
+      l64o   l65o   l66o   l67o   l68o   l69o   l70o   l71o
+      l72o   l73o   l74o   l75o   l76o   l77o   l78o   l79o
+      l80o   l81o   l82o   l83o   l84o   l85o   l86o   l87o
+      l88o   l89o   l90o   l91o   l92o   l93o   l94o   l95o
+      l96o   l97o   l98o   l99o  l100o  l101o  l102o  l103o
+     l104o  l105o  l106o  l107o  l108o  l109o  l110o  l111o
+     l112o  l113o  l114o  l115o  l116o  l117o  l118o  l119o
+     l120o  l121o  l122o  l123o  l124o  l125o  l126o  l127o
+     l128o  l129o  l130o  l131o  l132o  l133o  l134o  l135o
+     l136o  l137o  l138o  l139o  l140o  l141o  l142o  l143o
+     l144o  l145o  l146o  l147o  l148o  l149o  l150o  l151o
+     l152o  l153o  l154o  l155o  l156o  l157o  l158o  l159o
+     l160o  l161o  l162o  l163o  l164o  l165o  l166o  l167o
+     l168o  l169o  l170o  l171o  l172o  l173o  l174o  l175o
+     l176o  l177o  l178o  l179o  l180o  l181o  l182o  l183o
+     l184o  l185o  l186o  l187o  l188o  l189o  l190o  l191o
+     l192o  l193o  l194o  l195o  l196o  l197o  l198o  l199o
+     l200o  l201o  l202o  l203o  l204o  l205o  l206o  l207o
+     l208o  l209o  l210o  l211o  l212o  l213o  l214o  l215o
+     l216o  l217o  l218o  l219o  l220o  l221o  l222o  l223o
+     l224o  l225o  l226o  l227o  l228o  l229o  l230o  l231o
+     l232o  l233o  l234o  l235o  l236o  l237o  l238o  l239o
+     l240o  l241o  l242o  l243o  l244o  l245o  l246o  l247o
+     l248o  l249o  l250o  l251o  l252o  l253o  l254o  l255o
+     l256o  l257o  l258o  l259o  l260o  l261o  l262o  l263o
+     l264o  l265o  l266o  l267o  l268o  l269o  l270o  l271o
+     l272o  l273o  l274o  l275o  l276o  l277o  l278o  l279o
+     l280o  l281o  l282o  l283o  l284o  l285o  l286o  l287o
+     l288o  l289o  l290o  l291o  l292o  l293o  l294o  l295o
+     l296o  l297o  l298o  l299o  l300o  l301o  l302o  l303o
+     l304o  l305o  l306o  l307o  l308o  l309o  l310o  l311o
+     l312o  l313o  l314o  l315o  l316o  l317o  l318o  l319o
+     l320o  l321o  l322o  l323o  l324o  l325o  l326o  l327o
+     l328o  l329o  l330o  l331o  l332o  l333o  l334o  l335o
+     l336o  l337o  l338o  l339o  l340o  l341o  l342o  l343o
+     l344o  l345o  l346o  l347o  l348o  l349o  l350o  l351o
+     l352o  l353o  l354o  l355o  l356o  l357o  l358o  l359o
+     l360o  l361o  l362o  l363o  l364o  l365o  l366o  l367o
+     l368o  l369o  l370o  l371o  l372o  l373o  l374o  l375o
+     l376o  l377o  l378o  l379o  l380o  l381o  l382o  l383o
+     l384o  l385o  l386o  l387o  l388o  l389o  l390o  l391o
+     l392o  l393o  l394o  l395o  l396o  l397o  l398o  l399o
+     l400o  l401o  l402o  l403o  l404o  l405o  l406o  l407o
+     l408o  l409o  l410o  l411o  l412o  l413o  l414o  l415o
+     l416o  l417o  l418o  l419o  l420o  l421o  l422o  l423o
+     l424o  l425o  l426o  l427o  l428o  l429o  l430o  l431o
+     l432o  l433o  l434o  l435o  l436o  l437o  l438o  l439o
+     l440o  l441o  l442o  l443o  l444o  l445o  l446o  l447o
+     l448o  l449o  l450o  l451o  l452o  l453o  l454o  l455o
+     l456o  l457o  l458o  l459o  l460o  l461o  l462o  l463o
+     l464o  l465o  l466o  l467o  l468o  l469o  l470o  l471o
+     l472o  l473o  l474o  l475o  l476o  l477o  l478o  l479o
+     l480o  l481o  l482o  l483o  l484o  l485o  l486o  l487o
+     l488o  l489o  l490o  l491o  l492o  l493o  l494o  l495o
+     l496o  l497o  l498o  l499o  l500o  l501o  l502o  l503o
+     l504o  l505o  l506o  l507o  l508o  l509o  l510o  l511o
+     l512o  l513o  l514o  l515o  l516o  l517o  l518o  l519o
+     l520o  l521o  l522o  l523o  l524o  l525o  l526o  l527o
+     l528o  l529o  l530o  l531o  l532o  l533o  l534o  l535o
+     l536o  l537o  l538o  l539o  l540o  l541o  l542o  l543o
+     l544o  l545o  l546o  l547o  l548o  l549o  l550o  l551o
+     l552o  l553o  l554o  l555o  l556o  l557o  l558o  l559o
+     l560o  l561o  l562o  l563o  l564o  l565o  l566o  l567o
+     l568o  l569o  l570o  l571o  l572o  l573o  l574o  l575o
+     l576o  l577o  l578o  l579o  l580o  l581o  l582o  l583o
+     l584o  l585o  l586o  l587o  l588o  l589o  l590o  l591o
+     l592o  l593o  l594o  l595o  l596o  l597o  l598o  l599o
+     l600o  l601o  l602o  l603o  l604o  l605o  l606o  l607o
+     l608o  l609o  l610o  l611o  l612o  l613o  l614o  l615o
+     l616o  l617o  l618o  l619o  l620o  l621o  l622o  l623o
+     l624o  l625o  l626o  l627o  l628o  l629o  l630o  l631o
+     l632o  l633o  l634o  l635o  l636o  l637o  l638o  l639o
+     l640o  l641o  l642o  l643o  l644o  l645o  l646o  l647o
+     l648o  l649o  l650o  l651o  l652o  l653o  l654o  l655o
+     l656o  l657o  l658o  l659o  l660o  l661o  l662o  l663o
+     l664o  l665o  l666o  l667o  l668o  l669o  l670o  l671o
+     l672o  l673o  l674o  l675o  l676o  l677o  l678o  l679o
+     l680o  l681o  l682o  l683o  l684o  l685o  l686o  l687o
+     l688o  l689o  l690o  l691o  l692o  l693o  l694o  l695o
+     l696o  l697o  l698o  l699o  l700o  l701o  l702o  l703o
+     l704o  l705o  l706o  l707o  l708o  l709o  l710o  l711o
+     l712o  l713o  l714o  l715o  l716o  l717o  l718o  l719o
+     l720o  l721o  l722o  l723o  l724o  l725o  l726o  l727o
+     l728o  l729o  l730o  l731o  l732o  l733o  l734o  l735o
+     l736o  l737o  l738o  l739o  l740o  l741o  l742o  l743o
+     l744o  l745o  l746o  l747o  l748o  l749o  l750o  l751o
+     l752o  l753o  l754o  l755o  l756o  l757o  l758o  l759o
+     l760o  l761o  l762o  l763o  l764o  l765o  l766o  l767o
+     l768o  l769o  l770o  l771o  l772o  l773o  l774o  l775o
+     l776o  l777o  l778o  l779o  l780o  l781o  l782o  l783o
+     l784o  l785o  l786o  l787o  l788o  l789o  l790o  l791o
+     l792o  l793o  l794o  l795o  l796o  l797o  l798o  l799o
+     l800o  l801o  l802o  l803o  l804o  l805o  l806o  l807o
+     l808o  l809o  l810o  l811o  l812o  l813o  l814o  l815o
+     l816o  l817o  l818o  l819o  l820o  l821o  l822o  l823o
+     l824o  l825o  l826o  l827o  l828o  l829o  l830o  l831o
+     l832o  l833o  l834o  l835o  l836o  l837o  l838o  l839o
+     l840o  l841o  l842o  l843o  l844o  l845o  l846o  l847o
+     l848o  l849o  l850o  l851o  l852o  l853o  l854o  l855o
+     l856o  l857o  l858o  l859o  l860o  l861o  l862o  l863o
+     l864o  l865o  l866o  l867o  l868o  l869o  l870o  l871o
+     l872o  l873o  l874o  l875o  l876o  l877o  l878o  l879o
+     l880o  l881o  l882o  l883o  l884o  l885o  l886o  l887o
+     l888o  l889o  l890o  l891o  l892o  l893o  l894o  l895o
+     l896o  l897o  l898o  l899o  l900o  l901o  l902o  l903o
+     l904o  l905o  l906o  l907o  l908o  l909o  l910o  l911o
+     l912o  l913o  l914o  l915o  l916o  l917o  l918o  l919o
+     l920o  l921o  l922o  l923o  l924o  l925o  l926o  l927o
+     l928o  l929o  l930o  l931o  l932o  l933o  l934o  l935o
+     l936o  l937o  l938o  l939o  l940o  l941o  l942o  l943o
+     l944o  l945o  l946o  l947o  l948o  l949o  l950o  l951o
+     l952o  l953o  l954o  l955o  l956o  l957o  l958o  l959o
+     l960o  l961o  l962o  l963o  l964o  l965o  l966o  l967o
+     l968o  l969o  l970o  l971o  l972o  l973o  l974o  l975o
+     l976o  l977o  l978o  l979o  l980o  l981o  l982o  l983o
+     l984o  l985o  l986o  l987o  l988o  l989o  l990o  l991o
+     l992o  l993o  l994o  l995o  l996o  l997o  l998o  l999o
+    l1000o l1001o l1002o l1003o l1004o l1005o l1006o l1007o
+    l1008o l1009o l1010o l1011o l1012o l1013o l1014o l1015o
+    l1016o l1017o l1018o l1019o l1020o l1021o l1022o l1023o
+    l1024o l1025o l1026o l1027o l1028o l1029o l1030o l1031o
+    l1032o l1033o l1034o l1035o l1036o l1037o l1038o l1039o
+    l1040o l1041o l1042o l1043o l1044o l1045o l1046o l1047o
+    l1048o l1049o l1050o l1051o l1052o l1053o l1054o l1055o
+    l1056o l1057o l1058o l1059o l1060o l1061o l1062o l1063o
+    l1064o l1065o l1066o l1067o l1068o l1069o l1070o l1071o
+    l1072o l1073o l1074o l1075o l1076o l1077o l1078o l1079o
+    l1080o l1081o l1082o l1083o l1084o l1085o l1086o l1087o
+    l1088o l1089o l1090o l1091o l1092o l1093o l1094o l1095o
+    l1096o l1097o l1098o l1099o l1100o l1101o l1102o l1103o
+    l1104o l1105o l1106o l1107o l1108o l1109o l1110o l1111o
+    l1112o l1113o l1114o l1115o l1116o l1117o l1118o l1119o
+    l1120o l1121o l1122o l1123o l1124o l1125o l1126o l1127o
+    l1128o l1129o l1130o l1131o l1132o l1133o l1134o l1135o
+    l1136o l1137o l1138o l1139o l1140o l1141o l1142o l1143o
+    l1144o l1145o l1146o l1147o l1148o l1149o l1150o l1151o
+    l1152o l1153o l1154o l1155o l1156o l1157o l1158o l1159o
+    l1160o l1161o l1162o l1163o l1164o l1165o l1166o l1167o
+    l1168o l1169o l1170o l1171o l1172o l1173o l1174o l1175o
+    l1176o l1177o l1178o l1179o l1180o l1181o l1182o l1183o
+    l1184o l1185o l1186o l1187o l1188o l1189o l1190o l1191o
+    l1192o l1193o l1194o l1195o l1196o l1197o l1198o l1199o
+    l1200o l1201o l1202o l1203o l1204o l1205o l1206o l1207o
+    l1208o l1209o l1210o l1211o l1212o l1213o l1214o l1215o
+    l1216o l1217o l1218o l1219o l1220o l1221o l1222o l1223o
+    l1224o l1225o l1226o l1227o l1228o l1229o l1230o l1231o
+    l1232o l1233o l1234o l1235o l1236o l1237o l1238o l1239o
+    l1240o l1241o l1242o l1243o l1244o l1245o l1246o l1247o
+    l1248o l1249o l1250o l1251o l1252o l1253o l1254o l1255o
+    l1256o l1257o l1258o l1259o l1260o l1261o l1262o l1263o
+    l1264o l1265o l1266o l1267o l1268o l1269o l1270o l1271o
+    l1272o l1273o l1274o l1275o l1276o l1277o l1278o l1279o
+    l1280o l1281o l1282o l1283o l1284o l1285o l1286o l1287o
+    l1288o l1289o l1290o l1291o l1292o l1293o l1294o l1295o
+    l1296o l1297o l1298o l1299o l1300o l1301o l1302o l1303o
+    l1304o l1305o l1306o l1307o l1308o l1309o l1310o l1311o
+    l1312o l1313o l1314o l1315o l1316o l1317o l1318o l1319o
+    l1320o l1321o l1322o l1323o l1324o l1325o l1326o l1327o
+    l1328o l1329o l1330o l1331o l1332o l1333o l1334o l1335o
+    l1336o l1337o l1338o l1339o l1340o l1341o l1342o l1343o
+    l1344o l1345o l1346o l1347o l1348o l1349o l1350o l1351o
+    l1352o l1353o l1354o l1355o l1356o l1357o l1358o l1359o
+    l1360o l1361o l1362o l1363o l1364o l1365o l1366o l1367o
+    l1368o l1369o l1370o l1371o l1372o l1373o l1374o l1375o
+    l1376o l1377o l1378o l1379o l1380o l1381o l1382o l1383o
+    l1384o l1385o l1386o l1387o l1388o l1389o l1390o l1391o
+    l1392o l1393o l1394o l1395o l1396o l1397o l1398o l1399o
+    l1400o l1401o l1402o l1403o l1404o l1405o l1406o l1407o
+    l1408o l1409o l1410o l1411o l1412o l1413o l1414o l1415o
+    l1416o l1417o l1418o l1419o l1420o l1421o l1422o l1423o
+    l1424o l1425o l1426o l1427o l1428o l1429o l1430o l1431o
+    l1432o l1433o l1434o l1435o l1436o l1437o l1438o l1439o
+    l1440o l1441o l1442o l1443o l1444o l1445o l1446o l1447o
+    l1448o l1449o l1450o l1451o l1452o l1453o l1454o l1455o
+    l1456o l1457o l1458o l1459o l1460o l1461o l1462o l1463o
+    l1464o l1465o l1466o l1467o l1468o l1469o l1470o l1471o
+    l1472o l1473o l1474o l1475o l1476o l1477o l1478o l1479o
+    l1480o l1481o l1482o l1483o l1484o l1485o l1486o l1487o
+    l1488o l1489o l1490o l1491o l1492o l1493o l1494o l1495o
+    l1496o l1497o l1498o l1499o l1500o l1501o l1502o l1503o
+    l1504o l1505o l1506o l1507o l1508o l1509o l1510o l1511o
+    l1512o l1513o l1514o l1515o l1516o l1517o l1518o l1519o
+    l1520o l1521o l1522o l1523o l1524o l1525o l1526o l1527o
+    l1528o l1529o l1530o l1531o l1532o l1533o l1534o l1535o
+    l1536o l1537o l1538o l1539o l1540o l1541o l1542o l1543o
+    l1544o l1545o l1546o l1547o l1548o l1549o l1550o l1551o
+    l1552o l1553o l1554o l1555o l1556o l1557o l1558o l1559o
+    l1560o l1561o l1562o l1563o l1564o l1565o l1566o l1567o
+    l1568o l1569o l1570o l1571o l1572o l1573o l1574o l1575o
+    l1576o l1577o l1578o l1579o l1580o l1581o l1582o l1583o
+    l1584o l1585o l1586o l1587o l1588o l1589o l1590o l1591o
+    l1592o l1593o l1594o l1595o l1596o l1597o l1598o l1599o
+    l1600o l1601o l1602o l1603o l1604o l1605o l1606o l1607o
+    l1608o l1609o l1610o l1611o l1612o l1613o l1614o l1615o
+    l1616o l1617o l1618o l1619o l1620o l1621o l1622o l1623o
+    l1624o l1625o l1626o l1627o l1628o l1629o l1630o l1631o
+    l1632o l1633o l1634o l1635o l1636o l1637o l1638o l1639o
+    l1640o l1641o l1642o l1643o l1644o l1645o l1646o l1647o
+    l1648o l1649o l1650o l1651o l1652o l1653o l1654o l1655o
+    l1656o l1657o l1658o l1659o l1660o l1661o l1662o l1663o
+    l1664o l1665o l1666o l1667o l1668o l1669o l1670o l1671o
+    l1672o l1673o l1674o l1675o l1676o l1677o l1678o l1679o
+    l1680o l1681o l1682o l1683o l1684o l1685o l1686o l1687o
+    l1688o l1689o l1690o l1691o l1692o l1693o l1694o l1695o
+    l1696o l1697o l1698o l1699o l1700o l1701o l1702o l1703o
+    l1704o l1705o l1706o l1707o l1708o l1709o l1710o l1711o
+    l1712o l1713o l1714o l1715o l1716o l1717o l1718o l1719o
+    l1720o l1721o l1722o l1723o l1724o l1725o l1726o l1727o
+    l1728o l1729o l1730o l1731o l1732o l1733o l1734o l1735o
+    l1736o l1737o l1738o l1739o l1740o l1741o l1742o l1743o
+    l1744o l1745o l1746o l1747o l1748o l1749o l1750o l1751o
+    l1752o l1753o l1754o l1755o l1756o l1757o l1758o l1759o
+    l1760o l1761o l1762o l1763o l1764o l1765o l1766o l1767o
+    l1768o l1769o l1770o l1771o l1772o l1773o l1774o l1775o
+    l1776o l1777o l1778o l1779o l1780o l1781o l1782o l1783o
+    l1784o l1785o l1786o l1787o l1788o l1789o l1790o l1791o
+    l1792o l1793o l1794o l1795o l1796o l1797o l1798o l1799o
+    l1800o l1801o l1802o l1803o l1804o l1805o l1806o l1807o
+    l1808o l1809o l1810o l1811o l1812o l1813o l1814o l1815o
+    l1816o l1817o l1818o l1819o l1820o l1821o l1822o l1823o
+    l1824o l1825o l1826o l1827o l1828o l1829o l1830o l1831o
+    l1832o l1833o l1834o l1835o l1836o l1837o l1838o l1839o
+    l1840o l1841o l1842o l1843o l1844o l1845o l1846o l1847o
+    l1848o l1849o l1850o l1851o l1852o l1853o l1854o l1855o
+    l1856o l1857o l1858o l1859o l1860o l1861o l1862o l1863o
+    l1864o l1865o l1866o l1867o l1868o l1869o l1870o l1871o
+    l1872o l1873o l1874o l1875o l1876o l1877o l1878o l1879o
+    l1880o l1881o l1882o l1883o l1884o l1885o l1886o l1887o
+    l1888o l1889o l1890o l1891o l1892o l1893o l1894o l1895o
+    l1896o l1897o l1898o l1899o l1900o l1901o l1902o l1903o
+    l1904o l1905o l1906o l1907o l1908o l1909o l1910o l1911o
+    l1912o l1913o l1914o l1915o l1916o l1917o l1918o l1919o
+    l1920o l1921o l1922o l1923o l1924o l1925o l1926o l1927o
+    l1928o l1929o l1930o l1931o l1932o l1933o l1934o l1935o
+    l1936o l1937o l1938o l1939o l1940o l1941o l1942o l1943o
+    l1944o l1945o l1946o l1947o l1948o l1949o l1950o l1951o
+    l1952o l1953o l1954o l1955o l1956o l1957o l1958o l1959o
+    l1960o l1961o l1962o l1963o l1964o l1965o l1966o l1967o
+    l1968o l1969o l1970o l1971o l1972o l1973o l1974o l1975o
+    l1976o l1977o l1978o l1979o l1980o l1981o l1982o l1983o
+    l1984o l1985o l1986o l1987o l1988o l1989o l1990o l1991o
+    l1992o l1993o l1994o l1995o l1996o l1997o l1998o l1999o
+    l2000o l2001o l2002o l2003o l2004o l2005o l2006o l2007o
+    l2008o l2009o l2010o l2011o l2012o l2013o l2014o l2015o
+    l2016o l2017o l2018o l2019o l2020o l2021o l2022o l2023o
+    l2024o l2025o l2026o l2027o l2028o l2029o l2030o l2031o
+    l2032o l2033o l2034o l2035o l2036o l2037o l2038o l2039o
+    l2040o l2041o l2042o l2043o l2044o l2045o l2046o l2047o
+    l2048o l2049o l2050o l2051o l2052o l2053o l2054o l2055o
+    l2056o l2057o l2058o l2059o l2060o l2061o l2062o l2063o
+    l2064o l2065o l2066o l2067o l2068o l2069o l2070o l2071o
+    l2072o l2073o l2074o l2075o l2076o l2077o l2078o l2079o
+    l2080o l2081o l2082o l2083o l2084o l2085o l2086o l2087o
+    l2088o l2089o l2090o l2091o l2092o l2093o l2094o l2095o
+    l2096o l2097o l2098o l2099o l2100o l2101o l2102o l2103o
+    l2104o l2105o l2106o l2107o l2108o l2109o l2110o l2111o
+    l2112o l2113o l2114o l2115o l2116o l2117o l2118o l2119o
+    l2120o l2121o l2122o l2123o l2124o l2125o l2126o l2127o
+    l2128o l2129o l2130o l2131o l2132o l2133o l2134o l2135o
+    l2136o l2137o l2138o l2139o l2140o l2141o l2142o l2143o
+    l2144o l2145o l2146o l2147o l2148o l2149o l2150o l2151o
+    l2152o l2153o l2154o l2155o l2156o l2157o l2158o l2159o
+    l2160o l2161o l2162o l2163o l2164o l2165o l2166o l2167o
+    l2168o l2169o l2170o l2171o l2172o l2173o l2174o l2175o
+    l2176o l2177o l2178o l2179o l2180o l2181o l2182o l2183o
+    l2184o l2185o l2186o l2187o l2188o l2189o l2190o l2191o
+    l2192o l2193o l2194o l2195o l2196o l2197o l2198o l2199o
+    l2200o l2201o l2202o l2203o l2204o l2205o l2206o l2207o
+    l2208o l2209o l2210o l2211o l2212o l2213o l2214o l2215o
+    l2216o l2217o l2218o l2219o l2220o l2221o l2222o l2223o
+    l2224o l2225o l2226o l2227o l2228o l2229o l2230o l2231o
+    l2232o l2233o l2234o l2235o l2236o l2237o l2238o l2239o
+    l2240o l2241o l2242o l2243o l2244o l2245o l2246o l2247o
+    l2248o l2249o l2250o l2251o l2252o l2253o l2254o l2255o
+    l2256o l2257o l2258o l2259o l2260o l2261o l2262o l2263o
+    l2264o l2265o l2266o l2267o l2268o l2269o l2270o l2271o
+    l2272o l2273o l2274o l2275o l2276o l2277o l2278o l2279o
+    l2280o l2281o l2282o l2283o l2284o l2285o l2286o l2287o
+    l2288o l2289o l2290o l2291o l2292o l2293o l2294o l2295o
+    l2296o l2297o l2298o l2299o l2300o l2301o l2302o l2303o
+    l2304o l2305o l2306o l2307o l2308o l2309o l2310o l2311o
+    l2312o l2313o l2314o l2315o l2316o l2317o l2318o l2319o
+    l2320o l2321o l2322o l2323o l2324o l2325o l2326o l2327o
+    l2328o l2329o l2330o l2331o l2332o l2333o l2334o l2335o
+    l2336o l2337o l2338o l2339o l2340o l2341o l2342o l2343o
+    l2344o l2345o l2346o l2347o l2348o l2349o l2350o l2351o
+    l2352o l2353o l2354o l2355o l2356o l2357o l2358o l2359o
+    l2360o l2361o l2362o l2363o l2364o l2365o l2366o l2367o
+    l2368o l2369o l2370o l2371o l2372o l2373o l2374o l2375o
+    l2376o l2377o l2378o l2379o l2380o l2381o l2382o l2383o
+    l2384o l2385o l2386o l2387o l2388o l2389o l2390o l2391o
+    l2392o l2393o l2394o l2395o l2396o l2397o l2398o l2399o
+    l2400o l2401o l2402o l2403o l2404o l2405o l2406o l2407o
+    l2408o l2409o l2410o l2411o l2412o l2413o l2414o l2415o
+    l2416o l2417o l2418o l2419o l2420o l2421o l2422o l2423o
+    l2424o l2425o l2426o l2427o l2428o l2429o l2430o l2431o
+    l2432o l2433o l2434o l2435o l2436o l2437o l2438o l2439o
+    l2440o l2441o l2442o l2443o l2444o l2445o l2446o l2447o
+    l2448o l2449o l2450o l2451o l2452o l2453o l2454o l2455o
+    l2456o l2457o l2458o l2459o l2460o l2461o l2462o l2463o
+    l2464o l2465o l2466o l2467o l2468o l2469o l2470o l2471o
+    l2472o l2473o l2474o l2475o l2476o l2477o l2478o l2479o
+    l2480o l2481o l2482o l2483o l2484o l2485o l2486o l2487o
+    l2488o l2489o l2490o l2491o l2492o l2493o l2494o l2495o
+    l2496o l2497o l2498o l2499o l2500o l2501o l2502o l2503o
+    l2504o l2505o l2506o l2507o l2508o l2509o l2510o l2511o
+    l2512o l2513o l2514o l2515o l2516o l2517o l2518o l2519o
+    l2520o l2521o l2522o l2523o l2524o l2525o l2526o l2527o
+    l2528o l2529o l2530o l2531o l2532o l2533o l2534o l2535o
+    l2536o l2537o l2538o l2539o l2540o l2541o l2542o l2543o
+    l2544o l2545o l2546o l2547o l2548o l2549o l2550o l2551o
+    l2552o l2553o l2554o l2555o l2556o l2557o l2558o l2559o
+    l2560o l2561o l2562o l2563o l2564o l2565o l2566o l2567o
+    l2568o l2569o l2570o l2571o l2572o l2573o l2574o l2575o
+    l2576o l2577o l2578o l2579o l2580o l2581o l2582o l2583o
+    l2584o l2585o l2586o l2587o l2588o l2589o l2590o l2591o
+    l2592o l2593o l2594o l2595o l2596o l2597o l2598o l2599o
+    l2600o l2601o l2602o l2603o l2604o l2605o l2606o l2607o
+    l2608o l2609o l2610o l2611o l2612o l2613o l2614o l2615o
+    l2616o l2617o l2618o l2619o l2620o l2621o l2622o l2623o
+    l2624o l2625o l2626o l2627o l2628o l2629o l2630o l2631o
+    l2632o l2633o l2634o l2635o l2636o l2637o l2638o l2639o
+    l2640o l2641o l2642o l2643o l2644o l2645o l2646o l2647o
+    l2648o l2649o l2650o l2651o l2652o l2653o l2654o l2655o
+    l2656o l2657o l2658o l2659o l2660o l2661o l2662o l2663o
+    l2664o l2665o l2666o l2667o l2668o l2669o l2670o l2671o
+    l2672o l2673o l2674o l2675o l2676o l2677o l2678o l2679o
+    l2680o l2681o l2682o l2683o l2684o l2685o l2686o l2687o
+    l2688o l2689o l2690o l2691o l2692o l2693o l2694o l2695o
+    l2696o l2697o l2698o l2699o l2700o l2701o l2702o l2703o
+    l2704o l2705o l2706o l2707o l2708o l2709o l2710o l2711o
+    l2712o l2713o l2714o l2715o l2716o l2717o l2718o l2719o
+    l2720o l2721o l2722o l2723o l2724o l2725o l2726o l2727o
+    l2728o l2729o l2730o l2731o l2732o l2733o l2734o l2735o
+    l2736o l2737o l2738o l2739o l2740o l2741o l2742o l2743o
+    l2744o l2745o l2746o l2747o l2748o l2749o l2750o l2751o
+    l2752o l2753o l2754o l2755o l2756o l2757o l2758o l2759o
+    l2760o l2761o l2762o l2763o l2764o l2765o l2766o l2767o
+    l2768o l2769o l2770o l2771o l2772o l2773o l2774o l2775o
+    l2776o l2777o l2778o l2779o l2780o l2781o l2782o l2783o
+    l2784o l2785o l2786o l2787o l2788o l2789o l2790o l2791o
+    l2792o l2793o l2794o l2795o l2796o l2797o l2798o l2799o
+    l2800o l2801o l2802o l2803o l2804o l2805o l2806o l2807o
+    l2808o l2809o l2810o l2811o l2812o l2813o l2814o l2815o
+    l2816o l2817o l2818o l2819o l2820o l2821o l2822o l2823o
+    l2824o l2825o l2826o l2827o l2828o l2829o l2830o l2831o
+    l2832o l2833o l2834o l2835o l2836o l2837o l2838o l2839o
+    l2840o l2841o l2842o l2843o l2844o l2845o l2846o l2847o
+    l2848o l2849o l2850o l2851o l2852o l2853o l2854o l2855o
+    l2856o l2857o l2858o l2859o l2860o l2861o l2862o l2863o
+    l2864o l2865o l2866o l2867o l2868o l2869o l2870o l2871o
+    l2872o l2873o l2874o l2875o l2876o l2877o l2878o l2879o
+    l2880o l2881o l2882o l2883o l2884o l2885o l2886o l2887o
+    l2888o l2889o l2890o l2891o l2892o l2893o l2894o l2895o
+    l2896o l2897o l2898o l2899o l2900o l2901o l2902o l2903o
+    l2904o l2905o l2906o l2907o l2908o l2909o l2910o l2911o
+    l2912o l2913o l2914o l2915o l2916o l2917o l2918o l2919o
+    l2920o l2921o l2922o l2923o l2924o l2925o l2926o l2927o
+    l2928o l2929o l2930o l2931o l2932o l2933o l2934o l2935o
+    l2936o l2937o l2938o l2939o l2940o l2941o l2942o l2943o
+    l2944o l2945o l2946o l2947o l2948o l2949o l2950o l2951o
+    l2952o l2953o l2954o l2955o l2956o l2957o l2958o l2959o
+    l2960o l2961o l2962o l2963o l2964o l2965o l2966o l2967o
+    l2968o l2969o l2970o l2971o l2972o l2973o l2974o l2975o
+    l2976o l2977o l2978o l2979o l2980o l2981o l2982o l2983o
+    l2984o l2985o l2986o l2987o l2988o l2989o l2990o l2991o
+    l2992o l2993o l2994o l2995o l2996o l2997o l2998o l2999o
+    l3000o l3001o l3002o l3003o l3004o l3005o l3006o l3007o
+    l3008o l3009o l3010o l3011o l3012o l3013o l3014o l3015o
+    l3016o l3017o l3018o l3019o l3020o l3021o l3022o l3023o
+    l3024o l3025o l3026o l3027o l3028o l3029o l3030o l3031o
+    l3032o l3033o l3034o l3035o l3036o l3037o l3038o l3039o
+    l3040o l3041o l3042o l3043o l3044o l3045o l3046o l3047o
+    l3048o l3049o l3050o l3051o l3052o l3053o l3054o l3055o
+    l3056o l3057o l3058o l3059o l3060o l3061o l3062o l3063o
+    l3064o l3065o l3066o l3067o l3068o l3069o l3070o l3071o
+    l3072o l3073o l3074o l3075o l3076o l3077o l3078o l3079o
+    l3080o l3081o l3082o l3083o l3084o l3085o l3086o l3087o
+    l3088o l3089o l3090o l3091o l3092o l3093o l3094o l3095o
+    l3096o l3097o l3098o l3099o l3100o l3101o l3102o l3103o
+    l3104o l3105o l3106o l3107o l3108o l3109o l3110o l3111o
+    l3112o l3113o l3114o l3115o l3116o l3117o l3118o l3119o
+    l3120o l3121o l3122o l3123o l3124o l3125o l3126o l3127o
+    l3128o l3129o l3130o l3131o l3132o l3133o l3134o l3135o
+    l3136o l3137o l3138o l3139o l3140o l3141o l3142o l3143o
+    l3144o l3145o l3146o l3147o l3148o l3149o l3150o l3151o
+    l3152o l3153o l3154o l3155o l3156o l3157o l3158o l3159o
+    l3160o l3161o l3162o l3163o l3164o l3165o l3166o l3167o
+    l3168o l3169o l3170o l3171o l3172o l3173o l3174o l3175o
+    l3176o l3177o l3178o l3179o l3180o l3181o l3182o l3183o
+    l3184o l3185o l3186o l3187o l3188o l3189o l3190o l3191o
+    l3192o l3193o l3194o l3195o l3196o l3197o l3198o l3199o
+    l3200o l3201o l3202o l3203o l3204o l3205o l3206o l3207o
+    l3208o l3209o l3210o l3211o l3212o l3213o l3214o l3215o
+    l3216o l3217o l3218o l3219o l3220o l3221o l3222o l3223o
+    l3224o l3225o l3226o l3227o l3228o l3229o l3230o l3231o
+    l3232o l3233o l3234o l3235o l3236o l3237o l3238o l3239o
+    l3240o l3241o l3242o l3243o l3244o l3245o l3246o l3247o
+    l3248o l3249o l3250o l3251o l3252o l3253o l3254o l3255o
+    l3256o l3257o l3258o l3259o l3260o l3261o l3262o l3263o
+    l3264o l3265o l3266o l3267o l3268o l3269o l3270o l3271o
+    l3272o l3273o l3274o l3275o l3276o l3277o l3278o l3279o
+    l3280o l3281o l3282o l3283o l3284o l3285o l3286o l3287o
+    l3288o l3289o l3290o l3291o l3292o l3293o l3294o l3295o
+    l3296o l3297o l3298o l3299o l3300o l3301o l3302o l3303o
+    l3304o l3305o l3306o l3307o l3308o l3309o l3310o l3311o
+    l3312o l3313o l3314o l3315o l3316o l3317o l3318o l3319o
+    l3320o l3321o l3322o l3323o l3324o l3325o l3326o l3327o
+    l3328o l3329o l3330o l3331o l3332o l3333o l3334o l3335o
+    l3336o l3337o l3338o l3339o l3340o l3341o l3342o l3343o
+    l3344o l3345o l3346o l3347o l3348o l3349o l3350o l3351o
+    l3352o l3353o l3354o l3355o l3356o l3357o l3358o l3359o
+    l3360o l3361o l3362o l3363o l3364o l3365o l3366o l3367o
+    l3368o l3369o l3370o l3371o l3372o l3373o l3374o l3375o
+    l3376o l3377o l3378o l3379o l3380o l3381o l3382o l3383o
+    l3384o l3385o l3386o l3387o l3388o l3389o l3390o l3391o
+    l3392o l3393o l3394o l3395o l3396o l3397o l3398o l3399o
+    l3400o l3401o l3402o l3403o l3404o l3405o l3406o l3407o
+    l3408o l3409o l3410o l3411o l3412o l3413o l3414o l3415o
+    l3416o l3417o l3418o l3419o l3420o l3421o l3422o l3423o
+    l3424o l3425o l3426o l3427o l3428o l3429o l3430o l3431o
+    l3432o l3433o l3434o l3435o l3436o l3437o l3438o l3439o
+    l3440o l3441o l3442o l3443o l3444o l3445o l3446o l3447o
+    l3448o l3449o l3450o l3451o l3452o l3453o l3454o l3455o
+    l3456o l3457o l3458o l3459o l3460o l3461o l3462o l3463o
+    l3464o l3465o l3466o l3467o l3468o l3469o l3470o l3471o
+    l3472o l3473o l3474o l3475o l3476o l3477o l3478o l3479o
+    l3480o l3481o l3482o l3483o l3484o l3485o l3486o l3487o
+    l3488o l3489o l3490o l3491o l3492o l3493o l3494o l3495o
+    l3496o l3497o l3498o l3499o l3500o l3501o l3502o l3503o
+    l3504o l3505o l3506o l3507o l3508o l3509o l3510o l3511o
+    l3512o l3513o l3514o l3515o l3516o l3517o l3518o l3519o
+    l3520o l3521o l3522o l3523o l3524o l3525o l3526o l3527o
+    l3528o l3529o l3530o l3531o l3532o l3533o l3534o l3535o
+    l3536o l3537o l3538o l3539o l3540o l3541o l3542o l3543o
+    l3544o l3545o l3546o l3547o l3548o l3549o l3550o l3551o
+    l3552o l3553o l3554o l3555o l3556o l3557o l3558o l3559o
+    l3560o l3561o l3562o l3563o l3564o l3565o l3566o l3567o
+    l3568o l3569o l3570o l3571o l3572o l3573o l3574o l3575o
+    l3576o l3577o l3578o l3579o l3580o l3581o l3582o l3583o
+    l3584o l3585o l3586o l3587o l3588o l3589o l3590o l3591o
+    l3592o l3593o l3594o l3595o l3596o l3597o l3598o l3599o
+    l3600o l3601o l3602o l3603o l3604o l3605o l3606o l3607o
+    l3608o l3609o l3610o l3611o l3612o l3613o l3614o l3615o
+    l3616o l3617o l3618o l3619o l3620o l3621o l3622o l3623o
+    l3624o l3625o l3626o l3627o l3628o l3629o l3630o l3631o
+    l3632o l3633o l3634o l3635o l3636o l3637o l3638o l3639o
+    l3640o l3641o l3642o l3643o l3644o l3645o l3646o l3647o
+    l3648o l3649o l3650o l3651o l3652o l3653o l3654o l3655o
+    l3656o l3657o l3658o l3659o l3660o l3661o l3662o l3663o
+    l3664o l3665o l3666o l3667o l3668o l3669o l3670o l3671o
+    l3672o l3673o l3674o l3675o l3676o l3677o l3678o l3679o
+    l3680o l3681o l3682o l3683o l3684o l3685o l3686o l3687o
+    l3688o l3689o l3690o l3691o l3692o l3693o l3694o l3695o
+    l3696o l3697o l3698o l3699o l3700o l3701o l3702o l3703o
+    l3704o l3705o l3706o l3707o l3708o l3709o l3710o l3711o
+    l3712o l3713o l3714o l3715o l3716o l3717o l3718o l3719o
+    l3720o l3721o l3722o l3723o l3724o l3725o l3726o l3727o
+    l3728o l3729o l3730o l3731o l3732o l3733o l3734o l3735o
+    l3736o l3737o l3738o l3739o l3740o l3741o l3742o l3743o
+    l3744o l3745o l3746o l3747o l3748o l3749o l3750o l3751o
+    l3752o l3753o l3754o l3755o l3756o l3757o l3758o l3759o
+    l3760o l3761o l3762o l3763o l3764o l3765o l3766o l3767o
+    l3768o l3769o l3770o l3771o l3772o l3773o l3774o l3775o
+    l3776o l3777o l3778o l3779o l3780o l3781o l3782o l3783o
+    l3784o l3785o l3786o l3787o l3788o l3789o l3790o l3791o
+    l3792o l3793o l3794o l3795o l3796o l3797o l3798o l3799o
+    l3800o l3801o l3802o l3803o l3804o l3805o l3806o l3807o
+    l3808o l3809o l3810o l3811o l3812o l3813o l3814o l3815o
+    l3816o l3817o l3818o l3819o l3820o l3821o l3822o l3823o
+    l3824o l3825o l3826o l3827o l3828o l3829o l3830o l3831o
+    l3832o l3833o l3834o l3835o l3836o l3837o l3838o l3839o
+    l3840o l3841o l3842o l3843o l3844o l3845o l3846o l3847o
+    l3848o l3849o l3850o l3851o l3852o l3853o l3854o l3855o
+    l3856o l3857o l3858o l3859o l3860o l3861o l3862o l3863o
+    l3864o l3865o l3866o l3867o l3868o l3869o l3870o l3871o
+    l3872o l3873o l3874o l3875o l3876o l3877o l3878o l3879o
+    l3880o l3881o l3882o l3883o l3884o l3885o l3886o l3887o
+    l3888o l3889o l3890o l3891o l3892o l3893o l3894o l3895o
+    l3896o l3897o l3898o l3899o l3900o l3901o l3902o l3903o
+    l3904o l3905o l3906o l3907o l3908o l3909o l3910o l3911o
+    l3912o l3913o l3914o l3915o l3916o l3917o l3918o l3919o
+    l3920o l3921o l3922o l3923o l3924o l3925o l3926o l3927o
+    l3928o l3929o l3930o l3931o l3932o l3933o l3934o l3935o
+    l3936o l3937o l3938o l3939o l3940o l3941o l3942o l3943o
+    l3944o l3945o l3946o l3947o l3948o l3949o l3950o l3951o
+    l3952o l3953o l3954o l3955o l3956o l3957o l3958o l3959o
+    l3960o l3961o l3962o l3963o l3964o l3965o l3966o l3967o
+    l3968o l3969o l3970o l3971o l3972o l3973o l3974o l3975o
+    l3976o l3977o l3978o l3979o l3980o l3981o l3982o l3983o
+    l3984o l3985o l3986o l3987o l3988o l3989o l3990o l3991o
+    l3992o l3993o l3994o l3995o l3996o l3997o l3998o l3999o
+    l4000o l4001o l4002o l4003o l4004o l4005o l4006o l4007o
+    l4008o l4009o l4010o l4011o l4012o l4013o l4014o l4015o
+    l4016o l4017o l4018o l4019o l4020o l4021o l4022o l4023o
+    l4024o l4025o l4026o l4027o l4028o l4029o l4030o l4031o
+    l4032o l4033o l4034o l4035o l4036o l4037o l4038o l4039o
+    l4040o l4041o l4042o l4043o l4044o l4045o l4046o l4047o
+    l4048o l4049o l4050o l4051o l4052o l4053o l4054o l4055o
+    l4056o l4057o l4058o l4059o l4060o l4061o l4062o l4063o
+    l4064o l4065o l4066o l4067o l4068o l4069o l4070o l4071o
+    l4072o l4073o l4074o l4075o l4076o l4077o l4078o l4079o
+    l4080o l4081o l4082o l4083o l4084o l4085o l4086o l4087o
+    l4088o l4089o l4090o l4091o l4092o l4093o l4094o l4095o
+];
+define register offset=$(REG_LOCALS_BASE) size=8 [
+       l0q _    l1q _    l2q _    l3q _    l4q _    l5q _    l6q _    l7q _
+       l8q _    l9q _   l10q _   l11q _   l12q _   l13q _   l14q _   l15q _
+      l16q _   l17q _   l18q _   l19q _   l20q _   l21q _   l22q _   l23q _
+      l24q _   l25q _   l26q _   l27q _   l28q _   l29q _   l30q _   l31q _
+      l32q _   l33q _   l34q _   l35q _   l36q _   l37q _   l38q _   l39q _
+      l40q _   l41q _   l42q _   l43q _   l44q _   l45q _   l46q _   l47q _
+      l48q _   l49q _   l50q _   l51q _   l52q _   l53q _   l54q _   l55q _
+      l56q _   l57q _   l58q _   l59q _   l60q _   l61q _   l62q _   l63q _
+      l64q _   l65q _   l66q _   l67q _   l68q _   l69q _   l70q _   l71q _
+      l72q _   l73q _   l74q _   l75q _   l76q _   l77q _   l78q _   l79q _
+      l80q _   l81q _   l82q _   l83q _   l84q _   l85q _   l86q _   l87q _
+      l88q _   l89q _   l90q _   l91q _   l92q _   l93q _   l94q _   l95q _
+      l96q _   l97q _   l98q _   l99q _  l100q _  l101q _  l102q _  l103q _
+     l104q _  l105q _  l106q _  l107q _  l108q _  l109q _  l110q _  l111q _
+     l112q _  l113q _  l114q _  l115q _  l116q _  l117q _  l118q _  l119q _
+     l120q _  l121q _  l122q _  l123q _  l124q _  l125q _  l126q _  l127q _
+     l128q _  l129q _  l130q _  l131q _  l132q _  l133q _  l134q _  l135q _
+     l136q _  l137q _  l138q _  l139q _  l140q _  l141q _  l142q _  l143q _
+     l144q _  l145q _  l146q _  l147q _  l148q _  l149q _  l150q _  l151q _
+     l152q _  l153q _  l154q _  l155q _  l156q _  l157q _  l158q _  l159q _
+     l160q _  l161q _  l162q _  l163q _  l164q _  l165q _  l166q _  l167q _
+     l168q _  l169q _  l170q _  l171q _  l172q _  l173q _  l174q _  l175q _
+     l176q _  l177q _  l178q _  l179q _  l180q _  l181q _  l182q _  l183q _
+     l184q _  l185q _  l186q _  l187q _  l188q _  l189q _  l190q _  l191q _
+     l192q _  l193q _  l194q _  l195q _  l196q _  l197q _  l198q _  l199q _
+     l200q _  l201q _  l202q _  l203q _  l204q _  l205q _  l206q _  l207q _
+     l208q _  l209q _  l210q _  l211q _  l212q _  l213q _  l214q _  l215q _
+     l216q _  l217q _  l218q _  l219q _  l220q _  l221q _  l222q _  l223q _
+     l224q _  l225q _  l226q _  l227q _  l228q _  l229q _  l230q _  l231q _
+     l232q _  l233q _  l234q _  l235q _  l236q _  l237q _  l238q _  l239q _
+     l240q _  l241q _  l242q _  l243q _  l244q _  l245q _  l246q _  l247q _
+     l248q _  l249q _  l250q _  l251q _  l252q _  l253q _  l254q _  l255q _
+     l256q _  l257q _  l258q _  l259q _  l260q _  l261q _  l262q _  l263q _
+     l264q _  l265q _  l266q _  l267q _  l268q _  l269q _  l270q _  l271q _
+     l272q _  l273q _  l274q _  l275q _  l276q _  l277q _  l278q _  l279q _
+     l280q _  l281q _  l282q _  l283q _  l284q _  l285q _  l286q _  l287q _
+     l288q _  l289q _  l290q _  l291q _  l292q _  l293q _  l294q _  l295q _
+     l296q _  l297q _  l298q _  l299q _  l300q _  l301q _  l302q _  l303q _
+     l304q _  l305q _  l306q _  l307q _  l308q _  l309q _  l310q _  l311q _
+     l312q _  l313q _  l314q _  l315q _  l316q _  l317q _  l318q _  l319q _
+     l320q _  l321q _  l322q _  l323q _  l324q _  l325q _  l326q _  l327q _
+     l328q _  l329q _  l330q _  l331q _  l332q _  l333q _  l334q _  l335q _
+     l336q _  l337q _  l338q _  l339q _  l340q _  l341q _  l342q _  l343q _
+     l344q _  l345q _  l346q _  l347q _  l348q _  l349q _  l350q _  l351q _
+     l352q _  l353q _  l354q _  l355q _  l356q _  l357q _  l358q _  l359q _
+     l360q _  l361q _  l362q _  l363q _  l364q _  l365q _  l366q _  l367q _
+     l368q _  l369q _  l370q _  l371q _  l372q _  l373q _  l374q _  l375q _
+     l376q _  l377q _  l378q _  l379q _  l380q _  l381q _  l382q _  l383q _
+     l384q _  l385q _  l386q _  l387q _  l388q _  l389q _  l390q _  l391q _
+     l392q _  l393q _  l394q _  l395q _  l396q _  l397q _  l398q _  l399q _
+     l400q _  l401q _  l402q _  l403q _  l404q _  l405q _  l406q _  l407q _
+     l408q _  l409q _  l410q _  l411q _  l412q _  l413q _  l414q _  l415q _
+     l416q _  l417q _  l418q _  l419q _  l420q _  l421q _  l422q _  l423q _
+     l424q _  l425q _  l426q _  l427q _  l428q _  l429q _  l430q _  l431q _
+     l432q _  l433q _  l434q _  l435q _  l436q _  l437q _  l438q _  l439q _
+     l440q _  l441q _  l442q _  l443q _  l444q _  l445q _  l446q _  l447q _
+     l448q _  l449q _  l450q _  l451q _  l452q _  l453q _  l454q _  l455q _
+     l456q _  l457q _  l458q _  l459q _  l460q _  l461q _  l462q _  l463q _
+     l464q _  l465q _  l466q _  l467q _  l468q _  l469q _  l470q _  l471q _
+     l472q _  l473q _  l474q _  l475q _  l476q _  l477q _  l478q _  l479q _
+     l480q _  l481q _  l482q _  l483q _  l484q _  l485q _  l486q _  l487q _
+     l488q _  l489q _  l490q _  l491q _  l492q _  l493q _  l494q _  l495q _
+     l496q _  l497q _  l498q _  l499q _  l500q _  l501q _  l502q _  l503q _
+     l504q _  l505q _  l506q _  l507q _  l508q _  l509q _  l510q _  l511q _
+     l512q _  l513q _  l514q _  l515q _  l516q _  l517q _  l518q _  l519q _
+     l520q _  l521q _  l522q _  l523q _  l524q _  l525q _  l526q _  l527q _
+     l528q _  l529q _  l530q _  l531q _  l532q _  l533q _  l534q _  l535q _
+     l536q _  l537q _  l538q _  l539q _  l540q _  l541q _  l542q _  l543q _
+     l544q _  l545q _  l546q _  l547q _  l548q _  l549q _  l550q _  l551q _
+     l552q _  l553q _  l554q _  l555q _  l556q _  l557q _  l558q _  l559q _
+     l560q _  l561q _  l562q _  l563q _  l564q _  l565q _  l566q _  l567q _
+     l568q _  l569q _  l570q _  l571q _  l572q _  l573q _  l574q _  l575q _
+     l576q _  l577q _  l578q _  l579q _  l580q _  l581q _  l582q _  l583q _
+     l584q _  l585q _  l586q _  l587q _  l588q _  l589q _  l590q _  l591q _
+     l592q _  l593q _  l594q _  l595q _  l596q _  l597q _  l598q _  l599q _
+     l600q _  l601q _  l602q _  l603q _  l604q _  l605q _  l606q _  l607q _
+     l608q _  l609q _  l610q _  l611q _  l612q _  l613q _  l614q _  l615q _
+     l616q _  l617q _  l618q _  l619q _  l620q _  l621q _  l622q _  l623q _
+     l624q _  l625q _  l626q _  l627q _  l628q _  l629q _  l630q _  l631q _
+     l632q _  l633q _  l634q _  l635q _  l636q _  l637q _  l638q _  l639q _
+     l640q _  l641q _  l642q _  l643q _  l644q _  l645q _  l646q _  l647q _
+     l648q _  l649q _  l650q _  l651q _  l652q _  l653q _  l654q _  l655q _
+     l656q _  l657q _  l658q _  l659q _  l660q _  l661q _  l662q _  l663q _
+     l664q _  l665q _  l666q _  l667q _  l668q _  l669q _  l670q _  l671q _
+     l672q _  l673q _  l674q _  l675q _  l676q _  l677q _  l678q _  l679q _
+     l680q _  l681q _  l682q _  l683q _  l684q _  l685q _  l686q _  l687q _
+     l688q _  l689q _  l690q _  l691q _  l692q _  l693q _  l694q _  l695q _
+     l696q _  l697q _  l698q _  l699q _  l700q _  l701q _  l702q _  l703q _
+     l704q _  l705q _  l706q _  l707q _  l708q _  l709q _  l710q _  l711q _
+     l712q _  l713q _  l714q _  l715q _  l716q _  l717q _  l718q _  l719q _
+     l720q _  l721q _  l722q _  l723q _  l724q _  l725q _  l726q _  l727q _
+     l728q _  l729q _  l730q _  l731q _  l732q _  l733q _  l734q _  l735q _
+     l736q _  l737q _  l738q _  l739q _  l740q _  l741q _  l742q _  l743q _
+     l744q _  l745q _  l746q _  l747q _  l748q _  l749q _  l750q _  l751q _
+     l752q _  l753q _  l754q _  l755q _  l756q _  l757q _  l758q _  l759q _
+     l760q _  l761q _  l762q _  l763q _  l764q _  l765q _  l766q _  l767q _
+     l768q _  l769q _  l770q _  l771q _  l772q _  l773q _  l774q _  l775q _
+     l776q _  l777q _  l778q _  l779q _  l780q _  l781q _  l782q _  l783q _
+     l784q _  l785q _  l786q _  l787q _  l788q _  l789q _  l790q _  l791q _
+     l792q _  l793q _  l794q _  l795q _  l796q _  l797q _  l798q _  l799q _
+     l800q _  l801q _  l802q _  l803q _  l804q _  l805q _  l806q _  l807q _
+     l808q _  l809q _  l810q _  l811q _  l812q _  l813q _  l814q _  l815q _
+     l816q _  l817q _  l818q _  l819q _  l820q _  l821q _  l822q _  l823q _
+     l824q _  l825q _  l826q _  l827q _  l828q _  l829q _  l830q _  l831q _
+     l832q _  l833q _  l834q _  l835q _  l836q _  l837q _  l838q _  l839q _
+     l840q _  l841q _  l842q _  l843q _  l844q _  l845q _  l846q _  l847q _
+     l848q _  l849q _  l850q _  l851q _  l852q _  l853q _  l854q _  l855q _
+     l856q _  l857q _  l858q _  l859q _  l860q _  l861q _  l862q _  l863q _
+     l864q _  l865q _  l866q _  l867q _  l868q _  l869q _  l870q _  l871q _
+     l872q _  l873q _  l874q _  l875q _  l876q _  l877q _  l878q _  l879q _
+     l880q _  l881q _  l882q _  l883q _  l884q _  l885q _  l886q _  l887q _
+     l888q _  l889q _  l890q _  l891q _  l892q _  l893q _  l894q _  l895q _
+     l896q _  l897q _  l898q _  l899q _  l900q _  l901q _  l902q _  l903q _
+     l904q _  l905q _  l906q _  l907q _  l908q _  l909q _  l910q _  l911q _
+     l912q _  l913q _  l914q _  l915q _  l916q _  l917q _  l918q _  l919q _
+     l920q _  l921q _  l922q _  l923q _  l924q _  l925q _  l926q _  l927q _
+     l928q _  l929q _  l930q _  l931q _  l932q _  l933q _  l934q _  l935q _
+     l936q _  l937q _  l938q _  l939q _  l940q _  l941q _  l942q _  l943q _
+     l944q _  l945q _  l946q _  l947q _  l948q _  l949q _  l950q _  l951q _
+     l952q _  l953q _  l954q _  l955q _  l956q _  l957q _  l958q _  l959q _
+     l960q _  l961q _  l962q _  l963q _  l964q _  l965q _  l966q _  l967q _
+     l968q _  l969q _  l970q _  l971q _  l972q _  l973q _  l974q _  l975q _
+     l976q _  l977q _  l978q _  l979q _  l980q _  l981q _  l982q _  l983q _
+     l984q _  l985q _  l986q _  l987q _  l988q _  l989q _  l990q _  l991q _
+     l992q _  l993q _  l994q _  l995q _  l996q _  l997q _  l998q _  l999q _
+    l1000q _ l1001q _ l1002q _ l1003q _ l1004q _ l1005q _ l1006q _ l1007q _
+    l1008q _ l1009q _ l1010q _ l1011q _ l1012q _ l1013q _ l1014q _ l1015q _
+    l1016q _ l1017q _ l1018q _ l1019q _ l1020q _ l1021q _ l1022q _ l1023q _
+    l1024q _ l1025q _ l1026q _ l1027q _ l1028q _ l1029q _ l1030q _ l1031q _
+    l1032q _ l1033q _ l1034q _ l1035q _ l1036q _ l1037q _ l1038q _ l1039q _
+    l1040q _ l1041q _ l1042q _ l1043q _ l1044q _ l1045q _ l1046q _ l1047q _
+    l1048q _ l1049q _ l1050q _ l1051q _ l1052q _ l1053q _ l1054q _ l1055q _
+    l1056q _ l1057q _ l1058q _ l1059q _ l1060q _ l1061q _ l1062q _ l1063q _
+    l1064q _ l1065q _ l1066q _ l1067q _ l1068q _ l1069q _ l1070q _ l1071q _
+    l1072q _ l1073q _ l1074q _ l1075q _ l1076q _ l1077q _ l1078q _ l1079q _
+    l1080q _ l1081q _ l1082q _ l1083q _ l1084q _ l1085q _ l1086q _ l1087q _
+    l1088q _ l1089q _ l1090q _ l1091q _ l1092q _ l1093q _ l1094q _ l1095q _
+    l1096q _ l1097q _ l1098q _ l1099q _ l1100q _ l1101q _ l1102q _ l1103q _
+    l1104q _ l1105q _ l1106q _ l1107q _ l1108q _ l1109q _ l1110q _ l1111q _
+    l1112q _ l1113q _ l1114q _ l1115q _ l1116q _ l1117q _ l1118q _ l1119q _
+    l1120q _ l1121q _ l1122q _ l1123q _ l1124q _ l1125q _ l1126q _ l1127q _
+    l1128q _ l1129q _ l1130q _ l1131q _ l1132q _ l1133q _ l1134q _ l1135q _
+    l1136q _ l1137q _ l1138q _ l1139q _ l1140q _ l1141q _ l1142q _ l1143q _
+    l1144q _ l1145q _ l1146q _ l1147q _ l1148q _ l1149q _ l1150q _ l1151q _
+    l1152q _ l1153q _ l1154q _ l1155q _ l1156q _ l1157q _ l1158q _ l1159q _
+    l1160q _ l1161q _ l1162q _ l1163q _ l1164q _ l1165q _ l1166q _ l1167q _
+    l1168q _ l1169q _ l1170q _ l1171q _ l1172q _ l1173q _ l1174q _ l1175q _
+    l1176q _ l1177q _ l1178q _ l1179q _ l1180q _ l1181q _ l1182q _ l1183q _
+    l1184q _ l1185q _ l1186q _ l1187q _ l1188q _ l1189q _ l1190q _ l1191q _
+    l1192q _ l1193q _ l1194q _ l1195q _ l1196q _ l1197q _ l1198q _ l1199q _
+    l1200q _ l1201q _ l1202q _ l1203q _ l1204q _ l1205q _ l1206q _ l1207q _
+    l1208q _ l1209q _ l1210q _ l1211q _ l1212q _ l1213q _ l1214q _ l1215q _
+    l1216q _ l1217q _ l1218q _ l1219q _ l1220q _ l1221q _ l1222q _ l1223q _
+    l1224q _ l1225q _ l1226q _ l1227q _ l1228q _ l1229q _ l1230q _ l1231q _
+    l1232q _ l1233q _ l1234q _ l1235q _ l1236q _ l1237q _ l1238q _ l1239q _
+    l1240q _ l1241q _ l1242q _ l1243q _ l1244q _ l1245q _ l1246q _ l1247q _
+    l1248q _ l1249q _ l1250q _ l1251q _ l1252q _ l1253q _ l1254q _ l1255q _
+    l1256q _ l1257q _ l1258q _ l1259q _ l1260q _ l1261q _ l1262q _ l1263q _
+    l1264q _ l1265q _ l1266q _ l1267q _ l1268q _ l1269q _ l1270q _ l1271q _
+    l1272q _ l1273q _ l1274q _ l1275q _ l1276q _ l1277q _ l1278q _ l1279q _
+    l1280q _ l1281q _ l1282q _ l1283q _ l1284q _ l1285q _ l1286q _ l1287q _
+    l1288q _ l1289q _ l1290q _ l1291q _ l1292q _ l1293q _ l1294q _ l1295q _
+    l1296q _ l1297q _ l1298q _ l1299q _ l1300q _ l1301q _ l1302q _ l1303q _
+    l1304q _ l1305q _ l1306q _ l1307q _ l1308q _ l1309q _ l1310q _ l1311q _
+    l1312q _ l1313q _ l1314q _ l1315q _ l1316q _ l1317q _ l1318q _ l1319q _
+    l1320q _ l1321q _ l1322q _ l1323q _ l1324q _ l1325q _ l1326q _ l1327q _
+    l1328q _ l1329q _ l1330q _ l1331q _ l1332q _ l1333q _ l1334q _ l1335q _
+    l1336q _ l1337q _ l1338q _ l1339q _ l1340q _ l1341q _ l1342q _ l1343q _
+    l1344q _ l1345q _ l1346q _ l1347q _ l1348q _ l1349q _ l1350q _ l1351q _
+    l1352q _ l1353q _ l1354q _ l1355q _ l1356q _ l1357q _ l1358q _ l1359q _
+    l1360q _ l1361q _ l1362q _ l1363q _ l1364q _ l1365q _ l1366q _ l1367q _
+    l1368q _ l1369q _ l1370q _ l1371q _ l1372q _ l1373q _ l1374q _ l1375q _
+    l1376q _ l1377q _ l1378q _ l1379q _ l1380q _ l1381q _ l1382q _ l1383q _
+    l1384q _ l1385q _ l1386q _ l1387q _ l1388q _ l1389q _ l1390q _ l1391q _
+    l1392q _ l1393q _ l1394q _ l1395q _ l1396q _ l1397q _ l1398q _ l1399q _
+    l1400q _ l1401q _ l1402q _ l1403q _ l1404q _ l1405q _ l1406q _ l1407q _
+    l1408q _ l1409q _ l1410q _ l1411q _ l1412q _ l1413q _ l1414q _ l1415q _
+    l1416q _ l1417q _ l1418q _ l1419q _ l1420q _ l1421q _ l1422q _ l1423q _
+    l1424q _ l1425q _ l1426q _ l1427q _ l1428q _ l1429q _ l1430q _ l1431q _
+    l1432q _ l1433q _ l1434q _ l1435q _ l1436q _ l1437q _ l1438q _ l1439q _
+    l1440q _ l1441q _ l1442q _ l1443q _ l1444q _ l1445q _ l1446q _ l1447q _
+    l1448q _ l1449q _ l1450q _ l1451q _ l1452q _ l1453q _ l1454q _ l1455q _
+    l1456q _ l1457q _ l1458q _ l1459q _ l1460q _ l1461q _ l1462q _ l1463q _
+    l1464q _ l1465q _ l1466q _ l1467q _ l1468q _ l1469q _ l1470q _ l1471q _
+    l1472q _ l1473q _ l1474q _ l1475q _ l1476q _ l1477q _ l1478q _ l1479q _
+    l1480q _ l1481q _ l1482q _ l1483q _ l1484q _ l1485q _ l1486q _ l1487q _
+    l1488q _ l1489q _ l1490q _ l1491q _ l1492q _ l1493q _ l1494q _ l1495q _
+    l1496q _ l1497q _ l1498q _ l1499q _ l1500q _ l1501q _ l1502q _ l1503q _
+    l1504q _ l1505q _ l1506q _ l1507q _ l1508q _ l1509q _ l1510q _ l1511q _
+    l1512q _ l1513q _ l1514q _ l1515q _ l1516q _ l1517q _ l1518q _ l1519q _
+    l1520q _ l1521q _ l1522q _ l1523q _ l1524q _ l1525q _ l1526q _ l1527q _
+    l1528q _ l1529q _ l1530q _ l1531q _ l1532q _ l1533q _ l1534q _ l1535q _
+    l1536q _ l1537q _ l1538q _ l1539q _ l1540q _ l1541q _ l1542q _ l1543q _
+    l1544q _ l1545q _ l1546q _ l1547q _ l1548q _ l1549q _ l1550q _ l1551q _
+    l1552q _ l1553q _ l1554q _ l1555q _ l1556q _ l1557q _ l1558q _ l1559q _
+    l1560q _ l1561q _ l1562q _ l1563q _ l1564q _ l1565q _ l1566q _ l1567q _
+    l1568q _ l1569q _ l1570q _ l1571q _ l1572q _ l1573q _ l1574q _ l1575q _
+    l1576q _ l1577q _ l1578q _ l1579q _ l1580q _ l1581q _ l1582q _ l1583q _
+    l1584q _ l1585q _ l1586q _ l1587q _ l1588q _ l1589q _ l1590q _ l1591q _
+    l1592q _ l1593q _ l1594q _ l1595q _ l1596q _ l1597q _ l1598q _ l1599q _
+    l1600q _ l1601q _ l1602q _ l1603q _ l1604q _ l1605q _ l1606q _ l1607q _
+    l1608q _ l1609q _ l1610q _ l1611q _ l1612q _ l1613q _ l1614q _ l1615q _
+    l1616q _ l1617q _ l1618q _ l1619q _ l1620q _ l1621q _ l1622q _ l1623q _
+    l1624q _ l1625q _ l1626q _ l1627q _ l1628q _ l1629q _ l1630q _ l1631q _
+    l1632q _ l1633q _ l1634q _ l1635q _ l1636q _ l1637q _ l1638q _ l1639q _
+    l1640q _ l1641q _ l1642q _ l1643q _ l1644q _ l1645q _ l1646q _ l1647q _
+    l1648q _ l1649q _ l1650q _ l1651q _ l1652q _ l1653q _ l1654q _ l1655q _
+    l1656q _ l1657q _ l1658q _ l1659q _ l1660q _ l1661q _ l1662q _ l1663q _
+    l1664q _ l1665q _ l1666q _ l1667q _ l1668q _ l1669q _ l1670q _ l1671q _
+    l1672q _ l1673q _ l1674q _ l1675q _ l1676q _ l1677q _ l1678q _ l1679q _
+    l1680q _ l1681q _ l1682q _ l1683q _ l1684q _ l1685q _ l1686q _ l1687q _
+    l1688q _ l1689q _ l1690q _ l1691q _ l1692q _ l1693q _ l1694q _ l1695q _
+    l1696q _ l1697q _ l1698q _ l1699q _ l1700q _ l1701q _ l1702q _ l1703q _
+    l1704q _ l1705q _ l1706q _ l1707q _ l1708q _ l1709q _ l1710q _ l1711q _
+    l1712q _ l1713q _ l1714q _ l1715q _ l1716q _ l1717q _ l1718q _ l1719q _
+    l1720q _ l1721q _ l1722q _ l1723q _ l1724q _ l1725q _ l1726q _ l1727q _
+    l1728q _ l1729q _ l1730q _ l1731q _ l1732q _ l1733q _ l1734q _ l1735q _
+    l1736q _ l1737q _ l1738q _ l1739q _ l1740q _ l1741q _ l1742q _ l1743q _
+    l1744q _ l1745q _ l1746q _ l1747q _ l1748q _ l1749q _ l1750q _ l1751q _
+    l1752q _ l1753q _ l1754q _ l1755q _ l1756q _ l1757q _ l1758q _ l1759q _
+    l1760q _ l1761q _ l1762q _ l1763q _ l1764q _ l1765q _ l1766q _ l1767q _
+    l1768q _ l1769q _ l1770q _ l1771q _ l1772q _ l1773q _ l1774q _ l1775q _
+    l1776q _ l1777q _ l1778q _ l1779q _ l1780q _ l1781q _ l1782q _ l1783q _
+    l1784q _ l1785q _ l1786q _ l1787q _ l1788q _ l1789q _ l1790q _ l1791q _
+    l1792q _ l1793q _ l1794q _ l1795q _ l1796q _ l1797q _ l1798q _ l1799q _
+    l1800q _ l1801q _ l1802q _ l1803q _ l1804q _ l1805q _ l1806q _ l1807q _
+    l1808q _ l1809q _ l1810q _ l1811q _ l1812q _ l1813q _ l1814q _ l1815q _
+    l1816q _ l1817q _ l1818q _ l1819q _ l1820q _ l1821q _ l1822q _ l1823q _
+    l1824q _ l1825q _ l1826q _ l1827q _ l1828q _ l1829q _ l1830q _ l1831q _
+    l1832q _ l1833q _ l1834q _ l1835q _ l1836q _ l1837q _ l1838q _ l1839q _
+    l1840q _ l1841q _ l1842q _ l1843q _ l1844q _ l1845q _ l1846q _ l1847q _
+    l1848q _ l1849q _ l1850q _ l1851q _ l1852q _ l1853q _ l1854q _ l1855q _
+    l1856q _ l1857q _ l1858q _ l1859q _ l1860q _ l1861q _ l1862q _ l1863q _
+    l1864q _ l1865q _ l1866q _ l1867q _ l1868q _ l1869q _ l1870q _ l1871q _
+    l1872q _ l1873q _ l1874q _ l1875q _ l1876q _ l1877q _ l1878q _ l1879q _
+    l1880q _ l1881q _ l1882q _ l1883q _ l1884q _ l1885q _ l1886q _ l1887q _
+    l1888q _ l1889q _ l1890q _ l1891q _ l1892q _ l1893q _ l1894q _ l1895q _
+    l1896q _ l1897q _ l1898q _ l1899q _ l1900q _ l1901q _ l1902q _ l1903q _
+    l1904q _ l1905q _ l1906q _ l1907q _ l1908q _ l1909q _ l1910q _ l1911q _
+    l1912q _ l1913q _ l1914q _ l1915q _ l1916q _ l1917q _ l1918q _ l1919q _
+    l1920q _ l1921q _ l1922q _ l1923q _ l1924q _ l1925q _ l1926q _ l1927q _
+    l1928q _ l1929q _ l1930q _ l1931q _ l1932q _ l1933q _ l1934q _ l1935q _
+    l1936q _ l1937q _ l1938q _ l1939q _ l1940q _ l1941q _ l1942q _ l1943q _
+    l1944q _ l1945q _ l1946q _ l1947q _ l1948q _ l1949q _ l1950q _ l1951q _
+    l1952q _ l1953q _ l1954q _ l1955q _ l1956q _ l1957q _ l1958q _ l1959q _
+    l1960q _ l1961q _ l1962q _ l1963q _ l1964q _ l1965q _ l1966q _ l1967q _
+    l1968q _ l1969q _ l1970q _ l1971q _ l1972q _ l1973q _ l1974q _ l1975q _
+    l1976q _ l1977q _ l1978q _ l1979q _ l1980q _ l1981q _ l1982q _ l1983q _
+    l1984q _ l1985q _ l1986q _ l1987q _ l1988q _ l1989q _ l1990q _ l1991q _
+    l1992q _ l1993q _ l1994q _ l1995q _ l1996q _ l1997q _ l1998q _ l1999q _
+    l2000q _ l2001q _ l2002q _ l2003q _ l2004q _ l2005q _ l2006q _ l2007q _
+    l2008q _ l2009q _ l2010q _ l2011q _ l2012q _ l2013q _ l2014q _ l2015q _
+    l2016q _ l2017q _ l2018q _ l2019q _ l2020q _ l2021q _ l2022q _ l2023q _
+    l2024q _ l2025q _ l2026q _ l2027q _ l2028q _ l2029q _ l2030q _ l2031q _
+    l2032q _ l2033q _ l2034q _ l2035q _ l2036q _ l2037q _ l2038q _ l2039q _
+    l2040q _ l2041q _ l2042q _ l2043q _ l2044q _ l2045q _ l2046q _ l2047q _
+    l2048q _ l2049q _ l2050q _ l2051q _ l2052q _ l2053q _ l2054q _ l2055q _
+    l2056q _ l2057q _ l2058q _ l2059q _ l2060q _ l2061q _ l2062q _ l2063q _
+    l2064q _ l2065q _ l2066q _ l2067q _ l2068q _ l2069q _ l2070q _ l2071q _
+    l2072q _ l2073q _ l2074q _ l2075q _ l2076q _ l2077q _ l2078q _ l2079q _
+    l2080q _ l2081q _ l2082q _ l2083q _ l2084q _ l2085q _ l2086q _ l2087q _
+    l2088q _ l2089q _ l2090q _ l2091q _ l2092q _ l2093q _ l2094q _ l2095q _
+    l2096q _ l2097q _ l2098q _ l2099q _ l2100q _ l2101q _ l2102q _ l2103q _
+    l2104q _ l2105q _ l2106q _ l2107q _ l2108q _ l2109q _ l2110q _ l2111q _
+    l2112q _ l2113q _ l2114q _ l2115q _ l2116q _ l2117q _ l2118q _ l2119q _
+    l2120q _ l2121q _ l2122q _ l2123q _ l2124q _ l2125q _ l2126q _ l2127q _
+    l2128q _ l2129q _ l2130q _ l2131q _ l2132q _ l2133q _ l2134q _ l2135q _
+    l2136q _ l2137q _ l2138q _ l2139q _ l2140q _ l2141q _ l2142q _ l2143q _
+    l2144q _ l2145q _ l2146q _ l2147q _ l2148q _ l2149q _ l2150q _ l2151q _
+    l2152q _ l2153q _ l2154q _ l2155q _ l2156q _ l2157q _ l2158q _ l2159q _
+    l2160q _ l2161q _ l2162q _ l2163q _ l2164q _ l2165q _ l2166q _ l2167q _
+    l2168q _ l2169q _ l2170q _ l2171q _ l2172q _ l2173q _ l2174q _ l2175q _
+    l2176q _ l2177q _ l2178q _ l2179q _ l2180q _ l2181q _ l2182q _ l2183q _
+    l2184q _ l2185q _ l2186q _ l2187q _ l2188q _ l2189q _ l2190q _ l2191q _
+    l2192q _ l2193q _ l2194q _ l2195q _ l2196q _ l2197q _ l2198q _ l2199q _
+    l2200q _ l2201q _ l2202q _ l2203q _ l2204q _ l2205q _ l2206q _ l2207q _
+    l2208q _ l2209q _ l2210q _ l2211q _ l2212q _ l2213q _ l2214q _ l2215q _
+    l2216q _ l2217q _ l2218q _ l2219q _ l2220q _ l2221q _ l2222q _ l2223q _
+    l2224q _ l2225q _ l2226q _ l2227q _ l2228q _ l2229q _ l2230q _ l2231q _
+    l2232q _ l2233q _ l2234q _ l2235q _ l2236q _ l2237q _ l2238q _ l2239q _
+    l2240q _ l2241q _ l2242q _ l2243q _ l2244q _ l2245q _ l2246q _ l2247q _
+    l2248q _ l2249q _ l2250q _ l2251q _ l2252q _ l2253q _ l2254q _ l2255q _
+    l2256q _ l2257q _ l2258q _ l2259q _ l2260q _ l2261q _ l2262q _ l2263q _
+    l2264q _ l2265q _ l2266q _ l2267q _ l2268q _ l2269q _ l2270q _ l2271q _
+    l2272q _ l2273q _ l2274q _ l2275q _ l2276q _ l2277q _ l2278q _ l2279q _
+    l2280q _ l2281q _ l2282q _ l2283q _ l2284q _ l2285q _ l2286q _ l2287q _
+    l2288q _ l2289q _ l2290q _ l2291q _ l2292q _ l2293q _ l2294q _ l2295q _
+    l2296q _ l2297q _ l2298q _ l2299q _ l2300q _ l2301q _ l2302q _ l2303q _
+    l2304q _ l2305q _ l2306q _ l2307q _ l2308q _ l2309q _ l2310q _ l2311q _
+    l2312q _ l2313q _ l2314q _ l2315q _ l2316q _ l2317q _ l2318q _ l2319q _
+    l2320q _ l2321q _ l2322q _ l2323q _ l2324q _ l2325q _ l2326q _ l2327q _
+    l2328q _ l2329q _ l2330q _ l2331q _ l2332q _ l2333q _ l2334q _ l2335q _
+    l2336q _ l2337q _ l2338q _ l2339q _ l2340q _ l2341q _ l2342q _ l2343q _
+    l2344q _ l2345q _ l2346q _ l2347q _ l2348q _ l2349q _ l2350q _ l2351q _
+    l2352q _ l2353q _ l2354q _ l2355q _ l2356q _ l2357q _ l2358q _ l2359q _
+    l2360q _ l2361q _ l2362q _ l2363q _ l2364q _ l2365q _ l2366q _ l2367q _
+    l2368q _ l2369q _ l2370q _ l2371q _ l2372q _ l2373q _ l2374q _ l2375q _
+    l2376q _ l2377q _ l2378q _ l2379q _ l2380q _ l2381q _ l2382q _ l2383q _
+    l2384q _ l2385q _ l2386q _ l2387q _ l2388q _ l2389q _ l2390q _ l2391q _
+    l2392q _ l2393q _ l2394q _ l2395q _ l2396q _ l2397q _ l2398q _ l2399q _
+    l2400q _ l2401q _ l2402q _ l2403q _ l2404q _ l2405q _ l2406q _ l2407q _
+    l2408q _ l2409q _ l2410q _ l2411q _ l2412q _ l2413q _ l2414q _ l2415q _
+    l2416q _ l2417q _ l2418q _ l2419q _ l2420q _ l2421q _ l2422q _ l2423q _
+    l2424q _ l2425q _ l2426q _ l2427q _ l2428q _ l2429q _ l2430q _ l2431q _
+    l2432q _ l2433q _ l2434q _ l2435q _ l2436q _ l2437q _ l2438q _ l2439q _
+    l2440q _ l2441q _ l2442q _ l2443q _ l2444q _ l2445q _ l2446q _ l2447q _
+    l2448q _ l2449q _ l2450q _ l2451q _ l2452q _ l2453q _ l2454q _ l2455q _
+    l2456q _ l2457q _ l2458q _ l2459q _ l2460q _ l2461q _ l2462q _ l2463q _
+    l2464q _ l2465q _ l2466q _ l2467q _ l2468q _ l2469q _ l2470q _ l2471q _
+    l2472q _ l2473q _ l2474q _ l2475q _ l2476q _ l2477q _ l2478q _ l2479q _
+    l2480q _ l2481q _ l2482q _ l2483q _ l2484q _ l2485q _ l2486q _ l2487q _
+    l2488q _ l2489q _ l2490q _ l2491q _ l2492q _ l2493q _ l2494q _ l2495q _
+    l2496q _ l2497q _ l2498q _ l2499q _ l2500q _ l2501q _ l2502q _ l2503q _
+    l2504q _ l2505q _ l2506q _ l2507q _ l2508q _ l2509q _ l2510q _ l2511q _
+    l2512q _ l2513q _ l2514q _ l2515q _ l2516q _ l2517q _ l2518q _ l2519q _
+    l2520q _ l2521q _ l2522q _ l2523q _ l2524q _ l2525q _ l2526q _ l2527q _
+    l2528q _ l2529q _ l2530q _ l2531q _ l2532q _ l2533q _ l2534q _ l2535q _
+    l2536q _ l2537q _ l2538q _ l2539q _ l2540q _ l2541q _ l2542q _ l2543q _
+    l2544q _ l2545q _ l2546q _ l2547q _ l2548q _ l2549q _ l2550q _ l2551q _
+    l2552q _ l2553q _ l2554q _ l2555q _ l2556q _ l2557q _ l2558q _ l2559q _
+    l2560q _ l2561q _ l2562q _ l2563q _ l2564q _ l2565q _ l2566q _ l2567q _
+    l2568q _ l2569q _ l2570q _ l2571q _ l2572q _ l2573q _ l2574q _ l2575q _
+    l2576q _ l2577q _ l2578q _ l2579q _ l2580q _ l2581q _ l2582q _ l2583q _
+    l2584q _ l2585q _ l2586q _ l2587q _ l2588q _ l2589q _ l2590q _ l2591q _
+    l2592q _ l2593q _ l2594q _ l2595q _ l2596q _ l2597q _ l2598q _ l2599q _
+    l2600q _ l2601q _ l2602q _ l2603q _ l2604q _ l2605q _ l2606q _ l2607q _
+    l2608q _ l2609q _ l2610q _ l2611q _ l2612q _ l2613q _ l2614q _ l2615q _
+    l2616q _ l2617q _ l2618q _ l2619q _ l2620q _ l2621q _ l2622q _ l2623q _
+    l2624q _ l2625q _ l2626q _ l2627q _ l2628q _ l2629q _ l2630q _ l2631q _
+    l2632q _ l2633q _ l2634q _ l2635q _ l2636q _ l2637q _ l2638q _ l2639q _
+    l2640q _ l2641q _ l2642q _ l2643q _ l2644q _ l2645q _ l2646q _ l2647q _
+    l2648q _ l2649q _ l2650q _ l2651q _ l2652q _ l2653q _ l2654q _ l2655q _
+    l2656q _ l2657q _ l2658q _ l2659q _ l2660q _ l2661q _ l2662q _ l2663q _
+    l2664q _ l2665q _ l2666q _ l2667q _ l2668q _ l2669q _ l2670q _ l2671q _
+    l2672q _ l2673q _ l2674q _ l2675q _ l2676q _ l2677q _ l2678q _ l2679q _
+    l2680q _ l2681q _ l2682q _ l2683q _ l2684q _ l2685q _ l2686q _ l2687q _
+    l2688q _ l2689q _ l2690q _ l2691q _ l2692q _ l2693q _ l2694q _ l2695q _
+    l2696q _ l2697q _ l2698q _ l2699q _ l2700q _ l2701q _ l2702q _ l2703q _
+    l2704q _ l2705q _ l2706q _ l2707q _ l2708q _ l2709q _ l2710q _ l2711q _
+    l2712q _ l2713q _ l2714q _ l2715q _ l2716q _ l2717q _ l2718q _ l2719q _
+    l2720q _ l2721q _ l2722q _ l2723q _ l2724q _ l2725q _ l2726q _ l2727q _
+    l2728q _ l2729q _ l2730q _ l2731q _ l2732q _ l2733q _ l2734q _ l2735q _
+    l2736q _ l2737q _ l2738q _ l2739q _ l2740q _ l2741q _ l2742q _ l2743q _
+    l2744q _ l2745q _ l2746q _ l2747q _ l2748q _ l2749q _ l2750q _ l2751q _
+    l2752q _ l2753q _ l2754q _ l2755q _ l2756q _ l2757q _ l2758q _ l2759q _
+    l2760q _ l2761q _ l2762q _ l2763q _ l2764q _ l2765q _ l2766q _ l2767q _
+    l2768q _ l2769q _ l2770q _ l2771q _ l2772q _ l2773q _ l2774q _ l2775q _
+    l2776q _ l2777q _ l2778q _ l2779q _ l2780q _ l2781q _ l2782q _ l2783q _
+    l2784q _ l2785q _ l2786q _ l2787q _ l2788q _ l2789q _ l2790q _ l2791q _
+    l2792q _ l2793q _ l2794q _ l2795q _ l2796q _ l2797q _ l2798q _ l2799q _
+    l2800q _ l2801q _ l2802q _ l2803q _ l2804q _ l2805q _ l2806q _ l2807q _
+    l2808q _ l2809q _ l2810q _ l2811q _ l2812q _ l2813q _ l2814q _ l2815q _
+    l2816q _ l2817q _ l2818q _ l2819q _ l2820q _ l2821q _ l2822q _ l2823q _
+    l2824q _ l2825q _ l2826q _ l2827q _ l2828q _ l2829q _ l2830q _ l2831q _
+    l2832q _ l2833q _ l2834q _ l2835q _ l2836q _ l2837q _ l2838q _ l2839q _
+    l2840q _ l2841q _ l2842q _ l2843q _ l2844q _ l2845q _ l2846q _ l2847q _
+    l2848q _ l2849q _ l2850q _ l2851q _ l2852q _ l2853q _ l2854q _ l2855q _
+    l2856q _ l2857q _ l2858q _ l2859q _ l2860q _ l2861q _ l2862q _ l2863q _
+    l2864q _ l2865q _ l2866q _ l2867q _ l2868q _ l2869q _ l2870q _ l2871q _
+    l2872q _ l2873q _ l2874q _ l2875q _ l2876q _ l2877q _ l2878q _ l2879q _
+    l2880q _ l2881q _ l2882q _ l2883q _ l2884q _ l2885q _ l2886q _ l2887q _
+    l2888q _ l2889q _ l2890q _ l2891q _ l2892q _ l2893q _ l2894q _ l2895q _
+    l2896q _ l2897q _ l2898q _ l2899q _ l2900q _ l2901q _ l2902q _ l2903q _
+    l2904q _ l2905q _ l2906q _ l2907q _ l2908q _ l2909q _ l2910q _ l2911q _
+    l2912q _ l2913q _ l2914q _ l2915q _ l2916q _ l2917q _ l2918q _ l2919q _
+    l2920q _ l2921q _ l2922q _ l2923q _ l2924q _ l2925q _ l2926q _ l2927q _
+    l2928q _ l2929q _ l2930q _ l2931q _ l2932q _ l2933q _ l2934q _ l2935q _
+    l2936q _ l2937q _ l2938q _ l2939q _ l2940q _ l2941q _ l2942q _ l2943q _
+    l2944q _ l2945q _ l2946q _ l2947q _ l2948q _ l2949q _ l2950q _ l2951q _
+    l2952q _ l2953q _ l2954q _ l2955q _ l2956q _ l2957q _ l2958q _ l2959q _
+    l2960q _ l2961q _ l2962q _ l2963q _ l2964q _ l2965q _ l2966q _ l2967q _
+    l2968q _ l2969q _ l2970q _ l2971q _ l2972q _ l2973q _ l2974q _ l2975q _
+    l2976q _ l2977q _ l2978q _ l2979q _ l2980q _ l2981q _ l2982q _ l2983q _
+    l2984q _ l2985q _ l2986q _ l2987q _ l2988q _ l2989q _ l2990q _ l2991q _
+    l2992q _ l2993q _ l2994q _ l2995q _ l2996q _ l2997q _ l2998q _ l2999q _
+    l3000q _ l3001q _ l3002q _ l3003q _ l3004q _ l3005q _ l3006q _ l3007q _
+    l3008q _ l3009q _ l3010q _ l3011q _ l3012q _ l3013q _ l3014q _ l3015q _
+    l3016q _ l3017q _ l3018q _ l3019q _ l3020q _ l3021q _ l3022q _ l3023q _
+    l3024q _ l3025q _ l3026q _ l3027q _ l3028q _ l3029q _ l3030q _ l3031q _
+    l3032q _ l3033q _ l3034q _ l3035q _ l3036q _ l3037q _ l3038q _ l3039q _
+    l3040q _ l3041q _ l3042q _ l3043q _ l3044q _ l3045q _ l3046q _ l3047q _
+    l3048q _ l3049q _ l3050q _ l3051q _ l3052q _ l3053q _ l3054q _ l3055q _
+    l3056q _ l3057q _ l3058q _ l3059q _ l3060q _ l3061q _ l3062q _ l3063q _
+    l3064q _ l3065q _ l3066q _ l3067q _ l3068q _ l3069q _ l3070q _ l3071q _
+    l3072q _ l3073q _ l3074q _ l3075q _ l3076q _ l3077q _ l3078q _ l3079q _
+    l3080q _ l3081q _ l3082q _ l3083q _ l3084q _ l3085q _ l3086q _ l3087q _
+    l3088q _ l3089q _ l3090q _ l3091q _ l3092q _ l3093q _ l3094q _ l3095q _
+    l3096q _ l3097q _ l3098q _ l3099q _ l3100q _ l3101q _ l3102q _ l3103q _
+    l3104q _ l3105q _ l3106q _ l3107q _ l3108q _ l3109q _ l3110q _ l3111q _
+    l3112q _ l3113q _ l3114q _ l3115q _ l3116q _ l3117q _ l3118q _ l3119q _
+    l3120q _ l3121q _ l3122q _ l3123q _ l3124q _ l3125q _ l3126q _ l3127q _
+    l3128q _ l3129q _ l3130q _ l3131q _ l3132q _ l3133q _ l3134q _ l3135q _
+    l3136q _ l3137q _ l3138q _ l3139q _ l3140q _ l3141q _ l3142q _ l3143q _
+    l3144q _ l3145q _ l3146q _ l3147q _ l3148q _ l3149q _ l3150q _ l3151q _
+    l3152q _ l3153q _ l3154q _ l3155q _ l3156q _ l3157q _ l3158q _ l3159q _
+    l3160q _ l3161q _ l3162q _ l3163q _ l3164q _ l3165q _ l3166q _ l3167q _
+    l3168q _ l3169q _ l3170q _ l3171q _ l3172q _ l3173q _ l3174q _ l3175q _
+    l3176q _ l3177q _ l3178q _ l3179q _ l3180q _ l3181q _ l3182q _ l3183q _
+    l3184q _ l3185q _ l3186q _ l3187q _ l3188q _ l3189q _ l3190q _ l3191q _
+    l3192q _ l3193q _ l3194q _ l3195q _ l3196q _ l3197q _ l3198q _ l3199q _
+    l3200q _ l3201q _ l3202q _ l3203q _ l3204q _ l3205q _ l3206q _ l3207q _
+    l3208q _ l3209q _ l3210q _ l3211q _ l3212q _ l3213q _ l3214q _ l3215q _
+    l3216q _ l3217q _ l3218q _ l3219q _ l3220q _ l3221q _ l3222q _ l3223q _
+    l3224q _ l3225q _ l3226q _ l3227q _ l3228q _ l3229q _ l3230q _ l3231q _
+    l3232q _ l3233q _ l3234q _ l3235q _ l3236q _ l3237q _ l3238q _ l3239q _
+    l3240q _ l3241q _ l3242q _ l3243q _ l3244q _ l3245q _ l3246q _ l3247q _
+    l3248q _ l3249q _ l3250q _ l3251q _ l3252q _ l3253q _ l3254q _ l3255q _
+    l3256q _ l3257q _ l3258q _ l3259q _ l3260q _ l3261q _ l3262q _ l3263q _
+    l3264q _ l3265q _ l3266q _ l3267q _ l3268q _ l3269q _ l3270q _ l3271q _
+    l3272q _ l3273q _ l3274q _ l3275q _ l3276q _ l3277q _ l3278q _ l3279q _
+    l3280q _ l3281q _ l3282q _ l3283q _ l3284q _ l3285q _ l3286q _ l3287q _
+    l3288q _ l3289q _ l3290q _ l3291q _ l3292q _ l3293q _ l3294q _ l3295q _
+    l3296q _ l3297q _ l3298q _ l3299q _ l3300q _ l3301q _ l3302q _ l3303q _
+    l3304q _ l3305q _ l3306q _ l3307q _ l3308q _ l3309q _ l3310q _ l3311q _
+    l3312q _ l3313q _ l3314q _ l3315q _ l3316q _ l3317q _ l3318q _ l3319q _
+    l3320q _ l3321q _ l3322q _ l3323q _ l3324q _ l3325q _ l3326q _ l3327q _
+    l3328q _ l3329q _ l3330q _ l3331q _ l3332q _ l3333q _ l3334q _ l3335q _
+    l3336q _ l3337q _ l3338q _ l3339q _ l3340q _ l3341q _ l3342q _ l3343q _
+    l3344q _ l3345q _ l3346q _ l3347q _ l3348q _ l3349q _ l3350q _ l3351q _
+    l3352q _ l3353q _ l3354q _ l3355q _ l3356q _ l3357q _ l3358q _ l3359q _
+    l3360q _ l3361q _ l3362q _ l3363q _ l3364q _ l3365q _ l3366q _ l3367q _
+    l3368q _ l3369q _ l3370q _ l3371q _ l3372q _ l3373q _ l3374q _ l3375q _
+    l3376q _ l3377q _ l3378q _ l3379q _ l3380q _ l3381q _ l3382q _ l3383q _
+    l3384q _ l3385q _ l3386q _ l3387q _ l3388q _ l3389q _ l3390q _ l3391q _
+    l3392q _ l3393q _ l3394q _ l3395q _ l3396q _ l3397q _ l3398q _ l3399q _
+    l3400q _ l3401q _ l3402q _ l3403q _ l3404q _ l3405q _ l3406q _ l3407q _
+    l3408q _ l3409q _ l3410q _ l3411q _ l3412q _ l3413q _ l3414q _ l3415q _
+    l3416q _ l3417q _ l3418q _ l3419q _ l3420q _ l3421q _ l3422q _ l3423q _
+    l3424q _ l3425q _ l3426q _ l3427q _ l3428q _ l3429q _ l3430q _ l3431q _
+    l3432q _ l3433q _ l3434q _ l3435q _ l3436q _ l3437q _ l3438q _ l3439q _
+    l3440q _ l3441q _ l3442q _ l3443q _ l3444q _ l3445q _ l3446q _ l3447q _
+    l3448q _ l3449q _ l3450q _ l3451q _ l3452q _ l3453q _ l3454q _ l3455q _
+    l3456q _ l3457q _ l3458q _ l3459q _ l3460q _ l3461q _ l3462q _ l3463q _
+    l3464q _ l3465q _ l3466q _ l3467q _ l3468q _ l3469q _ l3470q _ l3471q _
+    l3472q _ l3473q _ l3474q _ l3475q _ l3476q _ l3477q _ l3478q _ l3479q _
+    l3480q _ l3481q _ l3482q _ l3483q _ l3484q _ l3485q _ l3486q _ l3487q _
+    l3488q _ l3489q _ l3490q _ l3491q _ l3492q _ l3493q _ l3494q _ l3495q _
+    l3496q _ l3497q _ l3498q _ l3499q _ l3500q _ l3501q _ l3502q _ l3503q _
+    l3504q _ l3505q _ l3506q _ l3507q _ l3508q _ l3509q _ l3510q _ l3511q _
+    l3512q _ l3513q _ l3514q _ l3515q _ l3516q _ l3517q _ l3518q _ l3519q _
+    l3520q _ l3521q _ l3522q _ l3523q _ l3524q _ l3525q _ l3526q _ l3527q _
+    l3528q _ l3529q _ l3530q _ l3531q _ l3532q _ l3533q _ l3534q _ l3535q _
+    l3536q _ l3537q _ l3538q _ l3539q _ l3540q _ l3541q _ l3542q _ l3543q _
+    l3544q _ l3545q _ l3546q _ l3547q _ l3548q _ l3549q _ l3550q _ l3551q _
+    l3552q _ l3553q _ l3554q _ l3555q _ l3556q _ l3557q _ l3558q _ l3559q _
+    l3560q _ l3561q _ l3562q _ l3563q _ l3564q _ l3565q _ l3566q _ l3567q _
+    l3568q _ l3569q _ l3570q _ l3571q _ l3572q _ l3573q _ l3574q _ l3575q _
+    l3576q _ l3577q _ l3578q _ l3579q _ l3580q _ l3581q _ l3582q _ l3583q _
+    l3584q _ l3585q _ l3586q _ l3587q _ l3588q _ l3589q _ l3590q _ l3591q _
+    l3592q _ l3593q _ l3594q _ l3595q _ l3596q _ l3597q _ l3598q _ l3599q _
+    l3600q _ l3601q _ l3602q _ l3603q _ l3604q _ l3605q _ l3606q _ l3607q _
+    l3608q _ l3609q _ l3610q _ l3611q _ l3612q _ l3613q _ l3614q _ l3615q _
+    l3616q _ l3617q _ l3618q _ l3619q _ l3620q _ l3621q _ l3622q _ l3623q _
+    l3624q _ l3625q _ l3626q _ l3627q _ l3628q _ l3629q _ l3630q _ l3631q _
+    l3632q _ l3633q _ l3634q _ l3635q _ l3636q _ l3637q _ l3638q _ l3639q _
+    l3640q _ l3641q _ l3642q _ l3643q _ l3644q _ l3645q _ l3646q _ l3647q _
+    l3648q _ l3649q _ l3650q _ l3651q _ l3652q _ l3653q _ l3654q _ l3655q _
+    l3656q _ l3657q _ l3658q _ l3659q _ l3660q _ l3661q _ l3662q _ l3663q _
+    l3664q _ l3665q _ l3666q _ l3667q _ l3668q _ l3669q _ l3670q _ l3671q _
+    l3672q _ l3673q _ l3674q _ l3675q _ l3676q _ l3677q _ l3678q _ l3679q _
+    l3680q _ l3681q _ l3682q _ l3683q _ l3684q _ l3685q _ l3686q _ l3687q _
+    l3688q _ l3689q _ l3690q _ l3691q _ l3692q _ l3693q _ l3694q _ l3695q _
+    l3696q _ l3697q _ l3698q _ l3699q _ l3700q _ l3701q _ l3702q _ l3703q _
+    l3704q _ l3705q _ l3706q _ l3707q _ l3708q _ l3709q _ l3710q _ l3711q _
+    l3712q _ l3713q _ l3714q _ l3715q _ l3716q _ l3717q _ l3718q _ l3719q _
+    l3720q _ l3721q _ l3722q _ l3723q _ l3724q _ l3725q _ l3726q _ l3727q _
+    l3728q _ l3729q _ l3730q _ l3731q _ l3732q _ l3733q _ l3734q _ l3735q _
+    l3736q _ l3737q _ l3738q _ l3739q _ l3740q _ l3741q _ l3742q _ l3743q _
+    l3744q _ l3745q _ l3746q _ l3747q _ l3748q _ l3749q _ l3750q _ l3751q _
+    l3752q _ l3753q _ l3754q _ l3755q _ l3756q _ l3757q _ l3758q _ l3759q _
+    l3760q _ l3761q _ l3762q _ l3763q _ l3764q _ l3765q _ l3766q _ l3767q _
+    l3768q _ l3769q _ l3770q _ l3771q _ l3772q _ l3773q _ l3774q _ l3775q _
+    l3776q _ l3777q _ l3778q _ l3779q _ l3780q _ l3781q _ l3782q _ l3783q _
+    l3784q _ l3785q _ l3786q _ l3787q _ l3788q _ l3789q _ l3790q _ l3791q _
+    l3792q _ l3793q _ l3794q _ l3795q _ l3796q _ l3797q _ l3798q _ l3799q _
+    l3800q _ l3801q _ l3802q _ l3803q _ l3804q _ l3805q _ l3806q _ l3807q _
+    l3808q _ l3809q _ l3810q _ l3811q _ l3812q _ l3813q _ l3814q _ l3815q _
+    l3816q _ l3817q _ l3818q _ l3819q _ l3820q _ l3821q _ l3822q _ l3823q _
+    l3824q _ l3825q _ l3826q _ l3827q _ l3828q _ l3829q _ l3830q _ l3831q _
+    l3832q _ l3833q _ l3834q _ l3835q _ l3836q _ l3837q _ l3838q _ l3839q _
+    l3840q _ l3841q _ l3842q _ l3843q _ l3844q _ l3845q _ l3846q _ l3847q _
+    l3848q _ l3849q _ l3850q _ l3851q _ l3852q _ l3853q _ l3854q _ l3855q _
+    l3856q _ l3857q _ l3858q _ l3859q _ l3860q _ l3861q _ l3862q _ l3863q _
+    l3864q _ l3865q _ l3866q _ l3867q _ l3868q _ l3869q _ l3870q _ l3871q _
+    l3872q _ l3873q _ l3874q _ l3875q _ l3876q _ l3877q _ l3878q _ l3879q _
+    l3880q _ l3881q _ l3882q _ l3883q _ l3884q _ l3885q _ l3886q _ l3887q _
+    l3888q _ l3889q _ l3890q _ l3891q _ l3892q _ l3893q _ l3894q _ l3895q _
+    l3896q _ l3897q _ l3898q _ l3899q _ l3900q _ l3901q _ l3902q _ l3903q _
+    l3904q _ l3905q _ l3906q _ l3907q _ l3908q _ l3909q _ l3910q _ l3911q _
+    l3912q _ l3913q _ l3914q _ l3915q _ l3916q _ l3917q _ l3918q _ l3919q _
+    l3920q _ l3921q _ l3922q _ l3923q _ l3924q _ l3925q _ l3926q _ l3927q _
+    l3928q _ l3929q _ l3930q _ l3931q _ l3932q _ l3933q _ l3934q _ l3935q _
+    l3936q _ l3937q _ l3938q _ l3939q _ l3940q _ l3941q _ l3942q _ l3943q _
+    l3944q _ l3945q _ l3946q _ l3947q _ l3948q _ l3949q _ l3950q _ l3951q _
+    l3952q _ l3953q _ l3954q _ l3955q _ l3956q _ l3957q _ l3958q _ l3959q _
+    l3960q _ l3961q _ l3962q _ l3963q _ l3964q _ l3965q _ l3966q _ l3967q _
+    l3968q _ l3969q _ l3970q _ l3971q _ l3972q _ l3973q _ l3974q _ l3975q _
+    l3976q _ l3977q _ l3978q _ l3979q _ l3980q _ l3981q _ l3982q _ l3983q _
+    l3984q _ l3985q _ l3986q _ l3987q _ l3988q _ l3989q _ l3990q _ l3991q _
+    l3992q _ l3993q _ l3994q _ l3995q _ l3996q _ l3997q _ l3998q _ l3999q _
+    l4000q _ l4001q _ l4002q _ l4003q _ l4004q _ l4005q _ l4006q _ l4007q _
+    l4008q _ l4009q _ l4010q _ l4011q _ l4012q _ l4013q _ l4014q _ l4015q _
+    l4016q _ l4017q _ l4018q _ l4019q _ l4020q _ l4021q _ l4022q _ l4023q _
+    l4024q _ l4025q _ l4026q _ l4027q _ l4028q _ l4029q _ l4030q _ l4031q _
+    l4032q _ l4033q _ l4034q _ l4035q _ l4036q _ l4037q _ l4038q _ l4039q _
+    l4040q _ l4041q _ l4042q _ l4043q _ l4044q _ l4045q _ l4046q _ l4047q _
+    l4048q _ l4049q _ l4050q _ l4051q _ l4052q _ l4053q _ l4054q _ l4055q _
+    l4056q _ l4057q _ l4058q _ l4059q _ l4060q _ l4061q _ l4062q _ l4063q _
+    l4064q _ l4065q _ l4066q _ l4067q _ l4068q _ l4069q _ l4070q _ l4071q _
+    l4072q _ l4073q _ l4074q _ l4075q _ l4076q _ l4077q _ l4078q _ l4079q _
+    l4080q _ l4081q _ l4082q _ l4083q _ l4084q _ l4085q _ l4086q _ l4087q _
+    l4088q _ l4089q _ l4090q _ l4091q _ l4092q _ l4093q _ l4094q _ l4095q _
+];
+define register offset=$(REG_LOCALS_BASE) size=4 [
+       l0 _ _ _    l1 _ _ _    l2 _ _ _    l3 _ _ _    l4 _ _ _    l5 _ _ _    l6 _ _ _    l7 _ _ _
+       l8 _ _ _    l9 _ _ _   l10 _ _ _   l11 _ _ _   l12 _ _ _   l13 _ _ _   l14 _ _ _   l15 _ _ _
+      l16 _ _ _   l17 _ _ _   l18 _ _ _   l19 _ _ _   l20 _ _ _   l21 _ _ _   l22 _ _ _   l23 _ _ _
+      l24 _ _ _   l25 _ _ _   l26 _ _ _   l27 _ _ _   l28 _ _ _   l29 _ _ _   l30 _ _ _   l31 _ _ _
+      l32 _ _ _   l33 _ _ _   l34 _ _ _   l35 _ _ _   l36 _ _ _   l37 _ _ _   l38 _ _ _   l39 _ _ _
+      l40 _ _ _   l41 _ _ _   l42 _ _ _   l43 _ _ _   l44 _ _ _   l45 _ _ _   l46 _ _ _   l47 _ _ _
+      l48 _ _ _   l49 _ _ _   l50 _ _ _   l51 _ _ _   l52 _ _ _   l53 _ _ _   l54 _ _ _   l55 _ _ _
+      l56 _ _ _   l57 _ _ _   l58 _ _ _   l59 _ _ _   l60 _ _ _   l61 _ _ _   l62 _ _ _   l63 _ _ _
+      l64 _ _ _   l65 _ _ _   l66 _ _ _   l67 _ _ _   l68 _ _ _   l69 _ _ _   l70 _ _ _   l71 _ _ _
+      l72 _ _ _   l73 _ _ _   l74 _ _ _   l75 _ _ _   l76 _ _ _   l77 _ _ _   l78 _ _ _   l79 _ _ _
+      l80 _ _ _   l81 _ _ _   l82 _ _ _   l83 _ _ _   l84 _ _ _   l85 _ _ _   l86 _ _ _   l87 _ _ _
+      l88 _ _ _   l89 _ _ _   l90 _ _ _   l91 _ _ _   l92 _ _ _   l93 _ _ _   l94 _ _ _   l95 _ _ _
+      l96 _ _ _   l97 _ _ _   l98 _ _ _   l99 _ _ _  l100 _ _ _  l101 _ _ _  l102 _ _ _  l103 _ _ _
+     l104 _ _ _  l105 _ _ _  l106 _ _ _  l107 _ _ _  l108 _ _ _  l109 _ _ _  l110 _ _ _  l111 _ _ _
+     l112 _ _ _  l113 _ _ _  l114 _ _ _  l115 _ _ _  l116 _ _ _  l117 _ _ _  l118 _ _ _  l119 _ _ _
+     l120 _ _ _  l121 _ _ _  l122 _ _ _  l123 _ _ _  l124 _ _ _  l125 _ _ _  l126 _ _ _  l127 _ _ _
+     l128 _ _ _  l129 _ _ _  l130 _ _ _  l131 _ _ _  l132 _ _ _  l133 _ _ _  l134 _ _ _  l135 _ _ _
+     l136 _ _ _  l137 _ _ _  l138 _ _ _  l139 _ _ _  l140 _ _ _  l141 _ _ _  l142 _ _ _  l143 _ _ _
+     l144 _ _ _  l145 _ _ _  l146 _ _ _  l147 _ _ _  l148 _ _ _  l149 _ _ _  l150 _ _ _  l151 _ _ _
+     l152 _ _ _  l153 _ _ _  l154 _ _ _  l155 _ _ _  l156 _ _ _  l157 _ _ _  l158 _ _ _  l159 _ _ _
+     l160 _ _ _  l161 _ _ _  l162 _ _ _  l163 _ _ _  l164 _ _ _  l165 _ _ _  l166 _ _ _  l167 _ _ _
+     l168 _ _ _  l169 _ _ _  l170 _ _ _  l171 _ _ _  l172 _ _ _  l173 _ _ _  l174 _ _ _  l175 _ _ _
+     l176 _ _ _  l177 _ _ _  l178 _ _ _  l179 _ _ _  l180 _ _ _  l181 _ _ _  l182 _ _ _  l183 _ _ _
+     l184 _ _ _  l185 _ _ _  l186 _ _ _  l187 _ _ _  l188 _ _ _  l189 _ _ _  l190 _ _ _  l191 _ _ _
+     l192 _ _ _  l193 _ _ _  l194 _ _ _  l195 _ _ _  l196 _ _ _  l197 _ _ _  l198 _ _ _  l199 _ _ _
+     l200 _ _ _  l201 _ _ _  l202 _ _ _  l203 _ _ _  l204 _ _ _  l205 _ _ _  l206 _ _ _  l207 _ _ _
+     l208 _ _ _  l209 _ _ _  l210 _ _ _  l211 _ _ _  l212 _ _ _  l213 _ _ _  l214 _ _ _  l215 _ _ _
+     l216 _ _ _  l217 _ _ _  l218 _ _ _  l219 _ _ _  l220 _ _ _  l221 _ _ _  l222 _ _ _  l223 _ _ _
+     l224 _ _ _  l225 _ _ _  l226 _ _ _  l227 _ _ _  l228 _ _ _  l229 _ _ _  l230 _ _ _  l231 _ _ _
+     l232 _ _ _  l233 _ _ _  l234 _ _ _  l235 _ _ _  l236 _ _ _  l237 _ _ _  l238 _ _ _  l239 _ _ _
+     l240 _ _ _  l241 _ _ _  l242 _ _ _  l243 _ _ _  l244 _ _ _  l245 _ _ _  l246 _ _ _  l247 _ _ _
+     l248 _ _ _  l249 _ _ _  l250 _ _ _  l251 _ _ _  l252 _ _ _  l253 _ _ _  l254 _ _ _  l255 _ _ _
+     l256 _ _ _  l257 _ _ _  l258 _ _ _  l259 _ _ _  l260 _ _ _  l261 _ _ _  l262 _ _ _  l263 _ _ _
+     l264 _ _ _  l265 _ _ _  l266 _ _ _  l267 _ _ _  l268 _ _ _  l269 _ _ _  l270 _ _ _  l271 _ _ _
+     l272 _ _ _  l273 _ _ _  l274 _ _ _  l275 _ _ _  l276 _ _ _  l277 _ _ _  l278 _ _ _  l279 _ _ _
+     l280 _ _ _  l281 _ _ _  l282 _ _ _  l283 _ _ _  l284 _ _ _  l285 _ _ _  l286 _ _ _  l287 _ _ _
+     l288 _ _ _  l289 _ _ _  l290 _ _ _  l291 _ _ _  l292 _ _ _  l293 _ _ _  l294 _ _ _  l295 _ _ _
+     l296 _ _ _  l297 _ _ _  l298 _ _ _  l299 _ _ _  l300 _ _ _  l301 _ _ _  l302 _ _ _  l303 _ _ _
+     l304 _ _ _  l305 _ _ _  l306 _ _ _  l307 _ _ _  l308 _ _ _  l309 _ _ _  l310 _ _ _  l311 _ _ _
+     l312 _ _ _  l313 _ _ _  l314 _ _ _  l315 _ _ _  l316 _ _ _  l317 _ _ _  l318 _ _ _  l319 _ _ _
+     l320 _ _ _  l321 _ _ _  l322 _ _ _  l323 _ _ _  l324 _ _ _  l325 _ _ _  l326 _ _ _  l327 _ _ _
+     l328 _ _ _  l329 _ _ _  l330 _ _ _  l331 _ _ _  l332 _ _ _  l333 _ _ _  l334 _ _ _  l335 _ _ _
+     l336 _ _ _  l337 _ _ _  l338 _ _ _  l339 _ _ _  l340 _ _ _  l341 _ _ _  l342 _ _ _  l343 _ _ _
+     l344 _ _ _  l345 _ _ _  l346 _ _ _  l347 _ _ _  l348 _ _ _  l349 _ _ _  l350 _ _ _  l351 _ _ _
+     l352 _ _ _  l353 _ _ _  l354 _ _ _  l355 _ _ _  l356 _ _ _  l357 _ _ _  l358 _ _ _  l359 _ _ _
+     l360 _ _ _  l361 _ _ _  l362 _ _ _  l363 _ _ _  l364 _ _ _  l365 _ _ _  l366 _ _ _  l367 _ _ _
+     l368 _ _ _  l369 _ _ _  l370 _ _ _  l371 _ _ _  l372 _ _ _  l373 _ _ _  l374 _ _ _  l375 _ _ _
+     l376 _ _ _  l377 _ _ _  l378 _ _ _  l379 _ _ _  l380 _ _ _  l381 _ _ _  l382 _ _ _  l383 _ _ _
+     l384 _ _ _  l385 _ _ _  l386 _ _ _  l387 _ _ _  l388 _ _ _  l389 _ _ _  l390 _ _ _  l391 _ _ _
+     l392 _ _ _  l393 _ _ _  l394 _ _ _  l395 _ _ _  l396 _ _ _  l397 _ _ _  l398 _ _ _  l399 _ _ _
+     l400 _ _ _  l401 _ _ _  l402 _ _ _  l403 _ _ _  l404 _ _ _  l405 _ _ _  l406 _ _ _  l407 _ _ _
+     l408 _ _ _  l409 _ _ _  l410 _ _ _  l411 _ _ _  l412 _ _ _  l413 _ _ _  l414 _ _ _  l415 _ _ _
+     l416 _ _ _  l417 _ _ _  l418 _ _ _  l419 _ _ _  l420 _ _ _  l421 _ _ _  l422 _ _ _  l423 _ _ _
+     l424 _ _ _  l425 _ _ _  l426 _ _ _  l427 _ _ _  l428 _ _ _  l429 _ _ _  l430 _ _ _  l431 _ _ _
+     l432 _ _ _  l433 _ _ _  l434 _ _ _  l435 _ _ _  l436 _ _ _  l437 _ _ _  l438 _ _ _  l439 _ _ _
+     l440 _ _ _  l441 _ _ _  l442 _ _ _  l443 _ _ _  l444 _ _ _  l445 _ _ _  l446 _ _ _  l447 _ _ _
+     l448 _ _ _  l449 _ _ _  l450 _ _ _  l451 _ _ _  l452 _ _ _  l453 _ _ _  l454 _ _ _  l455 _ _ _
+     l456 _ _ _  l457 _ _ _  l458 _ _ _  l459 _ _ _  l460 _ _ _  l461 _ _ _  l462 _ _ _  l463 _ _ _
+     l464 _ _ _  l465 _ _ _  l466 _ _ _  l467 _ _ _  l468 _ _ _  l469 _ _ _  l470 _ _ _  l471 _ _ _
+     l472 _ _ _  l473 _ _ _  l474 _ _ _  l475 _ _ _  l476 _ _ _  l477 _ _ _  l478 _ _ _  l479 _ _ _
+     l480 _ _ _  l481 _ _ _  l482 _ _ _  l483 _ _ _  l484 _ _ _  l485 _ _ _  l486 _ _ _  l487 _ _ _
+     l488 _ _ _  l489 _ _ _  l490 _ _ _  l491 _ _ _  l492 _ _ _  l493 _ _ _  l494 _ _ _  l495 _ _ _
+     l496 _ _ _  l497 _ _ _  l498 _ _ _  l499 _ _ _  l500 _ _ _  l501 _ _ _  l502 _ _ _  l503 _ _ _
+     l504 _ _ _  l505 _ _ _  l506 _ _ _  l507 _ _ _  l508 _ _ _  l509 _ _ _  l510 _ _ _  l511 _ _ _
+     l512 _ _ _  l513 _ _ _  l514 _ _ _  l515 _ _ _  l516 _ _ _  l517 _ _ _  l518 _ _ _  l519 _ _ _
+     l520 _ _ _  l521 _ _ _  l522 _ _ _  l523 _ _ _  l524 _ _ _  l525 _ _ _  l526 _ _ _  l527 _ _ _
+     l528 _ _ _  l529 _ _ _  l530 _ _ _  l531 _ _ _  l532 _ _ _  l533 _ _ _  l534 _ _ _  l535 _ _ _
+     l536 _ _ _  l537 _ _ _  l538 _ _ _  l539 _ _ _  l540 _ _ _  l541 _ _ _  l542 _ _ _  l543 _ _ _
+     l544 _ _ _  l545 _ _ _  l546 _ _ _  l547 _ _ _  l548 _ _ _  l549 _ _ _  l550 _ _ _  l551 _ _ _
+     l552 _ _ _  l553 _ _ _  l554 _ _ _  l555 _ _ _  l556 _ _ _  l557 _ _ _  l558 _ _ _  l559 _ _ _
+     l560 _ _ _  l561 _ _ _  l562 _ _ _  l563 _ _ _  l564 _ _ _  l565 _ _ _  l566 _ _ _  l567 _ _ _
+     l568 _ _ _  l569 _ _ _  l570 _ _ _  l571 _ _ _  l572 _ _ _  l573 _ _ _  l574 _ _ _  l575 _ _ _
+     l576 _ _ _  l577 _ _ _  l578 _ _ _  l579 _ _ _  l580 _ _ _  l581 _ _ _  l582 _ _ _  l583 _ _ _
+     l584 _ _ _  l585 _ _ _  l586 _ _ _  l587 _ _ _  l588 _ _ _  l589 _ _ _  l590 _ _ _  l591 _ _ _
+     l592 _ _ _  l593 _ _ _  l594 _ _ _  l595 _ _ _  l596 _ _ _  l597 _ _ _  l598 _ _ _  l599 _ _ _
+     l600 _ _ _  l601 _ _ _  l602 _ _ _  l603 _ _ _  l604 _ _ _  l605 _ _ _  l606 _ _ _  l607 _ _ _
+     l608 _ _ _  l609 _ _ _  l610 _ _ _  l611 _ _ _  l612 _ _ _  l613 _ _ _  l614 _ _ _  l615 _ _ _
+     l616 _ _ _  l617 _ _ _  l618 _ _ _  l619 _ _ _  l620 _ _ _  l621 _ _ _  l622 _ _ _  l623 _ _ _
+     l624 _ _ _  l625 _ _ _  l626 _ _ _  l627 _ _ _  l628 _ _ _  l629 _ _ _  l630 _ _ _  l631 _ _ _
+     l632 _ _ _  l633 _ _ _  l634 _ _ _  l635 _ _ _  l636 _ _ _  l637 _ _ _  l638 _ _ _  l639 _ _ _
+     l640 _ _ _  l641 _ _ _  l642 _ _ _  l643 _ _ _  l644 _ _ _  l645 _ _ _  l646 _ _ _  l647 _ _ _
+     l648 _ _ _  l649 _ _ _  l650 _ _ _  l651 _ _ _  l652 _ _ _  l653 _ _ _  l654 _ _ _  l655 _ _ _
+     l656 _ _ _  l657 _ _ _  l658 _ _ _  l659 _ _ _  l660 _ _ _  l661 _ _ _  l662 _ _ _  l663 _ _ _
+     l664 _ _ _  l665 _ _ _  l666 _ _ _  l667 _ _ _  l668 _ _ _  l669 _ _ _  l670 _ _ _  l671 _ _ _
+     l672 _ _ _  l673 _ _ _  l674 _ _ _  l675 _ _ _  l676 _ _ _  l677 _ _ _  l678 _ _ _  l679 _ _ _
+     l680 _ _ _  l681 _ _ _  l682 _ _ _  l683 _ _ _  l684 _ _ _  l685 _ _ _  l686 _ _ _  l687 _ _ _
+     l688 _ _ _  l689 _ _ _  l690 _ _ _  l691 _ _ _  l692 _ _ _  l693 _ _ _  l694 _ _ _  l695 _ _ _
+     l696 _ _ _  l697 _ _ _  l698 _ _ _  l699 _ _ _  l700 _ _ _  l701 _ _ _  l702 _ _ _  l703 _ _ _
+     l704 _ _ _  l705 _ _ _  l706 _ _ _  l707 _ _ _  l708 _ _ _  l709 _ _ _  l710 _ _ _  l711 _ _ _
+     l712 _ _ _  l713 _ _ _  l714 _ _ _  l715 _ _ _  l716 _ _ _  l717 _ _ _  l718 _ _ _  l719 _ _ _
+     l720 _ _ _  l721 _ _ _  l722 _ _ _  l723 _ _ _  l724 _ _ _  l725 _ _ _  l726 _ _ _  l727 _ _ _
+     l728 _ _ _  l729 _ _ _  l730 _ _ _  l731 _ _ _  l732 _ _ _  l733 _ _ _  l734 _ _ _  l735 _ _ _
+     l736 _ _ _  l737 _ _ _  l738 _ _ _  l739 _ _ _  l740 _ _ _  l741 _ _ _  l742 _ _ _  l743 _ _ _
+     l744 _ _ _  l745 _ _ _  l746 _ _ _  l747 _ _ _  l748 _ _ _  l749 _ _ _  l750 _ _ _  l751 _ _ _
+     l752 _ _ _  l753 _ _ _  l754 _ _ _  l755 _ _ _  l756 _ _ _  l757 _ _ _  l758 _ _ _  l759 _ _ _
+     l760 _ _ _  l761 _ _ _  l762 _ _ _  l763 _ _ _  l764 _ _ _  l765 _ _ _  l766 _ _ _  l767 _ _ _
+     l768 _ _ _  l769 _ _ _  l770 _ _ _  l771 _ _ _  l772 _ _ _  l773 _ _ _  l774 _ _ _  l775 _ _ _
+     l776 _ _ _  l777 _ _ _  l778 _ _ _  l779 _ _ _  l780 _ _ _  l781 _ _ _  l782 _ _ _  l783 _ _ _
+     l784 _ _ _  l785 _ _ _  l786 _ _ _  l787 _ _ _  l788 _ _ _  l789 _ _ _  l790 _ _ _  l791 _ _ _
+     l792 _ _ _  l793 _ _ _  l794 _ _ _  l795 _ _ _  l796 _ _ _  l797 _ _ _  l798 _ _ _  l799 _ _ _
+     l800 _ _ _  l801 _ _ _  l802 _ _ _  l803 _ _ _  l804 _ _ _  l805 _ _ _  l806 _ _ _  l807 _ _ _
+     l808 _ _ _  l809 _ _ _  l810 _ _ _  l811 _ _ _  l812 _ _ _  l813 _ _ _  l814 _ _ _  l815 _ _ _
+     l816 _ _ _  l817 _ _ _  l818 _ _ _  l819 _ _ _  l820 _ _ _  l821 _ _ _  l822 _ _ _  l823 _ _ _
+     l824 _ _ _  l825 _ _ _  l826 _ _ _  l827 _ _ _  l828 _ _ _  l829 _ _ _  l830 _ _ _  l831 _ _ _
+     l832 _ _ _  l833 _ _ _  l834 _ _ _  l835 _ _ _  l836 _ _ _  l837 _ _ _  l838 _ _ _  l839 _ _ _
+     l840 _ _ _  l841 _ _ _  l842 _ _ _  l843 _ _ _  l844 _ _ _  l845 _ _ _  l846 _ _ _  l847 _ _ _
+     l848 _ _ _  l849 _ _ _  l850 _ _ _  l851 _ _ _  l852 _ _ _  l853 _ _ _  l854 _ _ _  l855 _ _ _
+     l856 _ _ _  l857 _ _ _  l858 _ _ _  l859 _ _ _  l860 _ _ _  l861 _ _ _  l862 _ _ _  l863 _ _ _
+     l864 _ _ _  l865 _ _ _  l866 _ _ _  l867 _ _ _  l868 _ _ _  l869 _ _ _  l870 _ _ _  l871 _ _ _
+     l872 _ _ _  l873 _ _ _  l874 _ _ _  l875 _ _ _  l876 _ _ _  l877 _ _ _  l878 _ _ _  l879 _ _ _
+     l880 _ _ _  l881 _ _ _  l882 _ _ _  l883 _ _ _  l884 _ _ _  l885 _ _ _  l886 _ _ _  l887 _ _ _
+     l888 _ _ _  l889 _ _ _  l890 _ _ _  l891 _ _ _  l892 _ _ _  l893 _ _ _  l894 _ _ _  l895 _ _ _
+     l896 _ _ _  l897 _ _ _  l898 _ _ _  l899 _ _ _  l900 _ _ _  l901 _ _ _  l902 _ _ _  l903 _ _ _
+     l904 _ _ _  l905 _ _ _  l906 _ _ _  l907 _ _ _  l908 _ _ _  l909 _ _ _  l910 _ _ _  l911 _ _ _
+     l912 _ _ _  l913 _ _ _  l914 _ _ _  l915 _ _ _  l916 _ _ _  l917 _ _ _  l918 _ _ _  l919 _ _ _
+     l920 _ _ _  l921 _ _ _  l922 _ _ _  l923 _ _ _  l924 _ _ _  l925 _ _ _  l926 _ _ _  l927 _ _ _
+     l928 _ _ _  l929 _ _ _  l930 _ _ _  l931 _ _ _  l932 _ _ _  l933 _ _ _  l934 _ _ _  l935 _ _ _
+     l936 _ _ _  l937 _ _ _  l938 _ _ _  l939 _ _ _  l940 _ _ _  l941 _ _ _  l942 _ _ _  l943 _ _ _
+     l944 _ _ _  l945 _ _ _  l946 _ _ _  l947 _ _ _  l948 _ _ _  l949 _ _ _  l950 _ _ _  l951 _ _ _
+     l952 _ _ _  l953 _ _ _  l954 _ _ _  l955 _ _ _  l956 _ _ _  l957 _ _ _  l958 _ _ _  l959 _ _ _
+     l960 _ _ _  l961 _ _ _  l962 _ _ _  l963 _ _ _  l964 _ _ _  l965 _ _ _  l966 _ _ _  l967 _ _ _
+     l968 _ _ _  l969 _ _ _  l970 _ _ _  l971 _ _ _  l972 _ _ _  l973 _ _ _  l974 _ _ _  l975 _ _ _
+     l976 _ _ _  l977 _ _ _  l978 _ _ _  l979 _ _ _  l980 _ _ _  l981 _ _ _  l982 _ _ _  l983 _ _ _
+     l984 _ _ _  l985 _ _ _  l986 _ _ _  l987 _ _ _  l988 _ _ _  l989 _ _ _  l990 _ _ _  l991 _ _ _
+     l992 _ _ _  l993 _ _ _  l994 _ _ _  l995 _ _ _  l996 _ _ _  l997 _ _ _  l998 _ _ _  l999 _ _ _
+    l1000 _ _ _ l1001 _ _ _ l1002 _ _ _ l1003 _ _ _ l1004 _ _ _ l1005 _ _ _ l1006 _ _ _ l1007 _ _ _
+    l1008 _ _ _ l1009 _ _ _ l1010 _ _ _ l1011 _ _ _ l1012 _ _ _ l1013 _ _ _ l1014 _ _ _ l1015 _ _ _
+    l1016 _ _ _ l1017 _ _ _ l1018 _ _ _ l1019 _ _ _ l1020 _ _ _ l1021 _ _ _ l1022 _ _ _ l1023 _ _ _
+    l1024 _ _ _ l1025 _ _ _ l1026 _ _ _ l1027 _ _ _ l1028 _ _ _ l1029 _ _ _ l1030 _ _ _ l1031 _ _ _
+    l1032 _ _ _ l1033 _ _ _ l1034 _ _ _ l1035 _ _ _ l1036 _ _ _ l1037 _ _ _ l1038 _ _ _ l1039 _ _ _
+    l1040 _ _ _ l1041 _ _ _ l1042 _ _ _ l1043 _ _ _ l1044 _ _ _ l1045 _ _ _ l1046 _ _ _ l1047 _ _ _
+    l1048 _ _ _ l1049 _ _ _ l1050 _ _ _ l1051 _ _ _ l1052 _ _ _ l1053 _ _ _ l1054 _ _ _ l1055 _ _ _
+    l1056 _ _ _ l1057 _ _ _ l1058 _ _ _ l1059 _ _ _ l1060 _ _ _ l1061 _ _ _ l1062 _ _ _ l1063 _ _ _
+    l1064 _ _ _ l1065 _ _ _ l1066 _ _ _ l1067 _ _ _ l1068 _ _ _ l1069 _ _ _ l1070 _ _ _ l1071 _ _ _
+    l1072 _ _ _ l1073 _ _ _ l1074 _ _ _ l1075 _ _ _ l1076 _ _ _ l1077 _ _ _ l1078 _ _ _ l1079 _ _ _
+    l1080 _ _ _ l1081 _ _ _ l1082 _ _ _ l1083 _ _ _ l1084 _ _ _ l1085 _ _ _ l1086 _ _ _ l1087 _ _ _
+    l1088 _ _ _ l1089 _ _ _ l1090 _ _ _ l1091 _ _ _ l1092 _ _ _ l1093 _ _ _ l1094 _ _ _ l1095 _ _ _
+    l1096 _ _ _ l1097 _ _ _ l1098 _ _ _ l1099 _ _ _ l1100 _ _ _ l1101 _ _ _ l1102 _ _ _ l1103 _ _ _
+    l1104 _ _ _ l1105 _ _ _ l1106 _ _ _ l1107 _ _ _ l1108 _ _ _ l1109 _ _ _ l1110 _ _ _ l1111 _ _ _
+    l1112 _ _ _ l1113 _ _ _ l1114 _ _ _ l1115 _ _ _ l1116 _ _ _ l1117 _ _ _ l1118 _ _ _ l1119 _ _ _
+    l1120 _ _ _ l1121 _ _ _ l1122 _ _ _ l1123 _ _ _ l1124 _ _ _ l1125 _ _ _ l1126 _ _ _ l1127 _ _ _
+    l1128 _ _ _ l1129 _ _ _ l1130 _ _ _ l1131 _ _ _ l1132 _ _ _ l1133 _ _ _ l1134 _ _ _ l1135 _ _ _
+    l1136 _ _ _ l1137 _ _ _ l1138 _ _ _ l1139 _ _ _ l1140 _ _ _ l1141 _ _ _ l1142 _ _ _ l1143 _ _ _
+    l1144 _ _ _ l1145 _ _ _ l1146 _ _ _ l1147 _ _ _ l1148 _ _ _ l1149 _ _ _ l1150 _ _ _ l1151 _ _ _
+    l1152 _ _ _ l1153 _ _ _ l1154 _ _ _ l1155 _ _ _ l1156 _ _ _ l1157 _ _ _ l1158 _ _ _ l1159 _ _ _
+    l1160 _ _ _ l1161 _ _ _ l1162 _ _ _ l1163 _ _ _ l1164 _ _ _ l1165 _ _ _ l1166 _ _ _ l1167 _ _ _
+    l1168 _ _ _ l1169 _ _ _ l1170 _ _ _ l1171 _ _ _ l1172 _ _ _ l1173 _ _ _ l1174 _ _ _ l1175 _ _ _
+    l1176 _ _ _ l1177 _ _ _ l1178 _ _ _ l1179 _ _ _ l1180 _ _ _ l1181 _ _ _ l1182 _ _ _ l1183 _ _ _
+    l1184 _ _ _ l1185 _ _ _ l1186 _ _ _ l1187 _ _ _ l1188 _ _ _ l1189 _ _ _ l1190 _ _ _ l1191 _ _ _
+    l1192 _ _ _ l1193 _ _ _ l1194 _ _ _ l1195 _ _ _ l1196 _ _ _ l1197 _ _ _ l1198 _ _ _ l1199 _ _ _
+    l1200 _ _ _ l1201 _ _ _ l1202 _ _ _ l1203 _ _ _ l1204 _ _ _ l1205 _ _ _ l1206 _ _ _ l1207 _ _ _
+    l1208 _ _ _ l1209 _ _ _ l1210 _ _ _ l1211 _ _ _ l1212 _ _ _ l1213 _ _ _ l1214 _ _ _ l1215 _ _ _
+    l1216 _ _ _ l1217 _ _ _ l1218 _ _ _ l1219 _ _ _ l1220 _ _ _ l1221 _ _ _ l1222 _ _ _ l1223 _ _ _
+    l1224 _ _ _ l1225 _ _ _ l1226 _ _ _ l1227 _ _ _ l1228 _ _ _ l1229 _ _ _ l1230 _ _ _ l1231 _ _ _
+    l1232 _ _ _ l1233 _ _ _ l1234 _ _ _ l1235 _ _ _ l1236 _ _ _ l1237 _ _ _ l1238 _ _ _ l1239 _ _ _
+    l1240 _ _ _ l1241 _ _ _ l1242 _ _ _ l1243 _ _ _ l1244 _ _ _ l1245 _ _ _ l1246 _ _ _ l1247 _ _ _
+    l1248 _ _ _ l1249 _ _ _ l1250 _ _ _ l1251 _ _ _ l1252 _ _ _ l1253 _ _ _ l1254 _ _ _ l1255 _ _ _
+    l1256 _ _ _ l1257 _ _ _ l1258 _ _ _ l1259 _ _ _ l1260 _ _ _ l1261 _ _ _ l1262 _ _ _ l1263 _ _ _
+    l1264 _ _ _ l1265 _ _ _ l1266 _ _ _ l1267 _ _ _ l1268 _ _ _ l1269 _ _ _ l1270 _ _ _ l1271 _ _ _
+    l1272 _ _ _ l1273 _ _ _ l1274 _ _ _ l1275 _ _ _ l1276 _ _ _ l1277 _ _ _ l1278 _ _ _ l1279 _ _ _
+    l1280 _ _ _ l1281 _ _ _ l1282 _ _ _ l1283 _ _ _ l1284 _ _ _ l1285 _ _ _ l1286 _ _ _ l1287 _ _ _
+    l1288 _ _ _ l1289 _ _ _ l1290 _ _ _ l1291 _ _ _ l1292 _ _ _ l1293 _ _ _ l1294 _ _ _ l1295 _ _ _
+    l1296 _ _ _ l1297 _ _ _ l1298 _ _ _ l1299 _ _ _ l1300 _ _ _ l1301 _ _ _ l1302 _ _ _ l1303 _ _ _
+    l1304 _ _ _ l1305 _ _ _ l1306 _ _ _ l1307 _ _ _ l1308 _ _ _ l1309 _ _ _ l1310 _ _ _ l1311 _ _ _
+    l1312 _ _ _ l1313 _ _ _ l1314 _ _ _ l1315 _ _ _ l1316 _ _ _ l1317 _ _ _ l1318 _ _ _ l1319 _ _ _
+    l1320 _ _ _ l1321 _ _ _ l1322 _ _ _ l1323 _ _ _ l1324 _ _ _ l1325 _ _ _ l1326 _ _ _ l1327 _ _ _
+    l1328 _ _ _ l1329 _ _ _ l1330 _ _ _ l1331 _ _ _ l1332 _ _ _ l1333 _ _ _ l1334 _ _ _ l1335 _ _ _
+    l1336 _ _ _ l1337 _ _ _ l1338 _ _ _ l1339 _ _ _ l1340 _ _ _ l1341 _ _ _ l1342 _ _ _ l1343 _ _ _
+    l1344 _ _ _ l1345 _ _ _ l1346 _ _ _ l1347 _ _ _ l1348 _ _ _ l1349 _ _ _ l1350 _ _ _ l1351 _ _ _
+    l1352 _ _ _ l1353 _ _ _ l1354 _ _ _ l1355 _ _ _ l1356 _ _ _ l1357 _ _ _ l1358 _ _ _ l1359 _ _ _
+    l1360 _ _ _ l1361 _ _ _ l1362 _ _ _ l1363 _ _ _ l1364 _ _ _ l1365 _ _ _ l1366 _ _ _ l1367 _ _ _
+    l1368 _ _ _ l1369 _ _ _ l1370 _ _ _ l1371 _ _ _ l1372 _ _ _ l1373 _ _ _ l1374 _ _ _ l1375 _ _ _
+    l1376 _ _ _ l1377 _ _ _ l1378 _ _ _ l1379 _ _ _ l1380 _ _ _ l1381 _ _ _ l1382 _ _ _ l1383 _ _ _
+    l1384 _ _ _ l1385 _ _ _ l1386 _ _ _ l1387 _ _ _ l1388 _ _ _ l1389 _ _ _ l1390 _ _ _ l1391 _ _ _
+    l1392 _ _ _ l1393 _ _ _ l1394 _ _ _ l1395 _ _ _ l1396 _ _ _ l1397 _ _ _ l1398 _ _ _ l1399 _ _ _
+    l1400 _ _ _ l1401 _ _ _ l1402 _ _ _ l1403 _ _ _ l1404 _ _ _ l1405 _ _ _ l1406 _ _ _ l1407 _ _ _
+    l1408 _ _ _ l1409 _ _ _ l1410 _ _ _ l1411 _ _ _ l1412 _ _ _ l1413 _ _ _ l1414 _ _ _ l1415 _ _ _
+    l1416 _ _ _ l1417 _ _ _ l1418 _ _ _ l1419 _ _ _ l1420 _ _ _ l1421 _ _ _ l1422 _ _ _ l1423 _ _ _
+    l1424 _ _ _ l1425 _ _ _ l1426 _ _ _ l1427 _ _ _ l1428 _ _ _ l1429 _ _ _ l1430 _ _ _ l1431 _ _ _
+    l1432 _ _ _ l1433 _ _ _ l1434 _ _ _ l1435 _ _ _ l1436 _ _ _ l1437 _ _ _ l1438 _ _ _ l1439 _ _ _
+    l1440 _ _ _ l1441 _ _ _ l1442 _ _ _ l1443 _ _ _ l1444 _ _ _ l1445 _ _ _ l1446 _ _ _ l1447 _ _ _
+    l1448 _ _ _ l1449 _ _ _ l1450 _ _ _ l1451 _ _ _ l1452 _ _ _ l1453 _ _ _ l1454 _ _ _ l1455 _ _ _
+    l1456 _ _ _ l1457 _ _ _ l1458 _ _ _ l1459 _ _ _ l1460 _ _ _ l1461 _ _ _ l1462 _ _ _ l1463 _ _ _
+    l1464 _ _ _ l1465 _ _ _ l1466 _ _ _ l1467 _ _ _ l1468 _ _ _ l1469 _ _ _ l1470 _ _ _ l1471 _ _ _
+    l1472 _ _ _ l1473 _ _ _ l1474 _ _ _ l1475 _ _ _ l1476 _ _ _ l1477 _ _ _ l1478 _ _ _ l1479 _ _ _
+    l1480 _ _ _ l1481 _ _ _ l1482 _ _ _ l1483 _ _ _ l1484 _ _ _ l1485 _ _ _ l1486 _ _ _ l1487 _ _ _
+    l1488 _ _ _ l1489 _ _ _ l1490 _ _ _ l1491 _ _ _ l1492 _ _ _ l1493 _ _ _ l1494 _ _ _ l1495 _ _ _
+    l1496 _ _ _ l1497 _ _ _ l1498 _ _ _ l1499 _ _ _ l1500 _ _ _ l1501 _ _ _ l1502 _ _ _ l1503 _ _ _
+    l1504 _ _ _ l1505 _ _ _ l1506 _ _ _ l1507 _ _ _ l1508 _ _ _ l1509 _ _ _ l1510 _ _ _ l1511 _ _ _
+    l1512 _ _ _ l1513 _ _ _ l1514 _ _ _ l1515 _ _ _ l1516 _ _ _ l1517 _ _ _ l1518 _ _ _ l1519 _ _ _
+    l1520 _ _ _ l1521 _ _ _ l1522 _ _ _ l1523 _ _ _ l1524 _ _ _ l1525 _ _ _ l1526 _ _ _ l1527 _ _ _
+    l1528 _ _ _ l1529 _ _ _ l1530 _ _ _ l1531 _ _ _ l1532 _ _ _ l1533 _ _ _ l1534 _ _ _ l1535 _ _ _
+    l1536 _ _ _ l1537 _ _ _ l1538 _ _ _ l1539 _ _ _ l1540 _ _ _ l1541 _ _ _ l1542 _ _ _ l1543 _ _ _
+    l1544 _ _ _ l1545 _ _ _ l1546 _ _ _ l1547 _ _ _ l1548 _ _ _ l1549 _ _ _ l1550 _ _ _ l1551 _ _ _
+    l1552 _ _ _ l1553 _ _ _ l1554 _ _ _ l1555 _ _ _ l1556 _ _ _ l1557 _ _ _ l1558 _ _ _ l1559 _ _ _
+    l1560 _ _ _ l1561 _ _ _ l1562 _ _ _ l1563 _ _ _ l1564 _ _ _ l1565 _ _ _ l1566 _ _ _ l1567 _ _ _
+    l1568 _ _ _ l1569 _ _ _ l1570 _ _ _ l1571 _ _ _ l1572 _ _ _ l1573 _ _ _ l1574 _ _ _ l1575 _ _ _
+    l1576 _ _ _ l1577 _ _ _ l1578 _ _ _ l1579 _ _ _ l1580 _ _ _ l1581 _ _ _ l1582 _ _ _ l1583 _ _ _
+    l1584 _ _ _ l1585 _ _ _ l1586 _ _ _ l1587 _ _ _ l1588 _ _ _ l1589 _ _ _ l1590 _ _ _ l1591 _ _ _
+    l1592 _ _ _ l1593 _ _ _ l1594 _ _ _ l1595 _ _ _ l1596 _ _ _ l1597 _ _ _ l1598 _ _ _ l1599 _ _ _
+    l1600 _ _ _ l1601 _ _ _ l1602 _ _ _ l1603 _ _ _ l1604 _ _ _ l1605 _ _ _ l1606 _ _ _ l1607 _ _ _
+    l1608 _ _ _ l1609 _ _ _ l1610 _ _ _ l1611 _ _ _ l1612 _ _ _ l1613 _ _ _ l1614 _ _ _ l1615 _ _ _
+    l1616 _ _ _ l1617 _ _ _ l1618 _ _ _ l1619 _ _ _ l1620 _ _ _ l1621 _ _ _ l1622 _ _ _ l1623 _ _ _
+    l1624 _ _ _ l1625 _ _ _ l1626 _ _ _ l1627 _ _ _ l1628 _ _ _ l1629 _ _ _ l1630 _ _ _ l1631 _ _ _
+    l1632 _ _ _ l1633 _ _ _ l1634 _ _ _ l1635 _ _ _ l1636 _ _ _ l1637 _ _ _ l1638 _ _ _ l1639 _ _ _
+    l1640 _ _ _ l1641 _ _ _ l1642 _ _ _ l1643 _ _ _ l1644 _ _ _ l1645 _ _ _ l1646 _ _ _ l1647 _ _ _
+    l1648 _ _ _ l1649 _ _ _ l1650 _ _ _ l1651 _ _ _ l1652 _ _ _ l1653 _ _ _ l1654 _ _ _ l1655 _ _ _
+    l1656 _ _ _ l1657 _ _ _ l1658 _ _ _ l1659 _ _ _ l1660 _ _ _ l1661 _ _ _ l1662 _ _ _ l1663 _ _ _
+    l1664 _ _ _ l1665 _ _ _ l1666 _ _ _ l1667 _ _ _ l1668 _ _ _ l1669 _ _ _ l1670 _ _ _ l1671 _ _ _
+    l1672 _ _ _ l1673 _ _ _ l1674 _ _ _ l1675 _ _ _ l1676 _ _ _ l1677 _ _ _ l1678 _ _ _ l1679 _ _ _
+    l1680 _ _ _ l1681 _ _ _ l1682 _ _ _ l1683 _ _ _ l1684 _ _ _ l1685 _ _ _ l1686 _ _ _ l1687 _ _ _
+    l1688 _ _ _ l1689 _ _ _ l1690 _ _ _ l1691 _ _ _ l1692 _ _ _ l1693 _ _ _ l1694 _ _ _ l1695 _ _ _
+    l1696 _ _ _ l1697 _ _ _ l1698 _ _ _ l1699 _ _ _ l1700 _ _ _ l1701 _ _ _ l1702 _ _ _ l1703 _ _ _
+    l1704 _ _ _ l1705 _ _ _ l1706 _ _ _ l1707 _ _ _ l1708 _ _ _ l1709 _ _ _ l1710 _ _ _ l1711 _ _ _
+    l1712 _ _ _ l1713 _ _ _ l1714 _ _ _ l1715 _ _ _ l1716 _ _ _ l1717 _ _ _ l1718 _ _ _ l1719 _ _ _
+    l1720 _ _ _ l1721 _ _ _ l1722 _ _ _ l1723 _ _ _ l1724 _ _ _ l1725 _ _ _ l1726 _ _ _ l1727 _ _ _
+    l1728 _ _ _ l1729 _ _ _ l1730 _ _ _ l1731 _ _ _ l1732 _ _ _ l1733 _ _ _ l1734 _ _ _ l1735 _ _ _
+    l1736 _ _ _ l1737 _ _ _ l1738 _ _ _ l1739 _ _ _ l1740 _ _ _ l1741 _ _ _ l1742 _ _ _ l1743 _ _ _
+    l1744 _ _ _ l1745 _ _ _ l1746 _ _ _ l1747 _ _ _ l1748 _ _ _ l1749 _ _ _ l1750 _ _ _ l1751 _ _ _
+    l1752 _ _ _ l1753 _ _ _ l1754 _ _ _ l1755 _ _ _ l1756 _ _ _ l1757 _ _ _ l1758 _ _ _ l1759 _ _ _
+    l1760 _ _ _ l1761 _ _ _ l1762 _ _ _ l1763 _ _ _ l1764 _ _ _ l1765 _ _ _ l1766 _ _ _ l1767 _ _ _
+    l1768 _ _ _ l1769 _ _ _ l1770 _ _ _ l1771 _ _ _ l1772 _ _ _ l1773 _ _ _ l1774 _ _ _ l1775 _ _ _
+    l1776 _ _ _ l1777 _ _ _ l1778 _ _ _ l1779 _ _ _ l1780 _ _ _ l1781 _ _ _ l1782 _ _ _ l1783 _ _ _
+    l1784 _ _ _ l1785 _ _ _ l1786 _ _ _ l1787 _ _ _ l1788 _ _ _ l1789 _ _ _ l1790 _ _ _ l1791 _ _ _
+    l1792 _ _ _ l1793 _ _ _ l1794 _ _ _ l1795 _ _ _ l1796 _ _ _ l1797 _ _ _ l1798 _ _ _ l1799 _ _ _
+    l1800 _ _ _ l1801 _ _ _ l1802 _ _ _ l1803 _ _ _ l1804 _ _ _ l1805 _ _ _ l1806 _ _ _ l1807 _ _ _
+    l1808 _ _ _ l1809 _ _ _ l1810 _ _ _ l1811 _ _ _ l1812 _ _ _ l1813 _ _ _ l1814 _ _ _ l1815 _ _ _
+    l1816 _ _ _ l1817 _ _ _ l1818 _ _ _ l1819 _ _ _ l1820 _ _ _ l1821 _ _ _ l1822 _ _ _ l1823 _ _ _
+    l1824 _ _ _ l1825 _ _ _ l1826 _ _ _ l1827 _ _ _ l1828 _ _ _ l1829 _ _ _ l1830 _ _ _ l1831 _ _ _
+    l1832 _ _ _ l1833 _ _ _ l1834 _ _ _ l1835 _ _ _ l1836 _ _ _ l1837 _ _ _ l1838 _ _ _ l1839 _ _ _
+    l1840 _ _ _ l1841 _ _ _ l1842 _ _ _ l1843 _ _ _ l1844 _ _ _ l1845 _ _ _ l1846 _ _ _ l1847 _ _ _
+    l1848 _ _ _ l1849 _ _ _ l1850 _ _ _ l1851 _ _ _ l1852 _ _ _ l1853 _ _ _ l1854 _ _ _ l1855 _ _ _
+    l1856 _ _ _ l1857 _ _ _ l1858 _ _ _ l1859 _ _ _ l1860 _ _ _ l1861 _ _ _ l1862 _ _ _ l1863 _ _ _
+    l1864 _ _ _ l1865 _ _ _ l1866 _ _ _ l1867 _ _ _ l1868 _ _ _ l1869 _ _ _ l1870 _ _ _ l1871 _ _ _
+    l1872 _ _ _ l1873 _ _ _ l1874 _ _ _ l1875 _ _ _ l1876 _ _ _ l1877 _ _ _ l1878 _ _ _ l1879 _ _ _
+    l1880 _ _ _ l1881 _ _ _ l1882 _ _ _ l1883 _ _ _ l1884 _ _ _ l1885 _ _ _ l1886 _ _ _ l1887 _ _ _
+    l1888 _ _ _ l1889 _ _ _ l1890 _ _ _ l1891 _ _ _ l1892 _ _ _ l1893 _ _ _ l1894 _ _ _ l1895 _ _ _
+    l1896 _ _ _ l1897 _ _ _ l1898 _ _ _ l1899 _ _ _ l1900 _ _ _ l1901 _ _ _ l1902 _ _ _ l1903 _ _ _
+    l1904 _ _ _ l1905 _ _ _ l1906 _ _ _ l1907 _ _ _ l1908 _ _ _ l1909 _ _ _ l1910 _ _ _ l1911 _ _ _
+    l1912 _ _ _ l1913 _ _ _ l1914 _ _ _ l1915 _ _ _ l1916 _ _ _ l1917 _ _ _ l1918 _ _ _ l1919 _ _ _
+    l1920 _ _ _ l1921 _ _ _ l1922 _ _ _ l1923 _ _ _ l1924 _ _ _ l1925 _ _ _ l1926 _ _ _ l1927 _ _ _
+    l1928 _ _ _ l1929 _ _ _ l1930 _ _ _ l1931 _ _ _ l1932 _ _ _ l1933 _ _ _ l1934 _ _ _ l1935 _ _ _
+    l1936 _ _ _ l1937 _ _ _ l1938 _ _ _ l1939 _ _ _ l1940 _ _ _ l1941 _ _ _ l1942 _ _ _ l1943 _ _ _
+    l1944 _ _ _ l1945 _ _ _ l1946 _ _ _ l1947 _ _ _ l1948 _ _ _ l1949 _ _ _ l1950 _ _ _ l1951 _ _ _
+    l1952 _ _ _ l1953 _ _ _ l1954 _ _ _ l1955 _ _ _ l1956 _ _ _ l1957 _ _ _ l1958 _ _ _ l1959 _ _ _
+    l1960 _ _ _ l1961 _ _ _ l1962 _ _ _ l1963 _ _ _ l1964 _ _ _ l1965 _ _ _ l1966 _ _ _ l1967 _ _ _
+    l1968 _ _ _ l1969 _ _ _ l1970 _ _ _ l1971 _ _ _ l1972 _ _ _ l1973 _ _ _ l1974 _ _ _ l1975 _ _ _
+    l1976 _ _ _ l1977 _ _ _ l1978 _ _ _ l1979 _ _ _ l1980 _ _ _ l1981 _ _ _ l1982 _ _ _ l1983 _ _ _
+    l1984 _ _ _ l1985 _ _ _ l1986 _ _ _ l1987 _ _ _ l1988 _ _ _ l1989 _ _ _ l1990 _ _ _ l1991 _ _ _
+    l1992 _ _ _ l1993 _ _ _ l1994 _ _ _ l1995 _ _ _ l1996 _ _ _ l1997 _ _ _ l1998 _ _ _ l1999 _ _ _
+    l2000 _ _ _ l2001 _ _ _ l2002 _ _ _ l2003 _ _ _ l2004 _ _ _ l2005 _ _ _ l2006 _ _ _ l2007 _ _ _
+    l2008 _ _ _ l2009 _ _ _ l2010 _ _ _ l2011 _ _ _ l2012 _ _ _ l2013 _ _ _ l2014 _ _ _ l2015 _ _ _
+    l2016 _ _ _ l2017 _ _ _ l2018 _ _ _ l2019 _ _ _ l2020 _ _ _ l2021 _ _ _ l2022 _ _ _ l2023 _ _ _
+    l2024 _ _ _ l2025 _ _ _ l2026 _ _ _ l2027 _ _ _ l2028 _ _ _ l2029 _ _ _ l2030 _ _ _ l2031 _ _ _
+    l2032 _ _ _ l2033 _ _ _ l2034 _ _ _ l2035 _ _ _ l2036 _ _ _ l2037 _ _ _ l2038 _ _ _ l2039 _ _ _
+    l2040 _ _ _ l2041 _ _ _ l2042 _ _ _ l2043 _ _ _ l2044 _ _ _ l2045 _ _ _ l2046 _ _ _ l2047 _ _ _
+    l2048 _ _ _ l2049 _ _ _ l2050 _ _ _ l2051 _ _ _ l2052 _ _ _ l2053 _ _ _ l2054 _ _ _ l2055 _ _ _
+    l2056 _ _ _ l2057 _ _ _ l2058 _ _ _ l2059 _ _ _ l2060 _ _ _ l2061 _ _ _ l2062 _ _ _ l2063 _ _ _
+    l2064 _ _ _ l2065 _ _ _ l2066 _ _ _ l2067 _ _ _ l2068 _ _ _ l2069 _ _ _ l2070 _ _ _ l2071 _ _ _
+    l2072 _ _ _ l2073 _ _ _ l2074 _ _ _ l2075 _ _ _ l2076 _ _ _ l2077 _ _ _ l2078 _ _ _ l2079 _ _ _
+    l2080 _ _ _ l2081 _ _ _ l2082 _ _ _ l2083 _ _ _ l2084 _ _ _ l2085 _ _ _ l2086 _ _ _ l2087 _ _ _
+    l2088 _ _ _ l2089 _ _ _ l2090 _ _ _ l2091 _ _ _ l2092 _ _ _ l2093 _ _ _ l2094 _ _ _ l2095 _ _ _
+    l2096 _ _ _ l2097 _ _ _ l2098 _ _ _ l2099 _ _ _ l2100 _ _ _ l2101 _ _ _ l2102 _ _ _ l2103 _ _ _
+    l2104 _ _ _ l2105 _ _ _ l2106 _ _ _ l2107 _ _ _ l2108 _ _ _ l2109 _ _ _ l2110 _ _ _ l2111 _ _ _
+    l2112 _ _ _ l2113 _ _ _ l2114 _ _ _ l2115 _ _ _ l2116 _ _ _ l2117 _ _ _ l2118 _ _ _ l2119 _ _ _
+    l2120 _ _ _ l2121 _ _ _ l2122 _ _ _ l2123 _ _ _ l2124 _ _ _ l2125 _ _ _ l2126 _ _ _ l2127 _ _ _
+    l2128 _ _ _ l2129 _ _ _ l2130 _ _ _ l2131 _ _ _ l2132 _ _ _ l2133 _ _ _ l2134 _ _ _ l2135 _ _ _
+    l2136 _ _ _ l2137 _ _ _ l2138 _ _ _ l2139 _ _ _ l2140 _ _ _ l2141 _ _ _ l2142 _ _ _ l2143 _ _ _
+    l2144 _ _ _ l2145 _ _ _ l2146 _ _ _ l2147 _ _ _ l2148 _ _ _ l2149 _ _ _ l2150 _ _ _ l2151 _ _ _
+    l2152 _ _ _ l2153 _ _ _ l2154 _ _ _ l2155 _ _ _ l2156 _ _ _ l2157 _ _ _ l2158 _ _ _ l2159 _ _ _
+    l2160 _ _ _ l2161 _ _ _ l2162 _ _ _ l2163 _ _ _ l2164 _ _ _ l2165 _ _ _ l2166 _ _ _ l2167 _ _ _
+    l2168 _ _ _ l2169 _ _ _ l2170 _ _ _ l2171 _ _ _ l2172 _ _ _ l2173 _ _ _ l2174 _ _ _ l2175 _ _ _
+    l2176 _ _ _ l2177 _ _ _ l2178 _ _ _ l2179 _ _ _ l2180 _ _ _ l2181 _ _ _ l2182 _ _ _ l2183 _ _ _
+    l2184 _ _ _ l2185 _ _ _ l2186 _ _ _ l2187 _ _ _ l2188 _ _ _ l2189 _ _ _ l2190 _ _ _ l2191 _ _ _
+    l2192 _ _ _ l2193 _ _ _ l2194 _ _ _ l2195 _ _ _ l2196 _ _ _ l2197 _ _ _ l2198 _ _ _ l2199 _ _ _
+    l2200 _ _ _ l2201 _ _ _ l2202 _ _ _ l2203 _ _ _ l2204 _ _ _ l2205 _ _ _ l2206 _ _ _ l2207 _ _ _
+    l2208 _ _ _ l2209 _ _ _ l2210 _ _ _ l2211 _ _ _ l2212 _ _ _ l2213 _ _ _ l2214 _ _ _ l2215 _ _ _
+    l2216 _ _ _ l2217 _ _ _ l2218 _ _ _ l2219 _ _ _ l2220 _ _ _ l2221 _ _ _ l2222 _ _ _ l2223 _ _ _
+    l2224 _ _ _ l2225 _ _ _ l2226 _ _ _ l2227 _ _ _ l2228 _ _ _ l2229 _ _ _ l2230 _ _ _ l2231 _ _ _
+    l2232 _ _ _ l2233 _ _ _ l2234 _ _ _ l2235 _ _ _ l2236 _ _ _ l2237 _ _ _ l2238 _ _ _ l2239 _ _ _
+    l2240 _ _ _ l2241 _ _ _ l2242 _ _ _ l2243 _ _ _ l2244 _ _ _ l2245 _ _ _ l2246 _ _ _ l2247 _ _ _
+    l2248 _ _ _ l2249 _ _ _ l2250 _ _ _ l2251 _ _ _ l2252 _ _ _ l2253 _ _ _ l2254 _ _ _ l2255 _ _ _
+    l2256 _ _ _ l2257 _ _ _ l2258 _ _ _ l2259 _ _ _ l2260 _ _ _ l2261 _ _ _ l2262 _ _ _ l2263 _ _ _
+    l2264 _ _ _ l2265 _ _ _ l2266 _ _ _ l2267 _ _ _ l2268 _ _ _ l2269 _ _ _ l2270 _ _ _ l2271 _ _ _
+    l2272 _ _ _ l2273 _ _ _ l2274 _ _ _ l2275 _ _ _ l2276 _ _ _ l2277 _ _ _ l2278 _ _ _ l2279 _ _ _
+    l2280 _ _ _ l2281 _ _ _ l2282 _ _ _ l2283 _ _ _ l2284 _ _ _ l2285 _ _ _ l2286 _ _ _ l2287 _ _ _
+    l2288 _ _ _ l2289 _ _ _ l2290 _ _ _ l2291 _ _ _ l2292 _ _ _ l2293 _ _ _ l2294 _ _ _ l2295 _ _ _
+    l2296 _ _ _ l2297 _ _ _ l2298 _ _ _ l2299 _ _ _ l2300 _ _ _ l2301 _ _ _ l2302 _ _ _ l2303 _ _ _
+    l2304 _ _ _ l2305 _ _ _ l2306 _ _ _ l2307 _ _ _ l2308 _ _ _ l2309 _ _ _ l2310 _ _ _ l2311 _ _ _
+    l2312 _ _ _ l2313 _ _ _ l2314 _ _ _ l2315 _ _ _ l2316 _ _ _ l2317 _ _ _ l2318 _ _ _ l2319 _ _ _
+    l2320 _ _ _ l2321 _ _ _ l2322 _ _ _ l2323 _ _ _ l2324 _ _ _ l2325 _ _ _ l2326 _ _ _ l2327 _ _ _
+    l2328 _ _ _ l2329 _ _ _ l2330 _ _ _ l2331 _ _ _ l2332 _ _ _ l2333 _ _ _ l2334 _ _ _ l2335 _ _ _
+    l2336 _ _ _ l2337 _ _ _ l2338 _ _ _ l2339 _ _ _ l2340 _ _ _ l2341 _ _ _ l2342 _ _ _ l2343 _ _ _
+    l2344 _ _ _ l2345 _ _ _ l2346 _ _ _ l2347 _ _ _ l2348 _ _ _ l2349 _ _ _ l2350 _ _ _ l2351 _ _ _
+    l2352 _ _ _ l2353 _ _ _ l2354 _ _ _ l2355 _ _ _ l2356 _ _ _ l2357 _ _ _ l2358 _ _ _ l2359 _ _ _
+    l2360 _ _ _ l2361 _ _ _ l2362 _ _ _ l2363 _ _ _ l2364 _ _ _ l2365 _ _ _ l2366 _ _ _ l2367 _ _ _
+    l2368 _ _ _ l2369 _ _ _ l2370 _ _ _ l2371 _ _ _ l2372 _ _ _ l2373 _ _ _ l2374 _ _ _ l2375 _ _ _
+    l2376 _ _ _ l2377 _ _ _ l2378 _ _ _ l2379 _ _ _ l2380 _ _ _ l2381 _ _ _ l2382 _ _ _ l2383 _ _ _
+    l2384 _ _ _ l2385 _ _ _ l2386 _ _ _ l2387 _ _ _ l2388 _ _ _ l2389 _ _ _ l2390 _ _ _ l2391 _ _ _
+    l2392 _ _ _ l2393 _ _ _ l2394 _ _ _ l2395 _ _ _ l2396 _ _ _ l2397 _ _ _ l2398 _ _ _ l2399 _ _ _
+    l2400 _ _ _ l2401 _ _ _ l2402 _ _ _ l2403 _ _ _ l2404 _ _ _ l2405 _ _ _ l2406 _ _ _ l2407 _ _ _
+    l2408 _ _ _ l2409 _ _ _ l2410 _ _ _ l2411 _ _ _ l2412 _ _ _ l2413 _ _ _ l2414 _ _ _ l2415 _ _ _
+    l2416 _ _ _ l2417 _ _ _ l2418 _ _ _ l2419 _ _ _ l2420 _ _ _ l2421 _ _ _ l2422 _ _ _ l2423 _ _ _
+    l2424 _ _ _ l2425 _ _ _ l2426 _ _ _ l2427 _ _ _ l2428 _ _ _ l2429 _ _ _ l2430 _ _ _ l2431 _ _ _
+    l2432 _ _ _ l2433 _ _ _ l2434 _ _ _ l2435 _ _ _ l2436 _ _ _ l2437 _ _ _ l2438 _ _ _ l2439 _ _ _
+    l2440 _ _ _ l2441 _ _ _ l2442 _ _ _ l2443 _ _ _ l2444 _ _ _ l2445 _ _ _ l2446 _ _ _ l2447 _ _ _
+    l2448 _ _ _ l2449 _ _ _ l2450 _ _ _ l2451 _ _ _ l2452 _ _ _ l2453 _ _ _ l2454 _ _ _ l2455 _ _ _
+    l2456 _ _ _ l2457 _ _ _ l2458 _ _ _ l2459 _ _ _ l2460 _ _ _ l2461 _ _ _ l2462 _ _ _ l2463 _ _ _
+    l2464 _ _ _ l2465 _ _ _ l2466 _ _ _ l2467 _ _ _ l2468 _ _ _ l2469 _ _ _ l2470 _ _ _ l2471 _ _ _
+    l2472 _ _ _ l2473 _ _ _ l2474 _ _ _ l2475 _ _ _ l2476 _ _ _ l2477 _ _ _ l2478 _ _ _ l2479 _ _ _
+    l2480 _ _ _ l2481 _ _ _ l2482 _ _ _ l2483 _ _ _ l2484 _ _ _ l2485 _ _ _ l2486 _ _ _ l2487 _ _ _
+    l2488 _ _ _ l2489 _ _ _ l2490 _ _ _ l2491 _ _ _ l2492 _ _ _ l2493 _ _ _ l2494 _ _ _ l2495 _ _ _
+    l2496 _ _ _ l2497 _ _ _ l2498 _ _ _ l2499 _ _ _ l2500 _ _ _ l2501 _ _ _ l2502 _ _ _ l2503 _ _ _
+    l2504 _ _ _ l2505 _ _ _ l2506 _ _ _ l2507 _ _ _ l2508 _ _ _ l2509 _ _ _ l2510 _ _ _ l2511 _ _ _
+    l2512 _ _ _ l2513 _ _ _ l2514 _ _ _ l2515 _ _ _ l2516 _ _ _ l2517 _ _ _ l2518 _ _ _ l2519 _ _ _
+    l2520 _ _ _ l2521 _ _ _ l2522 _ _ _ l2523 _ _ _ l2524 _ _ _ l2525 _ _ _ l2526 _ _ _ l2527 _ _ _
+    l2528 _ _ _ l2529 _ _ _ l2530 _ _ _ l2531 _ _ _ l2532 _ _ _ l2533 _ _ _ l2534 _ _ _ l2535 _ _ _
+    l2536 _ _ _ l2537 _ _ _ l2538 _ _ _ l2539 _ _ _ l2540 _ _ _ l2541 _ _ _ l2542 _ _ _ l2543 _ _ _
+    l2544 _ _ _ l2545 _ _ _ l2546 _ _ _ l2547 _ _ _ l2548 _ _ _ l2549 _ _ _ l2550 _ _ _ l2551 _ _ _
+    l2552 _ _ _ l2553 _ _ _ l2554 _ _ _ l2555 _ _ _ l2556 _ _ _ l2557 _ _ _ l2558 _ _ _ l2559 _ _ _
+    l2560 _ _ _ l2561 _ _ _ l2562 _ _ _ l2563 _ _ _ l2564 _ _ _ l2565 _ _ _ l2566 _ _ _ l2567 _ _ _
+    l2568 _ _ _ l2569 _ _ _ l2570 _ _ _ l2571 _ _ _ l2572 _ _ _ l2573 _ _ _ l2574 _ _ _ l2575 _ _ _
+    l2576 _ _ _ l2577 _ _ _ l2578 _ _ _ l2579 _ _ _ l2580 _ _ _ l2581 _ _ _ l2582 _ _ _ l2583 _ _ _
+    l2584 _ _ _ l2585 _ _ _ l2586 _ _ _ l2587 _ _ _ l2588 _ _ _ l2589 _ _ _ l2590 _ _ _ l2591 _ _ _
+    l2592 _ _ _ l2593 _ _ _ l2594 _ _ _ l2595 _ _ _ l2596 _ _ _ l2597 _ _ _ l2598 _ _ _ l2599 _ _ _
+    l2600 _ _ _ l2601 _ _ _ l2602 _ _ _ l2603 _ _ _ l2604 _ _ _ l2605 _ _ _ l2606 _ _ _ l2607 _ _ _
+    l2608 _ _ _ l2609 _ _ _ l2610 _ _ _ l2611 _ _ _ l2612 _ _ _ l2613 _ _ _ l2614 _ _ _ l2615 _ _ _
+    l2616 _ _ _ l2617 _ _ _ l2618 _ _ _ l2619 _ _ _ l2620 _ _ _ l2621 _ _ _ l2622 _ _ _ l2623 _ _ _
+    l2624 _ _ _ l2625 _ _ _ l2626 _ _ _ l2627 _ _ _ l2628 _ _ _ l2629 _ _ _ l2630 _ _ _ l2631 _ _ _
+    l2632 _ _ _ l2633 _ _ _ l2634 _ _ _ l2635 _ _ _ l2636 _ _ _ l2637 _ _ _ l2638 _ _ _ l2639 _ _ _
+    l2640 _ _ _ l2641 _ _ _ l2642 _ _ _ l2643 _ _ _ l2644 _ _ _ l2645 _ _ _ l2646 _ _ _ l2647 _ _ _
+    l2648 _ _ _ l2649 _ _ _ l2650 _ _ _ l2651 _ _ _ l2652 _ _ _ l2653 _ _ _ l2654 _ _ _ l2655 _ _ _
+    l2656 _ _ _ l2657 _ _ _ l2658 _ _ _ l2659 _ _ _ l2660 _ _ _ l2661 _ _ _ l2662 _ _ _ l2663 _ _ _
+    l2664 _ _ _ l2665 _ _ _ l2666 _ _ _ l2667 _ _ _ l2668 _ _ _ l2669 _ _ _ l2670 _ _ _ l2671 _ _ _
+    l2672 _ _ _ l2673 _ _ _ l2674 _ _ _ l2675 _ _ _ l2676 _ _ _ l2677 _ _ _ l2678 _ _ _ l2679 _ _ _
+    l2680 _ _ _ l2681 _ _ _ l2682 _ _ _ l2683 _ _ _ l2684 _ _ _ l2685 _ _ _ l2686 _ _ _ l2687 _ _ _
+    l2688 _ _ _ l2689 _ _ _ l2690 _ _ _ l2691 _ _ _ l2692 _ _ _ l2693 _ _ _ l2694 _ _ _ l2695 _ _ _
+    l2696 _ _ _ l2697 _ _ _ l2698 _ _ _ l2699 _ _ _ l2700 _ _ _ l2701 _ _ _ l2702 _ _ _ l2703 _ _ _
+    l2704 _ _ _ l2705 _ _ _ l2706 _ _ _ l2707 _ _ _ l2708 _ _ _ l2709 _ _ _ l2710 _ _ _ l2711 _ _ _
+    l2712 _ _ _ l2713 _ _ _ l2714 _ _ _ l2715 _ _ _ l2716 _ _ _ l2717 _ _ _ l2718 _ _ _ l2719 _ _ _
+    l2720 _ _ _ l2721 _ _ _ l2722 _ _ _ l2723 _ _ _ l2724 _ _ _ l2725 _ _ _ l2726 _ _ _ l2727 _ _ _
+    l2728 _ _ _ l2729 _ _ _ l2730 _ _ _ l2731 _ _ _ l2732 _ _ _ l2733 _ _ _ l2734 _ _ _ l2735 _ _ _
+    l2736 _ _ _ l2737 _ _ _ l2738 _ _ _ l2739 _ _ _ l2740 _ _ _ l2741 _ _ _ l2742 _ _ _ l2743 _ _ _
+    l2744 _ _ _ l2745 _ _ _ l2746 _ _ _ l2747 _ _ _ l2748 _ _ _ l2749 _ _ _ l2750 _ _ _ l2751 _ _ _
+    l2752 _ _ _ l2753 _ _ _ l2754 _ _ _ l2755 _ _ _ l2756 _ _ _ l2757 _ _ _ l2758 _ _ _ l2759 _ _ _
+    l2760 _ _ _ l2761 _ _ _ l2762 _ _ _ l2763 _ _ _ l2764 _ _ _ l2765 _ _ _ l2766 _ _ _ l2767 _ _ _
+    l2768 _ _ _ l2769 _ _ _ l2770 _ _ _ l2771 _ _ _ l2772 _ _ _ l2773 _ _ _ l2774 _ _ _ l2775 _ _ _
+    l2776 _ _ _ l2777 _ _ _ l2778 _ _ _ l2779 _ _ _ l2780 _ _ _ l2781 _ _ _ l2782 _ _ _ l2783 _ _ _
+    l2784 _ _ _ l2785 _ _ _ l2786 _ _ _ l2787 _ _ _ l2788 _ _ _ l2789 _ _ _ l2790 _ _ _ l2791 _ _ _
+    l2792 _ _ _ l2793 _ _ _ l2794 _ _ _ l2795 _ _ _ l2796 _ _ _ l2797 _ _ _ l2798 _ _ _ l2799 _ _ _
+    l2800 _ _ _ l2801 _ _ _ l2802 _ _ _ l2803 _ _ _ l2804 _ _ _ l2805 _ _ _ l2806 _ _ _ l2807 _ _ _
+    l2808 _ _ _ l2809 _ _ _ l2810 _ _ _ l2811 _ _ _ l2812 _ _ _ l2813 _ _ _ l2814 _ _ _ l2815 _ _ _
+    l2816 _ _ _ l2817 _ _ _ l2818 _ _ _ l2819 _ _ _ l2820 _ _ _ l2821 _ _ _ l2822 _ _ _ l2823 _ _ _
+    l2824 _ _ _ l2825 _ _ _ l2826 _ _ _ l2827 _ _ _ l2828 _ _ _ l2829 _ _ _ l2830 _ _ _ l2831 _ _ _
+    l2832 _ _ _ l2833 _ _ _ l2834 _ _ _ l2835 _ _ _ l2836 _ _ _ l2837 _ _ _ l2838 _ _ _ l2839 _ _ _
+    l2840 _ _ _ l2841 _ _ _ l2842 _ _ _ l2843 _ _ _ l2844 _ _ _ l2845 _ _ _ l2846 _ _ _ l2847 _ _ _
+    l2848 _ _ _ l2849 _ _ _ l2850 _ _ _ l2851 _ _ _ l2852 _ _ _ l2853 _ _ _ l2854 _ _ _ l2855 _ _ _
+    l2856 _ _ _ l2857 _ _ _ l2858 _ _ _ l2859 _ _ _ l2860 _ _ _ l2861 _ _ _ l2862 _ _ _ l2863 _ _ _
+    l2864 _ _ _ l2865 _ _ _ l2866 _ _ _ l2867 _ _ _ l2868 _ _ _ l2869 _ _ _ l2870 _ _ _ l2871 _ _ _
+    l2872 _ _ _ l2873 _ _ _ l2874 _ _ _ l2875 _ _ _ l2876 _ _ _ l2877 _ _ _ l2878 _ _ _ l2879 _ _ _
+    l2880 _ _ _ l2881 _ _ _ l2882 _ _ _ l2883 _ _ _ l2884 _ _ _ l2885 _ _ _ l2886 _ _ _ l2887 _ _ _
+    l2888 _ _ _ l2889 _ _ _ l2890 _ _ _ l2891 _ _ _ l2892 _ _ _ l2893 _ _ _ l2894 _ _ _ l2895 _ _ _
+    l2896 _ _ _ l2897 _ _ _ l2898 _ _ _ l2899 _ _ _ l2900 _ _ _ l2901 _ _ _ l2902 _ _ _ l2903 _ _ _
+    l2904 _ _ _ l2905 _ _ _ l2906 _ _ _ l2907 _ _ _ l2908 _ _ _ l2909 _ _ _ l2910 _ _ _ l2911 _ _ _
+    l2912 _ _ _ l2913 _ _ _ l2914 _ _ _ l2915 _ _ _ l2916 _ _ _ l2917 _ _ _ l2918 _ _ _ l2919 _ _ _
+    l2920 _ _ _ l2921 _ _ _ l2922 _ _ _ l2923 _ _ _ l2924 _ _ _ l2925 _ _ _ l2926 _ _ _ l2927 _ _ _
+    l2928 _ _ _ l2929 _ _ _ l2930 _ _ _ l2931 _ _ _ l2932 _ _ _ l2933 _ _ _ l2934 _ _ _ l2935 _ _ _
+    l2936 _ _ _ l2937 _ _ _ l2938 _ _ _ l2939 _ _ _ l2940 _ _ _ l2941 _ _ _ l2942 _ _ _ l2943 _ _ _
+    l2944 _ _ _ l2945 _ _ _ l2946 _ _ _ l2947 _ _ _ l2948 _ _ _ l2949 _ _ _ l2950 _ _ _ l2951 _ _ _
+    l2952 _ _ _ l2953 _ _ _ l2954 _ _ _ l2955 _ _ _ l2956 _ _ _ l2957 _ _ _ l2958 _ _ _ l2959 _ _ _
+    l2960 _ _ _ l2961 _ _ _ l2962 _ _ _ l2963 _ _ _ l2964 _ _ _ l2965 _ _ _ l2966 _ _ _ l2967 _ _ _
+    l2968 _ _ _ l2969 _ _ _ l2970 _ _ _ l2971 _ _ _ l2972 _ _ _ l2973 _ _ _ l2974 _ _ _ l2975 _ _ _
+    l2976 _ _ _ l2977 _ _ _ l2978 _ _ _ l2979 _ _ _ l2980 _ _ _ l2981 _ _ _ l2982 _ _ _ l2983 _ _ _
+    l2984 _ _ _ l2985 _ _ _ l2986 _ _ _ l2987 _ _ _ l2988 _ _ _ l2989 _ _ _ l2990 _ _ _ l2991 _ _ _
+    l2992 _ _ _ l2993 _ _ _ l2994 _ _ _ l2995 _ _ _ l2996 _ _ _ l2997 _ _ _ l2998 _ _ _ l2999 _ _ _
+    l3000 _ _ _ l3001 _ _ _ l3002 _ _ _ l3003 _ _ _ l3004 _ _ _ l3005 _ _ _ l3006 _ _ _ l3007 _ _ _
+    l3008 _ _ _ l3009 _ _ _ l3010 _ _ _ l3011 _ _ _ l3012 _ _ _ l3013 _ _ _ l3014 _ _ _ l3015 _ _ _
+    l3016 _ _ _ l3017 _ _ _ l3018 _ _ _ l3019 _ _ _ l3020 _ _ _ l3021 _ _ _ l3022 _ _ _ l3023 _ _ _
+    l3024 _ _ _ l3025 _ _ _ l3026 _ _ _ l3027 _ _ _ l3028 _ _ _ l3029 _ _ _ l3030 _ _ _ l3031 _ _ _
+    l3032 _ _ _ l3033 _ _ _ l3034 _ _ _ l3035 _ _ _ l3036 _ _ _ l3037 _ _ _ l3038 _ _ _ l3039 _ _ _
+    l3040 _ _ _ l3041 _ _ _ l3042 _ _ _ l3043 _ _ _ l3044 _ _ _ l3045 _ _ _ l3046 _ _ _ l3047 _ _ _
+    l3048 _ _ _ l3049 _ _ _ l3050 _ _ _ l3051 _ _ _ l3052 _ _ _ l3053 _ _ _ l3054 _ _ _ l3055 _ _ _
+    l3056 _ _ _ l3057 _ _ _ l3058 _ _ _ l3059 _ _ _ l3060 _ _ _ l3061 _ _ _ l3062 _ _ _ l3063 _ _ _
+    l3064 _ _ _ l3065 _ _ _ l3066 _ _ _ l3067 _ _ _ l3068 _ _ _ l3069 _ _ _ l3070 _ _ _ l3071 _ _ _
+    l3072 _ _ _ l3073 _ _ _ l3074 _ _ _ l3075 _ _ _ l3076 _ _ _ l3077 _ _ _ l3078 _ _ _ l3079 _ _ _
+    l3080 _ _ _ l3081 _ _ _ l3082 _ _ _ l3083 _ _ _ l3084 _ _ _ l3085 _ _ _ l3086 _ _ _ l3087 _ _ _
+    l3088 _ _ _ l3089 _ _ _ l3090 _ _ _ l3091 _ _ _ l3092 _ _ _ l3093 _ _ _ l3094 _ _ _ l3095 _ _ _
+    l3096 _ _ _ l3097 _ _ _ l3098 _ _ _ l3099 _ _ _ l3100 _ _ _ l3101 _ _ _ l3102 _ _ _ l3103 _ _ _
+    l3104 _ _ _ l3105 _ _ _ l3106 _ _ _ l3107 _ _ _ l3108 _ _ _ l3109 _ _ _ l3110 _ _ _ l3111 _ _ _
+    l3112 _ _ _ l3113 _ _ _ l3114 _ _ _ l3115 _ _ _ l3116 _ _ _ l3117 _ _ _ l3118 _ _ _ l3119 _ _ _
+    l3120 _ _ _ l3121 _ _ _ l3122 _ _ _ l3123 _ _ _ l3124 _ _ _ l3125 _ _ _ l3126 _ _ _ l3127 _ _ _
+    l3128 _ _ _ l3129 _ _ _ l3130 _ _ _ l3131 _ _ _ l3132 _ _ _ l3133 _ _ _ l3134 _ _ _ l3135 _ _ _
+    l3136 _ _ _ l3137 _ _ _ l3138 _ _ _ l3139 _ _ _ l3140 _ _ _ l3141 _ _ _ l3142 _ _ _ l3143 _ _ _
+    l3144 _ _ _ l3145 _ _ _ l3146 _ _ _ l3147 _ _ _ l3148 _ _ _ l3149 _ _ _ l3150 _ _ _ l3151 _ _ _
+    l3152 _ _ _ l3153 _ _ _ l3154 _ _ _ l3155 _ _ _ l3156 _ _ _ l3157 _ _ _ l3158 _ _ _ l3159 _ _ _
+    l3160 _ _ _ l3161 _ _ _ l3162 _ _ _ l3163 _ _ _ l3164 _ _ _ l3165 _ _ _ l3166 _ _ _ l3167 _ _ _
+    l3168 _ _ _ l3169 _ _ _ l3170 _ _ _ l3171 _ _ _ l3172 _ _ _ l3173 _ _ _ l3174 _ _ _ l3175 _ _ _
+    l3176 _ _ _ l3177 _ _ _ l3178 _ _ _ l3179 _ _ _ l3180 _ _ _ l3181 _ _ _ l3182 _ _ _ l3183 _ _ _
+    l3184 _ _ _ l3185 _ _ _ l3186 _ _ _ l3187 _ _ _ l3188 _ _ _ l3189 _ _ _ l3190 _ _ _ l3191 _ _ _
+    l3192 _ _ _ l3193 _ _ _ l3194 _ _ _ l3195 _ _ _ l3196 _ _ _ l3197 _ _ _ l3198 _ _ _ l3199 _ _ _
+    l3200 _ _ _ l3201 _ _ _ l3202 _ _ _ l3203 _ _ _ l3204 _ _ _ l3205 _ _ _ l3206 _ _ _ l3207 _ _ _
+    l3208 _ _ _ l3209 _ _ _ l3210 _ _ _ l3211 _ _ _ l3212 _ _ _ l3213 _ _ _ l3214 _ _ _ l3215 _ _ _
+    l3216 _ _ _ l3217 _ _ _ l3218 _ _ _ l3219 _ _ _ l3220 _ _ _ l3221 _ _ _ l3222 _ _ _ l3223 _ _ _
+    l3224 _ _ _ l3225 _ _ _ l3226 _ _ _ l3227 _ _ _ l3228 _ _ _ l3229 _ _ _ l3230 _ _ _ l3231 _ _ _
+    l3232 _ _ _ l3233 _ _ _ l3234 _ _ _ l3235 _ _ _ l3236 _ _ _ l3237 _ _ _ l3238 _ _ _ l3239 _ _ _
+    l3240 _ _ _ l3241 _ _ _ l3242 _ _ _ l3243 _ _ _ l3244 _ _ _ l3245 _ _ _ l3246 _ _ _ l3247 _ _ _
+    l3248 _ _ _ l3249 _ _ _ l3250 _ _ _ l3251 _ _ _ l3252 _ _ _ l3253 _ _ _ l3254 _ _ _ l3255 _ _ _
+    l3256 _ _ _ l3257 _ _ _ l3258 _ _ _ l3259 _ _ _ l3260 _ _ _ l3261 _ _ _ l3262 _ _ _ l3263 _ _ _
+    l3264 _ _ _ l3265 _ _ _ l3266 _ _ _ l3267 _ _ _ l3268 _ _ _ l3269 _ _ _ l3270 _ _ _ l3271 _ _ _
+    l3272 _ _ _ l3273 _ _ _ l3274 _ _ _ l3275 _ _ _ l3276 _ _ _ l3277 _ _ _ l3278 _ _ _ l3279 _ _ _
+    l3280 _ _ _ l3281 _ _ _ l3282 _ _ _ l3283 _ _ _ l3284 _ _ _ l3285 _ _ _ l3286 _ _ _ l3287 _ _ _
+    l3288 _ _ _ l3289 _ _ _ l3290 _ _ _ l3291 _ _ _ l3292 _ _ _ l3293 _ _ _ l3294 _ _ _ l3295 _ _ _
+    l3296 _ _ _ l3297 _ _ _ l3298 _ _ _ l3299 _ _ _ l3300 _ _ _ l3301 _ _ _ l3302 _ _ _ l3303 _ _ _
+    l3304 _ _ _ l3305 _ _ _ l3306 _ _ _ l3307 _ _ _ l3308 _ _ _ l3309 _ _ _ l3310 _ _ _ l3311 _ _ _
+    l3312 _ _ _ l3313 _ _ _ l3314 _ _ _ l3315 _ _ _ l3316 _ _ _ l3317 _ _ _ l3318 _ _ _ l3319 _ _ _
+    l3320 _ _ _ l3321 _ _ _ l3322 _ _ _ l3323 _ _ _ l3324 _ _ _ l3325 _ _ _ l3326 _ _ _ l3327 _ _ _
+    l3328 _ _ _ l3329 _ _ _ l3330 _ _ _ l3331 _ _ _ l3332 _ _ _ l3333 _ _ _ l3334 _ _ _ l3335 _ _ _
+    l3336 _ _ _ l3337 _ _ _ l3338 _ _ _ l3339 _ _ _ l3340 _ _ _ l3341 _ _ _ l3342 _ _ _ l3343 _ _ _
+    l3344 _ _ _ l3345 _ _ _ l3346 _ _ _ l3347 _ _ _ l3348 _ _ _ l3349 _ _ _ l3350 _ _ _ l3351 _ _ _
+    l3352 _ _ _ l3353 _ _ _ l3354 _ _ _ l3355 _ _ _ l3356 _ _ _ l3357 _ _ _ l3358 _ _ _ l3359 _ _ _
+    l3360 _ _ _ l3361 _ _ _ l3362 _ _ _ l3363 _ _ _ l3364 _ _ _ l3365 _ _ _ l3366 _ _ _ l3367 _ _ _
+    l3368 _ _ _ l3369 _ _ _ l3370 _ _ _ l3371 _ _ _ l3372 _ _ _ l3373 _ _ _ l3374 _ _ _ l3375 _ _ _
+    l3376 _ _ _ l3377 _ _ _ l3378 _ _ _ l3379 _ _ _ l3380 _ _ _ l3381 _ _ _ l3382 _ _ _ l3383 _ _ _
+    l3384 _ _ _ l3385 _ _ _ l3386 _ _ _ l3387 _ _ _ l3388 _ _ _ l3389 _ _ _ l3390 _ _ _ l3391 _ _ _
+    l3392 _ _ _ l3393 _ _ _ l3394 _ _ _ l3395 _ _ _ l3396 _ _ _ l3397 _ _ _ l3398 _ _ _ l3399 _ _ _
+    l3400 _ _ _ l3401 _ _ _ l3402 _ _ _ l3403 _ _ _ l3404 _ _ _ l3405 _ _ _ l3406 _ _ _ l3407 _ _ _
+    l3408 _ _ _ l3409 _ _ _ l3410 _ _ _ l3411 _ _ _ l3412 _ _ _ l3413 _ _ _ l3414 _ _ _ l3415 _ _ _
+    l3416 _ _ _ l3417 _ _ _ l3418 _ _ _ l3419 _ _ _ l3420 _ _ _ l3421 _ _ _ l3422 _ _ _ l3423 _ _ _
+    l3424 _ _ _ l3425 _ _ _ l3426 _ _ _ l3427 _ _ _ l3428 _ _ _ l3429 _ _ _ l3430 _ _ _ l3431 _ _ _
+    l3432 _ _ _ l3433 _ _ _ l3434 _ _ _ l3435 _ _ _ l3436 _ _ _ l3437 _ _ _ l3438 _ _ _ l3439 _ _ _
+    l3440 _ _ _ l3441 _ _ _ l3442 _ _ _ l3443 _ _ _ l3444 _ _ _ l3445 _ _ _ l3446 _ _ _ l3447 _ _ _
+    l3448 _ _ _ l3449 _ _ _ l3450 _ _ _ l3451 _ _ _ l3452 _ _ _ l3453 _ _ _ l3454 _ _ _ l3455 _ _ _
+    l3456 _ _ _ l3457 _ _ _ l3458 _ _ _ l3459 _ _ _ l3460 _ _ _ l3461 _ _ _ l3462 _ _ _ l3463 _ _ _
+    l3464 _ _ _ l3465 _ _ _ l3466 _ _ _ l3467 _ _ _ l3468 _ _ _ l3469 _ _ _ l3470 _ _ _ l3471 _ _ _
+    l3472 _ _ _ l3473 _ _ _ l3474 _ _ _ l3475 _ _ _ l3476 _ _ _ l3477 _ _ _ l3478 _ _ _ l3479 _ _ _
+    l3480 _ _ _ l3481 _ _ _ l3482 _ _ _ l3483 _ _ _ l3484 _ _ _ l3485 _ _ _ l3486 _ _ _ l3487 _ _ _
+    l3488 _ _ _ l3489 _ _ _ l3490 _ _ _ l3491 _ _ _ l3492 _ _ _ l3493 _ _ _ l3494 _ _ _ l3495 _ _ _
+    l3496 _ _ _ l3497 _ _ _ l3498 _ _ _ l3499 _ _ _ l3500 _ _ _ l3501 _ _ _ l3502 _ _ _ l3503 _ _ _
+    l3504 _ _ _ l3505 _ _ _ l3506 _ _ _ l3507 _ _ _ l3508 _ _ _ l3509 _ _ _ l3510 _ _ _ l3511 _ _ _
+    l3512 _ _ _ l3513 _ _ _ l3514 _ _ _ l3515 _ _ _ l3516 _ _ _ l3517 _ _ _ l3518 _ _ _ l3519 _ _ _
+    l3520 _ _ _ l3521 _ _ _ l3522 _ _ _ l3523 _ _ _ l3524 _ _ _ l3525 _ _ _ l3526 _ _ _ l3527 _ _ _
+    l3528 _ _ _ l3529 _ _ _ l3530 _ _ _ l3531 _ _ _ l3532 _ _ _ l3533 _ _ _ l3534 _ _ _ l3535 _ _ _
+    l3536 _ _ _ l3537 _ _ _ l3538 _ _ _ l3539 _ _ _ l3540 _ _ _ l3541 _ _ _ l3542 _ _ _ l3543 _ _ _
+    l3544 _ _ _ l3545 _ _ _ l3546 _ _ _ l3547 _ _ _ l3548 _ _ _ l3549 _ _ _ l3550 _ _ _ l3551 _ _ _
+    l3552 _ _ _ l3553 _ _ _ l3554 _ _ _ l3555 _ _ _ l3556 _ _ _ l3557 _ _ _ l3558 _ _ _ l3559 _ _ _
+    l3560 _ _ _ l3561 _ _ _ l3562 _ _ _ l3563 _ _ _ l3564 _ _ _ l3565 _ _ _ l3566 _ _ _ l3567 _ _ _
+    l3568 _ _ _ l3569 _ _ _ l3570 _ _ _ l3571 _ _ _ l3572 _ _ _ l3573 _ _ _ l3574 _ _ _ l3575 _ _ _
+    l3576 _ _ _ l3577 _ _ _ l3578 _ _ _ l3579 _ _ _ l3580 _ _ _ l3581 _ _ _ l3582 _ _ _ l3583 _ _ _
+    l3584 _ _ _ l3585 _ _ _ l3586 _ _ _ l3587 _ _ _ l3588 _ _ _ l3589 _ _ _ l3590 _ _ _ l3591 _ _ _
+    l3592 _ _ _ l3593 _ _ _ l3594 _ _ _ l3595 _ _ _ l3596 _ _ _ l3597 _ _ _ l3598 _ _ _ l3599 _ _ _
+    l3600 _ _ _ l3601 _ _ _ l3602 _ _ _ l3603 _ _ _ l3604 _ _ _ l3605 _ _ _ l3606 _ _ _ l3607 _ _ _
+    l3608 _ _ _ l3609 _ _ _ l3610 _ _ _ l3611 _ _ _ l3612 _ _ _ l3613 _ _ _ l3614 _ _ _ l3615 _ _ _
+    l3616 _ _ _ l3617 _ _ _ l3618 _ _ _ l3619 _ _ _ l3620 _ _ _ l3621 _ _ _ l3622 _ _ _ l3623 _ _ _
+    l3624 _ _ _ l3625 _ _ _ l3626 _ _ _ l3627 _ _ _ l3628 _ _ _ l3629 _ _ _ l3630 _ _ _ l3631 _ _ _
+    l3632 _ _ _ l3633 _ _ _ l3634 _ _ _ l3635 _ _ _ l3636 _ _ _ l3637 _ _ _ l3638 _ _ _ l3639 _ _ _
+    l3640 _ _ _ l3641 _ _ _ l3642 _ _ _ l3643 _ _ _ l3644 _ _ _ l3645 _ _ _ l3646 _ _ _ l3647 _ _ _
+    l3648 _ _ _ l3649 _ _ _ l3650 _ _ _ l3651 _ _ _ l3652 _ _ _ l3653 _ _ _ l3654 _ _ _ l3655 _ _ _
+    l3656 _ _ _ l3657 _ _ _ l3658 _ _ _ l3659 _ _ _ l3660 _ _ _ l3661 _ _ _ l3662 _ _ _ l3663 _ _ _
+    l3664 _ _ _ l3665 _ _ _ l3666 _ _ _ l3667 _ _ _ l3668 _ _ _ l3669 _ _ _ l3670 _ _ _ l3671 _ _ _
+    l3672 _ _ _ l3673 _ _ _ l3674 _ _ _ l3675 _ _ _ l3676 _ _ _ l3677 _ _ _ l3678 _ _ _ l3679 _ _ _
+    l3680 _ _ _ l3681 _ _ _ l3682 _ _ _ l3683 _ _ _ l3684 _ _ _ l3685 _ _ _ l3686 _ _ _ l3687 _ _ _
+    l3688 _ _ _ l3689 _ _ _ l3690 _ _ _ l3691 _ _ _ l3692 _ _ _ l3693 _ _ _ l3694 _ _ _ l3695 _ _ _
+    l3696 _ _ _ l3697 _ _ _ l3698 _ _ _ l3699 _ _ _ l3700 _ _ _ l3701 _ _ _ l3702 _ _ _ l3703 _ _ _
+    l3704 _ _ _ l3705 _ _ _ l3706 _ _ _ l3707 _ _ _ l3708 _ _ _ l3709 _ _ _ l3710 _ _ _ l3711 _ _ _
+    l3712 _ _ _ l3713 _ _ _ l3714 _ _ _ l3715 _ _ _ l3716 _ _ _ l3717 _ _ _ l3718 _ _ _ l3719 _ _ _
+    l3720 _ _ _ l3721 _ _ _ l3722 _ _ _ l3723 _ _ _ l3724 _ _ _ l3725 _ _ _ l3726 _ _ _ l3727 _ _ _
+    l3728 _ _ _ l3729 _ _ _ l3730 _ _ _ l3731 _ _ _ l3732 _ _ _ l3733 _ _ _ l3734 _ _ _ l3735 _ _ _
+    l3736 _ _ _ l3737 _ _ _ l3738 _ _ _ l3739 _ _ _ l3740 _ _ _ l3741 _ _ _ l3742 _ _ _ l3743 _ _ _
+    l3744 _ _ _ l3745 _ _ _ l3746 _ _ _ l3747 _ _ _ l3748 _ _ _ l3749 _ _ _ l3750 _ _ _ l3751 _ _ _
+    l3752 _ _ _ l3753 _ _ _ l3754 _ _ _ l3755 _ _ _ l3756 _ _ _ l3757 _ _ _ l3758 _ _ _ l3759 _ _ _
+    l3760 _ _ _ l3761 _ _ _ l3762 _ _ _ l3763 _ _ _ l3764 _ _ _ l3765 _ _ _ l3766 _ _ _ l3767 _ _ _
+    l3768 _ _ _ l3769 _ _ _ l3770 _ _ _ l3771 _ _ _ l3772 _ _ _ l3773 _ _ _ l3774 _ _ _ l3775 _ _ _
+    l3776 _ _ _ l3777 _ _ _ l3778 _ _ _ l3779 _ _ _ l3780 _ _ _ l3781 _ _ _ l3782 _ _ _ l3783 _ _ _
+    l3784 _ _ _ l3785 _ _ _ l3786 _ _ _ l3787 _ _ _ l3788 _ _ _ l3789 _ _ _ l3790 _ _ _ l3791 _ _ _
+    l3792 _ _ _ l3793 _ _ _ l3794 _ _ _ l3795 _ _ _ l3796 _ _ _ l3797 _ _ _ l3798 _ _ _ l3799 _ _ _
+    l3800 _ _ _ l3801 _ _ _ l3802 _ _ _ l3803 _ _ _ l3804 _ _ _ l3805 _ _ _ l3806 _ _ _ l3807 _ _ _
+    l3808 _ _ _ l3809 _ _ _ l3810 _ _ _ l3811 _ _ _ l3812 _ _ _ l3813 _ _ _ l3814 _ _ _ l3815 _ _ _
+    l3816 _ _ _ l3817 _ _ _ l3818 _ _ _ l3819 _ _ _ l3820 _ _ _ l3821 _ _ _ l3822 _ _ _ l3823 _ _ _
+    l3824 _ _ _ l3825 _ _ _ l3826 _ _ _ l3827 _ _ _ l3828 _ _ _ l3829 _ _ _ l3830 _ _ _ l3831 _ _ _
+    l3832 _ _ _ l3833 _ _ _ l3834 _ _ _ l3835 _ _ _ l3836 _ _ _ l3837 _ _ _ l3838 _ _ _ l3839 _ _ _
+    l3840 _ _ _ l3841 _ _ _ l3842 _ _ _ l3843 _ _ _ l3844 _ _ _ l3845 _ _ _ l3846 _ _ _ l3847 _ _ _
+    l3848 _ _ _ l3849 _ _ _ l3850 _ _ _ l3851 _ _ _ l3852 _ _ _ l3853 _ _ _ l3854 _ _ _ l3855 _ _ _
+    l3856 _ _ _ l3857 _ _ _ l3858 _ _ _ l3859 _ _ _ l3860 _ _ _ l3861 _ _ _ l3862 _ _ _ l3863 _ _ _
+    l3864 _ _ _ l3865 _ _ _ l3866 _ _ _ l3867 _ _ _ l3868 _ _ _ l3869 _ _ _ l3870 _ _ _ l3871 _ _ _
+    l3872 _ _ _ l3873 _ _ _ l3874 _ _ _ l3875 _ _ _ l3876 _ _ _ l3877 _ _ _ l3878 _ _ _ l3879 _ _ _
+    l3880 _ _ _ l3881 _ _ _ l3882 _ _ _ l3883 _ _ _ l3884 _ _ _ l3885 _ _ _ l3886 _ _ _ l3887 _ _ _
+    l3888 _ _ _ l3889 _ _ _ l3890 _ _ _ l3891 _ _ _ l3892 _ _ _ l3893 _ _ _ l3894 _ _ _ l3895 _ _ _
+    l3896 _ _ _ l3897 _ _ _ l3898 _ _ _ l3899 _ _ _ l3900 _ _ _ l3901 _ _ _ l3902 _ _ _ l3903 _ _ _
+    l3904 _ _ _ l3905 _ _ _ l3906 _ _ _ l3907 _ _ _ l3908 _ _ _ l3909 _ _ _ l3910 _ _ _ l3911 _ _ _
+    l3912 _ _ _ l3913 _ _ _ l3914 _ _ _ l3915 _ _ _ l3916 _ _ _ l3917 _ _ _ l3918 _ _ _ l3919 _ _ _
+    l3920 _ _ _ l3921 _ _ _ l3922 _ _ _ l3923 _ _ _ l3924 _ _ _ l3925 _ _ _ l3926 _ _ _ l3927 _ _ _
+    l3928 _ _ _ l3929 _ _ _ l3930 _ _ _ l3931 _ _ _ l3932 _ _ _ l3933 _ _ _ l3934 _ _ _ l3935 _ _ _
+    l3936 _ _ _ l3937 _ _ _ l3938 _ _ _ l3939 _ _ _ l3940 _ _ _ l3941 _ _ _ l3942 _ _ _ l3943 _ _ _
+    l3944 _ _ _ l3945 _ _ _ l3946 _ _ _ l3947 _ _ _ l3948 _ _ _ l3949 _ _ _ l3950 _ _ _ l3951 _ _ _
+    l3952 _ _ _ l3953 _ _ _ l3954 _ _ _ l3955 _ _ _ l3956 _ _ _ l3957 _ _ _ l3958 _ _ _ l3959 _ _ _
+    l3960 _ _ _ l3961 _ _ _ l3962 _ _ _ l3963 _ _ _ l3964 _ _ _ l3965 _ _ _ l3966 _ _ _ l3967 _ _ _
+    l3968 _ _ _ l3969 _ _ _ l3970 _ _ _ l3971 _ _ _ l3972 _ _ _ l3973 _ _ _ l3974 _ _ _ l3975 _ _ _
+    l3976 _ _ _ l3977 _ _ _ l3978 _ _ _ l3979 _ _ _ l3980 _ _ _ l3981 _ _ _ l3982 _ _ _ l3983 _ _ _
+    l3984 _ _ _ l3985 _ _ _ l3986 _ _ _ l3987 _ _ _ l3988 _ _ _ l3989 _ _ _ l3990 _ _ _ l3991 _ _ _
+    l3992 _ _ _ l3993 _ _ _ l3994 _ _ _ l3995 _ _ _ l3996 _ _ _ l3997 _ _ _ l3998 _ _ _ l3999 _ _ _
+    l4000 _ _ _ l4001 _ _ _ l4002 _ _ _ l4003 _ _ _ l4004 _ _ _ l4005 _ _ _ l4006 _ _ _ l4007 _ _ _
+    l4008 _ _ _ l4009 _ _ _ l4010 _ _ _ l4011 _ _ _ l4012 _ _ _ l4013 _ _ _ l4014 _ _ _ l4015 _ _ _
+    l4016 _ _ _ l4017 _ _ _ l4018 _ _ _ l4019 _ _ _ l4020 _ _ _ l4021 _ _ _ l4022 _ _ _ l4023 _ _ _
+    l4024 _ _ _ l4025 _ _ _ l4026 _ _ _ l4027 _ _ _ l4028 _ _ _ l4029 _ _ _ l4030 _ _ _ l4031 _ _ _
+    l4032 _ _ _ l4033 _ _ _ l4034 _ _ _ l4035 _ _ _ l4036 _ _ _ l4037 _ _ _ l4038 _ _ _ l4039 _ _ _
+    l4040 _ _ _ l4041 _ _ _ l4042 _ _ _ l4043 _ _ _ l4044 _ _ _ l4045 _ _ _ l4046 _ _ _ l4047 _ _ _
+    l4048 _ _ _ l4049 _ _ _ l4050 _ _ _ l4051 _ _ _ l4052 _ _ _ l4053 _ _ _ l4054 _ _ _ l4055 _ _ _
+    l4056 _ _ _ l4057 _ _ _ l4058 _ _ _ l4059 _ _ _ l4060 _ _ _ l4061 _ _ _ l4062 _ _ _ l4063 _ _ _
+    l4064 _ _ _ l4065 _ _ _ l4066 _ _ _ l4067 _ _ _ l4068 _ _ _ l4069 _ _ _ l4070 _ _ _ l4071 _ _ _
+    l4072 _ _ _ l4073 _ _ _ l4074 _ _ _ l4075 _ _ _ l4076 _ _ _ l4077 _ _ _ l4078 _ _ _ l4079 _ _ _
+    l4080 _ _ _ l4081 _ _ _ l4082 _ _ _ l4083 _ _ _ l4084 _ _ _ l4085 _ _ _ l4086 _ _ _ l4087 _ _ _
+    l4088 _ _ _ l4089 _ _ _ l4090 _ _ _ l4091 _ _ _ l4092 _ _ _ l4093 _ _ _ l4094 _ _ _ l4095 _ _ _
+];
+
+# Artificial registers used to hold function inputs
+# Only used for the decompiler - emulation places inputs in locals directly
+define register offset=$(REG_INPUTS_BASE) size=16 [
+      i0o   i1o   i2o   i3o   i4o   i5o   i6o   i7o
+      i8o   i9o  i10o  i11o  i12o  i13o  i14o  i15o
+     i16o  i17o  i18o  i19o  i20o  i21o  i22o  i23o
+     i24o  i25o  i26o  i27o  i28o  i29o  i30o  i31o
+     i32o  i33o  i34o  i35o  i36o  i37o  i38o  i39o
+     i40o  i41o  i42o  i43o  i44o  i45o  i46o  i47o
+     i48o  i49o  i50o  i51o  i52o  i53o  i54o  i55o
+     i56o  i57o  i58o  i59o  i60o  i61o  i62o  i63o
+     i64o  i65o  i66o  i67o  i68o  i69o  i70o  i71o
+     i72o  i73o  i74o  i75o  i76o  i77o  i78o  i79o
+     i80o  i81o  i82o  i83o  i84o  i85o  i86o  i87o
+     i88o  i89o  i90o  i91o  i92o  i93o  i94o  i95o
+     i96o  i97o  i98o  i99o i100o i101o i102o i103o
+    i104o i105o i106o i107o i108o i109o i110o i111o
+    i112o i113o i114o i115o i116o i117o i118o i119o
+    i120o i121o i122o i123o i124o i125o i126o i127o
+    i128o i129o i130o i131o i132o i133o i134o i135o
+    i136o i137o i138o i139o i140o i141o i142o i143o
+    i144o i145o i146o i147o i148o i149o i150o i151o
+    i152o i153o i154o i155o i156o i157o i158o i159o
+    i160o i161o i162o i163o i164o i165o i166o i167o
+    i168o i169o i170o i171o i172o i173o i174o i175o
+    i176o i177o i178o i179o i180o i181o i182o i183o
+    i184o i185o i186o i187o i188o i189o i190o i191o
+    i192o i193o i194o i195o i196o i197o i198o i199o
+    i200o i201o i202o i203o i204o i205o i206o i207o
+    i208o i209o i210o i211o i212o i213o i214o i215o
+    i216o i217o i218o i219o i220o i221o i222o i223o
+    i224o i225o i226o i227o i228o i229o i230o i231o
+    i232o i233o i234o i235o i236o i237o i238o i239o
+    i240o i241o i242o i243o i244o i245o i246o i247o
+    i248o i249o i250o i251o i252o i253o i254o i255o
+];
+define register offset=$(REG_INPUTS_BASE) size=8 [
+      i0q _   i1q _   i2q _   i3q _   i4q _   i5q _   i6q _   i7q _
+      i8q _   i9q _  i10q _  i11q _  i12q _  i13q _  i14q _  i15q _
+     i16q _  i17q _  i18q _  i19q _  i20q _  i21q _  i22q _  i23q _
+     i24q _  i25q _  i26q _  i27q _  i28q _  i29q _  i30q _  i31q _
+     i32q _  i33q _  i34q _  i35q _  i36q _  i37q _  i38q _  i39q _
+     i40q _  i41q _  i42q _  i43q _  i44q _  i45q _  i46q _  i47q _
+     i48q _  i49q _  i50q _  i51q _  i52q _  i53q _  i54q _  i55q _
+     i56q _  i57q _  i58q _  i59q _  i60q _  i61q _  i62q _  i63q _
+     i64q _  i65q _  i66q _  i67q _  i68q _  i69q _  i70q _  i71q _
+     i72q _  i73q _  i74q _  i75q _  i76q _  i77q _  i78q _  i79q _
+     i80q _  i81q _  i82q _  i83q _  i84q _  i85q _  i86q _  i87q _
+     i88q _  i89q _  i90q _  i91q _  i92q _  i93q _  i94q _  i95q _
+     i96q _  i97q _  i98q _  i99q _ i100q _ i101q _ i102q _ i103q _
+    i104q _ i105q _ i106q _ i107q _ i108q _ i109q _ i110q _ i111q _
+    i112q _ i113q _ i114q _ i115q _ i116q _ i117q _ i118q _ i119q _
+    i120q _ i121q _ i122q _ i123q _ i124q _ i125q _ i126q _ i127q _
+    i128q _ i129q _ i130q _ i131q _ i132q _ i133q _ i134q _ i135q _
+    i136q _ i137q _ i138q _ i139q _ i140q _ i141q _ i142q _ i143q _
+    i144q _ i145q _ i146q _ i147q _ i148q _ i149q _ i150q _ i151q _
+    i152q _ i153q _ i154q _ i155q _ i156q _ i157q _ i158q _ i159q _
+    i160q _ i161q _ i162q _ i163q _ i164q _ i165q _ i166q _ i167q _
+    i168q _ i169q _ i170q _ i171q _ i172q _ i173q _ i174q _ i175q _
+    i176q _ i177q _ i178q _ i179q _ i180q _ i181q _ i182q _ i183q _
+    i184q _ i185q _ i186q _ i187q _ i188q _ i189q _ i190q _ i191q _
+    i192q _ i193q _ i194q _ i195q _ i196q _ i197q _ i198q _ i199q _
+    i200q _ i201q _ i202q _ i203q _ i204q _ i205q _ i206q _ i207q _
+    i208q _ i209q _ i210q _ i211q _ i212q _ i213q _ i214q _ i215q _
+    i216q _ i217q _ i218q _ i219q _ i220q _ i221q _ i222q _ i223q _
+    i224q _ i225q _ i226q _ i227q _ i228q _ i229q _ i230q _ i231q _
+    i232q _ i233q _ i234q _ i235q _ i236q _ i237q _ i238q _ i239q _
+    i240q _ i241q _ i242q _ i243q _ i244q _ i245q _ i246q _ i247q _
+    i248q _ i249q _ i250q _ i251q _ i252q _ i253q _ i254q _ i255q _
+];
+define register offset=$(REG_INPUTS_BASE) size=4 [
+      i0 _ _ _   i1 _ _ _   i2 _ _ _   i3 _ _ _   i4 _ _ _   i5 _ _ _   i6 _ _ _   i7 _ _ _
+      i8 _ _ _   i9 _ _ _  i10 _ _ _  i11 _ _ _  i12 _ _ _  i13 _ _ _  i14 _ _ _  i15 _ _ _
+     i16 _ _ _  i17 _ _ _  i18 _ _ _  i19 _ _ _  i20 _ _ _  i21 _ _ _  i22 _ _ _  i23 _ _ _
+     i24 _ _ _  i25 _ _ _  i26 _ _ _  i27 _ _ _  i28 _ _ _  i29 _ _ _  i30 _ _ _  i31 _ _ _
+     i32 _ _ _  i33 _ _ _  i34 _ _ _  i35 _ _ _  i36 _ _ _  i37 _ _ _  i38 _ _ _  i39 _ _ _
+     i40 _ _ _  i41 _ _ _  i42 _ _ _  i43 _ _ _  i44 _ _ _  i45 _ _ _  i46 _ _ _  i47 _ _ _
+     i48 _ _ _  i49 _ _ _  i50 _ _ _  i51 _ _ _  i52 _ _ _  i53 _ _ _  i54 _ _ _  i55 _ _ _
+     i56 _ _ _  i57 _ _ _  i58 _ _ _  i59 _ _ _  i60 _ _ _  i61 _ _ _  i62 _ _ _  i63 _ _ _
+     i64 _ _ _  i65 _ _ _  i66 _ _ _  i67 _ _ _  i68 _ _ _  i69 _ _ _  i70 _ _ _  i71 _ _ _
+     i72 _ _ _  i73 _ _ _  i74 _ _ _  i75 _ _ _  i76 _ _ _  i77 _ _ _  i78 _ _ _  i79 _ _ _
+     i80 _ _ _  i81 _ _ _  i82 _ _ _  i83 _ _ _  i84 _ _ _  i85 _ _ _  i86 _ _ _  i87 _ _ _
+     i88 _ _ _  i89 _ _ _  i90 _ _ _  i91 _ _ _  i92 _ _ _  i93 _ _ _  i94 _ _ _  i95 _ _ _
+     i96 _ _ _  i97 _ _ _  i98 _ _ _  i99 _ _ _ i100 _ _ _ i101 _ _ _ i102 _ _ _ i103 _ _ _
+    i104 _ _ _ i105 _ _ _ i106 _ _ _ i107 _ _ _ i108 _ _ _ i109 _ _ _ i110 _ _ _ i111 _ _ _
+    i112 _ _ _ i113 _ _ _ i114 _ _ _ i115 _ _ _ i116 _ _ _ i117 _ _ _ i118 _ _ _ i119 _ _ _
+    i120 _ _ _ i121 _ _ _ i122 _ _ _ i123 _ _ _ i124 _ _ _ i125 _ _ _ i126 _ _ _ i127 _ _ _
+    i128 _ _ _ i129 _ _ _ i130 _ _ _ i131 _ _ _ i132 _ _ _ i133 _ _ _ i134 _ _ _ i135 _ _ _
+    i136 _ _ _ i137 _ _ _ i138 _ _ _ i139 _ _ _ i140 _ _ _ i141 _ _ _ i142 _ _ _ i143 _ _ _
+    i144 _ _ _ i145 _ _ _ i146 _ _ _ i147 _ _ _ i148 _ _ _ i149 _ _ _ i150 _ _ _ i151 _ _ _
+    i152 _ _ _ i153 _ _ _ i154 _ _ _ i155 _ _ _ i156 _ _ _ i157 _ _ _ i158 _ _ _ i159 _ _ _
+    i160 _ _ _ i161 _ _ _ i162 _ _ _ i163 _ _ _ i164 _ _ _ i165 _ _ _ i166 _ _ _ i167 _ _ _
+    i168 _ _ _ i169 _ _ _ i170 _ _ _ i171 _ _ _ i172 _ _ _ i173 _ _ _ i174 _ _ _ i175 _ _ _
+    i176 _ _ _ i177 _ _ _ i178 _ _ _ i179 _ _ _ i180 _ _ _ i181 _ _ _ i182 _ _ _ i183 _ _ _
+    i184 _ _ _ i185 _ _ _ i186 _ _ _ i187 _ _ _ i188 _ _ _ i189 _ _ _ i190 _ _ _ i191 _ _ _
+    i192 _ _ _ i193 _ _ _ i194 _ _ _ i195 _ _ _ i196 _ _ _ i197 _ _ _ i198 _ _ _ i199 _ _ _
+    i200 _ _ _ i201 _ _ _ i202 _ _ _ i203 _ _ _ i204 _ _ _ i205 _ _ _ i206 _ _ _ i207 _ _ _
+    i208 _ _ _ i209 _ _ _ i210 _ _ _ i211 _ _ _ i212 _ _ _ i213 _ _ _ i214 _ _ _ i215 _ _ _
+    i216 _ _ _ i217 _ _ _ i218 _ _ _ i219 _ _ _ i220 _ _ _ i221 _ _ _ i222 _ _ _ i223 _ _ _
+    i224 _ _ _ i225 _ _ _ i226 _ _ _ i227 _ _ _ i228 _ _ _ i229 _ _ _ i230 _ _ _ i231 _ _ _
+    i232 _ _ _ i233 _ _ _ i234 _ _ _ i235 _ _ _ i236 _ _ _ i237 _ _ _ i238 _ _ _ i239 _ _ _
+    i240 _ _ _ i241 _ _ _ i242 _ _ _ i243 _ _ _ i244 _ _ _ i245 _ _ _ i246 _ _ _ i247 _ _ _
+    i248 _ _ _ i249 _ _ _ i250 _ _ _ i251 _ _ _ i252 _ _ _ i253 _ _ _ i254 _ _ _ i255 _ _ _
+];
+
+# Artificial registers used to hold function outputs
+define register offset=$(REG_OUTPUTS_BASE) size=16 [
+      o0o   o1o   o2o   o3o   o4o   o5o   o6o   o7o
+      o8o   o9o  o10o  o11o  o12o  o13o  o14o  o15o
+     o16o  o17o  o18o  o19o  o20o  o21o  o22o  o23o
+     o24o  o25o  o26o  o27o  o28o  o29o  o30o  o31o
+     o32o  o33o  o34o  o35o  o36o  o37o  o38o  o39o
+     o40o  o41o  o42o  o43o  o44o  o45o  o46o  o47o
+     o48o  o49o  o50o  o51o  o52o  o53o  o54o  o55o
+     o56o  o57o  o58o  o59o  o60o  o61o  o62o  o63o
+     o64o  o65o  o66o  o67o  o68o  o69o  o70o  o71o
+     o72o  o73o  o74o  o75o  o76o  o77o  o78o  o79o
+     o80o  o81o  o82o  o83o  o84o  o85o  o86o  o87o
+     o88o  o89o  o90o  o91o  o92o  o93o  o94o  o95o
+     o96o  o97o  o98o  o99o o100o o101o o102o o103o
+    o104o o105o o106o o107o o108o o109o o110o o111o
+    o112o o113o o114o o115o o116o o117o o118o o119o
+    o120o o121o o122o o123o o124o o125o o126o o127o
+    o128o o129o o130o o131o o132o o133o o134o o135o
+    o136o o137o o138o o139o o140o o141o o142o o143o
+    o144o o145o o146o o147o o148o o149o o150o o151o
+    o152o o153o o154o o155o o156o o157o o158o o159o
+    o160o o161o o162o o163o o164o o165o o166o o167o
+    o168o o169o o170o o171o o172o o173o o174o o175o
+    o176o o177o o178o o179o o180o o181o o182o o183o
+    o184o o185o o186o o187o o188o o189o o190o o191o
+    o192o o193o o194o o195o o196o o197o o198o o199o
+    o200o o201o o202o o203o o204o o205o o206o o207o
+    o208o o209o o210o o211o o212o o213o o214o o215o
+    o216o o217o o218o o219o o220o o221o o222o o223o
+    o224o o225o o226o o227o o228o o229o o230o o231o
+    o232o o233o o234o o235o o236o o237o o238o o239o
+    o240o o241o o242o o243o o244o o245o o246o o247o
+    o248o o249o o250o o251o o252o o253o o254o o255o
+];
+define register offset=$(REG_OUTPUTS_BASE) size=8 [
+      o0q _   o1q _   o2q _   o3q _   o4q _   o5q _   o6q _   o7q _
+      o8q _   o9q _  o10q _  o11q _  o12q _  o13q _  o14q _  o15q _
+     o16q _  o17q _  o18q _  o19q _  o20q _  o21q _  o22q _  o23q _
+     o24q _  o25q _  o26q _  o27q _  o28q _  o29q _  o30q _  o31q _
+     o32q _  o33q _  o34q _  o35q _  o36q _  o37q _  o38q _  o39q _
+     o40q _  o41q _  o42q _  o43q _  o44q _  o45q _  o46q _  o47q _
+     o48q _  o49q _  o50q _  o51q _  o52q _  o53q _  o54q _  o55q _
+     o56q _  o57q _  o58q _  o59q _  o60q _  o61q _  o62q _  o63q _
+     o64q _  o65q _  o66q _  o67q _  o68q _  o69q _  o70q _  o71q _
+     o72q _  o73q _  o74q _  o75q _  o76q _  o77q _  o78q _  o79q _
+     o80q _  o81q _  o82q _  o83q _  o84q _  o85q _  o86q _  o87q _
+     o88q _  o89q _  o90q _  o91q _  o92q _  o93q _  o94q _  o95q _
+     o96q _  o97q _  o98q _  o99q _ o100q _ o101q _ o102q _ o103q _
+    o104q _ o105q _ o106q _ o107q _ o108q _ o109q _ o110q _ o111q _
+    o112q _ o113q _ o114q _ o115q _ o116q _ o117q _ o118q _ o119q _
+    o120q _ o121q _ o122q _ o123q _ o124q _ o125q _ o126q _ o127q _
+    o128q _ o129q _ o130q _ o131q _ o132q _ o133q _ o134q _ o135q _
+    o136q _ o137q _ o138q _ o139q _ o140q _ o141q _ o142q _ o143q _
+    o144q _ o145q _ o146q _ o147q _ o148q _ o149q _ o150q _ o151q _
+    o152q _ o153q _ o154q _ o155q _ o156q _ o157q _ o158q _ o159q _
+    o160q _ o161q _ o162q _ o163q _ o164q _ o165q _ o166q _ o167q _
+    o168q _ o169q _ o170q _ o171q _ o172q _ o173q _ o174q _ o175q _
+    o176q _ o177q _ o178q _ o179q _ o180q _ o181q _ o182q _ o183q _
+    o184q _ o185q _ o186q _ o187q _ o188q _ o189q _ o190q _ o191q _
+    o192q _ o193q _ o194q _ o195q _ o196q _ o197q _ o198q _ o199q _
+    o200q _ o201q _ o202q _ o203q _ o204q _ o205q _ o206q _ o207q _
+    o208q _ o209q _ o210q _ o211q _ o212q _ o213q _ o214q _ o215q _
+    o216q _ o217q _ o218q _ o219q _ o220q _ o221q _ o222q _ o223q _
+    o224q _ o225q _ o226q _ o227q _ o228q _ o229q _ o230q _ o231q _
+    o232q _ o233q _ o234q _ o235q _ o236q _ o237q _ o238q _ o239q _
+    o240q _ o241q _ o242q _ o243q _ o244q _ o245q _ o246q _ o247q _
+    o248q _ o249q _ o250q _ o251q _ o252q _ o253q _ o254q _ o255q _
+];
+define register offset=$(REG_OUTPUTS_BASE) size=4 [
+      o0 _ _ _   o1 _ _ _   o2 _ _ _   o3 _ _ _   o4 _ _ _   o5 _ _ _   o6 _ _ _   o7 _ _ _
+      o8 _ _ _   o9 _ _ _  o10 _ _ _  o11 _ _ _  o12 _ _ _  o13 _ _ _  o14 _ _ _  o15 _ _ _
+     o16 _ _ _  o17 _ _ _  o18 _ _ _  o19 _ _ _  o20 _ _ _  o21 _ _ _  o22 _ _ _  o23 _ _ _
+     o24 _ _ _  o25 _ _ _  o26 _ _ _  o27 _ _ _  o28 _ _ _  o29 _ _ _  o30 _ _ _  o31 _ _ _
+     o32 _ _ _  o33 _ _ _  o34 _ _ _  o35 _ _ _  o36 _ _ _  o37 _ _ _  o38 _ _ _  o39 _ _ _
+     o40 _ _ _  o41 _ _ _  o42 _ _ _  o43 _ _ _  o44 _ _ _  o45 _ _ _  o46 _ _ _  o47 _ _ _
+     o48 _ _ _  o49 _ _ _  o50 _ _ _  o51 _ _ _  o52 _ _ _  o53 _ _ _  o54 _ _ _  o55 _ _ _
+     o56 _ _ _  o57 _ _ _  o58 _ _ _  o59 _ _ _  o60 _ _ _  o61 _ _ _  o62 _ _ _  o63 _ _ _
+     o64 _ _ _  o65 _ _ _  o66 _ _ _  o67 _ _ _  o68 _ _ _  o69 _ _ _  o70 _ _ _  o71 _ _ _
+     o72 _ _ _  o73 _ _ _  o74 _ _ _  o75 _ _ _  o76 _ _ _  o77 _ _ _  o78 _ _ _  o79 _ _ _
+     o80 _ _ _  o81 _ _ _  o82 _ _ _  o83 _ _ _  o84 _ _ _  o85 _ _ _  o86 _ _ _  o87 _ _ _
+     o88 _ _ _  o89 _ _ _  o90 _ _ _  o91 _ _ _  o92 _ _ _  o93 _ _ _  o94 _ _ _  o95 _ _ _
+     o96 _ _ _  o97 _ _ _  o98 _ _ _  o99 _ _ _ o100 _ _ _ o101 _ _ _ o102 _ _ _ o103 _ _ _
+    o104 _ _ _ o105 _ _ _ o106 _ _ _ o107 _ _ _ o108 _ _ _ o109 _ _ _ o110 _ _ _ o111 _ _ _
+    o112 _ _ _ o113 _ _ _ o114 _ _ _ o115 _ _ _ o116 _ _ _ o117 _ _ _ o118 _ _ _ o119 _ _ _
+    o120 _ _ _ o121 _ _ _ o122 _ _ _ o123 _ _ _ o124 _ _ _ o125 _ _ _ o126 _ _ _ o127 _ _ _
+    o128 _ _ _ o129 _ _ _ o130 _ _ _ o131 _ _ _ o132 _ _ _ o133 _ _ _ o134 _ _ _ o135 _ _ _
+    o136 _ _ _ o137 _ _ _ o138 _ _ _ o139 _ _ _ o140 _ _ _ o141 _ _ _ o142 _ _ _ o143 _ _ _
+    o144 _ _ _ o145 _ _ _ o146 _ _ _ o147 _ _ _ o148 _ _ _ o149 _ _ _ o150 _ _ _ o151 _ _ _
+    o152 _ _ _ o153 _ _ _ o154 _ _ _ o155 _ _ _ o156 _ _ _ o157 _ _ _ o158 _ _ _ o159 _ _ _
+    o160 _ _ _ o161 _ _ _ o162 _ _ _ o163 _ _ _ o164 _ _ _ o165 _ _ _ o166 _ _ _ o167 _ _ _
+    o168 _ _ _ o169 _ _ _ o170 _ _ _ o171 _ _ _ o172 _ _ _ o173 _ _ _ o174 _ _ _ o175 _ _ _
+    o176 _ _ _ o177 _ _ _ o178 _ _ _ o179 _ _ _ o180 _ _ _ o181 _ _ _ o182 _ _ _ o183 _ _ _
+    o184 _ _ _ o185 _ _ _ o186 _ _ _ o187 _ _ _ o188 _ _ _ o189 _ _ _ o190 _ _ _ o191 _ _ _
+    o192 _ _ _ o193 _ _ _ o194 _ _ _ o195 _ _ _ o196 _ _ _ o197 _ _ _ o198 _ _ _ o199 _ _ _
+    o200 _ _ _ o201 _ _ _ o202 _ _ _ o203 _ _ _ o204 _ _ _ o205 _ _ _ o206 _ _ _ o207 _ _ _
+    o208 _ _ _ o209 _ _ _ o210 _ _ _ o211 _ _ _ o212 _ _ _ o213 _ _ _ o214 _ _ _ o215 _ _ _
+    o216 _ _ _ o217 _ _ _ o218 _ _ _ o219 _ _ _ o220 _ _ _ o221 _ _ _ o222 _ _ _ o223 _ _ _
+    o224 _ _ _ o225 _ _ _ o226 _ _ _ o227 _ _ _ o228 _ _ _ o229 _ _ _ o230 _ _ _ o231 _ _ _
+    o232 _ _ _ o233 _ _ _ o234 _ _ _ o235 _ _ _ o236 _ _ _ o237 _ _ _ o238 _ _ _ o239 _ _ _
+    o240 _ _ _ o241 _ _ _ o242 _ _ _ o243 _ _ _ o244 _ _ _ o245 _ _ _ o246 _ _ _ o247 _ _ _
+    o248 _ _ _ o249 _ _ _ o250 _ _ _ o251 _ _ _ o252 _ _ _ o253 _ _ _ o254 _ _ _ o255 _ _ _
+];
+
+# Artificial temporary registers used to hold block arguments during branches
+define register offset=$(REG_TEMP_BASE) size=16 [ t0o ];
+define register offset=$(REG_TEMP_BASE) size=4 [ t0 ];
+
+# Shadow stack registers used to store the locals, stacks and return addresses for other frames during emulation
+# The current function's locals and stack are always stored in l*/s* registers.
+define register offset=$(REG_SSTACK_BASE) size=4 [ ss0 ];
+
+# All context registers are set by the pre-analyzer
+define context contextreg
+	ctx_is_directive = (0, 0) noflow
+	ctx_is_return = (1, 1) noflow
+	ctx_is_global_sp = (2, 2) noflow
+	ctx_directive_type = (3, 5) noflow
+	ctx_operand_size = (6, 13) noflow
+	ctx_case_index = (32, 63) noflow
+	ctx_br_target = (64, 95) noflow
+	ctx_sp = (96, 127) noflow
+;
+
+@define DIRECTIVE_CASE 0
+@define DIRECTIVE_DEFAULT 1
+@define DIRECTIVE_LOCALS 2
+@define DIRECTIVE_LOCAL 3
+
+# Include contents of WebAssembly.sinc file
+@include "WebAssembly.sinc"
diff --git a/Ghidra/Processors/WebAssembly/ghidra_scripts/analyze_dyncalls.py b/Ghidra/Processors/WebAssembly/ghidra_scripts/analyze_dyncalls.py
new file mode 100644
index 0000000000..3ef82c81c4
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/ghidra_scripts/analyze_dyncalls.py
@@ -0,0 +1,120 @@
+## ###
+#  IP: GHIDRA
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+##
+
+# Analyze Emscripten export::dynCall_* functions to identify which table
+# elements they call, and rename functions listed in the table by their dynCall
+# type and index. These dynCall indices are often used as function pointers in
+# compiled C/C++ code.
+# This script should only be used if your dynCall_ functions contain binary AND
+# operations (i.e. i32.and), indicating that the table is segmented into type-
+# specific power-of-two-sized chunks.
+# @author nneonneo
+# @category Analysis.Wasm
+# @keybinding
+# @menupath
+# @toolbar
+
+from __future__ import print_function
+from ghidra.program.model.symbol import SourceType
+
+l0 = currentProgram.getRegister("l0")
+progspace = currentProgram.addressFactory.getAddressSpace("ram")
+tablespace = currentProgram.addressFactory.getAddressSpace("table")
+# We insert every dynCall index into a special namespace so that function pointers
+# can be easily resolved.
+# The format is dynCall::func_{calltype}_{index}.
+dynCallNamespace = currentProgram.symbolTable.getOrCreateNameSpace(currentProgram.globalNamespace, "dynCall", SourceType.USER_DEFINED)
+dynCalls = {}
+
+def getConst(inst):
+    if inst.mnemonicString != "i32.const":
+        raise Exception("Expected a constant")
+    return inst.getOpObjects(0)[0].value
+
+def getTableFunction(offset):
+    funcAddr = getInt(tablespace.getAddress(offset * 4)) & 0xffffffff
+    return getFunctionAt(progspace.getAddress(funcAddr))
+
+def analyzeDyncall(function, calltype=None):
+    if calltype is None:
+        calltype = function.name.split("_", 1)[1]
+    # Iterate instructions backwards
+    instIterator = currentProgram.listing.getInstructions(function.body, False)
+    for inst in instIterator:
+        if inst.mnemonicString == "call_indirect":
+            break
+        elif inst.mnemonicString == "call":
+            # forwarding to another function
+            addr = inst.getOpObjects(0)[0]
+            func = getFunctionAt(addr)
+            # Note: name the new function in the global namespace,
+            # unlike the parent function which is in the export namespace
+            func.setName("dynCall_" + calltype, SourceType.USER_DEFINED)
+            return analyzeDyncall(func, calltype)
+    else:
+        raise Exception("call_indirect not found")
+
+    offset = 0
+    mask = 0xffffffff
+    while 1:
+        inst = next(instIterator)
+        if inst.mnemonicString == "i32.add":
+            offset = getConst(next(instIterator))
+        elif inst.mnemonicString == "i32.and":
+            mask = getConst(next(instIterator))
+        elif inst.mnemonicString == "i32.const":
+            offset = getConst(inst)
+            mask = 0
+            break
+        elif inst.mnemonicString == "local.get":
+            if inst.getRegister(0) != l0:
+                raise Exception("source is not l0?")
+            break
+        else:
+            raise Exception("Unrecognized instruction " + str(inst))
+
+    dynCalls[calltype] = (offset, mask)
+
+def renameDyncalls(calltype):
+    offset, mask = dynCalls.get(calltype, (0, 0))
+    nullFunc = getTableFunction(offset)
+    if nullFunc:
+        nullFunc.setName("nullFuncPtr_" + calltype, SourceType.USER_DEFINED)
+    else:
+        print("Warning: table index %d is invalid - has the table been loaded?" % offset)
+    monitor.setMessage("Renaming " + calltype + " functions")
+    monitor.initialize(mask)
+    for i in range(mask+1):
+        monitor.setProgress(i)
+        func = getTableFunction(offset + i)
+        if func:
+            name = "func_" + calltype + "_%d" % i
+            if func.name.startswith("unnamed_function_"):
+                func.setName(name, SourceType.ANALYSIS)
+            currentProgram.symbolTable.createLabel(func.entryPoint, name, dynCallNamespace, SourceType.USER_DEFINED)
+        else:
+            print("Warning: table index %d is invalid - has the table been loaded?" % (offset + i))
+
+for function in currentProgram.functionManager.getFunctions(True):
+    if function.parentNamespace.name == "export" and function.name.startswith("dynCall_"):
+        monitor.setMessage("Analyzing " + function.name)
+        try:
+            analyzeDyncall(function)
+        except Exception as e:
+            print("Failed to analyze %s: %s" % (function, e))
+
+for calltype in dynCalls:
+    renameDyncalls(calltype)
diff --git a/Ghidra/Processors/WebAssembly/ghidra_scripts/emulate_writev.py b/Ghidra/Processors/WebAssembly/ghidra_scripts/emulate_writev.py
new file mode 100644
index 0000000000..96d56814d5
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/ghidra_scripts/emulate_writev.py
@@ -0,0 +1,57 @@
+## ###
+#  IP: GHIDRA
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+##
+
+# A sample script to demonstrate emulation and function hooking with Wasm programs.
+# @author nneonneo
+# @category Analysis.Wasm
+# @keybinding
+# @menupath
+# @toolbar
+
+from __future__ import print_function
+from ghidra.app.emulator import EmulatorHelper
+from ghidra.program.emulation import WasmEmulationHelper
+import struct
+
+main = currentProgram.listing.getFunctions("export", "main")[0]
+emuHelper = EmulatorHelper(currentProgram)
+emuHelper.writeRegister(emuHelper.getPCRegister(), main.entryPoint.offset)
+wasmHelper = WasmEmulationHelper(emuHelper.language)
+ramSpace = currentProgram.addressFactory.defaultAddressSpace
+
+syscall3Addr = currentProgram.listing.getFunctions("import::env", "__syscall3")[0].entryPoint
+emuHelper.setBreakpoint(syscall3Addr)
+while 1:
+    if not emuHelper.run(monitor):
+        raise Exception("Emulation stopped: " + emuHelper.lastError)
+    if emuHelper.executionAddress == syscall3Addr:
+        l0 = emuHelper.readRegister("l0")
+        l1 = emuHelper.readRegister("l1")
+        l2 = emuHelper.readRegister("l2")
+        l3 = emuHelper.readRegister("l3")
+        if l0 == 146: # writev
+            # Read iovec array
+            data = emuHelper.readMemory(ramSpace.getAddress(l2), l3 * 8)
+            iovecs = [struct.unpack_from("<II", data.tostring(), 8 * i) for i in range(l3)]
+            msg = []
+            for io_base, io_len in iovecs:
+                if io_len:
+                    msg.append(emuHelper.readMemory(ramSpace.getAddress(io_base), io_len).tostring())
+            msg = "".join(msg)
+            print("writev:", repr(msg))
+            wasmHelper.simulateReturn(emuHelper.emulator, len(msg))
+        else:
+            wasmHelper.simulateReturn(emuHelper.emulator, -1)
diff --git a/Ghidra/Processors/WebAssembly/ghidra_scripts/rename_table_funcs.py b/Ghidra/Processors/WebAssembly/ghidra_scripts/rename_table_funcs.py
new file mode 100644
index 0000000000..4c4350a0b5
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/ghidra_scripts/rename_table_funcs.py
@@ -0,0 +1,47 @@
+## ###
+#  IP: GHIDRA
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+##
+
+# Rename dynamically-callable functions from the function table.
+# This is useful for analyzing programs where table indices are used as
+# function pointers, e.g. programs compiled with LLVM.
+# Note: if you have "dynCall_" functions that contain arithmetic operations
+# (AND, ADD, etc.) you may want to use analyze_dyncalls.py instead.
+# @author nneonneo
+# @category Analysis.Wasm
+# @keybinding
+# @menupath
+# @toolbar
+
+from __future__ import print_function
+from wasm.analysis import WasmAnalysis
+from ghidra.program.model.symbol import SourceType
+
+progspace = currentProgram.addressFactory.getAddressSpace("ram")
+tablespace = currentProgram.addressFactory.getAddressSpace("table")
+dynCallNamespace = currentProgram.symbolTable.getOrCreateNameSpace(currentProgram.globalNamespace, "dynCall", SourceType.USER_DEFINED)
+
+def getTableFunction(offset):
+    funcAddr = getInt(tablespace.getAddress(offset * 4)) & 0xffffffff
+    return getFunctionAt(progspace.getAddress(funcAddr))
+
+count = WasmAnalysis.getState(currentProgram).module.nonImportedTables[0].limits.initial
+for i in range(1, count):
+    func = getTableFunction(i)
+    if func:
+        name = "func_%d" % i
+        if func.name.startswith("unnamed_function_"):
+            func.setName(name, SourceType.ANALYSIS)
+        currentProgram.symbolTable.createLabel(func.entryPoint, name, dynCallNamespace, SourceType.USER_DEFINED)
diff --git a/Ghidra/Processors/WebAssembly/ghidra_scripts/spectest.py b/Ghidra/Processors/WebAssembly/ghidra_scripts/spectest.py
new file mode 100644
index 0000000000..b2ced8efa9
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/ghidra_scripts/spectest.py
@@ -0,0 +1,400 @@
+## ###
+#  IP: GHIDRA
+#
+#  Licensed under the Apache License, Version 2.0 (the "License");
+#  you may not use this file except in compliance with the License.
+#  You may obtain a copy of the License at
+#
+#       http://www.apache.org/licenses/LICENSE-2.0
+#
+#  Unless required by applicable law or agreed to in writing, software
+#  distributed under the License is distributed on an "AS IS" BASIS,
+#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+#  See the License for the specific language governing permissions and
+#  limitations under the License.
+##
+
+# A script to test the WebAssembly emulator against a .wast test suite.
+# As input, provide the .json file generated by wast2json.
+# It is recommended to run this script headless, as follows:
+# analyzeHeadless <projDir> <projName> -preScript spectest.py <test.json>
+# @author nneonneo
+# @category Analysis.Wasm
+# @keybinding
+# @menupath
+# @toolbar
+from __future__ import print_function
+import os
+import sys
+import json
+import struct
+
+from java.io import File
+from java.math import BigInteger
+from ghidra.app.emulator import EmulatorHelper
+from ghidra.app.plugin.core.analysis import AutoAnalysisManager
+from ghidra.program.emulation import WasmEmulationHelper
+from ghidra.program.flatapi import FlatProgramAPI
+from ghidra.program.model.listing import Program
+from wasm import WasmLoader
+from wasm.analysis import WasmAnalysis
+
+## Ensure output is not buffered
+class Unbuffered(object):
+   def __init__(self, stream):
+       self.stream = stream
+   def write(self, data):
+       self.stream.write(data)
+       self.stream.flush()
+   def writelines(self, datas):
+       self.stream.writelines(datas)
+       self.stream.flush()
+   def __getattr__(self, attr):
+       return getattr(self.stream, attr)
+
+sys.stdout = Unbuffered(sys.stdout)
+sys.stderr = Unbuffered(sys.stderr)
+eprint = lambda *args, **kwargs: print(*args, file=sys.stderr, **kwargs)
+
+"""
+Command schema (https://github.com/WebAssembly/wabt/blob/main/docs/wast2json.md):
+
+"module" 	{..., "name": <string>, "filename": <string>}
+"action" 	{..., "action": <action>}
+"assert_return" 	{..., "action": <action>, "expected": <expected>}
+"assert_exhaustion" 	{..., "action": <action>, "text": <string>}
+"assert_trap" 	{..., "action": <action>, "text": <string>}
+"assert_invalid" 	{..., "filename": <string>, "text": <string>, "module_type": <module_type>}
+"assert_malformed" 	{..., "filename": <string>, "text": <string>, "module_type": <module_type>}
+"assert_uninstantiable" 	{..., "filename": <string>, "text": <string>, "module_type": <module_type>}
+"assert_unlinkable" 	{..., "filename": <string>, "text": <string>, "module_type": <module_type>}
+"register" 	{..., "name": <string>, "as": <string>}
+"""
+
+null_val = 0x00000000
+# return address for the top-level function call
+ret_addr = 0x80000000
+
+class EmulationError(Exception):
+    pass
+
+def parse_ref(eit, eiv):
+    if eiv == "null":
+        return 0
+    if eit in ("externref", "exnref"):
+        # 0x0 is reserved for null, so we arbitrarily choose a nonzero encoding
+        # for externref objects. (This is essentially a host environment choice)
+        assert int(eiv) < 0x80000000
+        return 0x80000000 + int(eiv)
+    # this shouldn't actually happen: funcref is opaque to the host environment
+    # so wast commands should only be testing against funcref null
+    return int(eiv)
+
+def encode_arg(ei):
+    eit = ei["type"]
+    eiv = ei["value"]
+    if eit in ("i32", "f32"):
+        return struct.pack("<I", int(eiv))
+    elif eit in ("i64", "f64"):
+        return struct.pack("<Q", int(eiv))
+    elif eit in ("externref", "funcref", "exnref"):
+        return struct.pack("<I", parse_ref(eit, eiv))
+    elif eit == "v128":
+        eilt = ei["lane_type"]
+        if eilt == "i8":
+            return struct.pack("<16B", *[int(c) for c in eiv])
+        elif eilt == "i16":
+            return struct.pack("<8H", *[int(c) for c in eiv])
+        elif eilt in ("i32", "f32"):
+            return struct.pack("<4I", *[int(c) for c in eiv])
+        elif eilt in ("i64", "f64"):
+            return struct.pack("<2Q", *[int(c) for c in eiv])
+        else:
+            raise Exception("unknown lane type %s" % eilt)
+    else:
+        raise Exception("unknown value type %s" % eit)
+
+class EmulatedProgram(FlatProgramAPI):
+    def __init__(self, program):
+        super(EmulatedProgram, self).__init__(program)
+        self.emuHelper = EmulatorHelper(program)
+        self.wasmHelper = WasmEmulationHelper(self.emuHelper.language)
+        self.analysis = WasmAnalysis.getState(program)
+
+        ramSpace = self.currentProgram.addressFactory.defaultAddressSpace
+        self.retAddr = ramSpace.getAddress(ret_addr)
+        self.nullAddr = ramSpace.getAddress(null_val)
+        self.emuHelper.setBreakpoint(self.retAddr)
+        self.emuHelper.setBreakpoint(self.nullAddr)
+
+    def run_function(self, function, args):
+        stackBase = self.emuHelper.language.getRegister("s0").address
+        memState = self.emuHelper.emulator.memState
+
+        if len(args) != len(function.signature.arguments):
+            raise Exception("wrong number of arguments: got %d, expected %d" % (len(args), len(function.signature.arguments)))
+
+        biArgs = [BigInteger(1, encode_arg(arg)[::-1]) for arg in args]
+        self.wasmHelper.simulateCall(self.emuHelper.emulator, ret_addr, function.entryPoint.offset, biArgs)
+
+        while 1:
+            if not self.emuHelper.run(self.monitor):
+                err = self.emuHelper.lastError
+                if err.startswith("Unimplemented CALLOTHER pcodeop (halt_trap)"):
+                    raise EmulationError("unreachable")
+                elif err in ("Divide by 0", "Remainder by 0"):
+                    raise EmulationError("integer divide by zero")
+                raise EmulationError("Emulation stopped: " + err)
+            if self.emuHelper.executionAddress == self.retAddr:
+                break
+            elif self.emuHelper.executionAddress == self.nullAddr:
+                # tried to execute a null pointer
+                raise EmulationError("uninitialized element")
+
+        # Ghidra itself doesn't support multiple return values, so we grab that information from the Wasm analysis instead
+        sig = self.analysis.getFunctionByAddress(function.entryPoint)
+        res = []
+        for i, rt in enumerate(sig.returns):
+            res.append(self.emuHelper.readMemory(stackBase.add(i * WasmLoader.REG_SIZE), rt.size))
+        return res
+
+def import_program(dirname, filename):
+    prog = importFile(File(os.path.join(dirname, filename)))
+    if prog is None:
+        raise Exception("Failed to import file!")
+
+    tx = prog.startTransaction("analysis")
+    mgr = AutoAnalysisManager.getAnalysisManager(prog)
+
+    # Disable C stack analysis for wast tests
+    options = prog.getOptions(Program.ANALYSIS_PROPERTIES)
+    options.setInt("Wasm Pre-Analyzer.C Stack Pointer", -1)
+    mgr.initializeOptions(options)
+
+    mgr.reAnalyzeAll(None)
+    mgr.waitForAnalysis(None, monitor)
+    prog.endTransaction(tx, True)
+
+    prog_api = EmulatedProgram(prog)
+    return prog_api
+
+def execute_action(progs, action):
+    modname = action.get("module", None)
+    prog = progs.get(modname, None)
+    if prog is None:
+        raise ValueError("module was not loaded")
+
+    atype = action["type"]
+    field = action["field"]
+    export_ns = prog.getNamespace(None, "export")
+    syms = prog.getSymbols(field, export_ns)
+    if not syms:
+        raise ValueError("exported name %s not found" % (field.encode("unicode_escape"),))
+    sym_addr = syms[0].address
+
+    if atype == "get":
+        dlen = prog.getDataAt(sym_addr).length
+        return [prog.emuHelper.readMemory(sym_addr, dlen)]
+    elif atype == "invoke":
+        func = prog.getFunctionAt(sym_addr)
+        if func is None:
+            raise ValueError("exported symbol %s is not a function" % (field.encode("unicode_escape"),))
+        return prog.run_function(func, action["args"])
+    else:
+        raise ValueError("action type %s is not known" % (atype,))
+
+def assert_equal(msg, res, exp):
+    if res != exp:
+        raise AssertionError("wrong %s: got %s, expected %s" % (msg, res, exp))
+
+def format_f32(v):
+    return "0x%08x (%s)" % (v, struct.unpack("<f", struct.pack("<I", v))[0])
+
+def format_f64(v):
+    return "0x%016x (%s)" % (v, struct.unpack("<d", struct.pack("<Q", v))[0])
+
+def compare_f32(name, riv, eiv):
+    if eiv == "nan:canonical":
+        if (riv & 0x7fffffff) != 0x7fc00000:
+            raise AssertionError("wrong %s: got %s, expected canonical nan" % (name, format_f32(riv)))
+    elif eiv == "nan:arithmetic":
+        if (riv & 0x7fc00000) != 0x7fc00000:
+            raise AssertionError("wrong %s: got %s, expected arithmetic nan" % (name, format_f32(riv)))
+    else:
+        if riv != int(eiv):
+            raise AssertionError("wrong %s: got %s, expected %s" % (name, format_f32(riv), format_f32(int(eiv))))
+
+def compare_f64(name, riv, eiv):
+    if eiv == "nan:canonical":
+        if (riv & 0x7fffffffffffffff) != 0x7ff8000000000000:
+            raise AssertionError("wrong %s: got %s, expected canonical nan" % (name, format_f64(riv)))
+    elif eiv == "nan:arithmetic":
+        if (riv & 0x7ff8000000000000) != 0x7ff8000000000000:
+            raise AssertionError("wrong %s: got %s, expected arithmetic nan" % (name, format_f64(riv)))
+    else:
+        if riv != int(eiv):
+            raise AssertionError("wrong %s: got %s, expected %s" % (name, format_f64(riv), format_f64(int(eiv))))
+
+def compare_result_value(ei, ri):
+    eit = ei["type"]
+    eiv = ei["value"]
+    if eit == "i32":
+        assert_equal("i32 result length", len(ri), 4)
+        riv, = struct.unpack("<I", ri)
+        assert_equal("i32 result", riv, int(eiv))
+    elif eit == "i64":
+        assert_equal("i64 result length", len(ri), 8)
+        riv, = struct.unpack("<Q", ri)
+        assert_equal("i64 result", riv, int(eiv))
+    elif eit == "f32":
+        assert_equal("f32 result length", len(ri), 4)
+        riv, = struct.unpack("<I", ri)
+        compare_f32("f32 result", riv, eiv)
+    elif eit == "f64":
+        assert_equal("f64 result length", len(ri), 8)
+        riv, = struct.unpack("<Q", ri)
+        compare_f64("f64 result", riv, eiv)
+    elif eit in ("externref", "funcref", "exnref"):
+        assert_equal("ref result length", len(ri), 4)
+        riv, = struct.unpack("<I", ri)
+        assert_equal("ref result", riv, parse_ref(eit, eiv))
+    elif eit == "v128":
+        assert_equal("v128 result length", len(ri), 16)
+        eilt = ei["lane_type"]
+        if eilt == "i8":
+            assert_equal("i8x16 result", struct.unpack("<16B", ri), tuple([int(c) for c in eiv]))
+        elif eilt == "i16":
+            assert_equal("i16x8 result", struct.unpack("<8H", ri), tuple([int(c) for c in eiv]))
+        elif eilt == "i32":
+            assert_equal("i32x4 result", struct.unpack("<4I", ri), tuple([int(c) for c in eiv]))
+        elif eilt == "i64":
+            assert_equal("i64x2 result", struct.unpack("<2Q", ri), tuple([int(c) for c in eiv]))
+        elif eilt == "f32":
+            riv = struct.unpack("<4I", ri)
+            for i in range(4):
+                compare_f32("f32x4 lane %d" % i, riv[i], eiv[i])
+        elif eilt == "f64":
+            riv = struct.unpack("<2Q", ri)
+            for i in range(2):
+                compare_f64("f64x2 lane %d" % i, riv[i], eiv[i])
+        else:
+            raise Exception("unknown lane type %s" % eilt)
+    else:
+        raise Exception("unknown value type %s" % eit)
+
+def compare_result(result, expected):
+    assert_equal("number of values returned", len(result), len(expected))
+
+    for i in range(len(expected)):
+        ri = result[i]
+        ei = expected[i]
+        compare_result_value(ei, ri)
+
+def format_action(action):
+    return "%s %s" % (action["type"], action["field"].encode("unicode_escape"))
+
+def format_exception():
+    etype, exc, tb = sys.exc_info()
+    excs = unicode(exc)
+    if excs:
+        return "%s: %s" % (etype.__name__, excs)
+    else:
+        return etype.__name__
+
+def main():
+    file = askFile("wast .json file", "Open")
+    json_fn = file.absolutePath
+
+    testdata = json.load(open(json_fn))
+    testdir = os.path.dirname(json_fn)
+    # progs[None] is the current program
+    progs = {None: None}
+
+    succeeded_cmds = 0
+    failed_cmds = 0
+    skipped_cmds = 0
+
+    wast_fn = testdata["source_filename"]
+    for command in testdata["commands"]:
+        prefix = "%s:%d:" % (wast_fn, command["line"])
+        ctype = command["type"]
+        if ctype == "module":
+            try:
+                prog = import_program(testdir, command["filename"])
+                progs[None] = prog
+                if "name" in command:
+                    progs[command["name"]] = prog
+                succeeded_cmds += 1
+            except:
+                eprint(prefix, "ERROR: failed to load module %s: %s" % (command["filename"], format_exception()))
+                progs[None] = None
+                failed_cmds += 1
+
+        elif ctype == "action":
+            try:
+                execute_action(progs, command["action"])
+                succeeded_cmds += 1
+            except:
+                eprint(prefix, "ERROR: failed to execute action %s: %s" % (format_action(command["action"]), format_exception()))
+                failed_cmds += 1
+
+        elif ctype == "assert_return":
+            try:
+                result = execute_action(progs, command["action"])
+                compare_result(result, command["expected"])
+                succeeded_cmds += 1
+            except:
+                eprint(prefix, "ERROR: assert_return %s failed: %s" % (format_action(command["action"]), format_exception()))
+                failed_cmds += 1
+
+        elif ctype == "assert_exhaustion":
+            eprint(prefix, "NOTE: skipping assert_exhaustion %s" % format_action(command["action"]))
+            skipped_cmds += 1
+
+        elif ctype == "assert_trap":
+            try:
+                execute_action(progs, command["action"])
+                eprint(prefix, "ERROR: assert_trap %s did not trap; expected %r" % (format_action(command["action"]), command["text"]))
+                failed_cmds += 1
+            except EmulationError as e:
+                if e.args[0] == command["text"]:
+                    succeeded_cmds += 1
+                else:
+                    eprint(prefix, "ERROR: assert_trap %s trapped with %r but expected %r" % (format_action(command["action"]), e.args[0], command["text"]))
+                    failed_cmds += 1
+            except:
+                eprint(prefix, "ERROR: assert_trap %s failed: %s" % (format_action(command["action"]), format_exception()))
+                failed_cmds += 1
+
+        elif ctype == "assert_invalid":
+            eprint(prefix, "NOTE: skipping assert_invalid %s" % (command["filename"],))
+            skipped_cmds += 1
+
+        elif ctype == "assert_malformed":
+            eprint(prefix, "NOTE: skipping assert_malformed %s" % (command["filename"],))
+            skipped_cmds += 1
+
+        elif ctype == "assert_uninstantiable":
+            eprint(prefix, "NOTE: skipping assert_uninstantiable %s" % (command["filename"],))
+            skipped_cmds += 1
+
+        elif ctype == "assert_unlinkable":
+            eprint(prefix, "NOTE: skipping assert_unlinkable %s" % (command["filename"],))
+            skipped_cmds += 1
+
+        elif ctype == "register":
+            # TODO: save program in the root folder to benefit from automatic linking
+            progs[command["as"]] = progs[command.get("name", None)]
+            succeeded_cmds += 1
+
+        else:
+            eprint(prefix, "ERROR: unrecognized command %s" % (command["type"],))
+            failed_cmds += 1
+
+    if succeeded_cmds + failed_cmds + skipped_cmds != len(testdata["commands"]):
+        eprint("ERROR: invalid result totals!")
+
+    eprint("SUMMARY: %s: %d succeeded, %d failed, %d skipped (%d total)" % (os.path.basename(json_fn), succeeded_cmds, failed_cmds, skipped_cmds, len(testdata["commands"])))
+
+if __name__ == "__main__":
+    main()
diff --git a/Ghidra/Processors/WebAssembly/src/main/help/help/TOC_Source.xml b/Ghidra/Processors/WebAssembly/src/main/help/help/TOC_Source.xml
new file mode 100644
index 0000000000..dbad6be64a
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/help/help/TOC_Source.xml
@@ -0,0 +1,7 @@
+<?xml version='1.0' encoding='ISO-8859-1' ?>
+
+<tocroot>
+  <tocref id="Appendix">
+    <tocdef id="WebAssembly" text="WebAssembly" target="help/topics/WebAssembly/help.html" />
+  </tocref>
+</tocroot>
diff --git a/Ghidra/Processors/WebAssembly/src/main/help/help/topics/WebAssembly/help.html b/Ghidra/Processors/WebAssembly/src/main/help/help/topics/WebAssembly/help.html
new file mode 100644
index 0000000000..7facdfb33a
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/help/help/topics/WebAssembly/help.html
@@ -0,0 +1,111 @@
+<!DOCTYPE html>
+<html>
+  <head>
+    <meta name="generator" content="markdown_py 3.3.6 with fenced_code extension">
+    <meta http-equiv="Content-Language" content="en-us">
+    <meta charset="utf-8" />
+
+    <title>WebAssembly</title>
+    <link rel="stylesheet" type="text/css" href="help/shared/DefaultStyle.css">
+  </head>
+
+  <body><h1>WebAssembly</h1>
+
+<p>Module to load WebAssembly files into Ghidra, supporting disassembly and decompilation.</p>
+<h2>Features</h2>
+<ul>
+<li>Support for all WebAssembly 1.0 opcodes</li>
+<li>Cross-references for function calls and branches</li>
+<li>Cross-references for table entries and globals containing function pointers</li>
+<li>Recovery of the C stack, when the stack pointer is stored in a global variable (typical for compilers like Emscripten)</li>
+</ul>
+<h2>Tips</h2>
+<ul>
+<li>Many Wasm programs, especially those compiled by Emscripten or Clang, use a
+global variable to store the C stack pointer. This module will attempt to
+automatically detect the C stack pointer during analysis; if it fails, you may
+need to set it yourself before performing initial analysis by setting the "C
+Stack Pointer" in the Wasm Pre-Analyzer settings.</li>
+<li>By default, the C stack is assumed to grow in the negative direction, i.e.
+towards smaller addresses. However, compilers are actually free to choose either
+stack direction, and both positive and negative-growing stacks have been
+observed in real-world samples. If your C stack grows upwards (e.g. indicated by
+an add operation to the C stack pointer in the function prologue rather than a
+subtract), select the <code>pos-stack</code> compiler when importing the file, or via <code>Set
+Language...</code> on an existing file in the project window.</li>
+<li>Emscripten will usually translate function pointer calls into calls to
+exported <code>dyncall_</code> functions, which take a call-type-specific index as the
+first parameter. The index is used to index a sub-section of the main function
+table (table0) to find the function to call. The included script
+<code>analyze_dyncalls.py</code> can analyze the <code>dyncall_</code> functions, extract the indices,
+and rename referenced functions according to their call type and function index
+(which will often serve as function pointer values in memory). This can be used
+to resolve function pointer references, for example.</li>
+<li>Element segments may be passive, or have offset expressions that depend on
+imported globals. In this case, the element segments are not automatically
+loaded to the table. You can manually load these segments by calling
+<code>WasmLoader.loadElementsToTable</code>. For example, to load element segment #0 to
+table #0 at offset 0 in Python:</li>
+</ul>
+<pre><code class="language-python">from wasm import WasmLoader
+from wasm.analysis import WasmAnalysis
+from ghidra.util.task import ConsoleTaskMonitor
+monitor = ConsoleTaskMonitor()
+WasmLoader.loadElementsToTable(currentProgram, WasmAnalysis.getState(currentProgram).module, 0, 0, 0, monitor)
+</code></pre>
+<ul>
+<li>Similarly, data segments can be manually loaded as well. For example, to load
+data segment #5 to memory #0 at offset 0x1000, do the following in Python:</li>
+</ul>
+<pre><code class="language-python">from wasm import WasmLoader
+from wasm.analysis import WasmAnalysis
+from ghidra.util.task import ConsoleTaskMonitor
+monitor = ConsoleTaskMonitor()
+WasmLoader.loadDataToMemory(currentProgram, WasmAnalysis.getState(currentProgram).module, 5, 0, 0x1000, monitor)
+</code></pre>
+<h2>Emulation</h2>
+<p>This module supports emulation of Wasm code using the standard Ghidra emulation
+framework, i.e. via <code>EmulatorHelper</code>, <code>Emulator</code> and <code>Emulate</code>.</p>
+<p>Stack frames for inactive function frames (locals, Wasm stack variables, and the
+return address) are stored on a shadow stack, which begins at the <code>ss0</code> register
+and grows towards higher addresses in the register space.</p>
+<p>The <code>emulate_writev.py</code> script demonstrates emulation with hooking of the
+Emscripten <code>__syscall3</code> function in order to process <code>writev</code> calls.</p>
+<h2>Limitations and Known Bugs</h2>
+<ul>
+<li>Currently, inlining functions (via marking them "In Line") is not supported
+and will confuse the decompiler. This is because the inlined function's
+references to stack and local variables will affect the caller. I tried to solve
+this limitation by injecting code to save and restore stack and locals on
+function entry/exit, but ran into a Ghidra limitation - the decompiler does not
+inject "uponentry" Pcode into inlined functions.</li>
+<li>Currently, there is no way to change the C stack pointer after initial analysis
+(attempting to re-analyze the program with a new C stack pointer will not change
+anything).</li>
+<li>Initial analysis and disassembly can be very slow. This is primarily because
+Ghidra is quite slow at setting large numbers of context registers.</li>
+<li>Multiple return values are untested and will probably not work.</li>
+</ul>
+<h2>Internals</h2>
+<p>This module uses a pre-analyzer (WasmPreAnalyzer) to analyze all functions and
+opcodes, providing contextual information to the SLEIGH disassembler to enable
+correct disassembly (for example, operand sizes when they depend on the types in
+the value stack, branch target addresses, etc). In order to support recovery of
+the C stack, this module converts Wasm stack operations into operations on a
+register file. This frees up the decompiler's stack analysis to focus on the
+behaviour of the C stack, since the decompiler only supports a single stack.
+Additionally, parameter passing and returns are handled by virtual input/output
+registers which are copied to/from the stack and locals registers via Pcode
+injection.</p>
+<p>Four different types of "registers" are defined: input (iN), output (oN), stack
+(sN) and locals (lN). Of these, only the locals will be visible in the
+disassembly; stack registers will appear in the PCode, and input/output
+registers will appear in function types.</p>
+<h2>Acknowledgements</h2>
+<ul>
+<li>This module borrows loader functionality from this repo: https://github.com/andr3colonel/ghidra_wasm</li>
+<li>This module was directly based on https://github.com/garrettgu10/ghidra-wasm-plugin</li>
+</ul>
+
+  </body>
+</html>
\ No newline at end of file
diff --git a/Ghidra/Processors/WebAssembly/src/main/help/help/topics/WebAssembly/help.md b/Ghidra/Processors/WebAssembly/src/main/help/help/topics/WebAssembly/help.md
new file mode 100644
index 0000000000..49935bfb0e
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/help/help/topics/WebAssembly/help.md
@@ -0,0 +1,104 @@
+Module to load WebAssembly files into Ghidra, supporting disassembly and decompilation.
+
+## Features
+
+- Support for all WebAssembly 1.0 opcodes
+- Cross-references for function calls and branches
+- Cross-references for table entries and globals containing function pointers
+- Recovery of the C stack, when the stack pointer is stored in a global variable (typical for compilers like Emscripten)
+
+## Tips
+
+- Many Wasm programs, especially those compiled by Emscripten or Clang, use a
+global variable to store the C stack pointer. This module will attempt to
+automatically detect the C stack pointer during analysis; if it fails, you may
+need to set it yourself before performing initial analysis by setting the "C
+Stack Pointer" in the Wasm Pre-Analyzer settings.
+- By default, the C stack is assumed to grow in the negative direction, i.e.
+towards smaller addresses. However, compilers are actually free to choose either
+stack direction, and both positive and negative-growing stacks have been
+observed in real-world samples. If your C stack grows upwards (e.g. indicated by
+an add operation to the C stack pointer in the function prologue rather than a
+subtract), select the `pos-stack` compiler when importing the file, or via `Set
+Language...` on an existing file in the project window.
+- Emscripten will usually translate function pointer calls into calls to
+exported `dyncall_` functions, which take a call-type-specific index as the
+first parameter. The index is used to index a sub-section of the main function
+table (table0) to find the function to call. The included script
+`analyze_dyncalls.py` can analyze the `dyncall_` functions, extract the indices,
+and rename referenced functions according to their call type and function index
+(which will often serve as function pointer values in memory). This can be used
+to resolve function pointer references, for example.
+- Element segments may be passive, or have offset expressions that depend on
+imported globals. In this case, the element segments are not automatically
+loaded to the table. You can manually load these segments by calling
+`WasmLoader.loadElementsToTable`. For example, to load element segment #0 to
+table #0 at offset 0 in Python:
+
+```python
+from wasm import WasmLoader
+from wasm.analysis import WasmAnalysis
+from ghidra.util.task import ConsoleTaskMonitor
+monitor = ConsoleTaskMonitor()
+WasmLoader.loadElementsToTable(currentProgram, WasmAnalysis.getState(currentProgram).module, 0, 0, 0, monitor)
+```
+- Similarly, data segments can be manually loaded as well. For example, to load
+data segment #5 to memory #0 at offset 0x1000, do the following in Python:
+
+```python
+from wasm import WasmLoader
+from wasm.analysis import WasmAnalysis
+from ghidra.util.task import ConsoleTaskMonitor
+monitor = ConsoleTaskMonitor()
+WasmLoader.loadDataToMemory(currentProgram, WasmAnalysis.getState(currentProgram).module, 5, 0, 0x1000, monitor)
+```
+
+## Emulation
+
+This module supports emulation of Wasm code using the standard Ghidra emulation
+framework, i.e. via `EmulatorHelper`, `Emulator` and `Emulate`.
+
+Stack frames for inactive function frames (locals, Wasm stack variables, and the
+return address) are stored on a shadow stack, which begins at the `ss0` register
+and grows towards higher addresses in the register space.
+
+The `emulate_writev.py` script demonstrates emulation with hooking of the
+Emscripten `__syscall3` function in order to process `writev` calls.
+
+## Limitations and Known Bugs
+
+- Currently, inlining functions (via marking them "In Line") is not supported
+and will confuse the decompiler. This is because the inlined function's
+references to stack and local variables will affect the caller. I tried to solve
+this limitation by injecting code to save and restore stack and locals on
+function entry/exit, but ran into a Ghidra limitation - the decompiler does not
+inject "uponentry" Pcode into inlined functions.
+- Currently, there is no way to change the C stack pointer after initial analysis
+(attempting to re-analyze the program with a new C stack pointer will not change
+anything).
+- Initial analysis and disassembly can be very slow. This is primarily because
+Ghidra is quite slow at setting large numbers of context registers.
+- Multiple return values are untested and will probably not work.
+
+## Internals
+
+This module uses a pre-analyzer (WasmPreAnalyzer) to analyze all functions and
+opcodes, providing contextual information to the SLEIGH disassembler to enable
+correct disassembly (for example, operand sizes when they depend on the types in
+the value stack, branch target addresses, etc). In order to support recovery of
+the C stack, this module converts Wasm stack operations into operations on a
+register file. This frees up the decompiler's stack analysis to focus on the
+behaviour of the C stack, since the decompiler only supports a single stack.
+Additionally, parameter passing and returns are handled by virtual input/output
+registers which are copied to/from the stack and locals registers via Pcode
+injection.
+
+Four different types of "registers" are defined: input (iN), output (oN), stack
+(sN) and locals (lN). Of these, only the locals will be visible in the
+disassembly; stack registers will appear in the PCode, and input/output
+registers will appear in function types.
+
+## Acknowledgements
+
+- This module borrows loader functionality from this repo: https://github.com/andr3colonel/ghidra_wasm
+- This module was directly based on https://github.com/garrettgu10/ghidra-wasm-plugin
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/ghidra/program/emulation/WasmEmulateInstructionStateModifier.java b/Ghidra/Processors/WebAssembly/src/main/java/ghidra/program/emulation/WasmEmulateInstructionStateModifier.java
new file mode 100644
index 0000000000..3bafacc42f
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/ghidra/program/emulation/WasmEmulateInstructionStateModifier.java
@@ -0,0 +1,375 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.program.emulation;
+
+import java.io.IOException;
+import java.math.BigInteger;
+import java.util.Arrays;
+import java.util.List;
+import java.util.function.IntUnaryOperator;
+import java.util.function.LongToIntFunction;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.ByteProvider;
+import ghidra.app.util.bin.ByteProviderWrapper;
+import ghidra.app.util.bin.MemBufferByteProvider;
+import ghidra.pcode.emulate.Emulate;
+import ghidra.pcode.emulate.EmulateInstructionStateModifier;
+import ghidra.pcode.emulate.EmulateMemoryStateBuffer;
+import ghidra.pcode.emulate.callother.OpBehaviorOther;
+import ghidra.pcode.error.LowlevelError;
+import ghidra.pcode.memstate.MemoryState;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.address.AddressFactory;
+import ghidra.program.model.address.AddressSpace;
+import ghidra.program.model.data.LEB128;
+import ghidra.program.model.lang.Register;
+import ghidra.program.model.lang.RegisterValue;
+import ghidra.program.model.pcode.PcodeOp;
+import ghidra.program.model.pcode.Varnode;
+import wasm.WasmLoader;
+import wasm.analysis.WasmAnalysis;
+import wasm.analysis.WasmFuncSignature;
+import wasm.analysis.WasmFunctionAnalysis;
+import wasm.analysis.WasmFunctionAnalysis.StackEffect;
+import wasm.format.WasmHeader;
+import wasm.format.WasmModule;
+
+public class WasmEmulateInstructionStateModifier extends EmulateInstructionStateModifier {
+
+	private static class WasmFunctionAnalysisProvider {
+		private AddressSpace codeSpace;
+		private WasmModule module;
+		private WasmAnalysis analysis;
+		private long[] functionAddresses;
+
+		public WasmFunctionAnalysisProvider(AddressFactory addressFactory, MemoryState memoryState) {
+			Address moduleAddress = WasmLoader.getModuleAddress(addressFactory);
+			codeSpace = moduleAddress.getAddressSpace();
+			ByteProvider byteProvider = new MemBufferByteProvider(new EmulateMemoryStateBuffer(memoryState, moduleAddress));
+
+			// Since we don't have a Program context, we have to re-analyze the Wasm module
+			// from the memory contents.
+			try {
+				// XXX Nasty hack to retrieve the length of the Wasm module. Assumes that the
+				// memory following the module will be uninitialized, or set to zero.
+				BinaryReader reader = new BinaryReader(byteProvider, true);
+				new WasmHeader(reader);
+				long moduleSize;
+				while (true) {
+					moduleSize = reader.getPointerIndex();
+					int id = reader.readNextUnsignedByte();
+					long contentLength = reader.readNext(LEB128::unsigned);
+					reader.setPointerIndex(reader.getPointerIndex() + contentLength);
+					// A custom section (id 0) must have a name, so a zero-length custom section
+					// is invalid. This happens if we have two consecutive null bytes, which
+					// suggests that we're at the end of the module.
+					if (id == 0 && contentLength == 0) {
+						break;
+					}
+				}
+
+				reader = new BinaryReader(new ByteProviderWrapper(byteProvider, 0, moduleSize), true);
+				module = new WasmModule(reader);
+			} catch (IOException e) {
+				throw new LowlevelError("Unable to parse Wasm module", e);
+			}
+
+			analysis = new WasmAnalysis(addressFactory, module);
+			List<WasmFuncSignature> functions = analysis.getFunctions();
+			functionAddresses = new long[functions.size()];
+			for (int i = 0; i < functions.size(); i++) {
+				functionAddresses[i] = functions.get(i).getStartAddr().getOffset();
+			}
+			Arrays.sort(functionAddresses);
+		}
+
+		public WasmFunctionAnalysis getAnalysisForAddress(Address address) {
+			if (address.getAddressSpace() != codeSpace) {
+				return null;
+			}
+
+			int index = Arrays.binarySearch(functionAddresses, address.getOffset());
+			if (index < 0) {
+				/* No exact match, so the index is the negative of the insertion point */
+				index = -index - 2;
+			}
+			if (index < 0 || index >= functionAddresses.length) {
+				return null;
+			}
+			try {
+				return analysis.getFunctionAnalysis(codeSpace.getAddress(functionAddresses[index]));
+			} catch (IOException e) {
+				throw new LowlevelError("Unable to analyze Wasm function", e);
+			}
+		}
+	}
+
+	private WasmFunctionAnalysisProvider analysisProvider;
+	private WasmFunctionAnalysis prevAnalysis;
+	private Register contextRegister;
+	private long localsBase;
+	private WasmEmulationHelper helper;
+
+	public WasmEmulateInstructionStateModifier(Emulate emu) {
+		super(emu);
+
+		contextRegister = emu.getLanguage().getContextBaseRegister();
+		helper = new WasmEmulationHelper(emu.getLanguage());
+		localsBase = emu.getLanguage().getRegister("l0").getOffset();
+
+		registerPcodeOpBehavior("funcEntryCallOther", new FuncEntryOpBehaviour());
+		registerPcodeOpBehavior("popCallOther", new PopOpBehaviour());
+		registerPcodeOpBehavior("pushCallOther", new PushOpBehaviour());
+		registerPcodeOpBehavior("callPrologueCallOther", new CallPrologueOpBehaviour());
+		registerPcodeOpBehavior("callEpilogueCallOther", new CallEpilogueOpBehaviour());
+
+		registerPcodeOpBehavior("ctz", new BitCountOpBehaviour("ctz", Integer::numberOfTrailingZeros, Long::numberOfTrailingZeros));
+		registerPcodeOpBehavior("clz", new BitCountOpBehaviour("clz", Integer::numberOfLeadingZeros, Long::numberOfLeadingZeros));
+		registerPcodeOpBehavior("popcnt", new BitCountOpBehaviour("popcnt", Integer::bitCount, Long::bitCount));
+	}
+
+	private WasmFunctionAnalysis getAnalysis(Address address) {
+		// Optimization: cache the analysis for the current function, so we only need to
+		// search if the function changes
+		if (prevAnalysis != null) {
+			WasmFuncSignature func = prevAnalysis.getSignature();
+			if (address.compareTo(func.getStartAddr()) >= 0 && address.compareTo(func.getEndAddr()) <= 0) {
+				return prevAnalysis;
+			}
+		}
+		WasmFunctionAnalysis analysis = analysisProvider.getAnalysisForAddress(address);
+		if (analysis == null) {
+			return null;
+		}
+		prevAnalysis = analysis;
+		return analysis;
+	}
+
+	private class BitCountOpBehaviour implements OpBehaviorOther {
+		String name;
+		IntUnaryOperator i32Func;
+		LongToIntFunction i64Func;
+		public BitCountOpBehaviour(String name, IntUnaryOperator i32Func, LongToIntFunction i64Func) {
+			this.name = name;
+			this.i32Func = i32Func;
+			this.i64Func = i64Func;
+		}
+
+		@Override
+		public void evaluate(Emulate emu, Varnode out, Varnode[] inputs) {
+			MemoryState memState = emu.getMemoryState();
+			if (inputs.length != 2) {
+				throw new LowlevelError(name + " requires one input");
+			}
+
+			int size = inputs[1].getSize();
+			long value = memState.getValue(inputs[1]);
+			int result;
+			if (size == 4) {
+				result = i32Func.applyAsInt((int)value);
+			} else if (size == 8) {
+				result = i64Func.applyAsInt(value);
+			} else {
+				throw new LowlevelError(name + " cannot be applied to object of size " + size);
+			}
+
+			memState.setValue(out, (long)result);
+		}
+	}
+
+	private class FuncEntryOpBehaviour implements OpBehaviorOther {
+		@Override
+		public void evaluate(Emulate emu, Varnode out, Varnode[] inputs) {
+			MemoryState memState = emu.getMemoryState();
+			if (inputs.length != 3) {
+				throw new LowlevelError("funcEntryCallOther requires two inputs");
+			}
+
+			long inputOffset = inputs[1].getOffset();
+			long localsOffset = inputs[2].getOffset();
+			AddressSpace regSpace = emu.getLanguage().getAddressFactory().getAddressSpace("register");
+
+			WasmFunctionAnalysis funcAnalysis = getAnalysis(emu.getExecuteAddress());
+			if (funcAnalysis == null) {
+				throw new LowlevelError("Unable to find Wasm function analysis for address " +
+						emu.getExecuteAddress());
+			}
+			int numParams = funcAnalysis.getSignature().getParams().length;
+			int numLocals = funcAnalysis.getSignature().getLocals().length;
+			helper.copyRegisters(memState, inputOffset, localsOffset, numParams);
+			byte[] zero = new byte[WasmLoader.REG_SIZE];
+			for(int i=numParams; i<numLocals; i++) {
+				memState.setChunk(zero, regSpace, localsOffset + i * WasmLoader.REG_SIZE, zero.length);
+			}
+		}
+	}
+
+	private class PopOpBehaviour implements OpBehaviorOther {
+		@Override
+		public void evaluate(Emulate emu, Varnode out, Varnode[] inputs) {
+			// Pop operands from stack to a register block
+			if (inputs.length != 2) {
+				throw new LowlevelError("popCallOther requires one input");
+			}
+
+			long baseOffset = inputs[1].getOffset();
+
+			WasmFunctionAnalysis funcAnalysis = getAnalysis(emu.getExecuteAddress());
+			if (funcAnalysis == null) {
+				throw new LowlevelError("Unable to find Wasm function analysis for address " +
+						emu.getExecuteAddress());
+			}
+			StackEffect stackEffect = funcAnalysis.getStackEffect(emu.getExecuteAddress());
+			if (stackEffect == null) {
+				return;
+			}
+
+			long stackOffset = helper.getStackOffset(stackEffect.getPopHeight());
+			int count = stackEffect.getToPop().length;
+			helper.copyRegisters(emu.getMemoryState(), stackOffset, baseOffset, count);
+		}
+	}
+
+	private class PushOpBehaviour implements OpBehaviorOther {
+		@Override
+		public void evaluate(Emulate emu, Varnode out, Varnode[] inputs) {
+			// Push operands from one register block to stack
+			if (inputs.length != 2) {
+				throw new LowlevelError("pushCallOther requires one input");
+			}
+
+			long baseOffset = inputs[1].getOffset();
+
+			WasmFunctionAnalysis funcAnalysis = getAnalysis(emu.getExecuteAddress());
+			if (funcAnalysis == null) {
+				throw new LowlevelError("Unable to find Wasm function analysis for address " +
+						emu.getExecuteAddress());
+			}
+			StackEffect stackEffect = funcAnalysis.getStackEffect(emu.getExecuteAddress());
+			if (stackEffect == null) {
+				return;
+			}
+
+			long stackOffset = helper.getStackOffset(stackEffect.getPushHeight());
+			int count = stackEffect.getToPush().length;
+			helper.copyRegisters(emu.getMemoryState(), baseOffset, stackOffset, count);
+		}
+	}
+
+	private class CallPrologueOpBehaviour implements OpBehaviorOther {
+		@Override
+		public void evaluate(Emulate emu, Varnode out, Varnode[] inputs) {
+			MemoryState memState = emu.getMemoryState();
+			if (inputs.length != 2) {
+				throw new LowlevelError("callPrologueCallOther requires one input");
+			}
+
+			long baseOffset = inputs[1].getOffset();
+
+			// Push locals onto shadow stack
+			WasmFunctionAnalysis funcAnalysis = getAnalysis(emu.getExecuteAddress());
+			if (funcAnalysis == null) {
+				throw new LowlevelError("Unable to find Wasm function analysis for address " +
+						emu.getExecuteAddress());
+			}
+			helper.pushShadowStackRegs(memState, localsBase, funcAnalysis.getSignature().getLocals().length);
+
+			// Pop params into i* registers
+			StackEffect stackEffect = funcAnalysis.getStackEffect(emu.getExecuteAddress());
+			if (stackEffect == null) {
+				throw new LowlevelError("Unable to find stack effect for function at " + emu.getExecuteAddress());
+			}
+
+			long stackOffset = helper.getStackOffset(stackEffect.getPopHeight());
+			int count = stackEffect.getToPop().length;
+			helper.copyRegisters(memState, stackOffset, baseOffset, count);
+
+			// Push stack onto shadow stack
+			helper.pushShadowStackRegs(memState, helper.getStackOffset(0), stackEffect.getPopHeight());
+
+			// Push LR to shadow stack
+			helper.pushShadowStackLR(memState);
+		}
+	}
+
+	private class CallEpilogueOpBehaviour implements OpBehaviorOther {
+		@Override
+		public void evaluate(Emulate emu, Varnode out, Varnode[] inputs) {
+			MemoryState memState = emu.getMemoryState();
+			if (inputs.length != 2) {
+				throw new LowlevelError("callEpilogueCallOther requires one input");
+			}
+
+			long baseOffset = inputs[1].getOffset();
+
+			// Pop LR from shadow stack
+			helper.popShadowStackLR(memState);
+
+			// Pop outputs into o* registers
+			WasmFunctionAnalysis funcAnalysis = getAnalysis(emu.getExecuteAddress());
+			StackEffect stackEffect = funcAnalysis.getStackEffect(emu.getExecuteAddress());
+			if (stackEffect == null) {
+				throw new LowlevelError("Unable to find stack effect for function at " + emu.getExecuteAddress());
+			}
+
+			long stackOffset = helper.getStackOffset(stackEffect.getPopHeight());
+			int count = stackEffect.getToPop().length;
+			helper.copyRegisters(memState, stackOffset, baseOffset, count);
+
+			// Pop stack from shadow stack
+			int stackHeight = helper.popShadowStackRegs(memState, helper.getStackOffset(0));
+
+			// Push outputs onto stack
+			helper.copyRegisters(memState, baseOffset, helper.getStackOffset(stackHeight), count);
+
+			// Pop locals from shadow stack
+			helper.popShadowStackRegs(memState, localsBase);
+		}
+	}
+
+	private void updateContextValue(Emulate emulate, Address currentAddress) {
+		WasmFunctionAnalysis funcAnalysis = getAnalysis(currentAddress);
+		if (funcAnalysis == null) {
+			return;
+		}
+
+		BigInteger context = funcAnalysis.getContext(currentAddress);
+		if (context == null) {
+			return;
+		}
+
+		emulate.setContextRegisterValue(new RegisterValue(contextRegister, context));
+	}
+
+	@Override
+	public void initialExecuteCallback(Emulate emulate, Address current_address, RegisterValue contextRegisterValue) throws LowlevelError {
+		if (analysisProvider == null) {
+			analysisProvider = new WasmFunctionAnalysisProvider(emulate.getLanguage().getAddressFactory(), emulate.getMemoryState());
+		}
+
+		// Set initial context value
+		updateContextValue(emulate, current_address);
+
+		// Set SSP register if not set
+		helper.setInitialSSP(emulate.getMemoryState());
+	}
+
+	@Override
+	public void postExecuteCallback(Emulate emulate, Address lastExecuteAddress, PcodeOp[] lastExecutePcode, int lastPcodeIndex, Address currentAddress) throws LowlevelError {
+		updateContextValue(emulate, currentAddress);
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/ghidra/program/emulation/WasmEmulationHelper.java b/Ghidra/Processors/WebAssembly/src/main/java/ghidra/program/emulation/WasmEmulationHelper.java
new file mode 100644
index 0000000000..2c7f12bf8c
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/ghidra/program/emulation/WasmEmulationHelper.java
@@ -0,0 +1,191 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.program.emulation;
+
+import java.math.BigInteger;
+
+import ghidra.app.emulator.Emulator;
+import ghidra.pcode.memstate.MemoryState;
+import ghidra.program.model.address.AddressSpace;
+import ghidra.program.model.lang.Language;
+import ghidra.program.model.lang.Register;
+import wasm.WasmLoader;
+
+/** Class to manage Wasm stack and shadow stack semantics for emulation. */
+public class WasmEmulationHelper {
+    /*
+     * The shadow stack grows towards higher addresses. Each saved frame is
+     * structured as follows:
+     *
+     * [l0, l1, ..., lL-2, lL-1] [L] [s0, s1, ..., sS-2, sS-1] [S] [LR]
+     */
+    private AddressSpace regSpace;
+    private long stackBase;
+    private long inputsBase;
+    private long localsBase;
+    private Register sspRegister;
+    private Register lrRegister;
+    private Language language;
+
+    public WasmEmulationHelper(Language language) {
+        this.language = language;
+        sspRegister = language.getRegister("SSP");
+        lrRegister = language.getRegister("LR");
+        regSpace = language.getAddressFactory().getAddressSpace("register");
+        stackBase = language.getRegister("s0").getOffset();
+        inputsBase = language.getRegister("i0").getOffset();
+        localsBase = language.getRegister("l0").getOffset();
+    }
+
+    public void simulateCall(Emulator emulator, long retAddress, long funcAddress, long... inputs) {
+        BigInteger[] biInputs = new BigInteger[inputs.length];
+        for (int i = 0; i < inputs.length; i++) {
+            biInputs[i] = BigInteger.valueOf(inputs[i]);
+        }
+        simulateCall(emulator, retAddress, funcAddress, biInputs);
+    }
+
+    /**
+     * Simulate a function call. Call this before emulating a WASM function, and
+     * the call will return to retAddress when it completes.
+     *
+     * @param emulate
+     *            the emulation context
+     * @param retAddress
+     *            the address to which the function will return on completion
+     * @param funcAddress
+     *            the address of the function to call
+     * @param inputs
+     *            the inputs to provide to the function
+     */
+    public void simulateCall(Emulator emulator, long retAddress, long funcAddress, BigInteger... inputs) {
+        MemoryState memState = emulator.getMemState();
+
+        setInitialSSP(memState);
+
+        // Push dummy locals
+        pushShadowStackRegs(memState, 0, 0);
+        // Push dummy stack
+        pushShadowStackRegs(memState, 0, 0);
+        // Push target LR
+        memState.setValue(lrRegister, retAddress);
+        pushShadowStackLR(memState);
+
+        // Set inputs
+        for (int i = 0; i < inputs.length; i++) {
+            memState.setValue(regSpace, inputsBase + i * WasmLoader.REG_SIZE, WasmLoader.REG_SIZE, inputs[i]);
+        }
+
+        // Set up for call
+        memState.setValue(emulator.getPCRegisterName(), funcAddress);
+        emulator.setExecuteAddress(funcAddress);
+    }
+
+    public void simulateReturn(Emulator emulator, long... outputs) {
+        BigInteger[] biOutputs = new BigInteger[outputs.length];
+        for (int i = 0; i < outputs.length; i++) {
+            biOutputs[i] = BigInteger.valueOf(outputs[i]);
+        }
+        simulateReturn(emulator, biOutputs);
+    }
+
+    /**
+     * Simulate a return from a function. This can be useful for e.g. simulating
+     * imported functions.
+     *
+     * @param emulate
+     *            the emulation context
+     * @param outputs
+     *            the function outputs to push onto the caller's stack. The number
+     *            of outputs must match the function signature.
+     */
+    public void simulateReturn(Emulator emulator, BigInteger... outputs) {
+        MemoryState memState = emulator.getMemState();
+
+        // Pop LR from shadow stack
+        popShadowStackLR(memState);
+
+        // Pop shadow stack into stack
+        int stackHeight = popShadowStackRegs(memState, getStackOffset(0));
+
+        // Push outputs onto stack
+        for (int i = 0; i < outputs.length; i++) {
+            memState.setValue(regSpace, getStackOffset(stackHeight + i), WasmLoader.REG_SIZE, outputs[i]);
+        }
+
+        // Pop shadow locals into locals
+        popShadowStackRegs(memState, localsBase);
+
+        // Return to caller
+        long lr = memState.getValue(lrRegister);
+        memState.setValue(emulator.getPCRegisterName(), lr);
+        emulator.setExecuteAddress(lr);
+    }
+
+    /** Get offset of stack register by index */
+    public long getStackOffset(int count) {
+        return stackBase + count * WasmLoader.REG_SIZE;
+    }
+
+    public void copyRegisters(MemoryState memState, long sourceOffset, long destOffset, int count) {
+        byte[] data = new byte[count * WasmLoader.REG_SIZE];
+        memState.getChunk(data, regSpace, sourceOffset, data.length, false);
+        memState.setChunk(data, regSpace, destOffset, data.length);
+    }
+
+    public void pushShadowStackRegs(MemoryState memState, long sourceOffset, int count) {
+        long sspVal = memState.getValue(sspRegister);
+        memState.setValue(sspRegister, sspVal + WasmLoader.REG_SIZE * (count + 1));
+
+        byte[] data = new byte[count * WasmLoader.REG_SIZE];
+        memState.getChunk(data, regSpace, sourceOffset, data.length, false);
+        memState.setChunk(data, regSpace, sspVal, data.length);
+        memState.setValue(regSpace, sspVal + data.length, 4, count);
+    }
+
+    public int popShadowStackRegs(MemoryState memState, long destOffset) {
+        long sspVal = memState.getValue(sspRegister);
+        int count = (int) memState.getValue(regSpace, sspVal - WasmLoader.REG_SIZE, 4);
+        sspVal -= WasmLoader.REG_SIZE * (count + 1);
+        memState.setValue(sspRegister, sspVal);
+
+        byte[] data = new byte[count * WasmLoader.REG_SIZE];
+        memState.getChunk(data, regSpace, sspVal, data.length, false);
+        memState.setChunk(data, regSpace, destOffset, data.length);
+        return count;
+    }
+
+    public void pushShadowStackLR(MemoryState memState) {
+        long sspVal = memState.getValue(sspRegister);
+        memState.setValue(sspRegister, sspVal + WasmLoader.REG_SIZE);
+        long lrVal = memState.getValue(lrRegister);
+        memState.setValue(regSpace, sspVal, lrRegister.getNumBytes(), lrVal);
+    }
+
+    public void popShadowStackLR(MemoryState memState) {
+        long sspVal = memState.getValue(sspRegister) - WasmLoader.REG_SIZE;
+        memState.setValue(sspRegister, sspVal);
+        long lrVal = memState.getValue(regSpace, sspVal, lrRegister.getNumBytes());
+        memState.setValue(lrRegister, lrVal);
+    }
+
+    public void setInitialSSP(MemoryState memState) {
+        long value = memState.getValue(sspRegister);
+        if (value == 0) {
+            memState.setValue(sspRegister, language.getRegister("ss0").getOffset());
+        }
+    }
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/WasmLoader.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/WasmLoader.java
new file mode 100644
index 0000000000..397ea1edb7
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/WasmLoader.java
@@ -0,0 +1,708 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+
+import ghidra.app.util.MemoryBlockUtils;
+import ghidra.app.util.Option;
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.ByteProvider;
+import ghidra.app.util.importer.MessageLog;
+import ghidra.app.util.opinion.AbstractLibrarySupportLoader;
+import ghidra.app.util.opinion.LoadSpec;
+import ghidra.program.database.mem.FileBytes;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.address.AddressFactory;
+import ghidra.program.model.address.AddressSet;
+import ghidra.program.model.address.AddressSpace;
+import ghidra.program.model.data.ArrayDataType;
+import ghidra.program.model.data.DataType;
+import ghidra.program.model.data.DataUtilities;
+import ghidra.program.model.data.DataUtilities.ClearDataMode;
+import ghidra.program.model.lang.LanguageCompilerSpecPair;
+import ghidra.program.model.listing.CodeUnit;
+import ghidra.program.model.listing.Data;
+import ghidra.program.model.listing.Function;
+import ghidra.program.model.listing.Listing;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.mem.MemoryBlock;
+import ghidra.program.model.symbol.ExternalLocation;
+import ghidra.program.model.symbol.Namespace;
+import ghidra.program.model.symbol.RefType;
+import ghidra.program.model.symbol.SourceType;
+import ghidra.program.model.symbol.Symbol;
+import ghidra.program.model.symbol.SymbolUtilities;
+import ghidra.program.model.util.CodeUnitInsertionException;
+import ghidra.util.Msg;
+import ghidra.util.exception.InvalidInputException;
+import ghidra.util.task.TaskMonitor;
+import wasm.format.StructureBuilder;
+import wasm.format.WasmConstants;
+import wasm.format.WasmEnums.WasmExternalKind;
+import wasm.format.WasmHeader;
+import wasm.format.WasmModule;
+import wasm.format.sections.WasmNameSection;
+import wasm.format.sections.WasmSection;
+import wasm.format.sections.WasmUnknownCustomSection;
+import wasm.format.sections.structures.WasmCodeEntry;
+import wasm.format.sections.structures.WasmDataSegment;
+import wasm.format.sections.structures.WasmElementSegment;
+import wasm.format.sections.structures.WasmExportEntry;
+import wasm.format.sections.structures.WasmGlobalEntry;
+import wasm.format.sections.structures.WasmGlobalType;
+import wasm.format.sections.structures.WasmImportEntry;
+import wasm.format.sections.structures.WasmResizableLimits;
+import wasm.format.sections.structures.WasmTableType;
+
+public class WasmLoader extends AbstractLibrarySupportLoader {
+
+	public final static String WEBASSEMBLY = "WebAssembly";
+
+	public final static long IMPORT_BASE = 0x7f000000L;
+	public final static long CODE_BASE = 0x80000000L;
+	/* Size of each register */
+	public final static int REG_SIZE = 16;
+
+	@Override
+	public String getName() {
+		return WEBASSEMBLY;
+	}
+
+	@Override
+	public Collection<LoadSpec> findSupportedLoadSpecs(ByteProvider provider) throws IOException {
+		List<LoadSpec> loadSpecs = new ArrayList<>();
+
+		BinaryReader reader = new BinaryReader(provider, true);
+		WasmHeader header = new WasmHeader(reader);
+
+		if (Arrays.equals(WasmConstants.WASM_MAGIC, header.getMagic()) && WasmConstants.WASM_VERSION == header.getVersion()) {
+			loadSpecs.add(new LoadSpec(this, CODE_BASE, new LanguageCompilerSpecPair("Wasm:LE:32:default", "default"), true));
+		}
+
+		return loadSpecs;
+	}
+
+	// #region Address computations
+	public static long getFunctionAddressOffset(WasmModule module, int funcidx) {
+		List<WasmImportEntry> imports = module.getImports(WasmExternalKind.EXT_FUNCTION);
+		if (funcidx < imports.size()) {
+			return IMPORT_BASE + funcidx * 4;
+		} else {
+			WasmCodeEntry codeEntry = module.getNonImportedFunctions().get(funcidx - imports.size());
+			return CODE_BASE + codeEntry.getOffset();
+		}
+	}
+
+	public static long getFunctionSize(WasmModule module, int funcidx) {
+		List<WasmImportEntry> imports = module.getImports(WasmExternalKind.EXT_FUNCTION);
+		if (funcidx < imports.size()) {
+			return 4;
+		} else {
+			WasmCodeEntry codeEntry = module.getNonImportedFunctions().get(funcidx - imports.size());
+			return codeEntry.getCodeSize();
+		}
+	}
+
+	public static Address getFunctionAddress(AddressFactory addressFactory, WasmModule module, int funcidx) {
+		return addressFactory.getAddressSpace("ram").getAddress(getFunctionAddressOffset(module, funcidx));
+	}
+
+	public static Address getTableAddress(AddressFactory addressFactory, int tableidx, long itemIndex) {
+		return addressFactory.getAddressSpace("table").getAddress((((long) tableidx) << 32) + (itemIndex * 4));
+	}
+
+	public static Address getMemoryAddress(AddressFactory addressFactory, int memidx, long offset) {
+		if (memidx != 0) {
+			/* only handle memory 0 for now */
+			throw new IllegalArgumentException("non-zero memidx is not supported");
+		}
+
+		return addressFactory.getAddressSpace("ram").getAddress(offset);
+	}
+
+	public static Address getGlobalAddress(AddressFactory addressFactory, int globalidx) {
+		return addressFactory.getAddressSpace("global").getAddress(((long) globalidx) * REG_SIZE);
+	}
+
+	public static Address getModuleAddress(AddressFactory addressFactory) {
+		return getCodeAddress(addressFactory, 0);
+	}
+
+	private static Address getCodeAddress(AddressFactory addressFactory, long fileOffset) {
+		return addressFactory.getAddressSpace("ram").getAddress(CODE_BASE + fileOffset);
+	}
+	// #endregion
+
+	// #region Naming
+	private static Symbol createLabel(Program program, Address address, String name, Namespace namespace, SourceType sourceType) throws InvalidInputException {
+		if (name == null || name.isEmpty()) {
+			name = "unnamed";
+		}
+
+		// Make spaces into non-breaking spaces to avoid invalid chars
+		name = name.replace(" ", "\u00A0");
+		// Replace any other invalid chars with _
+		name = SymbolUtilities.replaceInvalidChars(name, true);
+		// Leave room for a suffix if necessary
+		int maxLen = SymbolUtilities.MAX_SYMBOL_NAME_LENGTH - 16;
+		if (name.length() > maxLen) {
+			name = name.substring(0, maxLen);
+		}
+		String newname = name;
+		int suffix = 0;
+		while (!program.getSymbolTable().getSymbols(newname, namespace).isEmpty()) {
+			suffix++;
+			newname = name + "_" + suffix;
+		}
+
+		return program.getSymbolTable().createLabel(address, newname, namespace, sourceType);
+	}
+
+	private static Namespace getNamespace(Program program, Namespace parent, String name) {
+		try {
+			return program.getSymbolTable().getOrCreateNameSpace(parent, name, SourceType.IMPORTED);
+		} catch (Exception e) {
+			return parent;
+		}
+	}
+
+	private static Namespace getObjectNamespace(Program program, WasmModule module, WasmExternalKind objectKind, int objidx) {
+		Namespace globalNamespace = program.getGlobalNamespace();
+
+		List<WasmImportEntry> imports = module.getImports(objectKind);
+		if (objidx < imports.size()) {
+			Namespace importNamespace = getNamespace(program, globalNamespace, "import");
+			return getNamespace(program, importNamespace, imports.get(objidx).getModule());
+		}
+		WasmExportEntry entry = module.findExport(objectKind, objidx);
+		if (entry != null) {
+			return getNamespace(program, globalNamespace, "export");
+		}
+		return globalNamespace;
+	}
+
+	private static String getObjectName(WasmModule module, WasmExternalKind objectKind, int objidx) {
+		List<WasmImportEntry> imports = module.getImports(objectKind);
+		if (objidx < imports.size()) {
+			return imports.get(objidx).getName();
+		}
+		WasmExportEntry entry = module.findExport(objectKind, objidx);
+		if (entry != null) {
+			return entry.getName();
+		}
+		return null;
+	}
+
+	public static Namespace getFunctionNamespace(Program program, WasmModule module, int funcidx) {
+		return getObjectNamespace(program, module, WasmExternalKind.EXT_FUNCTION, funcidx);
+	}
+
+	public static String getFunctionName(WasmModule module, int funcidx) {
+		String name;
+		WasmNameSection nameSection = module.getNameSection();
+		if (nameSection != null) {
+			name = nameSection.getFunctionName(funcidx);
+			if (name != null) {
+				return name;
+			}
+		}
+		name = getObjectName(module, WasmExternalKind.EXT_FUNCTION, funcidx);
+		if (name != null) {
+			return name;
+		}
+		return "unnamed_function_" + funcidx;
+	}
+
+	public static Namespace getGlobalNamespace(Program program, WasmModule module, int globalidx) {
+		return getObjectNamespace(program, module, WasmExternalKind.EXT_GLOBAL, globalidx);
+	}
+
+	public static String getGlobalName(Program program, WasmModule module, int globalidx) {
+		String name;
+		WasmNameSection nameSection = module.getNameSection();
+		if (nameSection != null) {
+			name = nameSection.getGlobalName(globalidx);
+			if (name != null) {
+				return name;
+			}
+		}
+		name = getObjectName(module, WasmExternalKind.EXT_GLOBAL, globalidx);
+		if (name != null) {
+			return name;
+		}
+		return "global_" + globalidx;
+	}
+	// #endregion
+
+	// #region Memory blocks
+	private static Data createData(Program program, Listing listing, Address address, DataType dt) {
+		try {
+			Data d = listing.getDataAt(address);
+			if (d == null || !dt.isEquivalent(d.getDataType())) {
+				d = DataUtilities.createData(program, address, dt, -1, false,
+						ClearDataMode.CLEAR_ALL_UNDEFINED_CONFLICT_DATA);
+			}
+			return d;
+		} catch (CodeUnitInsertionException e) {
+			Msg.warn(WasmLoader.class, "Data markup conflict at " + address, e);
+		}
+		return null;
+	}
+
+	private static MemoryBlock createModuleBlock(Program program, FileBytes fileBytes) throws Exception {
+		Address start = getCodeAddress(program.getAddressFactory(), 0);
+		MemoryBlock block = program.getMemory().createInitializedBlock(".module", start, fileBytes, 0, fileBytes.getSize(), false);
+		block.setRead(true);
+		block.setWrite(false);
+		block.setExecute(true);
+		block.setSourceName("Wasm Module");
+		block.setComment("The full file contents of the Wasm module");
+		return block;
+	}
+
+	private static void createImportStubBlock(Program program, Address startAddress, long length) {
+		try {
+			MemoryBlock block = program.getMemory().createUninitializedBlock(MemoryBlock.EXTERNAL_BLOCK_NAME, startAddress, length, false);
+			block.setRead(true);
+			block.setWrite(false);
+			block.setExecute(true);
+			block.setComment("NOTE: This block is artificial and is used to represent imported functions");
+		} catch (Exception e) {
+			Msg.error(WasmLoader.class, "Failed to create imported function block at " + startAddress, e);
+		}
+	}
+
+	private static void createTableBlock(Program program, DataType elementDataType, long numElements, int tableidx, TaskMonitor monitor) {
+		if (numElements == 0) {
+			return;
+		}
+		long byteSize = elementDataType.getLength() * numElements;
+		Address dataStart = getTableAddress(program.getAddressFactory(), tableidx, 0);
+		try {
+			MemoryBlock block = program.getMemory().createInitializedBlock(".table" + tableidx, dataStart, byteSize, (byte) 0x00, monitor, false);
+			block.setRead(true);
+			block.setWrite(true);
+			block.setExecute(false);
+			DataType tableDataType = new ArrayDataType(elementDataType, (int) numElements, elementDataType.getLength());
+			createData(program, program.getListing(), dataStart, tableDataType);
+			createLabel(program, dataStart, "table" + tableidx, program.getGlobalNamespace(), SourceType.IMPORTED);
+		} catch (Exception e) {
+			Msg.error(WasmLoader.class, "Failed to create table block " + tableidx + " at " + dataStart, e);
+		}
+	}
+
+	private static void createMemoryBlock(Program program, int memidx, long length, TaskMonitor monitor) {
+		if (length == 0) {
+			return;
+		}
+		Address dataStart = getMemoryAddress(program.getAddressFactory(), memidx, 0);
+		try {
+			MemoryBlock block = program.getMemory().createInitializedBlock(".memory" + memidx, dataStart, length, (byte) 0x00, monitor, false);
+			block.setRead(true);
+			block.setWrite(true);
+			block.setExecute(false);
+			block.setSourceName("Wasm Memory");
+		} catch (Exception e) {
+			Msg.error(WasmLoader.class, "Failed to create memory block " + memidx + " at " + dataStart, e);
+		}
+	}
+
+	private static void createGlobalBlock(Program program, DataType dataType, byte[] initBytes, int globalidx, int mutability, TaskMonitor monitor) {
+		Address dataStart = getGlobalAddress(program.getAddressFactory(), globalidx);
+		try {
+			MemoryBlock block;
+			if (initBytes == null) {
+				block = program.getMemory().createUninitializedBlock(".global" + globalidx, dataStart, dataType.getLength(), false);
+			} else {
+				block = program.getMemory().createInitializedBlock(".global" + globalidx, dataStart, dataType.getLength(), (byte) 0x00, monitor, false);
+				program.getMemory().setBytes(dataStart, initBytes);
+			}
+			block.setRead(true);
+			block.setWrite((mutability != 0) ? true : false);
+			block.setExecute(false);
+			createData(program, program.getListing(), dataStart, dataType);
+		} catch (Exception e) {
+			Msg.error(WasmLoader.class, "Failed to create global block " + globalidx + " at " + dataStart, e);
+		}
+	}
+
+	private static void createCodeLengthData(Program program, MemoryBlock moduleBlock, WasmModule module) {
+		List<WasmImportEntry> imports = module.getImports(WasmExternalKind.EXT_FUNCTION);
+		List<WasmCodeEntry> codeEntries = module.getNonImportedFunctions();
+		for (int i = 0; i < codeEntries.size(); i++) {
+			WasmCodeEntry entry = codeEntries.get(i);
+			StructureBuilder builder = new StructureBuilder("code_" + (i + imports.size()));
+			builder.addUnsignedLeb128(entry.getCodeSizeLeb128(), "code_size");
+			long offset = entry.getOffset() - entry.getCodeSizeLeb128().getLength();
+			createData(program, program.getListing(), moduleBlock.getStart().add(offset), builder.toStructure());
+		}
+	}
+	// #endregion
+
+	public void createImportExportSymbols(Program program, WasmModule module, int funcidx, Function function) throws Exception {
+
+		List<WasmImportEntry> imports = module.getImports(WasmExternalKind.EXT_FUNCTION);
+		// imported function
+		if (funcidx < imports.size()) {
+			WasmImportEntry importEntry = imports.get(funcidx);
+			// create Import symbol
+			ExternalLocation extLoc = program.getExternalManager().addExtFunction(
+					importEntry.getModule(), importEntry.getName(), function.getEntryPoint(),
+					SourceType.IMPORTED);
+			function.setThunkedFunction(extLoc.getFunction());
+			return;
+		}
+
+		WasmExportEntry entry = module.findExport(WasmExternalKind.EXT_FUNCTION, funcidx);
+		// exported function
+		if (entry != null) {
+			program.getSymbolTable().addExternalEntryPoint(function.getEntryPoint());
+		}
+	}
+
+	private void loadFunctions(Program program, FileBytes fileBytes, WasmModule module, TaskMonitor monitor) {
+		monitor.setMessage("Loading functions");
+		List<WasmImportEntry> imports = module.getImports(WasmExternalKind.EXT_FUNCTION);
+		List<WasmCodeEntry> codeEntries = module.getNonImportedFunctions();
+		int numFunctions = imports.size() + codeEntries.size();
+
+		if (imports.size() > 0) {
+			createImportStubBlock(program, getFunctionAddress(program.getAddressFactory(), module, 0), imports.size() * 4);
+		}
+
+		monitor.initialize(numFunctions);
+		for (int funcidx = 0; funcidx < numFunctions; funcidx++) {
+			if (monitor.isCancelled()) {
+				break;
+			}
+			monitor.incrementProgress(1);
+
+			Address startAddress = getFunctionAddress(program.getAddressFactory(), module, funcidx);
+			long functionLength = getFunctionSize(module, funcidx);
+			String functionName = getFunctionName(module, funcidx);
+			Namespace functionNamespace = getFunctionNamespace(program, module, funcidx);
+
+			try {
+				Symbol symbol = createLabel(program, startAddress, functionName, functionNamespace, SourceType.IMPORTED);
+				Function function = program.getFunctionManager().createFunction(symbol.getName(false), symbol.getParentNamespace(),
+						startAddress, new AddressSet(startAddress, startAddress.add(functionLength - 1)), SourceType.IMPORTED);
+				try {
+					createImportExportSymbols(program, module, funcidx, function);
+				} catch (Exception e) {
+					Msg.error(this, "Failed to create import/export symbol for function index " + funcidx + " (" + functionName + ") at " + startAddress, e);
+				}
+			} catch (Exception e) {
+				Msg.error(this, "Failed to create function index " + funcidx + " (" + functionName + ") at " + startAddress, e);
+			}
+		}
+	}
+
+	private void loadTables(Program program, FileBytes fileBytes, WasmModule module, TaskMonitor monitor) {
+		monitor.setMessage("Loading tables");
+		List<WasmImportEntry> imports = module.getImports(WasmExternalKind.EXT_TABLE);
+		List<WasmTableType> tables = module.getNonImportedTables();
+		int numTables = imports.size() + tables.size();
+
+		monitor.initialize(numTables);
+		for (int tableidx = 0; tableidx < numTables; tableidx++) {
+			if (monitor.isCancelled()) {
+				break;
+			}
+			monitor.incrementProgress(1);
+
+			WasmTableType table;
+			if (tableidx < imports.size()) {
+				table = imports.get(tableidx).getTableType();
+			} else {
+				table = tables.get(tableidx - imports.size());
+			}
+
+			createTableBlock(program, table.getElementDataType(), table.getLimits().getInitial(), tableidx, monitor);
+		}
+	}
+
+	/**
+	 * Copy element segment to table.
+	 *
+	 * This is public so that it can be called after loading, e.g. to load a passive
+	 * element segment once the dynamic table index and offset are known.
+	 *
+	 * For example, this could be called from a script as follows:
+	 *
+	 * WasmLoader.loadElementsToTable(getCurrentProgram(),
+	 * WasmAnalysis.getState(getCurrentProgram()).getModule(), elemidx, tableidx,
+	 * offset, new ConsoleTaskMonitor())
+	 */
+	public static void loadElementsToTable(Program program, WasmModule module, int elemidx, int tableidx, long offset, TaskMonitor monitor) throws Exception {
+		WasmElementSegment elemSegment = module.getElementSegments().get(elemidx);
+
+		byte[] initBytes = elemSegment.getInitData(module);
+		if (initBytes == null)
+			return;
+
+		program.getMemory().setBytes(getTableAddress(program.getAddressFactory(), tableidx, offset), initBytes);
+
+		Address[] refs = elemSegment.getAddresses(program.getAddressFactory(), module);
+		for (int i = 0; i < refs.length; i++) {
+			if (refs[i] != null) {
+				Address elementAddr = getTableAddress(program.getAddressFactory(), tableidx, offset + i);
+				program.getReferenceManager().removeAllReferencesFrom(elementAddr);
+				program.getReferenceManager().addMemoryReference(elementAddr, refs[i], RefType.DATA, SourceType.IMPORTED, 0);
+			}
+		}
+	}
+
+	private void loadElementSegments(Program program, FileBytes fileBytes, WasmModule module, TaskMonitor monitor) {
+		/* Load active element segments into tables */
+		monitor.setMessage("Loading table elements");
+		List<WasmElementSegment> entries = module.getElementSegments();
+
+		monitor.initialize(entries.size());
+		for (int elemidx = 0; elemidx < entries.size(); elemidx++) {
+			if (monitor.isCancelled()) {
+				break;
+			}
+			monitor.incrementProgress(1);
+
+			WasmElementSegment elemSegment = entries.get(elemidx);
+			int tableidx = (int) elemSegment.getTableIndex();
+
+			Long offset = elemSegment.getOffset();
+			if (offset == null)
+				continue;
+
+			try {
+				loadElementsToTable(program, module, elemidx, tableidx, offset, monitor);
+			} catch (Exception e) {
+				Msg.error(this, "Failed to initialize table " + tableidx + " with element segment " + elemidx + " at offset " + offset, e);
+			}
+		}
+	}
+
+	private void loadMemories(Program program, FileBytes fileBytes, WasmModule module, TaskMonitor monitor) {
+		monitor.setMessage("Loading memories");
+		List<WasmImportEntry> imports = module.getImports(WasmExternalKind.EXT_MEMORY);
+		List<WasmResizableLimits> memories = module.getNonImportedMemories();
+		int numMemories = imports.size() + memories.size();
+
+		monitor.initialize(numMemories);
+		for (int memidx = 0; memidx < numMemories; memidx++) {
+			if (monitor.isCancelled()) {
+				break;
+			}
+			monitor.incrementProgress(1);
+
+			if (memidx != 0) {
+				/* only handle memory 0 for now */
+				continue;
+			}
+			WasmResizableLimits mem;
+			if (memidx < imports.size()) {
+				mem = imports.get(memidx).getMemoryType();
+			} else {
+				mem = memories.get(memidx - imports.size());
+			}
+			createMemoryBlock(program, memidx, Math.min(mem.getInitial() * 65536L, CODE_BASE), monitor);
+		}
+	}
+
+	/**
+	 * Copy data segment to memory.
+	 *
+	 * This is public so that it can be called after loading, e.g. to load a passive
+	 * data segment once the dynamic memory index and offset are known.
+	 *
+	 * For example, this could be called from a script as follows:
+	 *
+	 * WasmLoader.loadDataToMemory(getCurrentProgram(),
+	 * WasmAnalysis.getState(getCurrentProgram()).getModule(), dataidx, memidx,
+	 * offset, new ConsoleTaskMonitor())
+	 */
+	public static void loadDataToMemory(Program program, WasmModule module, int dataidx, int memidx, long offset, TaskMonitor monitor) throws Exception {
+		WasmDataSegment dataSegment = module.getDataSegments().get(dataidx);
+		Address memStart = getMemoryAddress(program.getAddressFactory(), memidx, offset);
+		program.getMemory().setBytes(memStart, dataSegment.getData());
+	}
+
+	private void loadDataSegments(Program program, FileBytes fileBytes, WasmModule module, TaskMonitor monitor) {
+		/* Load active data segments into memory */
+		monitor.setMessage("Loading data segments");
+		List<WasmDataSegment> dataSegments = module.getDataSegments();
+
+		monitor.initialize(dataSegments.size());
+		for (int dataidx = 0; dataidx < dataSegments.size(); dataidx++) {
+			if (monitor.isCancelled()) {
+				break;
+			}
+			monitor.incrementProgress(1);
+
+			WasmDataSegment dataSegment = dataSegments.get(dataidx);
+			int memidx = (int) dataSegment.getIndex();
+			if (memidx != 0) {
+				/* only handle memory 0 for now */
+				continue;
+			}
+
+			Long offset = dataSegment.getMemoryOffset();
+			if (offset == null) {
+				continue;
+			}
+
+			try {
+				loadDataToMemory(program, module, dataidx, memidx, offset, monitor);
+			} catch (Exception e) {
+				Address memStart = getMemoryAddress(program.getAddressFactory(), memidx, offset);
+				Msg.error(this, "Failed to initialize memory " + memidx + " with data segment " + dataidx + " at " + memStart, e);
+			}
+		}
+	}
+
+	private void loadGlobals(Program program, FileBytes fileBytes, WasmModule module, TaskMonitor monitor) {
+		monitor.setMessage("Loading globals");
+		List<WasmImportEntry> imports = module.getImports(WasmExternalKind.EXT_GLOBAL);
+		List<WasmGlobalEntry> globals = module.getNonImportedGlobals();
+		int numGlobals = imports.size() + globals.size();
+
+		monitor.initialize(numGlobals);
+		for (int globalidx = 0; globalidx < numGlobals; globalidx++) {
+			if (monitor.isCancelled()) {
+				break;
+			}
+			monitor.incrementProgress(1);
+
+			WasmGlobalType globalType;
+			byte[] initBytes;
+			Address initRef;
+			Long initGlobal;
+			if (globalidx < imports.size()) {
+				globalType = imports.get(globalidx).getGlobalType();
+				initBytes = null;
+				initRef = null;
+				initGlobal = null;
+			} else {
+				WasmGlobalEntry entry = globals.get(globalidx - imports.size());
+				globalType = entry.getGlobalType();
+				initBytes = entry.asBytes(module);
+				initRef = entry.asAddress(program.getAddressFactory(), module);
+				initGlobal = entry.asGlobalGet();
+			}
+
+			createGlobalBlock(program, globalType.getType().asDataType(), initBytes, globalidx, globalType.getMutability(), monitor);
+
+			Address dataStart = getGlobalAddress(program.getAddressFactory(), globalidx);
+			Namespace namespace = getGlobalNamespace(program, module, globalidx);
+			String name = getGlobalName(program, module, globalidx);
+			try {
+				createLabel(program, dataStart, name, namespace, SourceType.IMPORTED);
+			} catch (Exception e) {
+				Msg.error(this, "Failed to label global " + globalidx + " (" + name + ") at " + dataStart, e);
+			}
+
+			if (initRef != null) {
+				program.getReferenceManager().removeAllReferencesFrom(dataStart);
+				program.getReferenceManager().addMemoryReference(dataStart, initRef, RefType.DATA, SourceType.IMPORTED, 0);
+			}
+			if (initGlobal != null) {
+				int commentType = CodeUnit.PLATE_COMMENT;
+				String currentComment = program.getListing().getComment(commentType, dataStart);
+				if (currentComment == null) {
+					currentComment = "";
+				} else if (!currentComment.isEmpty()) {
+					currentComment += "\n";
+				}
+				Address otherAddress = getGlobalAddress(program.getAddressFactory(), (int) (long) initGlobal);
+				program.getListing().setComment(dataStart, commentType, currentComment + "Initializer: {@symbol " + otherAddress + "}");
+			}
+		}
+	}
+
+	private MemoryBlock createCustomSectionBlock(Program program, FileBytes fileBytes, WasmUnknownCustomSection customSection, Address address)
+			throws Exception {
+		MemoryBlock block = program.getMemory().createInitializedBlock(customSection.getName(), address, fileBytes, customSection.getContentOffset(), customSection.getCustomSize(), false);
+		block.setRead(true);
+		block.setWrite(false);
+		block.setExecute(false);
+		block.setSourceName("Wasm Module");
+		return block;
+	}
+
+	private void createCustomSections(Program program, FileBytes fileBytes, WasmModule module, TaskMonitor monitor) {
+		monitor.setMessage("Creating custom sections");
+		// start right after the module block
+		Address address = AddressSpace.OTHER_SPACE.getAddress(fileBytes.getSize());
+		for (WasmSection section : module.getCustomSections()) {
+			if (!(section instanceof WasmUnknownCustomSection)) {
+				continue;
+			}
+			WasmUnknownCustomSection customSection = (WasmUnknownCustomSection) section;
+			try {
+				if (customSection.getCustomSize() == 0) {
+					continue;
+				}
+				monitor.setMessage("Creating custom section " + section.getName());
+				MemoryBlock block = createCustomSectionBlock(program, fileBytes, customSection, address);
+				address = address.add(block.getSize());
+			} catch (Exception e) {
+				Msg.error(this, "Failed to load Wasm Custom section " + customSection.getCustomName(), e);
+			}
+		}
+	}
+
+	@Override
+	protected void load(ByteProvider provider, LoadSpec loadSpec, List<Option> options,
+			Program program, TaskMonitor monitor, MessageLog log) throws IOException {
+
+		monitor.setMessage("Start loading");
+
+		try {
+			doLoad(provider, program, monitor);
+		} catch (Exception e) {
+			monitor.setMessage("Error");
+			Msg.error(this, "Failed to load Wasm module", e);
+		}
+	}
+
+	private void doLoad(ByteProvider provider, Program program, TaskMonitor monitor) throws Exception {
+		BinaryReader reader = new BinaryReader(provider, true);
+		WasmModule module = new WasmModule(reader);
+
+		FileBytes fileBytes = MemoryBlockUtils.createFileBytes(program, provider, 0, provider.length(), monitor);
+
+		MemoryBlock moduleBlock = createModuleBlock(program, fileBytes);
+		createData(program, program.getListing(), moduleBlock.getStart(), module.getHeader().toDataType());
+
+		for (WasmSection section : module.getSections()) {
+			monitor.setMessage("Creating section " + section.getName());
+			createData(program, program.getListing(), moduleBlock.getStart().add(section.getSectionOffset()), section.toDataType());
+		}
+
+		createCodeLengthData(program, moduleBlock, module);
+
+		createCustomSections(program, fileBytes, module, monitor);
+
+		loadFunctions(program, fileBytes, module, monitor);
+		loadTables(program, fileBytes, module, monitor);
+		loadElementSegments(program, fileBytes, module, monitor);
+		loadMemories(program, fileBytes, module, monitor);
+		loadDataSegments(program, fileBytes, module, monitor);
+		loadGlobals(program, fileBytes, module, monitor);
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/ValidationException.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/ValidationException.java
new file mode 100644
index 0000000000..61c7a50f44
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/ValidationException.java
@@ -0,0 +1,32 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.analysis;
+
+import ghidra.program.model.address.Address;
+
+public class ValidationException extends RuntimeException {
+	private Address instAddress;
+
+	public ValidationException(Address instAddress, String message) {
+		super(message);
+		this.instAddress = instAddress;
+	}
+
+	@Override
+	public String getMessage() {
+		return "Validation error at address " + instAddress + ": " + super.getMessage();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmAnalysis.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmAnalysis.java
new file mode 100644
index 0000000000..3f59074097
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmAnalysis.java
@@ -0,0 +1,151 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.analysis;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import ghidra.app.plugin.core.analysis.TransientProgramProperties;
+import ghidra.app.plugin.core.analysis.TransientProgramProperties.SCOPE;
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.ByteArrayProvider;
+import ghidra.app.util.bin.ByteProvider;
+import ghidra.app.util.bin.MemoryByteProvider;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.address.AddressFactory;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.mem.Memory;
+import wasm.WasmLoader;
+import wasm.format.WasmEnums.ValType;
+import wasm.format.WasmModule;
+import wasm.format.sections.structures.WasmCodeEntry;
+import wasm.format.sections.structures.WasmFuncType;
+
+public class WasmAnalysis {
+	/**
+	 * Return persistent <code>WasmAnalysis</code> which corresponds to
+	 * the specified program instance.
+	 *
+	 * @param program
+	 * @return <code>WasmAnalysis</code> for specified program instance
+	 */
+	public static synchronized WasmAnalysis getState(Program program) {
+		return TransientProgramProperties.getProperty(program, WasmAnalysis.class, SCOPE.PROGRAM, WasmAnalysis.class, () -> {
+			Memory mem = program.getMemory();
+			Address moduleStart = WasmLoader.getModuleAddress(program.getAddressFactory());
+			ByteProvider memByteProvider = new MemoryByteProvider(mem, moduleStart);
+			BinaryReader memBinaryReader = new BinaryReader(memByteProvider, true);
+			WasmModule module;
+			try {
+				module = new WasmModule(memBinaryReader);
+			} catch (IOException e) {
+				throw new RuntimeException(e);
+			}
+
+			return new WasmAnalysis(program.getAddressFactory(), module);
+		});
+	}
+
+	private WasmModule module = null;
+	private List<WasmFuncSignature> functions = null;
+	private Map<Address, WasmFuncSignature> functionsByAddress = new HashMap<>();
+	private Map<Address, WasmFunctionAnalysis> functionAnalyses = new HashMap<>();
+
+	public WasmAnalysis(AddressFactory addressFactory, WasmModule module) {
+		this.module = module;
+		this.functions = getFunctions(addressFactory, module);
+		for (WasmFuncSignature func : functions) {
+			functionsByAddress.put(func.getStartAddr(), func);
+		}
+	}
+
+	public WasmModule getModule() {
+		return module;
+	}
+
+	public List<WasmFuncSignature> getFunctions() {
+		return Collections.unmodifiableList(functions);
+	}
+
+	public WasmFuncSignature getFunction(int funcIdx) {
+		return functions.get(funcIdx);
+	}
+
+	public WasmFuncSignature getFunctionByAddress(Address address) {
+		return functionsByAddress.get(address);
+	}
+
+	public synchronized WasmFunctionAnalysis getFunctionAnalysis(Address entryPoint) throws IOException {
+		if (!functionAnalyses.containsKey(entryPoint)) {
+			WasmFuncSignature func = getFunctionByAddress(entryPoint);
+			if (func == null) {
+				return null;
+			}
+			WasmCodeEntry code = module.getFunctionCode(func.getFuncIdx());
+			if (code == null) {
+				return null;
+			}
+			BinaryReader codeReader = new BinaryReader(new ByteArrayProvider(code.getInstructions()), true);
+			WasmFunctionAnalysis funcAnalysis = new WasmFunctionAnalysis(func);
+			funcAnalysis.analyzeFunction(this, codeReader);
+			functionAnalyses.put(entryPoint, funcAnalysis);
+		}
+		return functionAnalyses.get(entryPoint);
+	}
+
+	public WasmFuncType getType(int typeidx) {
+		return module.getType(typeidx);
+	}
+
+	public ValType getGlobalType(int globalidx) {
+		return module.getGlobalType(globalidx).getType();
+	}
+
+	public ValType getTableType(int tableidx) {
+		return module.getTableType(tableidx).getElementType();
+	}
+
+	private static List<WasmFuncSignature> getFunctions(AddressFactory addressFactory, WasmModule module) {
+		int numFunctions = module.getFunctionCount();
+		List<WasmFuncSignature> functions = new ArrayList<>(numFunctions);
+		for (int funcidx = 0; funcidx < numFunctions; funcidx++) {
+			WasmFuncType funcType = module.getFunctionType(funcidx);
+			Address startAddress = WasmLoader.getFunctionAddress(addressFactory, module, funcidx);
+			Address endAddress = startAddress.add(WasmLoader.getFunctionSize(module, funcidx) - 1);
+			String name = WasmLoader.getFunctionName(module, funcidx);
+
+			WasmCodeEntry code = module.getFunctionCode(funcidx);
+			ValType[] params = funcType.getParamTypes();
+			ValType[] returns = funcType.getReturnTypes();
+			if (code == null) {
+				/* import */
+				functions.add(new WasmFuncSignature(params, returns, funcidx, name, startAddress));
+			} else {
+				ValType[] nonParamLocals = code.getLocals();
+				ValType[] locals = new ValType[params.length + nonParamLocals.length];
+
+				System.arraycopy(params, 0, locals, 0, params.length);
+				System.arraycopy(nonParamLocals, 0, locals, params.length, nonParamLocals.length);
+				functions.add(new WasmFuncSignature(params, returns, funcidx, name, startAddress, endAddress, locals));
+			}
+		}
+		return functions;
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmDWARFAnalyzer.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmDWARFAnalyzer.java
new file mode 100644
index 0000000000..bf167566ae
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmDWARFAnalyzer.java
@@ -0,0 +1,36 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.analysis;
+
+import ghidra.app.plugin.core.analysis.DWARFAnalyzer;
+import ghidra.app.util.bin.format.dwarf.sectionprovider.DWARFSectionProviderFactory;
+import ghidra.program.model.listing.Program;
+import ghidra.util.task.TaskMonitor;
+import wasm.WasmLoader;
+
+public class WasmDWARFAnalyzer extends DWARFAnalyzer {
+
+	@Override
+	public boolean canAnalyze(Program program) {
+		String format = program.getExecutableFormat();
+
+		if (WasmLoader.WEBASSEMBLY.equals(format)
+				&& DWARFSectionProviderFactory.createSectionProviderFor(program, TaskMonitor.DUMMY) != null) {
+			return true;
+		}
+		return false;
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmFuncSignature.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmFuncSignature.java
new file mode 100644
index 0000000000..9c3d9c41d2
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmFuncSignature.java
@@ -0,0 +1,80 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.analysis;
+
+import ghidra.program.model.address.Address;
+import wasm.format.WasmEnums.ValType;
+
+public class WasmFuncSignature {
+	private ValType[] params;
+	private ValType[] returns;
+	private int funcIdx;
+	private String name;
+	private Address startAddr;
+	private Address endAddr; // address of last byte in the function (inclusive)
+	private ValType[] locals;
+
+	public ValType[] getParams() {
+		return params;
+	}
+
+	public ValType[] getReturns() {
+		return returns;
+	}
+
+	public ValType[] getLocals() {
+		return locals;
+	}
+
+	public int getFuncIdx() {
+		return funcIdx;
+	}
+
+	public String getName() {
+		return name;
+	}
+
+	public Address getStartAddr() {
+		return startAddr;
+	}
+
+	public Address getEndAddr() {
+		return endAddr;
+	}
+
+	public boolean isImport() {
+		return locals == null;
+	}
+
+	public WasmFuncSignature(ValType[] paramTypes, ValType[] returnTypes, int funcIdx, String name, Address addr) {
+		this.funcIdx = funcIdx;
+		this.name = name;
+		this.startAddr = addr;
+		this.params = paramTypes;
+		this.returns = returnTypes;
+	}
+
+	public WasmFuncSignature(ValType[] paramTypes, ValType[] returnTypes, int funcIdx, String name, Address startAddr, Address endAddr, ValType[] locals) {
+		this(paramTypes, returnTypes, funcIdx, name, startAddr);
+		this.endAddr = endAddr;
+		this.locals = locals;
+	}
+
+	@Override
+	public String toString() {
+		return String.format("%s @ %s %dT -> %dT", name, startAddr.toString(), params.length, returns.length);
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmFunctionAnalysis.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmFunctionAnalysis.java
new file mode 100644
index 0000000000..e14c2c3fb1
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmFunctionAnalysis.java
@@ -0,0 +1,1525 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.analysis;
+
+import java.io.IOException;
+import java.math.BigInteger;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.data.LEB128;
+import ghidra.program.model.lang.Register;
+import ghidra.program.model.lang.RegisterValue;
+import ghidra.program.model.listing.ContextChangeException;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.listing.ProgramContext;
+import ghidra.util.Msg;
+import wasm.format.WasmEnums.ValType;
+import wasm.format.sections.structures.WasmFuncType;
+
+/**
+ * This preanalysis pass is partially patterned after the validation algorithm
+ * described in the Appendix:
+ * https://webassembly.github.io/spec/core/appendix/algorithm.html
+ */
+public class WasmFunctionAnalysis {
+
+	private WasmFuncSignature func;
+	/* null in the value stack means Unknown */
+	private List<ValType> valueStack = new ArrayList<>();
+	private List<ControlFrame> controlStack = new ArrayList<>();
+	private Map<Address, StackEffect> stackEffects = new HashMap<>();
+	private Map<Address, Long> globalGetSets = new HashMap<>();
+	private ContextRegister contextreg = new ContextRegister();
+
+	public WasmFunctionAnalysis(WasmFuncSignature func) {
+		this.func = func;
+	}
+
+	/*
+	 * Cache for program context changes so we can set the context register once,
+	 * instead of piece-by-piece
+	 */
+	private static class ContextRegister {
+		private static class RegisterDefinition {
+			private int start;
+			private int end;
+
+			public RegisterDefinition(int start, int end) {
+				this.start = start;
+				this.end = end;
+			}
+
+			public int getShift() {
+				return CONTEXT_REG_WIDTH - 1 - end;
+			}
+
+			public int getWidth() {
+				return end - start + 1;
+			}
+		}
+
+		/* These definitions must be synced with WebAssembly.slaspec */
+		private static final int CONTEXT_REG_WIDTH = 128;
+		private static final RegisterDefinition REG_IS_DIRECTIVE = new RegisterDefinition(0, 0);
+		private static final RegisterDefinition REG_IS_RETURN = new RegisterDefinition(1, 1);
+		private static final RegisterDefinition REG_IS_GLOBAL_SP = new RegisterDefinition(2, 2);
+		private static final RegisterDefinition REG_DIRECTIVE_TYPE = new RegisterDefinition(3, 5);
+		private static final RegisterDefinition REG_OPERAND_SIZE = new RegisterDefinition(6, 13);
+		private static final RegisterDefinition REG_CASE_INDEX = new RegisterDefinition(32, 63);
+		private static final RegisterDefinition REG_BR_TARGET = new RegisterDefinition(64, 95);
+		private static final RegisterDefinition REG_SP = new RegisterDefinition(96, 127);
+
+		private static final int DIRECTIVE_CASE = 0;
+		private static final int DIRECTIVE_DEFAULT = 1;
+		private static final int DIRECTIVE_LOCALS = 2;
+		private static final int DIRECTIVE_LOCAL = 3;
+
+		private Map<Address, BigInteger> contextValues = new HashMap<>();
+
+		private void setRegister(Address address, RegisterDefinition reg, long value) {
+			if (!contextValues.containsKey(address)) {
+				contextValues.put(address, BigInteger.ZERO);
+			}
+
+			if (value < 0 || value > (1L << reg.getWidth()) - 1) {
+				throw new ArithmeticException("Context register value " + value + " is out of range");
+			}
+			contextValues.put(address, contextValues.get(address).or(BigInteger.valueOf(value).shiftLeft(reg.getShift())));
+		}
+
+		public BigInteger getContext(Address address) {
+			return contextValues.get(address);
+		}
+
+		public void commitContext(Program program) {
+			ProgramContext context = program.getProgramContext();
+			Register contextRegister = context.getBaseContextRegister();
+			for (Map.Entry<Address, BigInteger> entry : contextValues.entrySet()) {
+				Address address = entry.getKey();
+				if (program.getListing().getInstructionContaining(address) != null)
+					continue;
+
+				RegisterValue value = new RegisterValue(contextRegister, entry.getValue());
+				try {
+					context.setRegisterValue(address, address, value);
+				} catch (ContextChangeException e) {
+					Msg.error(this, "Failed to set context register at " + address, e);
+				}
+			}
+			contextValues.clear();
+		}
+
+		public void setIsReturn(Address address, int value) {
+			setRegister(address, REG_IS_RETURN, value);
+		}
+
+		/**
+		 * Set how large the stack operand is. This currently affects local.*, global.*
+		 * and select instructions.
+		 */
+		public void setOperandSize(Address address, ValType type) {
+			if (type != null) {
+				// might be null if we're in an unreachable area
+				setRegister(address, REG_OPERAND_SIZE, type.getSize());
+			}
+		}
+
+		/** Mark this global.* instruction as operating on the C stack pointer. */
+		public void setIsGlobalSp(Address address, boolean value) {
+			setRegister(address, REG_IS_GLOBAL_SP, value ? 1 : 0);
+		}
+
+		/** Set the address that this instruction branches to. */
+		public void setBranchTarget(Address address, Address target) {
+			setRegister(address, REG_BR_TARGET, target.getOffset());
+		}
+
+		/**
+		 * Set the virtual stack pointer. Our SLEIGH converts stack operations into
+		 * register operations by using the stack pointer to index a register file.
+		 */
+		public void setStackPointer(Address address, long value) {
+			setRegister(address, REG_SP, value);
+		}
+
+		/* Number of locals table entries */
+		public void setLocalsDeclaration(Address address) {
+			setRegister(address, REG_IS_DIRECTIVE, 1);
+			setRegister(address, REG_DIRECTIVE_TYPE, DIRECTIVE_LOCALS);
+		}
+
+		/* One entry in the function locals table */
+		public void setLocalDeclaration(Address address) {
+			setRegister(address, REG_IS_DIRECTIVE, 1);
+			setRegister(address, REG_DIRECTIVE_TYPE, DIRECTIVE_LOCAL);
+		}
+
+		/**
+		 * Disassemble this "instruction" as a case statement underneath a br_table. We
+		 * break out case statements individually in order to provide each one with a
+		 * unique branch target.
+		 */
+		public void setBrTableCase(Address address, int index) {
+			setRegister(address, REG_IS_DIRECTIVE, 1);
+			if (index == -1) {
+				setRegister(address, REG_DIRECTIVE_TYPE, DIRECTIVE_DEFAULT);
+			} else {
+				setRegister(address, REG_DIRECTIVE_TYPE, DIRECTIVE_CASE);
+				setRegister(address, REG_CASE_INDEX, index);
+			}
+		}
+	}
+
+	private static class BlockType {
+		ValType[] params;
+		ValType[] returns;
+
+		public BlockType(WasmFuncSignature func) {
+			/* A function's parameters are in local variables rather than the stack */
+			params = new ValType[0];
+			returns = func.getReturns();
+		}
+
+		public BlockType(WasmAnalysis analysis, long blocktype) {
+			if (blocktype == -0x40) {
+				params = new ValType[0];
+				returns = new ValType[0];
+			} else if (blocktype < 0) {
+				params = new ValType[0];
+				returns = new ValType[] { ValType.fromByte((int) blocktype + 0x80) };
+			} else {
+				WasmFuncType type = analysis.getType((int) blocktype);
+				params = type.getParamTypes();
+				returns = type.getReturnTypes();
+			}
+		}
+	}
+
+	private enum BlockKind {
+		FUNCTION,
+		BLOCK,
+		IF,
+		LOOP
+	}
+
+	private class ControlFrame {
+		Address startAddress;
+		BlockKind blockKind;
+		BlockType blockType;
+		List<ValType> initialStack;
+		/** A list of instruction address which branch to this block. */
+		List<Address> branchAddresses = new ArrayList<>();
+		boolean unreachable = false;
+		boolean hasElse = false;
+
+		public ControlFrame(Address address, BlockType blockType) {
+			this.startAddress = address;
+			this.blockKind = BlockKind.FUNCTION;
+			this.blockType = blockType;
+			this.initialStack = new ArrayList<>();
+		}
+
+		public ControlFrame(Address address, BlockKind blockKind, BlockType blockType, List<ValType> stack) {
+			this.startAddress = address;
+			this.blockKind = blockKind;
+			this.blockType = blockType;
+			this.initialStack = new ArrayList<>(stack);
+		}
+
+		public ValType[] getBranchArguments() {
+			if (blockKind == BlockKind.LOOP) {
+				return blockType.params;
+			} else {
+				return blockType.returns;
+			}
+		}
+
+		/**
+		 * Track a branch to this block.
+		 *
+		 * @param program
+		 * @param stack
+		 *            Value stack after the parameters ({@link #getBranchArguments})
+		 *            have been popped
+		 * @param address
+		 *            Address of the branch instruction
+		 */
+		public void addBranch(Address address) {
+			branchAddresses.add(address);
+		}
+
+		public void setElse(Address address) {
+			hasElse = true;
+			if (blockKind != BlockKind.IF) {
+				throw new ValidationException(address, "else without corresponding if");
+			}
+			contextreg.setBranchTarget(startAddress, address.add(1));
+		}
+
+		public void setEnd(Address address) {
+			if (blockKind == BlockKind.IF && !hasElse) {
+				contextreg.setBranchTarget(startAddress, address);
+			}
+
+			Address branchTarget;
+			if (blockKind == BlockKind.LOOP) {
+				branchTarget = startAddress;
+			} else {
+				branchTarget = address;
+			}
+			for (Address branch : branchAddresses) {
+				contextreg.setBranchTarget(branch, branchTarget);
+			}
+		}
+
+		@Override
+		public String toString() {
+			return blockKind + "@" + startAddress;
+		}
+	}
+
+	// #region Exported pre-analysis results
+	public static class StackEffect {
+		private int popHeight; // Height of the stack *after* the pops
+		private ValType[] toPop;
+		private int pushHeight; // Height of the stack *before* the pushes
+		private ValType[] toPush;
+
+		public StackEffect(int popHeight, ValType[] toPop, int pushHeight, ValType[] toPush) {
+			this.popHeight = popHeight;
+			this.toPop = toPop;
+			this.pushHeight = pushHeight;
+			this.toPush = toPush;
+		}
+
+		public int getPopHeight() {
+			return popHeight;
+		}
+
+		public ValType[] getToPop() {
+			if (toPop == null) {
+				return new ValType[0];
+			}
+			return toPop;
+		}
+
+		public int getPushHeight() {
+			return pushHeight;
+		}
+
+		public ValType[] getToPush() {
+			if (toPush == null) {
+				return new ValType[0];
+			}
+			return toPush;
+		}
+	}
+
+	public WasmFuncSignature getSignature() {
+		return func;
+	}
+
+	/**
+	 * Set the stack effect of this instruction - which types it pushes and pops.
+	 * This is used to handle variable-argument instructions, which currently
+	 * includes branch, call and return instructions. TODO: Ideally, these would be
+	 * saved to the program context, which would save us from having to re-analyze
+	 * functions when reopening the DB.
+	 */
+	private void setStackEffect(Address address, int popHeight, ValType[] toPop, int pushHeight, ValType[] toPush) {
+		stackEffects.put(address, new StackEffect(popHeight, toPop, pushHeight, toPush));
+	}
+
+	public StackEffect getStackEffect(Address address) {
+		return stackEffects.get(address);
+	}
+	// #endregion
+
+	// #region BinaryReader utilities
+	private static long readLeb128(BinaryReader reader) throws IOException {
+		return reader.readNext(LEB128::unsigned);
+	}
+
+	private static long readSignedLeb128(BinaryReader reader) throws IOException {
+		return reader.readNext(LEB128::signed);
+	}
+	// #endregion
+
+	// #region Value stack manipulation
+	private void pushValue(Address instAddress, ValType type) {
+		valueStack.add(type);
+	}
+
+	private ValType popValue(Address instAddress) {
+		ControlFrame curBlock = getBlock(instAddress, 0);
+		if (valueStack.size() <= curBlock.initialStack.size()) {
+			/* If our stack is polymorphic, popping off an empty stack is ok */
+			if (curBlock.unreachable)
+				return null;
+			throw new ValidationException(instAddress, "pop from empty stack");
+		}
+		return valueStack.remove(valueStack.size() - 1);
+	}
+
+	private ValType popValue(Address instAddress, ValType expected) {
+		ValType actual = popValue(instAddress);
+		if (actual != expected && actual != null && expected != null) {
+			throw new ValidationException(instAddress, "pop type mismatch: got " + actual + ", expected " + expected);
+		}
+		return actual;
+	}
+
+	private void pushValues(Address instAddress, ValType[] types) {
+		for (int i = 0; i < types.length; i++) {
+			pushValue(instAddress, types[i]);
+		}
+	}
+
+	private ValType[] popValues(Address instAddress, ValType[] types) {
+		ValType[] popped = new ValType[types.length];
+		for (int i = types.length - 1; i >= 0; i--) {
+			popped[i] = popValue(instAddress, types[i]);
+		}
+		return popped;
+	}
+	// #endregion
+
+	// #region Control stack manipulation
+	private void pushBlock(Address instAddress, ControlFrame block) {
+		controlStack.add(block);
+		pushValues(instAddress, block.blockType.params);
+	}
+
+	private ControlFrame popBlock(Address instAddress) {
+		if (controlStack.isEmpty()) {
+			throw new ValidationException(instAddress, "pop from empty block stack");
+		}
+		ControlFrame block = getBlock(instAddress, 0);
+		popValues(instAddress, block.blockType.returns);
+		if (valueStack.size() != block.initialStack.size()) {
+			throw new ValidationException(instAddress, "block end has wrong number of parameters");
+		}
+		controlStack.remove(controlStack.size() - 1);
+		return block;
+	}
+
+	private ControlFrame getBlock(Address instAddress, long labelidx) {
+		if (labelidx >= controlStack.size()) {
+			throw new ValidationException(instAddress, "invalid label index " + labelidx);
+		}
+		return controlStack.get(controlStack.size() - 1 - (int) labelidx);
+	}
+
+	/** Mark stack as polymorphic from this point to the end of the block */
+	private void markUnreachable(Address instAddress) {
+		ControlFrame curBlock = getBlock(instAddress, 0);
+		valueStack = new ArrayList<>(curBlock.initialStack);
+		curBlock.unreachable = true;
+	}
+	// #endregion
+
+	// #region Common instruction code
+	private void memoryLoad(BinaryReader reader, Address instAddress, ValType destType) throws IOException {
+		readLeb128(reader); /* align */
+		readLeb128(reader); /* offset */
+		popValue(instAddress, ValType.i32);
+		pushValue(instAddress, destType);
+	}
+
+	private void memoryStore(BinaryReader reader, Address instAddress, ValType destType) throws IOException {
+		readLeb128(reader); /* align */
+		readLeb128(reader); /* offset */
+		popValue(instAddress, destType);
+		popValue(instAddress, ValType.i32);
+	}
+
+	private void unaryOp(Address instAddress, ValType srcType, ValType destType) {
+		popValue(instAddress, srcType);
+		pushValue(instAddress, destType);
+	}
+
+	private void binaryOp(Address instAddress, ValType srcType, ValType destType) {
+		popValue(instAddress, srcType);
+		popValue(instAddress, srcType);
+		pushValue(instAddress, destType);
+	}
+
+	// #endregion
+
+	private void analyzeOpcode(WasmAnalysis analysis, Address instAddress, BinaryReader reader) throws IOException {
+		contextreg.setStackPointer(instAddress, valueStack.size());
+		int opcode = reader.readNextUnsignedByte();
+		switch (opcode) {
+		case 0x00: /* unreachable */
+			markUnreachable(instAddress);
+			break;
+		case 0x01: /* nop */
+			break;
+
+		case 0x02: /* block bt */ {
+			BlockType blocktype = new BlockType(analysis, readSignedLeb128(reader));
+			popValues(instAddress, blocktype.params);
+			pushBlock(instAddress, this.new ControlFrame(instAddress, BlockKind.BLOCK, blocktype, valueStack));
+			break;
+		}
+		case 0x03: /* loop bt */ {
+			BlockType blocktype = new BlockType(analysis, readSignedLeb128(reader));
+			popValues(instAddress, blocktype.params);
+			pushBlock(instAddress, this.new ControlFrame(instAddress, BlockKind.LOOP, blocktype, valueStack));
+			break;
+		}
+		case 0x04: /* if bt */ {
+			BlockType blocktype = new BlockType(analysis, readSignedLeb128(reader));
+			popValue(instAddress, ValType.i32);
+			popValues(instAddress, blocktype.params);
+			pushBlock(instAddress, this.new ControlFrame(instAddress, BlockKind.IF, blocktype, valueStack));
+			break;
+		}
+		case 0x05: /* else */ {
+			ControlFrame block = popBlock(instAddress);
+			if (block.blockKind != BlockKind.IF) {
+				throw new ValidationException(instAddress, "else without matching if");
+			}
+
+			/*
+			 * The else instruction itself serves as a branch to the end of the block. The
+			 * branch from the if instruction will go to the instruction after the else.
+			 */
+			block.addBranch(instAddress);
+			block.setElse(instAddress);
+
+			block.unreachable = false;
+			pushBlock(instAddress, block);
+			break;
+		}
+		case 0x0B: /* end */ {
+			ControlFrame block = popBlock(instAddress);
+			// this stack effect will only be used by the final end
+			setStackEffect(instAddress, valueStack.size(), block.blockType.returns, 0, null);
+			pushValues(instAddress, block.blockType.returns);
+			block.setEnd(instAddress);
+			if (controlStack.isEmpty()) {
+				contextreg.setIsReturn(instAddress, 1);
+			}
+			break;
+		}
+
+		case 0x0C: /* br l */ {
+			long labelidx = readLeb128(reader);
+
+			ControlFrame block = getBlock(instAddress, labelidx);
+			ValType[] arguments = block.getBranchArguments();
+			popValues(instAddress, arguments);
+			setStackEffect(instAddress, valueStack.size(), arguments, block.initialStack.size(), arguments);
+			block.addBranch(instAddress);
+
+			markUnreachable(instAddress);
+			break;
+		}
+		case 0x0D: /* br_if l */ {
+			long labelidx = readLeb128(reader);
+			popValue(instAddress, ValType.i32);
+
+			ControlFrame block = getBlock(instAddress, labelidx);
+			ValType[] arguments = block.getBranchArguments();
+			popValues(instAddress, arguments);
+			setStackEffect(instAddress, valueStack.size(), arguments, block.initialStack.size(), arguments);
+			block.addBranch(instAddress);
+			pushValues(instAddress, arguments);
+
+			break;
+		}
+		case 0x0E: /* br_table l* l */ {
+			long count = readLeb128(reader);
+			popValue(instAddress, ValType.i32);
+			for (int i = 0; i < count + 1; i++) {
+				Address caseAddress = func.getStartAddr().add(reader.getPointerIndex());
+				contextreg.setBrTableCase(caseAddress, (i < count) ? i : -1);
+				long labelidx = readLeb128(reader);
+
+				ControlFrame block = getBlock(caseAddress, labelidx);
+				ValType[] arguments = block.getBranchArguments();
+				ValType[] actualArgs = popValues(caseAddress, arguments);
+				setStackEffect(caseAddress, valueStack.size(), arguments, block.initialStack.size(), arguments);
+				block.addBranch(caseAddress);
+				if (i < count) {
+					pushValues(caseAddress, actualArgs);
+				}
+			}
+			markUnreachable(instAddress);
+			break;
+		}
+		case 0x0F: /* return */ {
+			popValues(instAddress, func.getReturns());
+			setStackEffect(instAddress, valueStack.size(), func.getReturns(), 0, null);
+			markUnreachable(instAddress);
+			break;
+		}
+		case 0x10: /* call x */ {
+			long funcidx = readLeb128(reader);
+			WasmFuncSignature targetFunc = analysis.getFunction((int) funcidx);
+			ValType[] params = targetFunc.getParams();
+			ValType[] returns = targetFunc.getReturns();
+			popValues(instAddress, params);
+			setStackEffect(instAddress, valueStack.size(), params, valueStack.size(), returns);
+			contextreg.setBranchTarget(instAddress, targetFunc.getStartAddr());
+			pushValues(instAddress, returns);
+			break;
+		}
+		case 0x11: /* call_indirect x y */ {
+			long typeidx = readLeb128(reader);
+			long tableidx = readLeb128(reader);
+			if (analysis.getTableType((int) tableidx) != ValType.funcref) {
+				throw new ValidationException(instAddress, "call_indirect does not reference a function table");
+			}
+			WasmFuncType type = analysis.getType((int) typeidx);
+
+			popValue(instAddress, ValType.i32);
+			ValType[] params = type.getParamTypes();
+			ValType[] returns = type.getReturnTypes();
+			popValues(instAddress, params);
+			setStackEffect(instAddress, valueStack.size(), params, valueStack.size(), returns);
+			pushValues(instAddress, returns);
+			break;
+		}
+
+		case 0x1A: /* drop */ {
+			popValue(instAddress);
+			break;
+		}
+		case 0x1B: /* select */ {
+			popValue(instAddress, ValType.i32);
+			ValType t1 = popValue(instAddress);
+			ValType t2 = popValue(instAddress);
+			if (t1 != null && t2 != null && t1 != t2) {
+				throw new ValidationException(instAddress, "inconsistent types in select");
+			}
+			ValType resultType = (t1 != null) ? t1 : t2;
+			contextreg.setOperandSize(instAddress, resultType);
+			pushValue(instAddress, resultType);
+			break;
+		}
+		case 0x1C: /* select t */ {
+			long count = readLeb128(reader);
+			if (count != 1) {
+				throw new ValidationException(instAddress, "only select t is supported");
+			}
+			ValType t = ValType.fromByte(reader.readNextUnsignedByte());
+			popValue(instAddress, ValType.i32);
+			popValue(instAddress, t);
+			popValue(instAddress, t);
+			pushValue(instAddress, t);
+			break;
+		}
+
+		case 0x20: /* local.get x */ {
+			long localidx = readLeb128(reader);
+			ValType type = func.getLocals()[(int) localidx];
+			contextreg.setOperandSize(instAddress, type);
+			pushValue(instAddress, type);
+			break;
+		}
+		case 0x21: /* local.set x */ {
+			long localidx = readLeb128(reader);
+			ValType type = func.getLocals()[(int) localidx];
+			contextreg.setOperandSize(instAddress, type);
+			popValue(instAddress, type);
+			break;
+		}
+		case 0x22: /* local.tee x */ {
+			long localidx = readLeb128(reader);
+			ValType type = func.getLocals()[(int) localidx];
+			contextreg.setOperandSize(instAddress, type);
+			popValue(instAddress, type);
+			pushValue(instAddress, type);
+			break;
+		}
+		case 0x23: /* global.get x */ {
+			long globalidx = readLeb128(reader);
+			ValType type = analysis.getGlobalType((int) globalidx);
+			contextreg.setOperandSize(instAddress, type);
+			globalGetSets.put(instAddress, globalidx);
+			pushValue(instAddress, type);
+			break;
+		}
+		case 0x24: /* global.set x */ {
+			long globalidx = readLeb128(reader);
+			ValType type = analysis.getGlobalType((int) globalidx);
+			contextreg.setOperandSize(instAddress, type);
+			globalGetSets.put(instAddress, globalidx);
+			popValue(instAddress, type);
+			break;
+		}
+
+		case 0x25: /* table.get x */ {
+			long tableidx = readLeb128(reader);
+			ValType type = analysis.getTableType((int) tableidx);
+			popValue(instAddress, ValType.i32);
+			pushValue(instAddress, type);
+			break;
+		}
+		case 0x26: /* table.set x */ {
+			long tableidx = readLeb128(reader);
+			ValType type = analysis.getTableType((int) tableidx);
+			popValue(instAddress, type);
+			popValue(instAddress, ValType.i32);
+			break;
+		}
+
+		case 0x28: /* i32.load memarg */
+		case 0x2C: /* i32.load8_s memarg */
+		case 0x2D: /* i32.load8_u memarg */
+		case 0x2E: /* i32.load16_s memarg */
+		case 0x2F: /* i32.load16_u memarg */
+			memoryLoad(reader, instAddress, ValType.i32);
+			break;
+		case 0x29: /* i64.load memarg */
+		case 0x30: /* i64.load8_s memarg */
+		case 0x31: /* i64.load8_u memarg */
+		case 0x32: /* i64.load16_s memarg */
+		case 0x33: /* i64.load16_u memarg */
+		case 0x34: /* i64.load32_s memarg */
+		case 0x35: /* i64.load32_u memarg */
+			memoryLoad(reader, instAddress, ValType.i64);
+			break;
+		case 0x2A: /* f32.load memarg */
+			memoryLoad(reader, instAddress, ValType.f32);
+			break;
+		case 0x2B: /* f64.load memarg */
+			memoryLoad(reader, instAddress, ValType.f64);
+			break;
+
+		case 0x36: /* i32.store memarg */
+		case 0x3A: /* i32.store8 memarg */
+		case 0x3B: /* i32.store16 memarg */
+			memoryStore(reader, instAddress, ValType.i32);
+			break;
+		case 0x37: /* i64.store memarg */
+		case 0x3C: /* i64.store8 memarg */
+		case 0x3D: /* i64.store16 memarg */
+		case 0x3E: /* i64.store32 memarg */
+			memoryStore(reader, instAddress, ValType.i64);
+			break;
+		case 0x38: /* f32.store memarg */
+			memoryStore(reader, instAddress, ValType.f32);
+			break;
+		case 0x39: /* f64.store memarg */
+			memoryStore(reader, instAddress, ValType.f64);
+			break;
+
+		case 0x3F: /* memory.size */ {
+			readLeb128(reader); /* memidx */
+			pushValue(instAddress, ValType.i32);
+			break;
+		}
+		case 0x40: /* memory.grow */ {
+			readLeb128(reader); /* memidx */
+			popValue(instAddress, ValType.i32);
+			pushValue(instAddress, ValType.i32);
+			break;
+		}
+
+		case 0x41: /* i32.const i32 */ {
+			readSignedLeb128(reader); /* value */
+			pushValue(instAddress, ValType.i32);
+			break;
+		}
+		case 0x42: /* i64.const i64 */ {
+			readSignedLeb128(reader); /* value */
+			pushValue(instAddress, ValType.i64);
+			break;
+		}
+		case 0x43: /* f32.const f32 */ {
+			reader.readNextByteArray(4); /* value */
+			pushValue(instAddress, ValType.f32);
+			break;
+		}
+		case 0x44: /* f64.const f64 */ {
+			reader.readNextByteArray(8); /* value */
+			pushValue(instAddress, ValType.f64);
+			break;
+		}
+
+		case 0x45: /* i32.eqz */
+			unaryOp(instAddress, ValType.i32, ValType.i32);
+			break;
+		case 0x46: /* i32.eq */
+		case 0x47: /* i32.ne */
+		case 0x48: /* i32.lt_s */
+		case 0x49: /* i32.lt_u */
+		case 0x4A: /* i32.gt_s */
+		case 0x4B: /* i32.gt_u */
+		case 0x4C: /* i32.le_s */
+		case 0x4D: /* i32.le_u */
+		case 0x4E: /* i32.ge_s */
+		case 0x4F: /* i32.ge_u */
+			binaryOp(instAddress, ValType.i32, ValType.i32);
+			break;
+		case 0x50: /* i64.eqz */
+			unaryOp(instAddress, ValType.i64, ValType.i32);
+			break;
+		case 0x51: /* i64.eq */
+		case 0x52: /* i64.ne */
+		case 0x53: /* i64.lt_s */
+		case 0x54: /* i64.lt_u */
+		case 0x55: /* i64.gt_s */
+		case 0x56: /* i64.gt_u */
+		case 0x57: /* i64.le_s */
+		case 0x58: /* i64.le_u */
+		case 0x59: /* i64.ge_s */
+		case 0x5A: /* i64.ge_u */
+			binaryOp(instAddress, ValType.i64, ValType.i32);
+			break;
+		case 0x5B: /* f32.eq */
+		case 0x5C: /* f32.ne */
+		case 0x5D: /* f32.lt */
+		case 0x5E: /* f32.gt */
+		case 0x5F: /* f32.le */
+		case 0x60: /* f32.ge */
+			binaryOp(instAddress, ValType.f32, ValType.i32);
+			break;
+		case 0x61: /* f64.eq */
+		case 0x62: /* f64.ne */
+		case 0x63: /* f64.lt */
+		case 0x64: /* f64.gt */
+		case 0x65: /* f64.le */
+		case 0x66: /* f64.ge */
+			binaryOp(instAddress, ValType.f64, ValType.i32);
+			break;
+		case 0x67: /* i32.clz */
+		case 0x68: /* i32.ctz */
+		case 0x69: /* i32.popcnt */
+			unaryOp(instAddress, ValType.i32, ValType.i32);
+			break;
+		case 0x6A: /* i32.add */
+		case 0x6B: /* i32.sub */
+		case 0x6C: /* i32.mul */
+		case 0x6D: /* i32.div_s */
+		case 0x6E: /* i32.div_u */
+		case 0x6F: /* i32.rem_s */
+		case 0x70: /* i32.rem_u */
+		case 0x71: /* i32.and */
+		case 0x72: /* i32.or */
+		case 0x73: /* i32.xor */
+		case 0x74: /* i32.shl */
+		case 0x75: /* i32.shr_s */
+		case 0x76: /* i32.shr_u */
+		case 0x77: /* i32.rotl */
+		case 0x78: /* i32.rotr */
+			binaryOp(instAddress, ValType.i32, ValType.i32);
+			break;
+		case 0x79: /* i64.clz */
+		case 0x7A: /* i64.ctz */
+		case 0x7B: /* i64.popcnt */
+			unaryOp(instAddress, ValType.i64, ValType.i64);
+			break;
+		case 0x7C: /* i64.add */
+		case 0x7D: /* i64.sub */
+		case 0x7E: /* i64.mul */
+		case 0x7F: /* i64.div_s */
+		case 0x80: /* i64.div_u */
+		case 0x81: /* i64.rem_s */
+		case 0x82: /* i64.rem_u */
+		case 0x83: /* i64.and */
+		case 0x84: /* i64.or */
+		case 0x85: /* i64.xor */
+		case 0x86: /* i64.shl */
+		case 0x87: /* i64.shr_s */
+		case 0x88: /* i64.shr_u */
+		case 0x89: /* i64.rotl */
+		case 0x8A: /* i64.rotr */
+			binaryOp(instAddress, ValType.i64, ValType.i64);
+			break;
+		case 0x8B: /* f32.abs */
+		case 0x8C: /* f32.neg */
+		case 0x8D: /* f32.ceil */
+		case 0x8E: /* f32.floor */
+		case 0x8F: /* f32.trunc */
+		case 0x90: /* f32.nearest */
+		case 0x91: /* f32.sqrt */
+			unaryOp(instAddress, ValType.f32, ValType.f32);
+			break;
+		case 0x92: /* f32.add */
+		case 0x93: /* f32.sub */
+		case 0x94: /* f32.mul */
+		case 0x95: /* f32.div */
+		case 0x96: /* f32.min */
+		case 0x97: /* f32.max */
+		case 0x98: /* f32.copysign */
+			binaryOp(instAddress, ValType.f32, ValType.f32);
+			break;
+		case 0x99: /* f64.abs */
+		case 0x9A: /* f64.neg */
+		case 0x9B: /* f64.ceil */
+		case 0x9C: /* f64.floor */
+		case 0x9D: /* f64.trunc */
+		case 0x9E: /* f64.nearest */
+		case 0x9F: /* f64.sqrt */
+			unaryOp(instAddress, ValType.f64, ValType.f64);
+			break;
+		case 0xA0: /* f64.add */
+		case 0xA1: /* f64.sub */
+		case 0xA2: /* f64.mul */
+		case 0xA3: /* f64.div */
+		case 0xA4: /* f64.min */
+		case 0xA5: /* f64.max */
+		case 0xA6: /* f64.copysign */
+			binaryOp(instAddress, ValType.f64, ValType.f64);
+			break;
+		case 0xA7: /* i32.wrap_i64 */
+			unaryOp(instAddress, ValType.i64, ValType.i32);
+			break;
+		case 0xA8: /* i32.trunc_f32_s */
+		case 0xA9: /* i32.trunc_f32_u */
+			unaryOp(instAddress, ValType.f32, ValType.i32);
+			break;
+		case 0xAA: /* i32.trunc_f64_s */
+		case 0xAB: /* i32.trunc_f64_u */
+			unaryOp(instAddress, ValType.f64, ValType.i32);
+			break;
+		case 0xAC: /* i64.extend_i32_s */
+		case 0xAD: /* i64.extend_i32_u */
+			unaryOp(instAddress, ValType.i32, ValType.i64);
+			break;
+		case 0xAE: /* i64.trunc_f32_s */
+		case 0xAF: /* i64.trunc_f32_u */
+			unaryOp(instAddress, ValType.f32, ValType.i64);
+			break;
+		case 0xB0: /* i64.trunc_f64_s */
+		case 0xB1: /* i64.trunc_f64_u */
+			unaryOp(instAddress, ValType.f64, ValType.i64);
+			break;
+		case 0xB2: /* f32.convert_i32_s */
+		case 0xB3: /* f32.convert_i32_u */
+			unaryOp(instAddress, ValType.i32, ValType.f32);
+			break;
+		case 0xB4: /* f32.convert_i64_s */
+		case 0xB5: /* f32.convert_i64_u */
+			unaryOp(instAddress, ValType.i64, ValType.f32);
+			break;
+		case 0xB6: /* f32.demote_f64 */
+			unaryOp(instAddress, ValType.f64, ValType.f32);
+			break;
+		case 0xB7: /* f64.convert_i32_s */
+		case 0xB8: /* f64.convert_i32_u */
+			unaryOp(instAddress, ValType.i32, ValType.f64);
+			break;
+		case 0xB9: /* f64.convert_i64_s */
+		case 0xBA: /* f64.convert_i64_u */
+			unaryOp(instAddress, ValType.i64, ValType.f64);
+			break;
+		case 0xBB: /* f64.promote_f32 */
+			unaryOp(instAddress, ValType.f32, ValType.f64);
+			break;
+		case 0xBC: /* i32.reinterpret_f32 */
+			unaryOp(instAddress, ValType.f32, ValType.i32);
+			break;
+		case 0xBD: /* i64.reinterpret_f64 */
+			unaryOp(instAddress, ValType.f64, ValType.i64);
+			break;
+		case 0xBE: /* f32.reinterpret_i32 */
+			unaryOp(instAddress, ValType.i32, ValType.f32);
+			break;
+		case 0xBF: /* f64.reinterpret_i64 */
+			unaryOp(instAddress, ValType.i64, ValType.f64);
+			break;
+		case 0xC0: /* i32.extend8_s */
+		case 0xC1: /* i32.extend16_s */
+			unaryOp(instAddress, ValType.i32, ValType.i32);
+			break;
+		case 0xC2: /* i64.extend8_s */
+		case 0xC3: /* i64.extend16_s */
+		case 0xC4: /* i64.extend32_s */
+			unaryOp(instAddress, ValType.i64, ValType.i64);
+			break;
+
+		case 0xD0: /* ref.null t */ {
+			ValType reftype = ValType.fromByte(reader.readNextUnsignedByte());
+			pushValue(instAddress, reftype);
+			break;
+		}
+		case 0xD1: /* ref.is_null */
+			popValue(instAddress);
+			pushValue(instAddress, ValType.i32);
+			break;
+		case 0xD2: /* ref.func x */ {
+			long funcidx = readLeb128(reader);
+			WasmFuncSignature targetFunc = analysis.getFunction((int) funcidx);
+			contextreg.setBranchTarget(instAddress, targetFunc.getStartAddr());
+			pushValue(instAddress, ValType.funcref);
+			break;
+		}
+		case 0xFC: {
+			int opcode2 = reader.readNextUnsignedVarIntExact(LEB128::unsigned);
+			switch (opcode2) {
+			case 0x00: /* i32.trunc_sat_f32_s */
+			case 0x01: /* i32.trunc_sat_f32_u */
+				unaryOp(instAddress, ValType.f32, ValType.i32);
+				break;
+			case 0x02: /* i32.trunc_sat_f64_s */
+			case 0x03: /* i32.trunc_sat_f64_u */
+				unaryOp(instAddress, ValType.f64, ValType.i32);
+				break;
+			case 0x04: /* i64.trunc_sat_f32_s */
+			case 0x05: /* i64.trunc_sat_f32_u */
+				unaryOp(instAddress, ValType.f32, ValType.i64);
+				break;
+			case 0x06: /* i64.trunc_sat_f64_s */
+			case 0x07: /* i64.trunc_sat_f64_u */
+				unaryOp(instAddress, ValType.f64, ValType.i64);
+				break;
+			case 0x08: /* memory.init x */ {
+				readLeb128(reader); /* dataidx */
+				readLeb128(reader); /* memidx */
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress, ValType.i32);
+				break;
+			}
+			case 0x09: /* data.drop x */ {
+				readLeb128(reader); /* dataidx */
+				break;
+			}
+			case 0x0A: /* memory.copy */ {
+				readLeb128(reader); /* memidx */
+				readLeb128(reader); /* memidx2 */
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress, ValType.i32);
+				break;
+			}
+			case 0x0B: /* memory.fill */ {
+				readLeb128(reader); /* memidx */
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress, ValType.i32);
+				break;
+			}
+			case 0x0C: /* table.init x y */ {
+				readLeb128(reader); /* elemidx */
+				readLeb128(reader); /* tableidx */
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress, ValType.i32);
+				break;
+			}
+			case 0x0D: /* elem.drop x */ {
+				readLeb128(reader); /* elemidx */
+				break;
+			}
+			case 0x0E: /* table.copy x y */ {
+				readLeb128(reader); /* tableidx */
+				readLeb128(reader); /* tableidx2 */
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress, ValType.i32);
+				break;
+			}
+			case 0x0F: /* table.grow x */ {
+				readLeb128(reader); /* tableidx */
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress);
+				pushValue(instAddress, ValType.i32);
+				break;
+			}
+			case 0x10: /* table.size x */ {
+				readLeb128(reader); /* tableidx */
+				pushValue(instAddress, ValType.i32);
+				break;
+			}
+			case 0x11: /* table.fill x */ {
+				readLeb128(reader); /* tableidx */
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress);
+				popValue(instAddress, ValType.i32);
+				break;
+			}
+			default:
+				Msg.warn(this, "Illegal opcode 0xfc " + String.format("0x%02x", opcode2) + " at " + instAddress);
+				break;
+			}
+			break;
+		}
+		case 0xFD: {
+			int opcode2 = reader.readNextUnsignedVarIntExact(LEB128::unsigned);
+			switch (opcode2) {
+			case 0x0: /* v128.load */
+			case 0x1: /* v128.load8x8_s */
+			case 0x2: /* v128.load8x8_u */
+			case 0x3: /* v128.load16x4_s */
+			case 0x4: /* v128.load16x4_u */
+			case 0x5: /* v128.load32x2_s */
+			case 0x6: /* v128.load32x2_u */
+			case 0x7: /* v128.load8_splat */
+			case 0x8: /* v128.load16_splat */
+			case 0x9: /* v128.load32_splat */
+			case 0xA: /* v128.load64_splat */
+				memoryLoad(reader, instAddress, ValType.v128);
+				break;
+			case 0xB: /* v128.store */
+				memoryStore(reader, instAddress, ValType.v128);
+				break;
+			case 0xC: /* v128.const */
+				reader.readNextByteArray(16); /* value */
+				pushValue(instAddress, ValType.v128);
+				break;
+			case 0xD: /* i8x16.shuffle */
+				for (int i = 0; i < 16; i++)
+					reader.readNextByte(); /* laneidx16 */
+				binaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0xE: /* i8x16.swizzle */
+				binaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0xF: /* i8x16.splat */
+			case 0x10: /* i16x8.splat */
+			case 0x11: /* i32x4.splat */
+				unaryOp(instAddress, ValType.i32, ValType.v128);
+				break;
+			case 0x12: /* i64x2.splat */
+				unaryOp(instAddress, ValType.i64, ValType.v128);
+				break;
+			case 0x13: /* f32x4.splat */
+				unaryOp(instAddress, ValType.f32, ValType.v128);
+				break;
+			case 0x14: /* f64x2.splat */
+				unaryOp(instAddress, ValType.f64, ValType.v128);
+				break;
+			case 0x15: /* i8x16.extract_lane_s */
+			case 0x16: /* i8x16.extract_lane_u */
+				reader.readNextByte(); /* laneidx */
+				unaryOp(instAddress, ValType.v128, ValType.i32);
+				break;
+			case 0x17: /* i8x16.replace_lane */
+				reader.readNextByte(); /* laneidx */
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress, ValType.v128);
+				pushValue(instAddress, ValType.v128);
+				break;
+			case 0x18: /* i16x8.extract_lane_s */
+			case 0x19: /* i16x8.extract_lane_u */
+				reader.readNextByte(); /* laneidx */
+				unaryOp(instAddress, ValType.v128, ValType.i32);
+				break;
+			case 0x1A: /* i16x8.replace_lane */
+				reader.readNextByte(); /* laneidx */
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress, ValType.v128);
+				pushValue(instAddress, ValType.v128);
+				break;
+			case 0x1B: /* i32x4.extract_lane */
+				reader.readNextByte(); /* laneidx */
+				unaryOp(instAddress, ValType.v128, ValType.i32);
+				break;
+			case 0x1C: /* i32x4.replace_lane */
+				reader.readNextByte(); /* laneidx */
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress, ValType.v128);
+				pushValue(instAddress, ValType.v128);
+				break;
+			case 0x1D: /* i64x2.extract_lane */
+				reader.readNextByte(); /* laneidx */
+				unaryOp(instAddress, ValType.v128, ValType.i64);
+				break;
+			case 0x1E: /* i64x2.replace_lane */
+				reader.readNextByte(); /* laneidx */
+				popValue(instAddress, ValType.i64);
+				popValue(instAddress, ValType.v128);
+				pushValue(instAddress, ValType.v128);
+				break;
+			case 0x1F: /* f32x4.extract_lane */
+				reader.readNextByte(); /* laneidx */
+				unaryOp(instAddress, ValType.v128, ValType.f32);
+				break;
+			case 0x20: /* f32x4.replace_lane */
+				reader.readNextByte(); /* laneidx */
+				popValue(instAddress, ValType.f32);
+				popValue(instAddress, ValType.v128);
+				pushValue(instAddress, ValType.v128);
+				break;
+			case 0x21: /* f64x2.extract_lane */
+				reader.readNextByte(); /* laneidx */
+				unaryOp(instAddress, ValType.v128, ValType.f64);
+				break;
+			case 0x22: /* f64x2.replace_lane */
+				reader.readNextByte(); /* laneidx */
+				popValue(instAddress, ValType.f64);
+				popValue(instAddress, ValType.v128);
+				pushValue(instAddress, ValType.v128);
+				break;
+			case 0x23: /* i8x16.eq */
+			case 0x24: /* i8x16.ne */
+			case 0x25: /* i8x16.lt_s */
+			case 0x26: /* i8x16.lt_u */
+			case 0x27: /* i8x16.gt_s */
+			case 0x28: /* i8x16.gt_u */
+			case 0x29: /* i8x16.le_s */
+			case 0x2A: /* i8x16.le_u */
+			case 0x2B: /* i8x16.ge_s */
+			case 0x2C: /* i8x16.ge_u */
+			case 0x2D: /* i16x8.eq */
+			case 0x2E: /* i16x8.ne */
+			case 0x2F: /* i16x8.lt_s */
+			case 0x30: /* i16x8.lt_u */
+			case 0x31: /* i16x8.gt_s */
+			case 0x32: /* i16x8.gt_u */
+			case 0x33: /* i16x8.le_s */
+			case 0x34: /* i16x8.le_u */
+			case 0x35: /* i16x8.ge_s */
+			case 0x36: /* i16x8.ge_u */
+			case 0x37: /* i32x4.eq */
+			case 0x38: /* i32x4.ne */
+			case 0x39: /* i32x4.lt_s */
+			case 0x3A: /* i32x4.lt_u */
+			case 0x3B: /* i32x4.gt_s */
+			case 0x3C: /* i32x4.gt_u */
+			case 0x3D: /* i32x4.le_s */
+			case 0x3E: /* i32x4.le_u */
+			case 0x3F: /* i32x4.ge_s */
+			case 0x40: /* i32x4.ge_u */
+			case 0x41: /* f32x4.eq */
+			case 0x42: /* f32x4.ne */
+			case 0x43: /* f32x4.lt */
+			case 0x44: /* f32x4.gt */
+			case 0x45: /* f32x4.le */
+			case 0x46: /* f32x4.ge */
+			case 0x47: /* f64x2.eq */
+			case 0x48: /* f64x2.ne */
+			case 0x49: /* f64x2.lt */
+			case 0x4A: /* f64x2.gt */
+			case 0x4B: /* f64x2.le */
+			case 0x4C: /* f64x2.ge */
+				binaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0x4D: /* v128.not */
+				unaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0x4E: /* v128.and */
+			case 0x4F: /* v128.andnot */
+			case 0x50: /* v128.or */
+			case 0x51: /* v128.xor */
+				binaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0x52: /* v128.bitselect */
+				popValue(instAddress, ValType.v128);
+				popValue(instAddress, ValType.v128);
+				popValue(instAddress, ValType.v128);
+				pushValue(instAddress, ValType.v128);
+				break;
+			case 0x53: /* v128.any_true */
+				unaryOp(instAddress, ValType.v128, ValType.i32);
+				break;
+			case 0x54: /* v128.load8_lane */
+			case 0x55: /* v128.load16_lane */
+			case 0x56: /* v128.load32_lane */
+			case 0x57: /* v128.load64_lane */
+				readLeb128(reader); /* align */
+				readLeb128(reader); /* offset */
+				reader.readNextByte(); /* laneidx */
+				popValue(instAddress, ValType.v128);
+				popValue(instAddress, ValType.i32);
+				pushValue(instAddress, ValType.v128);
+				break;
+			case 0x58: /* v128.store8_lane */
+			case 0x59: /* v128.store16_lane */
+			case 0x5A: /* v128.store32_lane */
+			case 0x5B: /* v128.store64_lane */
+				readLeb128(reader); /* align */
+				readLeb128(reader); /* offset */
+				reader.readNextByte(); /* laneidx */
+				popValue(instAddress, ValType.v128);
+				popValue(instAddress, ValType.i32);
+				break;
+			case 0x5C: /* v128.load32_zero */
+			case 0x5D: /* v128.load64_zero */
+				readLeb128(reader); /* align */
+				readLeb128(reader); /* offset */
+				popValue(instAddress, ValType.i32);
+				pushValue(instAddress, ValType.v128);
+				break;
+			case 0x5E: /* f32x4.demote_f64x2_zero */
+			case 0x5F: /* f64x2.promote_low_f32x4 */
+			case 0x60: /* i8x16.abs */
+			case 0x61: /* i8x16.neg */
+			case 0x62: /* i8x16.popcnt */
+				unaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0x63: /* i8x16.all_true */
+			case 0x64: /* i8x16.bitmask */
+				unaryOp(instAddress, ValType.v128, ValType.i32);
+				break;
+			case 0x65: /* i8x16.narrow_i16x8_s */
+			case 0x66: /* i8x16.narrow_i16x8_u */
+				binaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0x67: /* f32x4.ceil */
+			case 0x68: /* f32x4.floor */
+			case 0x69: /* f32x4.trunc */
+			case 0x6A: /* f32x4.nearest */
+				unaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0x6B: /* i8x16.shl */
+			case 0x6C: /* i8x16.shr_s */
+			case 0x6D: /* i8x16.shr_u */
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress, ValType.v128);
+				pushValue(instAddress, ValType.v128);
+				break;
+			case 0x6E: /* i8x16.add */
+			case 0x6F: /* i8x16.add_sat_s */
+			case 0x70: /* i8x16.add_sat_u */
+			case 0x71: /* i8x16.sub */
+			case 0x72: /* i8x16.sub_sat_s */
+			case 0x73: /* i8x16.sub_sat_u */
+				binaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0x74: /* f64x2.ceil */
+			case 0x75: /* f64x2.floor */
+				unaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0x76: /* i8x16.min_s */
+			case 0x77: /* i8x16.min_u */
+			case 0x78: /* i8x16.max_s */
+			case 0x79: /* i8x16.max_u */
+				binaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0x7A: /* f64x2.trunc */
+				unaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0x7B: /* i8x16.avgr_u */
+				binaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0x7C: /* i16x8.extadd_pairwise_i8x16_s */
+			case 0x7D: /* i16x8.extadd_pairwise_i8x16_u */
+			case 0x7E: /* i32x4.extadd_pairwise_i16x8_s */
+			case 0x7F: /* i32x4.extadd_pairwise_i16x8_u */
+			case 0x80: /* i16x8.abs */
+			case 0x81: /* i16x8.neg */
+				unaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0x82: /* i16x8.q15mulr_sat_s */
+				binaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0x83: /* i16x8.all_true */
+			case 0x84: /* i16x8.bitmask */
+				unaryOp(instAddress, ValType.v128, ValType.i32);
+				break;
+			case 0x85: /* i16x8.narrow_i32x4_s */
+			case 0x86: /* i16x8.narrow_i32x4_u */
+				binaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0x87: /* i16x8.extend_low_i8x16_s */
+			case 0x88: /* i16x8.extend_high_i8x16_s */
+			case 0x89: /* i16x8.extend_low_i8x16_u */
+			case 0x8A: /* i16x8.extend_high_i8x16_u */
+				unaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0x8B: /* i16x8.shl */
+			case 0x8C: /* i16x8.shr_s */
+			case 0x8D: /* i16x8.shr_u */
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress, ValType.v128);
+				pushValue(instAddress, ValType.v128);
+				break;
+			case 0x8E: /* i16x8.add */
+			case 0x8F: /* i16x8.add_sat_s */
+			case 0x90: /* i16x8.add_sat_u */
+			case 0x91: /* i16x8.sub */
+			case 0x92: /* i16x8.sub_sat_s */
+			case 0x93: /* i16x8.sub_sat_u */
+				binaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0x94: /* f64x2.nearest */
+				unaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0x95: /* i16x8.mul */
+			case 0x96: /* i16x8.min_s */
+			case 0x97: /* i16x8.min_u */
+			case 0x98: /* i16x8.max_s */
+			case 0x99: /* i16x8.max_u */
+			case 0x9B: /* i16x8.avgr_u */
+			case 0x9C: /* i16x8.extmul_low_i8x16_s */
+			case 0x9D: /* i16x8.extmul_high_i8x16_s */
+			case 0x9E: /* i16x8.extmul_low_i8x16_u */
+			case 0x9F: /* i16x8.extmul_high_i8x16_u */
+				binaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0xA0: /* i32x4.abs */
+			case 0xA1: /* i32x4.neg */
+				unaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0xA3: /* i32x4.all_true */
+			case 0xA4: /* i32x4.bitmask */
+				unaryOp(instAddress, ValType.v128, ValType.i32);
+				break;
+			case 0xA7: /* i32x4.extend_low_i16x8_s */
+			case 0xA8: /* i32x4.extend_high_i16x8_s */
+			case 0xA9: /* i32x4.extend_low_i16x8_u */
+			case 0xAA: /* i32x4.extend_high_i16x8_u */
+				unaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0xAB: /* i32x4.shl */
+			case 0xAC: /* i32x4.shr_s */
+			case 0xAD: /* i32x4.shr_u */
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress, ValType.v128);
+				pushValue(instAddress, ValType.v128);
+				break;
+			case 0xAE: /* i32x4.add */
+			case 0xB1: /* i32x4.sub */
+			case 0xB5: /* i32x4.mul */
+			case 0xB6: /* i32x4.min_s */
+			case 0xB7: /* i32x4.min_u */
+			case 0xB8: /* i32x4.max_s */
+			case 0xB9: /* i32x4.max_u */
+			case 0xBA: /* i32x4.dot_i16x8_s */
+			case 0xBC: /* i32x4.extmul_low_i16x8_s */
+			case 0xBD: /* i32x4.extmul_high_i16x8_s */
+			case 0xBE: /* i32x4.extmul_low_i16x8_u */
+			case 0xBF: /* i32x4.extmul_high_i16x8_u */
+				binaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0xC0: /* i64x2.abs */
+			case 0xC1: /* i64x2.neg */
+				unaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0xC3: /* i64x2.all_true */
+			case 0xC4: /* i64x2.bitmask */
+				unaryOp(instAddress, ValType.v128, ValType.i32);
+				break;
+			case 0xC7: /* i64x2.extend_low_i32x4_s */
+			case 0xC8: /* i64x2.extend_high_i32x4_s */
+			case 0xC9: /* i64x2.extend_low_i32x4_u */
+			case 0xCA: /* i64x2.extend_high_i32x4_u */
+				unaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0xCB: /* i64x2.shl */
+			case 0xCC: /* i64x2.shr_s */
+			case 0xCD: /* i64x2.shr_u */
+				popValue(instAddress, ValType.i32);
+				popValue(instAddress, ValType.v128);
+				pushValue(instAddress, ValType.v128);
+				break;
+			case 0xCE: /* i64x2.add */
+			case 0xD1: /* i64x2.sub */
+			case 0xD5: /* i64x2.mul */
+			case 0xD6: /* i64x2.eq */
+			case 0xD7: /* i64x2.ne */
+			case 0xD8: /* i64x2.lt_s */
+			case 0xD9: /* i64x2.gt_s */
+			case 0xDA: /* i64x2.le_s */
+			case 0xDB: /* i64x2.ge_s */
+			case 0xDC: /* i64x2.extmul_low_i32x4_s */
+			case 0xDD: /* i64x2.extmul_high_i32x4_s */
+			case 0xDE: /* i64x2.extmul_low_i32x4_u */
+			case 0xDF: /* i64x2.extmul_high_i32x4_u */
+				binaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0xE0: /* f32x4.abs */
+			case 0xE1: /* f32x4.neg */
+			case 0xE3: /* f32x4.sqrt */
+				unaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0xE4: /* f32x4.add */
+			case 0xE5: /* f32x4.sub */
+			case 0xE6: /* f32x4.mul */
+			case 0xE7: /* f32x4.div */
+			case 0xE8: /* f32x4.min */
+			case 0xE9: /* f32x4.max */
+			case 0xEA: /* f32x4.pmin */
+			case 0xEB: /* f32x4.pmax */
+				binaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0xEC: /* f64x2.abs */
+			case 0xED: /* f64x2.neg */
+			case 0xEF: /* f64x2.sqrt */
+				unaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0xF0: /* f64x2.add */
+			case 0xF1: /* f64x2.sub */
+			case 0xF2: /* f64x2.mul */
+			case 0xF3: /* f64x2.div */
+			case 0xF4: /* f64x2.min */
+			case 0xF5: /* f64x2.max */
+			case 0xF6: /* f64x2.pmin */
+			case 0xF7: /* f64x2.pmax */
+				binaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			case 0xF8: /* i32x4.trunc_sat_f32x4_s */
+			case 0xF9: /* i32x4.trunc_sat_f32x4_u */
+			case 0xFA: /* f32x4.convert_i32x4_s */
+			case 0xFB: /* f32x4.convert_i32x4_u */
+			case 0xFC: /* i32x4.trunc_sat_f64x2_s_zero */
+			case 0xFD: /* i32x4.trunc_sat_f64x2_u_zero */
+			case 0xFE: /* f64x2.convert_low_i32x4_s */
+			case 0xFF: /* f64x2.convert_low_i32x4_u */
+				unaryOp(instAddress, ValType.v128, ValType.v128);
+				break;
+			default:
+				Msg.warn(this, "Illegal opcode 0xfd " + String.format("0x%02x", opcode2) + " at " + instAddress);
+				break;
+			}
+			break;
+		}
+		default:
+			Msg.warn(this, "Illegal opcode " + String.format("0x%02x", opcode) + " at " + instAddress);
+			break;
+		}
+	}
+
+	public void analyzeFunction(WasmAnalysis analysis, BinaryReader reader) throws IOException {
+		Address startAddress = func.getStartAddr();
+		long functionLength = func.getEndAddr().subtract(func.getStartAddr());
+
+		// read the function locals
+		Address instAddress;
+
+		instAddress = startAddress.add(reader.getPointerIndex());
+		contextreg.setLocalsDeclaration(instAddress);
+		long count = readLeb128(reader);
+		for (int i = 0; i < count; i++) {
+			instAddress = startAddress.add(reader.getPointerIndex());
+			contextreg.setLocalDeclaration(instAddress);
+			readLeb128(reader); /* count */
+			readLeb128(reader); /* type */
+		}
+
+		instAddress = startAddress.add(reader.getPointerIndex());
+		pushBlock(instAddress, new ControlFrame(instAddress, new BlockType(func)));
+		while (reader.getPointerIndex() <= functionLength) {
+			instAddress = startAddress.add(reader.getPointerIndex());
+			analyzeOpcode(analysis, instAddress, reader);
+		}
+	}
+
+	public BigInteger getContext(Address address) {
+		return contextreg.getContext(address);
+	}
+
+	public void applyContext(Program program, int cStackGlobal) {
+		for (Map.Entry<Address, Long> entry : globalGetSets.entrySet()) {
+			if (entry.getValue() == cStackGlobal) {
+				contextreg.setIsGlobalSp(entry.getKey(), entry.getValue() == cStackGlobal);
+			}
+		}
+		contextreg.commitContext(program);
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmPreAnalyzer.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmPreAnalyzer.java
new file mode 100644
index 0000000000..98121753ac
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmPreAnalyzer.java
@@ -0,0 +1,194 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.analysis;
+
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import ghidra.app.services.AbstractAnalyzer;
+import ghidra.app.services.AnalysisPriority;
+import ghidra.app.services.AnalyzerType;
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.MemoryByteProvider;
+import ghidra.app.util.importer.MessageLog;
+import ghidra.framework.options.Options;
+import ghidra.program.disassemble.Disassembler;
+import ghidra.program.disassemble.DisassemblerMessageListener;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.address.AddressSet;
+import ghidra.program.model.address.AddressSetView;
+import ghidra.program.model.data.LEB128;
+import ghidra.program.model.lang.Processor;
+import ghidra.program.model.listing.Function;
+import ghidra.program.model.listing.Program;
+import ghidra.util.HelpLocation;
+import ghidra.util.Msg;
+import ghidra.util.exception.CancelledException;
+import ghidra.util.task.TaskMonitor;
+
+public class WasmPreAnalyzer extends AbstractAnalyzer {
+	private final static String NAME = "Wasm Pre-Analyzer";
+	private final static String DESCRIPTION = "Analyze Wasm code before disassembly to resolve operand sizes and jump offsets";
+
+	private final static int CSTACK_GLOBAL_DISABLE = -1;
+	private final static int CSTACK_GLOBAL_AUTO = -2;
+
+	private final static String OPTION_NAME_CSTACK_GLOBAL = "C Stack Pointer";
+	private static final String OPTION_DESCRIPTION_CSTACK_GLOBAL = "0-based index of the global variable being used as the C stack pointer. Set to -1 to disable C stack inference. Set to -2 to guess C stack pointer automatically (default).";
+	private final static int OPTION_DEFAULT_CSTACK_GLOBAL = CSTACK_GLOBAL_AUTO;
+	private int cStackGlobal = OPTION_DEFAULT_CSTACK_GLOBAL;
+
+	public WasmPreAnalyzer() {
+		super(NAME, DESCRIPTION, AnalyzerType.BYTE_ANALYZER);
+		// run immediately before initial disassembly
+		setPriority(AnalysisPriority.BLOCK_ANALYSIS.before());
+		setDefaultEnablement(true);
+	}
+
+	@Override
+	public boolean canAnalyze(Program program) {
+		return program.getLanguage().getProcessor().equals(Processor.findOrPossiblyCreateProcessor("WebAssembly"));
+	}
+
+	@Override
+	public void registerOptions(Options options, Program program) {
+		HelpLocation helpLocation = new HelpLocation("AutoAnalysisPlugin", "Auto_Analysis_Option_Instructions");
+
+		options.registerOption(OPTION_NAME_CSTACK_GLOBAL, cStackGlobal, helpLocation,
+				OPTION_DESCRIPTION_CSTACK_GLOBAL);
+	}
+
+	@Override
+	public void optionsChanged(Options options, Program program) {
+		cStackGlobal = options.getInt(OPTION_NAME_CSTACK_GLOBAL, cStackGlobal);
+	}
+
+	private int guessCStackGlobalForFunction(Program program, Address funcAddress) throws IOException {
+		BinaryReader codeReader = new BinaryReader(new MemoryByteProvider(program.getMemory(), funcAddress), true);
+		int localsCount = codeReader.readNextVarInt(LEB128::signed);
+		for (int i = 0; i < localsCount; i++) {
+			codeReader.readNextVarInt(LEB128::signed); /* count */
+			codeReader.readNextVarInt(LEB128::signed); /* type */
+		}
+
+		/*
+		 * Look for a global.get at the start of the function, and assume that it loads
+		 * the C stack pointer if present
+		 */
+		if (codeReader.readNextUnsignedByte() != 0x23)
+			return -1;
+		return codeReader.readNextVarInt(LEB128::signed);
+	}
+
+	private int guessCStackGlobal(Program program, List<WasmFuncSignature> functions, TaskMonitor monitor) {
+		/* Guess the C stack global by looking at which global appears most often */
+		Map<Integer, Integer> cStackGuesses = new HashMap<>();
+		monitor.setMessage("Analyzing C stack...");
+		monitor.initialize(functions.size());
+		for (WasmFuncSignature function : functions) {
+			if (monitor.isCancelled()) {
+				return CSTACK_GLOBAL_AUTO;
+			}
+			monitor.incrementProgress(1);
+
+			if (function.isImport()) {
+				continue;
+			}
+
+			try {
+				int guessedGlobal = guessCStackGlobalForFunction(program, function.getStartAddr());
+				if (guessedGlobal != -1) {
+					int count = cStackGuesses.getOrDefault(guessedGlobal, 0);
+					cStackGuesses.put(guessedGlobal, count + 1);
+				}
+			} catch (IOException e) {
+				Msg.error(this, "Failed to analyze function " + function.getName(), e);
+			}
+		}
+
+		int bestGuess = CSTACK_GLOBAL_DISABLE;
+		int bestCount = -1;
+		for (Map.Entry<Integer, Integer> entry : cStackGuesses.entrySet()) {
+			if (entry.getValue() > bestCount) {
+				bestGuess = entry.getKey();
+				bestCount = entry.getValue();
+			}
+		}
+		Msg.info(this, "Guessed C stack global: " + bestGuess);
+		return bestGuess;
+	}
+
+	@Override
+	public boolean added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log) throws CancelledException {
+		monitor.setMessage("Parsing module...");
+		WasmAnalysis state = WasmAnalysis.getState(program);
+		List<WasmFuncSignature> functions = state.getFunctions();
+
+		if (cStackGlobal == CSTACK_GLOBAL_AUTO) {
+			cStackGlobal = guessCStackGlobal(program, functions, monitor);
+		}
+
+		monitor.setMessage("Analyzing functions...");
+		monitor.initialize(functions.size());
+
+		Disassembler disassembler = Disassembler.getDisassembler(program, monitor, new DisassemblerMessageListener() {
+			@Override
+			public void disassembleMessageReported(String msg) {
+				if (monitor != null) {
+					monitor.setMessage(msg);
+				}
+			}
+		});
+		disassembler.setRepeatPatternLimit(-1);
+
+		/*
+		 * TODO: Support reanalyzing changed functions, to handle patches and
+		 * significant function changes.
+		 * TODO: Support reanalyzing to change C stack pointer
+		 */
+		for (Function function : program.getListing().getFunctions(set, true)) {
+			if (monitor.isCancelled()) {
+				break;
+			}
+			monitor.incrementProgress(1);
+
+			WasmFunctionAnalysis funcAnalysis;
+			try {
+				funcAnalysis = state.getFunctionAnalysis(function.getEntryPoint());
+			} catch (Exception e) {
+				Msg.error(this, "Failed to analyze function " + function.getName() + " @ " + function.getEntryPoint(), e);
+				function.setComment("WARNING: Wasm function analysis failed, output may be incorrect: " + e);
+				continue;
+			}
+			if (funcAnalysis == null) {
+				continue;
+			}
+
+			try {
+				funcAnalysis.applyContext(program, cStackGlobal);
+				AddressSet funcSet = new AddressSet(
+					funcAnalysis.getSignature().getStartAddr(),
+					funcAnalysis.getSignature().getEndAddr());
+				disassembler.disassemble(funcSet, funcSet, false);
+			} catch (Exception e) {
+				Msg.error(this, "Failed to analyze function " + function.getName() + " @ " + function.getEntryPoint(), e);
+			}
+		}
+		return true;
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmSignatureAnalyzer.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmSignatureAnalyzer.java
new file mode 100644
index 0000000000..829d68dd74
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmSignatureAnalyzer.java
@@ -0,0 +1,118 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.analysis;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import ghidra.app.services.AbstractAnalyzer;
+import ghidra.app.services.AnalysisPriority;
+import ghidra.app.services.AnalyzerType;
+import ghidra.app.util.importer.MessageLog;
+import ghidra.program.model.address.AddressSetView;
+import ghidra.program.model.data.DataType;
+import ghidra.program.model.data.VoidDataType;
+import ghidra.program.model.lang.Processor;
+import ghidra.program.model.listing.Function;
+import ghidra.program.model.listing.Function.FunctionUpdateType;
+import ghidra.program.model.listing.Parameter;
+import ghidra.program.model.listing.ParameterImpl;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.symbol.SourceType;
+import ghidra.util.Msg;
+import ghidra.util.exception.CancelledException;
+import ghidra.util.task.TaskMonitor;
+import wasm.format.WasmEnums.ValType;
+
+public class WasmSignatureAnalyzer extends AbstractAnalyzer {
+	private final static String NAME = "Wasm Signature Analyzer";
+	private final static String DESCRIPTION = "Apply function signatures from Wasm metadata";
+
+	public WasmSignatureAnalyzer() {
+		super(NAME, DESCRIPTION, AnalyzerType.BYTE_ANALYZER);
+		// run immediately after Apply Data Archives, since that pass might introduce
+		// invalid signatures
+		setPriority(AnalysisPriority.FUNCTION_ID_ANALYSIS.after().after());
+		setDefaultEnablement(true);
+	}
+
+	@Override
+	public boolean canAnalyze(Program program) {
+		return program.getLanguage().getProcessor().equals(Processor.findOrPossiblyCreateProcessor("WebAssembly"));
+	}
+
+	private static boolean paramsMatch(List<Parameter> newParams, Parameter[] existingParams) {
+		/* TODO: what if existingParams has a struct which occupies multiple slots? */
+		if (newParams.size() != existingParams.length) {
+			return false;
+		}
+		for (int i = 0; i < existingParams.length; i++) {
+			if (newParams.get(i).getLength() != existingParams[i].getLength()) {
+				return false;
+			}
+		}
+		return true;
+	}
+
+	private static void setFunctionSignature(Program program, Function function, WasmFuncSignature sig) throws Exception {
+		DataType returnType;
+		if (sig.getReturns().length > 0) {
+			/* TODO handle multiple returns */
+			returnType = sig.getReturns()[0].asDataType();
+		} else {
+			returnType = VoidDataType.dataType;
+		}
+
+		function.setCallingConvention("__wasm");
+
+		if (returnType.getLength() != function.getReturnType().getLength()) {
+			/* function return type is wrong: reset it */
+			function.setReturnType(returnType, SourceType.IMPORTED);
+		}
+
+		List<Parameter> params = new ArrayList<>();
+		ValType[] rawParams = sig.getParams();
+		for (int i = 0; i < rawParams.length; i++) {
+			params.add(new ParameterImpl("param" + (i + 1), rawParams[i].asDataType(), program));
+		}
+
+		if (!paramsMatch(params, function.getParameters())) {
+			function.replaceParameters(params, FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS, true, SourceType.IMPORTED);
+		}
+	}
+
+	@Override
+	public boolean added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log) throws CancelledException {
+		WasmAnalysis state = WasmAnalysis.getState(program);
+		List<WasmFuncSignature> functions = state.getFunctions();
+		monitor.initialize(functions.size());
+		for (int i = 0; i < functions.size(); i++) {
+			if (monitor.isCancelled()) {
+				break;
+			}
+			monitor.setProgress(i);
+
+			WasmFuncSignature func = functions.get(i);
+			Function function = program.getListing().getFunctionAt(func.getStartAddr());
+			try {
+				setFunctionSignature(program, function, func);
+			} catch (Exception e) {
+				Msg.error(this, "Failed to set function signature for " + func.getName(), e);
+			}
+		}
+		return true;
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmStackVariableAnalyzer.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmStackVariableAnalyzer.java
new file mode 100644
index 0000000000..f410fbfabd
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/analysis/WasmStackVariableAnalyzer.java
@@ -0,0 +1,264 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.analysis;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import ghidra.app.cmd.function.CallDepthChangeInfo;
+import ghidra.app.services.AbstractAnalyzer;
+import ghidra.app.services.AnalysisPriority;
+import ghidra.app.services.AnalyzerType;
+import ghidra.app.util.importer.MessageLog;
+import ghidra.program.model.address.AddressSetView;
+import ghidra.program.model.data.ArrayDataType;
+import ghidra.program.model.data.ByteDataType;
+import ghidra.program.model.data.CharDataType;
+import ghidra.program.model.data.DataType;
+import ghidra.program.model.data.DefaultDataType;
+import ghidra.program.model.data.Float4DataType;
+import ghidra.program.model.data.Float8DataType;
+import ghidra.program.model.data.IntegerDataType;
+import ghidra.program.model.data.ShortDataType;
+import ghidra.program.model.data.SignedByteDataType;
+import ghidra.program.model.data.Undefined;
+import ghidra.program.model.data.Undefined1DataType;
+import ghidra.program.model.data.Undefined2DataType;
+import ghidra.program.model.data.Undefined4DataType;
+import ghidra.program.model.data.Undefined8DataType;
+import ghidra.program.model.data.UnsignedIntegerDataType;
+import ghidra.program.model.data.UnsignedShortDataType;
+import ghidra.program.model.lang.Processor;
+import ghidra.program.model.lang.Register;
+import ghidra.program.model.listing.Function;
+import ghidra.program.model.listing.Instruction;
+import ghidra.program.model.listing.InstructionIterator;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.listing.StackFrame;
+import ghidra.program.model.listing.Variable;
+import ghidra.program.model.scalar.Scalar;
+import ghidra.program.model.symbol.RefType;
+import ghidra.program.model.symbol.Reference;
+import ghidra.program.model.symbol.ReferenceManager;
+import ghidra.program.model.symbol.SourceType;
+import ghidra.program.model.symbol.StackReference;
+import ghidra.util.Msg;
+import ghidra.util.exception.CancelledException;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.exception.InvalidInputException;
+import ghidra.util.task.TaskMonitor;
+
+public class WasmStackVariableAnalyzer extends AbstractAnalyzer {
+	private static final String NAME = "Wasm Stack Analyzer";
+	private static final String DESCRIPTION = "Creates C stack variables for Wasm functions.";
+
+	public WasmStackVariableAnalyzer() {
+		super(NAME, DESCRIPTION, AnalyzerType.FUNCTION_ANALYZER);
+		setPriority(AnalysisPriority.DATA_TYPE_PROPOGATION.after().after().after());
+		setDefaultEnablement(true);
+	}
+
+	@Override
+	public boolean canAnalyze(Program program) {
+		return program.getLanguage().getProcessor().equals(Processor.findOrPossiblyCreateProcessor("WebAssembly"));
+	}
+
+	@Override
+	public boolean added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log) throws CancelledException {
+		monitor.initialize(program.getFunctionManager().getFunctionCount());
+
+		for (Function function : program.getListing().getFunctions(set, true)) {
+			monitor.checkCancelled();
+			monitor.setMessage("C Stack " + function.getName());
+			monitor.incrementProgress(1);
+
+			createStackPointerVariables(program, function, monitor);
+		}
+
+		return true;
+	}
+
+	private static DataType getMemoryDataType(String mnemonic) {
+		switch (mnemonic) {
+		case "i32.load":
+		case "i32.store":
+			return Undefined4DataType.dataType;
+		case "i64.load":
+		case "i64.store":
+			return Undefined8DataType.dataType;
+		case "f32.store":
+		case "f32.load":
+			return Float4DataType.dataType;
+		case "f64.store":
+		case "f64.load":
+			return Float8DataType.dataType;
+		case "i32.load8_s":
+		case "i64.load8_s":
+			return CharDataType.dataType;
+		case "i32.load8_u":
+		case "i64.load8_u":
+			return ByteDataType.dataType;
+		case "i32.store8":
+		case "i64.store8":
+			return Undefined1DataType.dataType;
+		case "i32.load16_s":
+		case "i64.load16_s":
+			return ShortDataType.dataType;
+		case "i32.load16_u":
+		case "i64.load16_u":
+			return UnsignedShortDataType.dataType;
+		case "i32.store16":
+		case "i64.store16":
+			return Undefined2DataType.dataType;
+		case "i64.load32_s":
+			return IntegerDataType.dataType;
+		case "i64.load32_u":
+			return UnsignedIntegerDataType.dataType;
+		case "i64.store32":
+			return Undefined4DataType.dataType;
+		case "v128.load":
+		case "v128.store":
+			return Undefined.getUndefinedDataType(16);
+		case "v128.load8_lane":
+		case "v128.load8_splat":
+		case "v128.store8_lane":
+			return Undefined1DataType.dataType;
+		case "v128.load16_lane":
+		case "v128.load16_splat":
+		case "v128.store16_lane":
+			return Undefined2DataType.dataType;
+		case "v128.load32_lane":
+		case "v128.load32_splat":
+		case "v128.load32_zero":
+		case "v128.store32_lane":
+			return Undefined4DataType.dataType;
+		case "v128.load64_lane":
+		case "v128.load64_splat":
+		case "v128.load64_zero":
+		case "v128.store64_lane":
+			return Undefined8DataType.dataType;
+		case "v128.load8x8_s":
+			return new ArrayDataType(SignedByteDataType.dataType, 8, 1);
+		case "v128.load8x8_u":
+			return new ArrayDataType(ByteDataType.dataType, 8, 1);
+		case "v128.load16x4_s":
+			return new ArrayDataType(ShortDataType.dataType, 4, 2);
+		case "v128.load16x4_u":
+			return new ArrayDataType(UnsignedShortDataType.dataType, 4, 2);
+		case "v128.load32x2_s":
+			return new ArrayDataType(IntegerDataType.dataType, 2, 4);
+		case "v128.load32x2_u":
+			return new ArrayDataType(UnsignedIntegerDataType.dataType, 2, 4);
+		}
+		return DefaultDataType.dataType;
+	}
+
+	private Variable createVar(Function func, int frameOffset, int offset, DataType dataType) throws InvalidInputException, DuplicateNameException {
+		StackFrame frame = func.getStackFrame();
+		int frameLoc = offset + frameOffset;
+		Variable var = frame.getVariableContaining(frameLoc);
+		if (var == null) {
+			var = frame.createVariable(null, frameLoc, dataType, SourceType.ANALYSIS);
+		} else if (var.getStackOffset() == frameLoc) {
+			DataType oldDt = var.getDataType();
+			if ((Undefined.isUndefined(oldDt) && !Undefined.isUndefined(dataType)) ||
+			(oldDt == DefaultDataType.DEFAULT && dataType != DefaultDataType.DEFAULT)) {
+				var.setDataType(dataType, SourceType.ANALYSIS);
+			}
+		}
+		return var;
+	}
+
+	private void defineFuncVariable(Program program, Function func, Instruction instr, int opIndex, int stackOffset, RefType refType) throws InvalidInputException, DuplicateNameException {
+		ReferenceManager refMgr = program.getReferenceManager();
+
+		Reference ref = instr.getPrimaryReference(opIndex);
+		DataType dataType = getMemoryDataType(instr.getMnemonicString());
+
+		if (ref != null && ref instanceof StackReference)
+			return;
+
+		refMgr.addStackReference(instr.getMinAddress(), opIndex, stackOffset, refType, SourceType.ANALYSIS);
+		createVar(func, 0, stackOffset, dataType);
+	}
+
+	// Get registers sorted by position within the register file
+	private List<Register> getRegisters(Object[] collection) {
+		List<Register> registers = new ArrayList<>();
+		for (Object obj : collection) {
+			if (obj instanceof Register) {
+				registers.add((Register) obj);
+			}
+		}
+		Collections.sort(registers);
+		return registers;
+	}
+
+	private void createStackPointerVariables(Program program, Function func, TaskMonitor monitor) throws CancelledException {
+		CallDepthChangeInfo info = new CallDepthChangeInfo(func, monitor);
+
+		InstructionIterator iter = program.getListing().getInstructions(func.getBody(), true);
+		while (iter.hasNext()) {
+			monitor.checkCancelled();
+			Instruction instr = iter.next();
+
+			try {
+				String mnemonic = instr.getMnemonicString();
+				if (mnemonic.contains(".load")) {
+					// Note: inputObjects is not sorted in any particular order (it may be derived
+					// from a HashSet)
+					Register base = getRegisters(instr.getInputObjects()).get(0);
+					// get offset from "align=A offset=O" operand
+					Scalar offset = (Scalar) instr.getOpObjects(0)[1];
+					int stackOffset = info.getRegDepth(instr.getMinAddress(), base);
+					if (stackOffset == Function.INVALID_STACK_DEPTH_CHANGE) {
+						continue;
+					}
+					defineFuncVariable(program, func, instr, 0, (int) (stackOffset + offset.getUnsignedValue()), RefType.READ);
+				} else if (mnemonic.contains(".store")) {
+					// Note: inputObjects is not sorted in any particular order (it may be derived
+					// from a HashSet)
+					Register base = getRegisters(instr.getInputObjects()).get(0);
+					// get offset from "align=A offset=O" operand
+					Scalar offset = (Scalar) instr.getOpObjects(0)[1];
+					int stackOffset = info.getRegDepth(instr.getMinAddress(), base);
+					if (stackOffset == Function.INVALID_STACK_DEPTH_CHANGE) {
+						continue;
+					}
+					defineFuncVariable(program, func, instr, 0, (int) (stackOffset + offset.getUnsignedValue()), RefType.WRITE);
+				} else if (mnemonic.equals("local.get") || mnemonic.equals("local.set")) {
+					// These instructions will only have one input
+					Register input = (Register) instr.getInputObjects()[0];
+					int stackOffset = info.getRegDepth(instr.getMinAddress(), input);
+					if (stackOffset == Function.INVALID_STACK_DEPTH_CHANGE) {
+						continue;
+					}
+					if (stackOffset == info.getDepth(instr.getMinAddress()) || stackOffset == 0) {
+						/*
+						 * Heuristically, avoid simple references to the frame or stack base, as they're
+						 * likely to be operands for a later operation
+						 */
+						continue;
+					}
+					defineFuncVariable(program, func, instr, 0, stackOffset, RefType.DATA);
+				}
+			} catch (Exception e) {
+				Msg.warn(this, "Failed to process instruction at " + instr.getMinAddress() + ": " + instr + ": " + e.getMessage());
+			}
+		}
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/StructureBuilder.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/StructureBuilder.java
new file mode 100644
index 0000000000..2fa3f51416
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/StructureBuilder.java
@@ -0,0 +1,135 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.data.ArrayDataType;
+import ghidra.program.model.data.CategoryPath;
+import ghidra.program.model.data.DataType;
+import ghidra.program.model.data.DataTypeComponent;
+import ghidra.program.model.data.DataTypeComponentImpl;
+import ghidra.program.model.data.Structure;
+import ghidra.program.model.data.StructureDataType;
+import ghidra.util.exception.DuplicateNameException;
+
+public class StructureBuilder {
+	private class SBStructure extends StructureDataType {
+		public SBStructure(CategoryPath path, String name, int length) {
+			super(path, name, length);
+		}
+
+		/**
+		 * Add a component to this structure. This function does not repack the
+		 * structure after adding, in order to avoid quadratic behaviour when adding a
+		 * large number of structure elements. To ensure correct behaviour, the
+		 * structure should be repacked after components have been added.
+		 */
+		@Override
+		public DataTypeComponent add(DataType dataType, int length, String componentName, String comment) {
+			dataType = validateDataType(dataType);
+
+			dataType = dataType.clone(dataMgr);
+
+			checkAncestry(dataType);
+
+			DataTypeComponentImpl dtc;
+			int offset = structLength;
+			int ordinal = numComponents;
+
+			int componentLength = getPreferredComponentLength(dataType, length);
+
+			dtc = new DataTypeComponentImpl(dataType, this, componentLength, ordinal, offset,
+					componentName, comment);
+			dataType.addParent(this);
+			components.add(dtc);
+
+			int structureGrowth = dtc.getLength();
+			if (!isPackingEnabled() && length > 0) {
+				structureGrowth = length;
+			}
+
+			numComponents++;
+			structLength += structureGrowth;
+			return dtc;
+		}
+	}
+
+	private SBStructure structure;
+
+	public StructureBuilder(String name) {
+		CategoryPath path = new CategoryPath(CategoryPath.ROOT, "Wasm");
+		structure = new SBStructure(path, name, 0);
+	}
+
+	public Structure toStructure() {
+		StructureDataType newStructure = new StructureDataType(structure.getCategoryPath(), structure.getName(), 0);
+		newStructure.replaceWith(structure);
+		return newStructure;
+	}
+
+	public void add(DataType dataType, int length, String name, String comment) {
+		structure.add(dataType, length, name, comment);
+	}
+
+	public void add(DataType dataType, int length, String name) {
+		add(dataType, length, name, null);
+	}
+
+	public void add(DataType dataType, String name, String comment) {
+		structure.add(dataType, dataType.getLength(), name, comment);
+	}
+
+	public void add(DataType dataType, String name) {
+		add(dataType, name, null);
+	}
+
+	public void addUnsignedLeb128(LEB128Info leb128, String name, String comment) {
+		add(StructConverter.ULEB128, leb128.getLength(), name, comment);
+	}
+
+	public void addUnsignedLeb128(LEB128Info leb128, String name) {
+		addUnsignedLeb128(leb128, name, null);
+	}
+
+	public void add(StructConverter converter, String name, String comment) throws DuplicateNameException, IOException {
+		add(converter.toDataType(), name, comment);
+	}
+
+	public void add(StructConverter converter, String name) throws DuplicateNameException, IOException {
+		add(converter.toDataType(), name, null);
+	}
+
+	public void addArray(DataType dataType, int numElements, String name, String comment) {
+		if (numElements > 0)
+			structure.add(new ArrayDataType(dataType, numElements, dataType.getLength()), name, comment);
+	}
+
+	public void addArray(DataType dataType, int numElements, String name) {
+		addArray(dataType, numElements, name, null);
+	}
+
+	public void addString(int byteSize, String name, String comment) {
+		if (byteSize > 0)
+			structure.add(StructConverter.STRING, byteSize, name, comment);
+	}
+
+	public void addString(int byteSize, String name) {
+		addString(byteSize, name, null);
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/WasmConstants.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/WasmConstants.java
new file mode 100644
index 0000000000..084aac39ae
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/WasmConstants.java
@@ -0,0 +1,21 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format;
+
+public class WasmConstants {
+	public final static byte[] WASM_MAGIC = new byte[] { 0, 0x61, 0x73, 0x6D };
+	public final static int WASM_VERSION = 1;
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/WasmEnums.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/WasmEnums.java
new file mode 100644
index 0000000000..cee1f2054f
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/WasmEnums.java
@@ -0,0 +1,108 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format;
+
+import java.util.HashMap;
+
+import ghidra.program.model.data.DataType;
+import ghidra.program.model.data.DoubleDataType;
+import ghidra.program.model.data.FloatDataType;
+import ghidra.program.model.data.PointerDataType;
+import ghidra.program.model.data.Undefined;
+import ghidra.program.model.data.Undefined4DataType;
+import ghidra.program.model.data.Undefined8DataType;
+
+public class WasmEnums {
+	public enum WasmExternalKind {
+		EXT_FUNCTION,
+		EXT_TABLE,
+		EXT_MEMORY,
+		EXT_GLOBAL
+	}
+
+	public enum ValType {
+		i32(0x7f),
+		i64(0x7e),
+		f32(0x7d),
+		f64(0x7c),
+		v128(0x7b),
+
+		funcref(0x70),
+		externref(0x6f);
+
+		private static final HashMap<Integer, ValType> BY_BYTE = new HashMap<>();
+		public static final DataType Undefined16 = Undefined.getUndefinedDataType(16);
+		public final int typeByte;
+
+		static {
+			for (ValType t : ValType.values()) {
+				BY_BYTE.put(t.typeByte, t);
+			}
+		}
+
+		private ValType(int v) {
+			this.typeByte = v;
+		}
+
+		public DataType asDataType() {
+			switch (this) {
+			case i32:
+				return Undefined4DataType.dataType;
+			case i64:
+				return Undefined8DataType.dataType;
+			case f32:
+				return FloatDataType.dataType;
+			case f64:
+				return DoubleDataType.dataType;
+			case v128:
+				return Undefined16;
+			case funcref:
+				return PointerDataType.dataType;
+			case externref:
+				return Undefined4DataType.dataType;
+			}
+			return null;
+		}
+
+		public int getSize() {
+			switch (this) {
+			case i32:
+			case f32:
+			case funcref:
+			case externref:
+				return 4;
+			case i64:
+			case f64:
+				return 8;
+			case v128:
+				return 16;
+			}
+			return 4;
+		}
+
+		public static ValType fromByte(int b) {
+			return BY_BYTE.get(b);
+		}
+
+		public static ValType[] fromBytes(byte[] types) {
+			ValType[] res = new ValType[types.length];
+			for (int i = 0; i < types.length; i++) {
+				res[i] = fromByte(types[i]);
+			}
+			return res;
+		}
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/WasmHeader.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/WasmHeader.java
new file mode 100644
index 0000000000..8790d9705f
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/WasmHeader.java
@@ -0,0 +1,54 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format;
+
+import java.io.IOException;
+import java.util.Arrays;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.data.DataType;
+import ghidra.util.exception.DuplicateNameException;
+
+public class WasmHeader implements StructConverter {
+
+	private byte[] magic;
+	private int version;
+
+	public WasmHeader(BinaryReader reader) throws IOException {
+		magic = reader.readNextByteArray(WasmConstants.WASM_MAGIC.length);
+		version = reader.readNextInt();
+		if (!Arrays.equals(WasmConstants.WASM_MAGIC, magic)) {
+			throw new IOException("not a wasm file.");
+		}
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureBuilder builder = new StructureBuilder("header");
+		builder.add(STRING, 4, "magic");
+		builder.add(DWORD, 4, "version");
+		return builder.toStructure();
+	}
+
+	public byte[] getMagic() {
+		return magic;
+	}
+
+	public int getVersion() {
+		return version;
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/WasmModule.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/WasmModule.java
new file mode 100644
index 0000000000..b270cde7b1
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/WasmModule.java
@@ -0,0 +1,273 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.EnumMap;
+import java.util.List;
+import java.util.Map;
+
+import ghidra.app.util.bin.BinaryReader;
+import wasm.format.WasmEnums.WasmExternalKind;
+import wasm.format.sections.WasmCodeSection;
+import wasm.format.sections.WasmCustomSection;
+import wasm.format.sections.WasmDataSection;
+import wasm.format.sections.WasmElementSection;
+import wasm.format.sections.WasmExportSection;
+import wasm.format.sections.WasmFunctionSection;
+import wasm.format.sections.WasmGlobalSection;
+import wasm.format.sections.WasmImportSection;
+import wasm.format.sections.WasmLinearMemorySection;
+import wasm.format.sections.WasmNameSection;
+import wasm.format.sections.WasmSection;
+import wasm.format.sections.WasmSection.WasmSectionId;
+import wasm.format.sections.WasmStartSection;
+import wasm.format.sections.WasmTableSection;
+import wasm.format.sections.WasmTypeSection;
+import wasm.format.sections.structures.WasmCodeEntry;
+import wasm.format.sections.structures.WasmDataSegment;
+import wasm.format.sections.structures.WasmElementSegment;
+import wasm.format.sections.structures.WasmExportEntry;
+import wasm.format.sections.structures.WasmFuncType;
+import wasm.format.sections.structures.WasmGlobalEntry;
+import wasm.format.sections.structures.WasmGlobalType;
+import wasm.format.sections.structures.WasmImportEntry;
+import wasm.format.sections.structures.WasmResizableLimits;
+import wasm.format.sections.structures.WasmTableType;
+
+public class WasmModule {
+
+	private WasmHeader header;
+	private List<WasmSection> sections = new ArrayList<>();
+	private List<WasmCustomSection> customSections = new ArrayList<>();
+	private Map<WasmSectionId, WasmSection> sectionMap = new EnumMap<>(WasmSectionId.class);
+
+	public WasmModule(BinaryReader reader) throws IOException {
+		header = new WasmHeader(reader);
+		while (reader.getPointerIndex() < reader.length()) {
+			WasmSection section = WasmSection.createSection(reader);
+			if (section == null)
+				continue;
+			sections.add(section);
+
+			/* Except for custom sections, all other sections may appear at most once. */
+			if (section.getId() == WasmSectionId.SEC_CUSTOM) {
+				customSections.add((WasmCustomSection) section);
+			} else {
+				sectionMap.put(section.getId(), section);
+			}
+		}
+	}
+
+	public WasmHeader getHeader() {
+		return header;
+	}
+
+	public List<WasmSection> getSections() {
+		return sections;
+	}
+
+	public WasmSection getSection(WasmSectionId sectionId) {
+		return sectionMap.get(sectionId);
+	}
+
+	// #region Sections which do not represent vectors of entries
+	public List<WasmCustomSection> getCustomSections() {
+		return Collections.unmodifiableList(customSections);
+	}
+
+	public WasmNameSection getNameSection() {
+		for (WasmCustomSection section : customSections) {
+			if (section instanceof WasmNameSection) {
+				return (WasmNameSection) section;
+			}
+		}
+		return null;
+	}
+
+	public WasmStartSection getStartSection() {
+		return (WasmStartSection) sectionMap.get(WasmSectionId.SEC_START);
+	}
+	// #endregion
+
+	// #region Sections which represent vectors of entries
+	private WasmTypeSection getTypeSection() {
+		return (WasmTypeSection) sectionMap.get(WasmSectionId.SEC_TYPE);
+	}
+
+	private WasmImportSection getImportSection() {
+		return (WasmImportSection) sectionMap.get(WasmSectionId.SEC_IMPORT);
+	}
+
+	private WasmFunctionSection getFunctionSection() {
+		return (WasmFunctionSection) sectionMap.get(WasmSectionId.SEC_FUNCTION);
+	}
+
+	private WasmTableSection getTableSection() {
+		return (WasmTableSection) sectionMap.get(WasmSectionId.SEC_TABLE);
+	}
+
+	private WasmLinearMemorySection getLinearMemorySection() {
+		return (WasmLinearMemorySection) sectionMap.get(WasmSectionId.SEC_LINEARMEMORY);
+	}
+
+	private WasmGlobalSection getGlobalSection() {
+		return (WasmGlobalSection) sectionMap.get(WasmSectionId.SEC_GLOBAL);
+	}
+
+	private WasmExportSection getExportSection() {
+		return (WasmExportSection) sectionMap.get(WasmSectionId.SEC_EXPORT);
+	}
+
+	private WasmElementSection getElementSection() {
+		return (WasmElementSection) sectionMap.get(WasmSectionId.SEC_ELEMENT);
+	}
+
+	private WasmCodeSection getCodeSection() {
+		return (WasmCodeSection) sectionMap.get(WasmSectionId.SEC_CODE);
+	}
+
+	private WasmDataSection getDataSection() {
+		return (WasmDataSection) sectionMap.get(WasmSectionId.SEC_DATA);
+	}
+
+	public WasmFuncType getType(int typeidx) {
+		WasmTypeSection typeSection = getTypeSection();
+		if (typeSection == null) {
+			throw new IndexOutOfBoundsException(typeidx);
+		}
+		return typeSection.getType(typeidx);
+	}
+
+	public List<WasmImportEntry> getImports(WasmExternalKind kind) {
+		WasmImportSection importSection = getImportSection();
+		if (importSection == null) {
+			return Collections.emptyList();
+		}
+		return importSection.getImports(kind);
+	}
+
+	public List<WasmTableType> getNonImportedTables() {
+		WasmTableSection tableSection = getTableSection();
+		if (tableSection == null) {
+			return Collections.emptyList();
+		}
+		return tableSection.getTables();
+	}
+
+	public List<WasmResizableLimits> getNonImportedMemories() {
+		WasmLinearMemorySection memorySection = getLinearMemorySection();
+		if (memorySection == null) {
+			return Collections.emptyList();
+		}
+		return memorySection.getMemories();
+	}
+
+	public List<WasmGlobalEntry> getNonImportedGlobals() {
+		WasmGlobalSection globalSection = getGlobalSection();
+		if (globalSection == null) {
+			return Collections.emptyList();
+		}
+		return globalSection.getEntries();
+	}
+
+	public List<WasmExportEntry> getExports(WasmExternalKind kind) {
+		WasmExportSection exportSection = getExportSection();
+		if (exportSection == null) {
+			return Collections.emptyList();
+		}
+		return exportSection.getExports(kind);
+	}
+
+	public List<WasmElementSegment> getElementSegments() {
+		WasmElementSection elementSection = getElementSection();
+		if (elementSection == null) {
+			return Collections.emptyList();
+		}
+		return elementSection.getSegments();
+	}
+
+	public List<WasmCodeEntry> getNonImportedFunctions() {
+		WasmCodeSection codeSection = getCodeSection();
+		if (codeSection == null) {
+			return Collections.emptyList();
+		}
+		return codeSection.getFunctions();
+	}
+
+	public List<WasmDataSegment> getDataSegments() {
+		WasmDataSection dataSection = getDataSection();
+		if (dataSection == null) {
+			return Collections.emptyList();
+		}
+		return dataSection.getSegments();
+	}
+	// #endregion
+
+	// #region Convenience functions
+	public int getFunctionCount() {
+		int numFunctions = getImports(WasmExternalKind.EXT_FUNCTION).size();
+		WasmFunctionSection functionSection = getFunctionSection();
+		if (functionSection != null) {
+			numFunctions += functionSection.getTypeCount();
+		}
+		return numFunctions;
+	}
+
+	public WasmFuncType getFunctionType(int funcidx) {
+		List<WasmImportEntry> imports = getImports(WasmExternalKind.EXT_FUNCTION);
+		if (funcidx < imports.size()) {
+			return getType(imports.get(funcidx).getFunctionType());
+		}
+		return getType(getFunctionSection().getTypeIdx(funcidx - imports.size()));
+	}
+
+	public WasmCodeEntry getFunctionCode(int funcidx) {
+		List<WasmImportEntry> imports = getImports(WasmExternalKind.EXT_FUNCTION);
+		if (funcidx < imports.size()) {
+			return null;
+		} else {
+			return getNonImportedFunctions().get(funcidx - imports.size());
+		}
+	}
+
+	public WasmGlobalType getGlobalType(int globalidx) {
+		List<WasmImportEntry> imports = getImports(WasmExternalKind.EXT_GLOBAL);
+		if (globalidx < imports.size()) {
+			return imports.get(globalidx).getGlobalType();
+		}
+		return getNonImportedGlobals().get(globalidx - imports.size()).getGlobalType();
+	}
+
+	public WasmTableType getTableType(int tableidx) {
+		List<WasmImportEntry> imports = getImports(WasmExternalKind.EXT_TABLE);
+		if (tableidx < imports.size()) {
+			return imports.get(tableidx).getTableType();
+		}
+		return getNonImportedTables().get(tableidx - imports.size());
+	}
+
+	public WasmExportEntry findExport(WasmExternalKind kind, int idx) {
+		WasmExportSection exportSection = getExportSection();
+		if (exportSection == null) {
+			return null;
+		}
+		return exportSection.findEntry(kind, idx);
+	}
+	// #endregion
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmCodeSection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmCodeSection.java
new file mode 100644
index 0000000000..83411e4da2
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmCodeSection.java
@@ -0,0 +1,57 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.sections.structures.WasmCodeEntry;
+
+public class WasmCodeSection extends WasmSection {
+
+	private LEB128Info count;
+	private List<WasmCodeEntry> functions = new ArrayList<WasmCodeEntry>();
+
+	public WasmCodeSection(BinaryReader reader) throws IOException {
+		super(reader);
+		count = reader.readNext(LEB128Info::unsigned);
+		for (int i = 0; i < count.asLong(); ++i) {
+			functions.add(new WasmCodeEntry(reader));
+		}
+	}
+
+	public List<WasmCodeEntry> getFunctions() {
+		return Collections.unmodifiableList(functions);
+	}
+
+	@Override
+	protected void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		builder.addUnsignedLeb128(count, "count");
+		// Do not add individual code entries to the structure: they need to be parsed
+		// as code instead of data.
+	}
+
+	@Override
+	public String getName() {
+		return ".code";
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmCustomSection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmCustomSection.java
new file mode 100644
index 0000000000..d807752226
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmCustomSection.java
@@ -0,0 +1,64 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.sections.structures.WasmName;
+
+public abstract class WasmCustomSection extends WasmSection {
+	private WasmName name;
+	private long customLength;
+
+	protected WasmCustomSection(BinaryReader reader) throws IOException {
+		super(reader);
+		name = new WasmName(reader);
+		customLength = getContentSize() - name.getSize();
+	}
+
+	public static WasmCustomSection create(BinaryReader reader) throws IOException {
+		long initialOffset = reader.getPointerIndex();
+		/* skip section header: id + contentLength */
+		reader.readNextUnsignedByte();
+		reader.readNext(LEB128Info::unsigned);
+
+		String name = new WasmName(reader).getValue();
+		reader.setPointerIndex(initialOffset);
+
+		if (name.equals("name")) {
+			return new WasmNameSection(reader);
+		}
+
+		return new WasmUnknownCustomSection(reader);
+	}
+
+	@Override
+	protected void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		builder.add(name, "name");
+	}
+
+	public String getCustomName() {
+		return name.getValue();
+	}
+
+	public long getCustomSize() {
+		return customLength;
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmDataSection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmDataSection.java
new file mode 100644
index 0000000000..de29ce44b9
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmDataSection.java
@@ -0,0 +1,58 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.sections.structures.WasmDataSegment;
+
+public class WasmDataSection extends WasmSection {
+
+	private LEB128Info count;
+	private List<WasmDataSegment> dataSegments = new ArrayList<WasmDataSegment>();
+
+	public WasmDataSection(BinaryReader reader) throws IOException {
+		super(reader);
+		count = reader.readNext(LEB128Info::unsigned);
+		for (int i = 0; i < count.asLong(); ++i) {
+			dataSegments.add(new WasmDataSegment(reader));
+		}
+	}
+
+	public List<WasmDataSegment> getSegments() {
+		return Collections.unmodifiableList(dataSegments);
+	}
+
+	@Override
+	protected void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		builder.addUnsignedLeb128(count, "count");
+		for (int i = 0; i < dataSegments.size(); i++) {
+			builder.add(dataSegments.get(i), "segment_" + i);
+		}
+	}
+
+	@Override
+	public String getName() {
+		return ".data";
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmElementSection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmElementSection.java
new file mode 100644
index 0000000000..9fac123adc
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmElementSection.java
@@ -0,0 +1,58 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.sections.structures.WasmElementSegment;
+
+public class WasmElementSection extends WasmSection {
+
+	private LEB128Info count;
+	private List<WasmElementSegment> elements = new ArrayList<WasmElementSegment>();
+
+	public WasmElementSection(BinaryReader reader) throws IOException {
+		super(reader);
+		count = reader.readNext(LEB128Info::unsigned);
+		for (int i = 0; i < count.asLong(); ++i) {
+			elements.add(new WasmElementSegment(reader));
+		}
+	}
+
+	public List<WasmElementSegment> getSegments() {
+		return Collections.unmodifiableList(elements);
+	}
+
+	@Override
+	protected void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		builder.addUnsignedLeb128(count, "count");
+		for (int i = 0; i < elements.size(); i++) {
+			builder.add(elements.get(i), "element_" + i);
+		}
+	}
+
+	@Override
+	public String getName() {
+		return ".element";
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmExportSection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmExportSection.java
new file mode 100644
index 0000000000..af213e3fe7
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmExportSection.java
@@ -0,0 +1,77 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.EnumMap;
+import java.util.List;
+import java.util.Map;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.WasmEnums.WasmExternalKind;
+import wasm.format.sections.structures.WasmExportEntry;
+
+public class WasmExportSection extends WasmSection {
+
+	private LEB128Info count;
+	private List<WasmExportEntry> exportList = new ArrayList<>();
+	private Map<WasmExternalKind, List<WasmExportEntry>> exports = new EnumMap<>(WasmExternalKind.class);
+
+	public WasmExportSection(BinaryReader reader) throws IOException {
+		super(reader);
+		count = reader.readNext(LEB128Info::unsigned);
+		for (int i = 0; i < count.asLong(); ++i) {
+			WasmExportEntry entry = new WasmExportEntry(reader);
+			WasmExternalKind kind = entry.getKind();
+			if (!exports.containsKey(kind)) {
+				exports.put(kind, new ArrayList<WasmExportEntry>());
+			}
+			exports.get(kind).add(entry);
+			exportList.add(entry);
+		}
+	}
+
+	public List<WasmExportEntry> getExports(WasmExternalKind kind) {
+		return exports.getOrDefault(kind, Collections.emptyList());
+	}
+
+	public WasmExportEntry findEntry(WasmExternalKind kind, int id) {
+		for (WasmExportEntry entry : getExports(kind)) {
+			if (entry.getIndex() == id) {
+				return entry;
+			}
+		}
+		return null;
+	}
+
+	@Override
+	protected void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		builder.addUnsignedLeb128(count, "count");
+		for (int i = 0; i < exportList.size(); i++) {
+			builder.add(exportList.get(i), "export_" + i);
+		}
+	}
+
+	@Override
+	public String getName() {
+		return ".export";
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmFunctionSection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmFunctionSection.java
new file mode 100644
index 0000000000..d5369a6b3a
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmFunctionSection.java
@@ -0,0 +1,60 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+
+public class WasmFunctionSection extends WasmSection {
+
+	private LEB128Info count;
+	private List<LEB128Info> types = new ArrayList<LEB128Info>();
+
+	public WasmFunctionSection(BinaryReader reader) throws IOException {
+		super(reader);
+		count = reader.readNext(LEB128Info::unsigned);
+		for (int i = 0; i < count.asLong(); ++i) {
+			types.add(reader.readNext(LEB128Info::unsigned));
+		}
+	}
+
+	public int getTypeIdx(int funcidx) {
+		return (int) types.get(funcidx).asLong();
+	}
+
+	public int getTypeCount() {
+		return types.size();
+	}
+
+	@Override
+	protected void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		builder.addUnsignedLeb128(count, "count");
+		for (int i = 0; i < types.size(); i++) {
+			builder.addUnsignedLeb128(types.get(i), "function_" + i);
+		}
+	}
+
+	@Override
+	public String getName() {
+		return ".function";
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmGlobalSection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmGlobalSection.java
new file mode 100644
index 0000000000..aa10d30a52
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmGlobalSection.java
@@ -0,0 +1,58 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.sections.structures.WasmGlobalEntry;
+
+public class WasmGlobalSection extends WasmSection {
+
+	private LEB128Info count;
+	private List<WasmGlobalEntry> globals = new ArrayList<>();
+
+	public WasmGlobalSection(BinaryReader reader) throws IOException {
+		super(reader);
+		count = reader.readNext(LEB128Info::unsigned);
+		for (int i = 0; i < count.asLong(); ++i) {
+			globals.add(new WasmGlobalEntry(reader));
+		}
+	}
+
+	public List<WasmGlobalEntry> getEntries() {
+		return Collections.unmodifiableList(globals);
+	}
+
+	@Override
+	protected void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		builder.addUnsignedLeb128(count, "count");
+		for (int i = 0; i < globals.size(); i++) {
+			builder.add(globals.get(i), "global_" + i);
+		}
+	}
+
+	@Override
+	public String getName() {
+		return ".global";
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmImportSection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmImportSection.java
new file mode 100644
index 0000000000..1361d6abc7
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmImportSection.java
@@ -0,0 +1,68 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.EnumMap;
+import java.util.List;
+import java.util.Map;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.WasmEnums.WasmExternalKind;
+import wasm.format.sections.structures.WasmImportEntry;
+
+public class WasmImportSection extends WasmSection {
+
+	private LEB128Info count;
+	private List<WasmImportEntry> importList = new ArrayList<>();
+	private Map<WasmExternalKind, List<WasmImportEntry>> imports = new EnumMap<>(WasmExternalKind.class);
+
+	public WasmImportSection(BinaryReader reader) throws IOException {
+		super(reader);
+		count = reader.readNext(LEB128Info::unsigned);
+		for (int i = 0; i < count.asLong(); ++i) {
+			WasmImportEntry entry = new WasmImportEntry(reader);
+			WasmExternalKind kind = entry.getKind();
+			if (!imports.containsKey(kind)) {
+				imports.put(kind, new ArrayList<WasmImportEntry>());
+			}
+			imports.get(kind).add(entry);
+			importList.add(entry);
+		}
+	}
+
+	public List<WasmImportEntry> getImports(WasmExternalKind kind) {
+		return imports.getOrDefault(kind, Collections.emptyList());
+	}
+
+	@Override
+	protected void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		builder.addUnsignedLeb128(count, "count");
+		for (int i = 0; i < importList.size(); i++) {
+			builder.add(importList.get(i), "import_" + i);
+		}
+	}
+
+	@Override
+	public String getName() {
+		return ".import";
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmLinearMemorySection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmLinearMemorySection.java
new file mode 100644
index 0000000000..de9b46618e
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmLinearMemorySection.java
@@ -0,0 +1,58 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.sections.structures.WasmResizableLimits;
+
+public class WasmLinearMemorySection extends WasmSection {
+
+	private LEB128Info count;
+	private List<WasmResizableLimits> limits = new ArrayList<WasmResizableLimits>();
+
+	public WasmLinearMemorySection(BinaryReader reader) throws IOException {
+		super(reader);
+		count = reader.readNext(LEB128Info::unsigned);
+		for (int i = 0; i < count.asLong(); ++i) {
+			limits.add(new WasmResizableLimits(reader));
+		}
+	}
+
+	public List<WasmResizableLimits> getMemories() {
+		return Collections.unmodifiableList(limits);
+	}
+
+	@Override
+	protected void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		builder.addUnsignedLeb128(count, "count");
+		for (int i = 0; i < limits.size(); i++) {
+			builder.add(limits.get(i), "memory_type_" + i);
+		}
+	}
+
+	@Override
+	public String getName() {
+		return ".linearMemory";
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmNameSection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmNameSection.java
new file mode 100644
index 0000000000..c8575a2582
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmNameSection.java
@@ -0,0 +1,97 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.EnumMap;
+import java.util.List;
+import java.util.Map;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.sections.structures.WasmNameLocalSubsection;
+import wasm.format.sections.structures.WasmNameMapSubsection;
+import wasm.format.sections.structures.WasmNameModuleSubsection;
+import wasm.format.sections.structures.WasmNameSubsection;
+import wasm.format.sections.structures.WasmNameSubsection.WasmNameSubsectionId;;
+
+public class WasmNameSection extends WasmCustomSection {
+	private List<WasmNameSubsection> subsections = new ArrayList<>();
+	private Map<WasmNameSubsectionId, WasmNameSubsection> subsectionMap = new EnumMap<>(WasmNameSubsectionId.class);
+
+	public WasmNameSection(BinaryReader reader) throws IOException {
+		super(reader);
+		long sectionEnd = getSectionOffset() + getSectionSize();
+		while (reader.getPointerIndex() < sectionEnd) {
+			WasmNameSubsection subsection = WasmNameSubsection.createSubsection(reader);
+			if (subsection == null)
+				continue;
+			subsections.add(subsection);
+			if (subsection.getId() != null)
+				subsectionMap.put(subsection.getId(), subsection);
+		}
+	}
+
+	@Override
+	protected void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		super.addToStructure(builder);
+		for (int i = 0; i < subsections.size(); i++) {
+			builder.add(subsections.get(i), subsections.get(i).getName());
+		}
+	}
+
+	public String getModuleName() {
+		WasmNameSubsection subsection = subsectionMap.get(WasmNameSubsectionId.NAME_MODULE);
+		if (subsection == null)
+			return null;
+		return ((WasmNameModuleSubsection) subsection).getModuleName();
+	}
+
+	public String getFunctionName(int idx) {
+		WasmNameSubsection subsection = subsectionMap.get(WasmNameSubsectionId.NAME_FUNCTION);
+		if (subsection == null)
+			return null;
+		return ((WasmNameMapSubsection) subsection).getName(idx);
+	}
+
+	public String getLocalName(int funcidx, int localidx) {
+		WasmNameSubsection subsection = subsectionMap.get(WasmNameSubsectionId.NAME_LOCAL);
+		if (subsection == null)
+			return null;
+		return ((WasmNameLocalSubsection) subsection).getLocalName(funcidx, localidx);
+	}
+
+	public String getGlobalName(int idx) {
+		WasmNameSubsection subsection = subsectionMap.get(WasmNameSubsectionId.NAME_GLOBAL);
+		if (subsection == null)
+			return null;
+		return ((WasmNameMapSubsection) subsection).getName(idx);
+	}
+
+	public String getDataName(int idx) {
+		WasmNameSubsection subsection = subsectionMap.get(WasmNameSubsectionId.NAME_DATA);
+		if (subsection == null)
+			return null;
+		return ((WasmNameMapSubsection) subsection).getName(idx);
+	}
+
+	@Override
+	public String getName() {
+		return ".name";
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmSection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmSection.java
new file mode 100644
index 0000000000..3eaa2a1ca3
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmSection.java
@@ -0,0 +1,123 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.data.DataType;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+
+public abstract class WasmSection implements StructConverter {
+
+	private WasmSectionId id;
+	private LEB128Info contentLength;
+	private long sectionOffset;
+
+	public enum WasmSectionId {
+		SEC_CUSTOM,
+		SEC_TYPE,
+		SEC_IMPORT,
+		SEC_FUNCTION,
+		SEC_TABLE,
+		SEC_LINEARMEMORY,
+		SEC_GLOBAL,
+		SEC_EXPORT,
+		SEC_START,
+		SEC_ELEMENT,
+		SEC_CODE,
+		SEC_DATA
+	}
+
+	public static WasmSection createSection(BinaryReader reader) throws IOException {
+		long sectionOffset = reader.getPointerIndex();
+		int id = reader.readNextUnsignedByte();
+		LEB128Info contentLength = reader.readNext(LEB128Info::unsigned);
+		reader.setPointerIndex(reader.getPointerIndex() + contentLength.asLong());
+
+		if(id >= WasmSectionId.values().length)
+			return null;
+
+		BinaryReader sectionReader = reader.clone(sectionOffset);
+
+		switch (WasmSectionId.values()[id]) {
+			case SEC_CUSTOM:
+				return WasmCustomSection.create(sectionReader);
+			case SEC_TYPE:
+				return new WasmTypeSection(sectionReader);
+			case SEC_IMPORT:
+				return new WasmImportSection(sectionReader);
+			case SEC_FUNCTION:
+				return new WasmFunctionSection(sectionReader);
+			case SEC_TABLE:
+				return new WasmTableSection(sectionReader);
+			case SEC_LINEARMEMORY:
+				return new WasmLinearMemorySection(sectionReader);
+			case SEC_GLOBAL:
+				return new WasmGlobalSection(sectionReader);
+			case SEC_EXPORT:
+				return new WasmExportSection(sectionReader);
+			case SEC_START:
+				return new WasmStartSection(sectionReader);
+			case SEC_ELEMENT:
+				return new WasmElementSection(sectionReader);
+			case SEC_CODE:
+				return new WasmCodeSection(sectionReader);
+			case SEC_DATA:
+				return new WasmDataSection(sectionReader);
+			default:
+				return null;
+		}
+	}
+
+	protected WasmSection(BinaryReader reader) throws IOException {
+		sectionOffset = reader.getPointerIndex();
+		id = WasmSectionId.values()[reader.readNextUnsignedByte()];
+		contentLength = reader.readNext(LEB128Info::unsigned);
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureBuilder builder = new StructureBuilder(getName());
+		builder.add(BYTE, "id");
+		builder.addUnsignedLeb128(contentLength, "size");
+		addToStructure(builder);
+		return builder.toStructure();
+	}
+
+	public abstract String getName();
+
+	protected abstract void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException;
+
+	public WasmSectionId getId() {
+		return id;
+	}
+
+	public long getSectionOffset() {
+		return sectionOffset;
+	}
+
+	public long getContentSize() {
+		return contentLength.asLong();
+	}
+
+	public long getSectionSize() {
+		return 1 + contentLength.getLength() + contentLength.asLong();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmStartSection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmStartSection.java
new file mode 100644
index 0000000000..820145485c
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmStartSection.java
@@ -0,0 +1,47 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+
+public class WasmStartSection extends WasmSection {
+
+	private LEB128Info funcIdx;
+
+	public WasmStartSection(BinaryReader reader) throws IOException {
+		super(reader);
+		funcIdx = reader.readNext(LEB128Info::unsigned);
+	}
+
+	public long getStartFunctionIndex() {
+		return funcIdx.asLong();
+	}
+
+	@Override
+	public void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		builder.addUnsignedLeb128(funcIdx, "func");
+	}
+
+	@Override
+	public String getName() {
+		return ".start";
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmTableSection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmTableSection.java
new file mode 100644
index 0000000000..3d7a317ba0
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmTableSection.java
@@ -0,0 +1,58 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.sections.structures.WasmTableType;
+
+public class WasmTableSection extends WasmSection {
+
+	private LEB128Info count;
+	private List<WasmTableType> tables = new ArrayList<WasmTableType>();
+
+	public WasmTableSection(BinaryReader reader) throws IOException {
+		super(reader);
+		count = reader.readNext(LEB128Info::unsigned);
+		for (int i = 0; i < count.asLong(); ++i) {
+			tables.add(new WasmTableType(reader));
+		}
+	}
+
+	public List<WasmTableType> getTables() {
+		return Collections.unmodifiableList(tables);
+	}
+
+	@Override
+	protected void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		builder.addUnsignedLeb128(count, "count");
+		for (int i = 0; i < tables.size(); i++) {
+			builder.add(tables.get(i), "table_" + i);
+		}
+	}
+
+	@Override
+	public String getName() {
+		return ".table";
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmTypeSection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmTypeSection.java
new file mode 100644
index 0000000000..4a8b20a774
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmTypeSection.java
@@ -0,0 +1,61 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.sections.structures.WasmFuncType;
+
+public class WasmTypeSection extends WasmSection {
+
+	private LEB128Info count;
+	private List<WasmFuncType> types = new ArrayList<WasmFuncType>();
+
+	public WasmTypeSection(BinaryReader reader) throws IOException {
+		super(reader);
+		count = reader.readNext(LEB128Info::unsigned);
+		for (int i = 0; i < count.asLong(); ++i) {
+			types.add(new WasmFuncType(reader));
+		}
+	}
+
+	public WasmFuncType getType(int typeidx) {
+		return types.get(typeidx);
+	}
+
+	public int getNumTypes() {
+		return types.size();
+	}
+
+	@Override
+	protected void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		builder.addUnsignedLeb128(count, "count");
+		for (int i = 0; i < types.size(); i++) {
+			builder.add(types.get(i), "type_" + i);
+		}
+	}
+
+	@Override
+	public String getName() {
+		return ".type";
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmUnknownCustomSection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmUnknownCustomSection.java
new file mode 100644
index 0000000000..9ca7ab84fb
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/WasmUnknownCustomSection.java
@@ -0,0 +1,58 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections;
+
+import java.io.IOException;
+
+import org.apache.commons.text.StringEscapeUtils;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+
+public class WasmUnknownCustomSection extends WasmCustomSection {
+	private long contentOffset;
+	private byte[] contents;
+
+	public WasmUnknownCustomSection(BinaryReader reader) throws IOException {
+		super(reader);
+		contentOffset = reader.getPointerIndex();
+		if (getCustomSize() == 0) {
+			contents = new byte[0];
+		} else {
+			contents = reader.readNextByteArray((int) getCustomSize());
+		}
+	}
+
+	@Override
+	protected void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		super.addToStructure(builder);
+		builder.addArray(BYTE, (int) getCustomSize(), "custom");
+	}
+
+	@Override
+	public String getName() {
+		return ".custom." + StringEscapeUtils.escapeJava(getCustomName()); // to avoid DataType conflict
+	}
+
+	public long getContentOffset() {
+		return contentOffset;
+	}
+
+	public byte[] getContents() {
+		return contents;
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/ConstantExpression.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/ConstantExpression.java
new file mode 100644
index 0000000000..0b0484bc0a
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/ConstantExpression.java
@@ -0,0 +1,223 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.address.AddressFactory;
+import ghidra.program.model.data.DataType;
+import ghidra.program.model.data.Float4DataType;
+import ghidra.program.model.data.Float8DataType;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.WasmLoader;
+import wasm.format.StructureBuilder;
+import wasm.format.WasmEnums.ValType;
+import wasm.format.WasmModule;
+
+/* A reader for expressions containing a single constant instruction.
+
+Such expressions consist of an instruction from the following list:
+- t.const c
+- ref.null
+- ref.func x
+- global.get x
+followed by an explicit end byte (0x0b).
+
+In principle, constant expressions could contain more than one instruction.
+However, a constant expression must produce a single value, so with the
+current list of allowed instructions, no valid expression can contain two
+or more instructions. This may change in the future: the extended-const
+proposal will add add/sub/mul instructions, at which point this class will
+need to be updated to handle multiple instructions in a single expression.
+*/
+public final class ConstantExpression implements StructConverter {
+
+	private ConstantInstruction type;
+	private LEB128Info opcode2;
+	private Object value;
+
+	private enum ConstantInstruction {
+		I32_CONST, /* i32.const n: value is LEB128 */
+		I64_CONST, /* i64.const n: value is LEB128 */
+		F32_CONST, /* f32.const z: value is byte[4] */
+		F64_CONST, /* f64.const z: value is byte[8] */
+		V128_CONST, /* v128.const z: value is byte[16] */
+		REF_NULL_FUNCREF, /* ref.null funcref: value is null */
+		REF_NULL_EXTERNREF, /* ref.null externref: value is null */
+		REF_FUNC, /* ref.func x: value is LEB128 funcidx */
+		GLOBAL_GET, /* global.get x: value is LEB128 globalidx */
+	}
+
+	public ConstantExpression(BinaryReader reader) throws IOException, IllegalArgumentException {
+		int typeCode = reader.readNextUnsignedByte();
+
+		switch (typeCode) {
+		case 0x23:
+			type = ConstantInstruction.GLOBAL_GET;
+			value = reader.readNext(LEB128Info::unsigned);
+			break;
+		case 0x41:
+			type = ConstantInstruction.I32_CONST;
+			value = reader.readNext(LEB128Info::signed);
+			break;
+		case 0x42:
+			type = ConstantInstruction.I64_CONST;
+			value = reader.readNext(LEB128Info::signed);
+			break;
+		case 0x43:
+			type = ConstantInstruction.F32_CONST;
+			value = reader.readNextByteArray(4);
+			break;
+		case 0x44:
+			type = ConstantInstruction.F64_CONST;
+			value = reader.readNextByteArray(8);
+			break;
+		case 0xD0: {
+			int refTypeCode = reader.readNextUnsignedByte();
+			if (refTypeCode == 0x6F) {
+				type = ConstantInstruction.REF_NULL_EXTERNREF;
+			} else if (refTypeCode == 0x70) {
+				type = ConstantInstruction.REF_NULL_FUNCREF;
+			} else {
+				throw new IllegalArgumentException("Invalid ref.null reftype " + refTypeCode);
+			}
+			value = null;
+			break;
+		}
+		case 0xD2:
+			type = ConstantInstruction.REF_FUNC;
+			value = reader.readNext(LEB128Info::unsigned);
+			break;
+		case 0xFD:
+			opcode2 = reader.readNext(LEB128Info::unsigned);
+			if (opcode2.asUInt32() == 0x0C) {
+				type = ConstantInstruction.V128_CONST;
+				value = reader.readNextByteArray(16);
+				break;
+			} else {
+				throw new IllegalArgumentException("Invalid instruction opcode 0xfd " + opcode2.asUInt32() + " in constant expression");
+			}
+		default:
+			throw new IllegalArgumentException("Invalid instruction opcode " + typeCode + " in constant expression");
+		}
+
+		int end = reader.readNextUnsignedByte();
+		if (end != 0x0b) {
+			throw new IllegalArgumentException("Missing end byte");
+		}
+	}
+
+	public static byte[] intToBytes(int value) {
+		byte[] result = new byte[4];
+		for (int i = 0; i < 4; i++) {
+			result[i] = (byte) value;
+			value >>= 8;
+		}
+		return result;
+	}
+
+	public static byte[] longToBytes(long value) {
+		byte[] result = new byte[8];
+		for (int i = 0; i < 8; i++) {
+			result[i] = (byte) value;
+			value >>= 8;
+		}
+		return result;
+	}
+
+	/**
+	 * Return the bytes that correspond to the value produced, i.e. 4 bytes for
+	 * i32.const, 8 bytes for f64.const, etc. Return null if the initializer cannot
+	 * be determined (e.g. global) This needs a reference to the module so that
+	 * function references can be resolved to their static addresses.
+	 */
+	public byte[] asBytes(WasmModule module) {
+		switch (type) {
+		case I32_CONST:
+			return intToBytes((int) ((LEB128Info) value).asLong());
+		case I64_CONST:
+			return longToBytes(((LEB128Info) value).asLong());
+		case REF_FUNC:
+			return intToBytes((int) WasmLoader.getFunctionAddressOffset(module, (int) ((LEB128Info) value).asLong()));
+		case F32_CONST:
+		case F64_CONST:
+		case V128_CONST:
+			return (byte[]) value;
+		case REF_NULL_FUNCREF:
+		case REF_NULL_EXTERNREF:
+			return new byte[] { 0, 0, 0, 0 };
+		case GLOBAL_GET:
+			return null;
+		default:
+			return null;
+		}
+	}
+
+	public Address asAddress(AddressFactory addressFactory, WasmModule module) {
+		if (type == ConstantInstruction.REF_FUNC) {
+			return WasmLoader.getFunctionAddress(addressFactory, module, (int) ((LEB128Info) value).asLong());
+		}
+		return null;
+	}
+
+	public Long asI32() {
+		if (type == ConstantInstruction.I32_CONST) {
+			return ((LEB128Info) value).asLong();
+		}
+		return null;
+	}
+
+	public Long asGlobalGet() {
+		if (type == ConstantInstruction.GLOBAL_GET) {
+			return ((LEB128Info) value).asLong();
+		}
+		return null;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureBuilder builder = new StructureBuilder("expr");
+		builder.add(BYTE, "opcode");
+		switch (type) {
+		case I32_CONST:
+		case I64_CONST:
+		case REF_FUNC:
+		case GLOBAL_GET:
+			builder.addUnsignedLeb128((LEB128Info) value, "value");
+			break;
+		case F32_CONST:
+			builder.add(Float4DataType.dataType, "value");
+			break;
+		case F64_CONST:
+			builder.add(Float8DataType.dataType, "value");
+			break;
+		case V128_CONST:
+			builder.addUnsignedLeb128((LEB128Info) opcode2, "opcode2");
+			builder.add(ValType.Undefined16, "value");
+			break;
+		case REF_NULL_FUNCREF:
+		case REF_NULL_EXTERNREF:
+			builder.add(BYTE, "nulltype");
+			break;
+		}
+		builder.add(BYTE, "end_opcode");
+		return builder.toStructure();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmCodeEntry.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmCodeEntry.java
new file mode 100644
index 0000000000..c637a23d4e
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmCodeEntry.java
@@ -0,0 +1,87 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.data.DataType;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.WasmEnums.ValType;
+
+public class WasmCodeEntry implements StructConverter {
+
+	private LEB128Info codeSize;
+	private List<WasmLocalEntry> locals = new ArrayList<WasmLocalEntry>();
+	private LEB128Info localCount;
+	private long codeOffset;
+	private byte[] instructions;
+
+	public WasmCodeEntry(BinaryReader reader) throws IOException {
+		codeSize = reader.readNext(LEB128Info::unsigned);
+		codeOffset = reader.getPointerIndex();
+		localCount = reader.readNext(LEB128Info::unsigned);
+		for (int i = 0; i < localCount.asLong(); ++i) {
+			locals.add(new WasmLocalEntry(reader));
+		}
+		instructions = reader.readByteArray(codeOffset, codeSize.asInt32());
+		reader.setPointerIndex(codeOffset + codeSize.asLong());
+	}
+
+	public LEB128Info getCodeSizeLeb128() {
+		return codeSize;
+	}
+
+	public long getCodeSize() {
+		return codeSize.asLong();
+	}
+
+	public long getOffset() {
+		return codeOffset;
+	}
+
+	public byte[] getInstructions() {
+		return instructions;
+	}
+
+	public ValType[] getLocals() {
+		int localCount = 0;
+		for (WasmLocalEntry local : locals) {
+			localCount += local.getCount();
+		}
+		ValType[] result = new ValType[localCount];
+		int pos = 0;
+		for (WasmLocalEntry local : locals) {
+			Arrays.fill(result, pos, pos + local.getCount(), ValType.fromByte(local.getType()));
+			pos += local.getCount();
+		}
+		return result;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureBuilder builder = new StructureBuilder("code_" + codeOffset);
+		builder.addUnsignedLeb128(codeSize, "code_size");
+		builder.addArray(BYTE, instructions.length, "instructions");
+		return builder.toStructure();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmDataSegment.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmDataSegment.java
new file mode 100644
index 0000000000..7444f29ab6
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmDataSegment.java
@@ -0,0 +1,109 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.data.DataType;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+
+public class WasmDataSegment implements StructConverter {
+
+	private LEB128Info mode;
+	private LEB128Info index;
+	private ConstantExpression offsetExpr;
+	private long fileOffset;
+	private LEB128Info size;
+	private byte[] data;
+
+	public WasmDataSegment(BinaryReader reader) throws IOException {
+		mode = reader.readNext(LEB128Info::unsigned);
+		long modeVal = mode.asLong();
+		if (modeVal == 2) {
+			index = reader.readNext(LEB128Info::unsigned);
+		} else {
+			/* for mode < 2, index defaults to 0 */
+			index = null;
+		}
+
+		if (modeVal == 0 || modeVal == 2) {
+			/* "active" segment with predefined offset */
+			offsetExpr = new ConstantExpression(reader);
+		} else {
+			/* "passive" segment loaded dynamically at runtime */
+			offsetExpr = null;
+		}
+
+		size = reader.readNext(LEB128Info::unsigned);
+		fileOffset = reader.getPointerIndex();
+		if (size.asLong() == 0) {
+			data = new byte[0];
+		} else {
+			data = reader.readNextByteArray((int) size.asLong());
+		}
+	}
+
+	public long getIndex() {
+		if (index == null)
+			return 0;
+		return index.asLong();
+	}
+
+	public long getFileOffset() {
+		return fileOffset;
+	}
+
+	public Long getMemoryOffset() {
+		if (offsetExpr != null) {
+			return offsetExpr.asI32();
+		}
+		return null;
+	}
+
+	public long getSize() {
+		return size.asLong();
+	}
+
+	public byte[] getData() {
+		return data;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		String structName = "data_segment_" + getIndex();
+		if (getMemoryOffset() != null) {
+			structName += "_" + getMemoryOffset();
+		}
+		StructureBuilder builder = new StructureBuilder(structName);
+
+		builder.addUnsignedLeb128(mode, "mode");
+		if (index != null) {
+			builder.addUnsignedLeb128(index, "index");
+		}
+		if (offsetExpr != null) {
+			builder.add(offsetExpr, "offset");
+		}
+		builder.addUnsignedLeb128(size, "size");
+		if (data.length != 0) {
+			builder.addArray(BYTE, data.length, "data");
+		}
+		return builder.toStructure();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmElementSegment.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmElementSegment.java
new file mode 100644
index 0000000000..2491375fe5
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmElementSegment.java
@@ -0,0 +1,215 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.address.AddressFactory;
+import ghidra.program.model.data.DataType;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.WasmLoader;
+import wasm.format.StructureBuilder;
+import wasm.format.WasmEnums.ValType;
+import wasm.format.WasmModule;
+
+public class WasmElementSegment implements StructConverter {
+
+	private LEB128Info flags;
+	private ElementSegmentMode mode;
+
+	private LEB128Info tableidx; /* if (flags & 3) == 2 */
+	private ConstantExpression offset; /* if (flags & 1) == 0 */
+	private LEB128Info count;
+
+	int elemkind; /* if (flags & 4) == 0 */
+	private List<LEB128Info> funcidxs; /* if (flags & 4) == 0 */
+
+	ValType elemtype; /* if (flags & 4) != 0 */
+	private List<ConstantExpression> exprs; /* if (flags & 4) != 0 */
+
+	public enum ElementSegmentMode {
+		active,
+		passive,
+		declarative,
+	}
+
+	public WasmElementSegment(BinaryReader reader) throws IOException {
+		flags = reader.readNext(LEB128Info::unsigned);
+		long flagVal = flags.asLong();
+		if ((flagVal & 3) == 2) {
+			/* active segment with explicit table index */
+			tableidx = reader.readNext(LEB128Info::unsigned);
+		} else {
+			/* tableidx defaults to 0 */
+			tableidx = null;
+		}
+
+		if ((flagVal & 1) == 0) {
+			/* active segment */
+			mode = ElementSegmentMode.active;
+			offset = new ConstantExpression(reader);
+		} else if ((flagVal & 2) == 0) {
+			mode = ElementSegmentMode.passive;
+		} else {
+			mode = ElementSegmentMode.declarative;
+		}
+
+		if ((flagVal & 3) == 0) {
+			/* implicit element type */
+			elemkind = 0;
+			elemtype = ValType.funcref;
+		} else {
+			/* explicit element type */
+			int typeCode = reader.readNextUnsignedByte();
+			if ((flagVal & 4) == 0) {
+				/* elemkind */
+				elemkind = typeCode;
+			} else {
+				/* reftype */
+				elemtype = ValType.fromByte(typeCode);
+			}
+		}
+
+		count = reader.readNext(LEB128Info::unsigned);
+		if ((flagVal & 4) == 0) {
+			/* vector of funcidx */
+			funcidxs = new ArrayList<>();
+			for (int i = 0; i < count.asLong(); i++) {
+				funcidxs.add(reader.readNext(LEB128Info::unsigned));
+			}
+		} else {
+			/* vector of expr */
+			exprs = new ArrayList<>();
+			for (int i = 0; i < count.asLong(); i++) {
+				exprs.add(new ConstantExpression(reader));
+			}
+		}
+	}
+
+	public ElementSegmentMode getMode() {
+		return mode;
+	}
+
+	public long getTableIndex() {
+		if (tableidx == null) {
+			return 0;
+		}
+		return tableidx.asLong();
+	}
+
+	public Long getOffset() {
+		if (offset == null) {
+			return null;
+		}
+		return offset.asI32();
+	}
+
+	public ValType getElementType() {
+		if ((flags.asLong() & 4) == 0) {
+			if (elemkind == 0) {
+				return ValType.funcref;
+			}
+			return null;
+		} else {
+			return elemtype;
+		}
+	}
+
+	public Address[] getAddresses(AddressFactory addressFactory, WasmModule module) {
+		int count = (int) this.count.asLong();
+		Address[] result = new Address[count];
+
+		if (funcidxs != null) {
+			for (int i = 0; i < count; i++) {
+				long funcidx = funcidxs.get(i).asLong();
+				result[i] = WasmLoader.getFunctionAddress(addressFactory, module, (int) funcidx);
+			}
+			return result;
+		}
+
+		if (exprs != null) {
+			for (int i = 0; i < count; i++) {
+				result[i] = exprs.get(i).asAddress(addressFactory, module);
+			}
+			return result;
+		}
+		return null;
+	}
+
+	public byte[] getInitData(WasmModule module) {
+		int elemSize = getElementType().getSize();
+		int count = (int) this.count.asLong();
+		byte[] result = new byte[count * elemSize];
+		Arrays.fill(result, (byte) 0x00);
+
+		if (funcidxs != null) {
+			for (int i = 0; i < count; i++) {
+				long funcidx = funcidxs.get(i).asLong();
+				long funcaddr = WasmLoader.getFunctionAddressOffset(module, (int) funcidx);
+				byte[] v = ConstantExpression.longToBytes(funcaddr);
+				System.arraycopy(v, 0, result, i * elemSize, elemSize);
+			}
+			return result;
+		}
+
+		if (exprs != null) {
+			for (int i = 0; i < count; i++) {
+				byte[] v = exprs.get(i).asBytes(module);
+				if (v != null)
+					System.arraycopy(v, 0, result, i * elemSize, elemSize);
+			}
+			return result;
+		}
+		return null;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureBuilder builder = new StructureBuilder("element_segment");
+		builder.addUnsignedLeb128(flags, "flags");
+		if (tableidx != null) {
+			builder.addUnsignedLeb128(tableidx, "tableidx");
+		}
+		if (offset != null) {
+			builder.add(offset, "offset");
+		}
+		if ((flags.asLong() & 3) != 0) {
+			/* both elemkind and reftype are single bytes */
+			builder.add(BYTE, "element_type");
+		}
+
+		builder.addUnsignedLeb128(count, "count");
+		if (funcidxs != null) {
+			for (int i = 0; i < funcidxs.size(); i++) {
+				builder.addUnsignedLeb128(funcidxs.get(i), "element" + i);
+			}
+		}
+		if (exprs != null) {
+			for (int i = 0; i < exprs.size(); i++) {
+				builder.add(exprs.get(i), "element" + i);
+			}
+		}
+
+		return builder.toStructure();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmExportEntry.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmExportEntry.java
new file mode 100644
index 0000000000..e6b386b96f
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmExportEntry.java
@@ -0,0 +1,60 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.data.DataType;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.WasmEnums.WasmExternalKind;
+
+public class WasmExportEntry implements StructConverter {
+
+	private WasmName name;
+	private WasmExternalKind kind;
+	private LEB128Info index;
+
+	public WasmExportEntry(BinaryReader reader) throws IOException {
+		name = new WasmName(reader);
+		kind = WasmExternalKind.values()[reader.readNextByte()];
+		index = reader.readNext(LEB128Info::unsigned);
+	}
+
+	public String getName() {
+		return name.getValue();
+	}
+
+	public int getIndex() {
+		return (int) index.asLong();
+	}
+
+	public WasmExternalKind getKind() {
+		return kind;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureBuilder builder = new StructureBuilder("export_" + getIndex());
+		builder.add(name, "name");
+		builder.add(BYTE, "kind");
+		builder.addUnsignedLeb128(index, "index");
+		return builder.toStructure();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmFuncType.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmFuncType.java
new file mode 100644
index 0000000000..51b7df96d4
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmFuncType.java
@@ -0,0 +1,81 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.data.DataType;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.WasmEnums.ValType;
+
+public class WasmFuncType implements StructConverter {
+
+	@SuppressWarnings("unused")
+	private int form; /* always 0 in this version */
+	private LEB128Info paramCount;
+	private ValType[] paramTypes;
+	private LEB128Info returnCount;
+	private ValType[] returnTypes;
+
+	public WasmFuncType(BinaryReader reader) throws IOException {
+		form = reader.readNextUnsignedByte();
+		paramCount = reader.readNext(LEB128Info::unsigned);
+		paramTypes = ValType.fromBytes(reader.readNextByteArray((int) paramCount.asLong()));
+		returnCount = reader.readNext(LEB128Info::unsigned);
+		returnTypes = ValType.fromBytes(reader.readNextByteArray((int) returnCount.asLong()));
+	}
+
+	public ValType[] getParamTypes() {
+		return paramTypes;
+	}
+
+	public ValType[] getReturnTypes() {
+		return returnTypes;
+	}
+
+	private static String typeTupleToString(ValType[] types) {
+		StringBuilder result = new StringBuilder();
+		result.append("(");
+		for (int i = 0; i < types.length; i++) {
+			if (i != 0) {
+				result.append(",");
+			}
+			result.append(types[i]);
+		}
+		result.append(")");
+		return result.toString();
+	}
+
+	@Override
+	public String toString() {
+		return typeTupleToString(paramTypes) + "->" + typeTupleToString(returnTypes);
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureBuilder builder = new StructureBuilder("func_type_" + paramCount.asLong() + "_" + returnCount.asLong());
+		builder.add(BYTE, "form");
+		builder.addUnsignedLeb128(paramCount, "param_count");
+		builder.addArray(BYTE, (int) paramCount.asLong(), "param_types");
+		builder.addUnsignedLeb128(returnCount, "return_count");
+		builder.addArray(BYTE, (int) returnCount.asLong(), "return_types");
+		return builder.toStructure();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmGlobalEntry.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmGlobalEntry.java
new file mode 100644
index 0000000000..83113ce7c7
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmGlobalEntry.java
@@ -0,0 +1,62 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.address.AddressFactory;
+import ghidra.program.model.data.DataType;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.WasmModule;
+
+public class WasmGlobalEntry implements StructConverter {
+
+	private WasmGlobalType type;
+	private ConstantExpression expr;
+
+	public WasmGlobalEntry(BinaryReader reader) throws IOException {
+		type = new WasmGlobalType(reader);
+		expr = new ConstantExpression(reader);
+	}
+
+	public WasmGlobalType getGlobalType() {
+		return type;
+	}
+
+	public byte[] asBytes(WasmModule module) {
+		return expr.asBytes(module);
+	}
+
+	public Address asAddress(AddressFactory addressFactory, WasmModule module) {
+		return expr.asAddress(addressFactory, module);
+	}
+
+	public Long asGlobalGet() {
+		return expr.asGlobalGet();
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureBuilder builder = new StructureBuilder("global_entry");
+		builder.add(type, "type");
+		builder.add(expr, "expr");
+		return builder.toStructure();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmGlobalType.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmGlobalType.java
new file mode 100644
index 0000000000..5a07a3abd6
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmGlobalType.java
@@ -0,0 +1,52 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.data.DataType;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.WasmEnums.ValType;
+
+public class WasmGlobalType implements StructConverter {
+
+	private ValType type;
+	private int mutability;
+
+	public WasmGlobalType(BinaryReader reader) throws IOException {
+		type = ValType.fromByte(reader.readNextUnsignedByte());
+		mutability = reader.readNextUnsignedByte();
+	}
+
+	public ValType getType() {
+		return type;
+	}
+
+	public int getMutability() {
+		return mutability;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureBuilder builder = new StructureBuilder("global_type");
+		builder.add(BYTE, "type");
+		builder.add(BYTE, "mutability");
+		return builder.toStructure();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmImportEntry.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmImportEntry.java
new file mode 100644
index 0000000000..f13a6f9ed1
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmImportEntry.java
@@ -0,0 +1,139 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+
+import org.apache.commons.text.StringEscapeUtils;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.data.DataType;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.WasmEnums.WasmExternalKind;
+
+public class WasmImportEntry implements StructConverter {
+
+	private WasmName module;
+	private WasmName field;
+	private WasmExternalKind kind;
+
+	private LEB128Info functionEntry;
+	private WasmTableType tableEntry;
+	private WasmResizableLimits memoryEntry;
+	private WasmGlobalType globalEntry;
+
+	private long startOffset, endOffset;
+
+	public WasmImportEntry(BinaryReader reader) throws IOException {
+		startOffset = reader.getPointerIndex();
+		module = new WasmName(reader);
+		field = new WasmName(reader);
+		kind = WasmExternalKind.values()[reader.readNextByte()];
+		switch (kind) {
+		case EXT_FUNCTION:
+			functionEntry = reader.readNext(LEB128Info::unsigned);
+			break;
+		case EXT_TABLE:
+			tableEntry = new WasmTableType(reader);
+			break;
+		case EXT_MEMORY:
+			memoryEntry = new WasmResizableLimits(reader);
+			break;
+		case EXT_GLOBAL:
+			globalEntry = new WasmGlobalType(reader);
+			break;
+		default:
+			break;
+		}
+		endOffset = reader.getPointerIndex();
+	}
+
+	public WasmExternalKind getKind() {
+		return kind;
+	}
+
+	public int getFunctionType() {
+		if (kind != WasmExternalKind.EXT_FUNCTION) {
+			throw new IllegalArgumentException("Cannot get function type of non-function import");
+		}
+		return (int) functionEntry.asLong();
+	}
+
+	public WasmTableType getTableType() {
+		if (kind != WasmExternalKind.EXT_TABLE) {
+			throw new IllegalArgumentException("Cannot get table type of non-table import");
+		}
+		return tableEntry;
+	}
+
+	public WasmResizableLimits getMemoryType() {
+		if (kind != WasmExternalKind.EXT_MEMORY) {
+			throw new IllegalArgumentException("Cannot get memory type of non-memory import");
+		}
+		return memoryEntry;
+	}
+
+	public WasmGlobalType getGlobalType() {
+		if (kind != WasmExternalKind.EXT_GLOBAL) {
+			throw new IllegalArgumentException("Cannot get global type of non-global import");
+		}
+		return globalEntry;
+	}
+
+	public String getModule() {
+		return module.getValue();
+	}
+
+	public String getName() {
+		return field.getValue();
+	}
+
+	public long getEntryOffset() {
+		return startOffset;
+	}
+
+	public long getEntrySize() {
+		return endOffset - startOffset;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureBuilder builder = new StructureBuilder("import_" + StringEscapeUtils.escapeJava(getName()));
+		builder.add(module, "module");
+		builder.add(field, "field");
+		builder.add(BYTE, "kind");
+		switch (kind) {
+		case EXT_FUNCTION:
+			builder.addUnsignedLeb128(functionEntry, "type");
+			break;
+		case EXT_TABLE:
+			builder.add(tableEntry, "type");
+			break;
+		case EXT_MEMORY:
+			builder.add(memoryEntry, "type");
+			break;
+		case EXT_GLOBAL:
+			builder.add(globalEntry, "type");
+			break;
+		default:
+			break;
+		}
+		return builder.toStructure();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmLocalEntry.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmLocalEntry.java
new file mode 100644
index 0000000000..c2025e5ea3
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmLocalEntry.java
@@ -0,0 +1,52 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.data.DataType;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+
+public class WasmLocalEntry implements StructConverter {
+
+	private LEB128Info count;
+	private int type;
+
+	public WasmLocalEntry(BinaryReader reader) throws IOException {
+		count = reader.readNext(LEB128Info::unsigned);
+		type = reader.readNextUnsignedByte();
+	}
+
+	public int getCount() {
+		return (int) count.asLong();
+	}
+
+	public int getType() {
+		return type;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureBuilder builder = new StructureBuilder("locals_" + count.asLong() + "_" + type);
+		builder.addUnsignedLeb128(count, "count");
+		builder.add(BYTE, "type");
+		return builder.toStructure();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmName.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmName.java
new file mode 100644
index 0000000000..4988debdf2
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmName.java
@@ -0,0 +1,57 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.data.DataType;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+
+public class WasmName implements StructConverter {
+	private LEB128Info size;
+	private String value;
+
+	public WasmName(BinaryReader reader) throws IOException {
+		size = reader.readNext(LEB128Info::unsigned);
+		if (size.asLong() == 0) {
+			value = "";
+		} else {
+			byte[] data = reader.readNextByteArray((int) size.asLong());
+			value = new String(data, StandardCharsets.UTF_8);
+		}
+	}
+
+	public long getSize() {
+		return size.getLength() + size.asLong();
+	}
+
+	public String getValue() {
+		return value;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureBuilder builder = new StructureBuilder("name_" + size.asLong());
+		builder.addUnsignedLeb128(size, "size");
+		builder.addString((int) size.asLong(), "value");
+		return builder.toStructure();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameIndirectMap.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameIndirectMap.java
new file mode 100644
index 0000000000..bbb8743881
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameIndirectMap.java
@@ -0,0 +1,71 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.data.DataType;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+
+public class WasmNameIndirectMap implements StructConverter {
+	private LEB128Info count;
+	private List<WasmIndirectAssoc> entries = new ArrayList<>();
+	private Map<Long, WasmNameMap> map = new HashMap<>();
+
+	private static class WasmIndirectAssoc {
+		LEB128Info idx;
+		WasmNameMap nameMap;
+	}
+
+	public WasmNameIndirectMap(BinaryReader reader) throws IOException {
+		count = reader.readNext(LEB128Info::unsigned);
+		for (int i = 0; i < count.asLong(); i++) {
+			WasmIndirectAssoc assoc = new WasmIndirectAssoc();
+			assoc.idx = reader.readNext(LEB128Info::unsigned);
+			assoc.nameMap = new WasmNameMap("namemap_func_" + i + "_locals", reader);
+			entries.add(assoc);
+			map.put(assoc.idx.asLong(), assoc.nameMap);
+		}
+	}
+
+	public String getEntry(long idx1, long idx2) {
+		WasmNameMap subMap = map.get(idx1);
+		if (subMap == null)
+			return null;
+
+		return subMap.getEntry(idx2);
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureBuilder builder = new StructureBuilder("indirectnamemap");
+		builder.addUnsignedLeb128(count, "count");
+		for (int i = 0; i < entries.size(); i++) {
+			WasmIndirectAssoc assoc = entries.get(i);
+			builder.addUnsignedLeb128(assoc.idx, "idx" + i);
+			builder.add(assoc.nameMap, "namemap" + i);
+		}
+		return builder.toStructure();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameLocalSubsection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameLocalSubsection.java
new file mode 100644
index 0000000000..d7dc781187
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameLocalSubsection.java
@@ -0,0 +1,46 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+
+public class WasmNameLocalSubsection extends WasmNameSubsection {
+
+	private WasmNameIndirectMap localNameMap;
+
+	public WasmNameLocalSubsection(BinaryReader reader) throws IOException {
+		super(reader);
+		localNameMap = new WasmNameIndirectMap(reader);
+	}
+
+	public String getLocalName(int funcidx, int localidx) {
+		return localNameMap.getEntry(funcidx, localidx);
+	}
+
+	@Override
+	public void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		builder.add(localNameMap, "local_names");
+	}
+
+	@Override
+	public String getName() {
+		return ".name.local";
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameMap.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameMap.java
new file mode 100644
index 0000000000..ca25772814
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameMap.java
@@ -0,0 +1,73 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.data.DataType;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+
+public class WasmNameMap implements StructConverter {
+	// this is used to avoid structure name conflict
+	private String structureName;
+	private LEB128Info count;
+	private List<WasmAssoc> entries = new ArrayList<>();
+	private Map<Long, WasmName> map = new HashMap<>();
+
+	private static class WasmAssoc {
+		LEB128Info idx;
+		WasmName name;
+	}
+
+	public WasmNameMap(String structureName, BinaryReader reader) throws IOException {
+		this.structureName = structureName;
+		count = reader.readNext(LEB128Info::unsigned);
+		for (int i = 0; i < count.asLong(); i++) {
+			WasmAssoc assoc = new WasmAssoc();
+			assoc.idx = reader.readNext(LEB128Info::unsigned);
+			assoc.name = new WasmName(reader);
+			entries.add(assoc);
+			map.put(assoc.idx.asLong(), assoc.name);
+		}
+	}
+
+	public String getEntry(long idx) {
+		WasmName result = map.get(idx);
+		if (result == null)
+			return null;
+		return result.getValue();
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureBuilder builder = new StructureBuilder(structureName);
+		builder.addUnsignedLeb128(count, "count");
+		for (int i = 0; i < entries.size(); i++) {
+			WasmAssoc assoc = entries.get(i);
+			builder.addUnsignedLeb128(assoc.idx, "idx" + i);
+			builder.add(assoc.name, "name" + i);
+		}
+		return builder.toStructure();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameMapSubsection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameMapSubsection.java
new file mode 100644
index 0000000000..62f9338213
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameMapSubsection.java
@@ -0,0 +1,52 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+
+import org.apache.commons.text.StringEscapeUtils;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+
+/**
+ * Common class for functions/globals/data names subsection
+ */
+public class WasmNameMapSubsection extends WasmNameSubsection {
+	private String entityName;
+	private WasmNameMap nameMap;
+
+	public WasmNameMapSubsection(String entityName, BinaryReader reader) throws IOException {
+		super(reader);
+		this.entityName = entityName;
+		nameMap = new WasmNameMap(entityName + "_namemap", reader);
+	}
+
+	public String getName(long idx) {
+		return nameMap.getEntry(idx);
+	}
+
+	@Override
+	public void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		builder.add(nameMap, StringEscapeUtils.escapeJava(entityName) + "_names");
+	}
+
+	@Override
+	public String getName() {
+		return ".name." + StringEscapeUtils.escapeJava(entityName);
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameModuleSubsection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameModuleSubsection.java
new file mode 100644
index 0000000000..a273acc677
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameModuleSubsection.java
@@ -0,0 +1,46 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+
+public class WasmNameModuleSubsection extends WasmNameSubsection {
+
+	private WasmName moduleName;
+
+	public WasmNameModuleSubsection(BinaryReader reader) throws IOException {
+		super(reader);
+		moduleName = new WasmName(reader);
+	}
+
+	public String getModuleName() {
+		return moduleName.getValue();
+	}
+
+	@Override
+	public void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		builder.add(moduleName, "module_name");
+	}
+
+	@Override
+	public String getName() {
+		return ".name.module";
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameSubsection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameSubsection.java
new file mode 100644
index 0000000000..41ebf12681
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameSubsection.java
@@ -0,0 +1,123 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.data.DataType;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+
+public abstract class WasmNameSubsection implements StructConverter {
+
+	protected int id;
+	private LEB128Info contentLength;
+	private long sectionOffset;
+
+	// see https://github.com/WebAssembly/extended-name-section/blob/main/proposals/extended-name-section/Overview.md
+	public enum WasmNameSubsectionId {
+		NAME_MODULE,
+		NAME_FUNCTION,
+		NAME_LOCAL,
+		NAME_LABELS,
+		NAME_TYPE,
+		NAME_TABLE,
+		NAME_MEMORY,
+		NAME_GLOBAL,
+		NAME_ELEM,
+		NAME_DATA
+	}
+
+	public static WasmNameSubsection createSubsection(BinaryReader reader) throws IOException {
+		long sectionOffset = reader.getPointerIndex();
+		int id = reader.readNextUnsignedByte();
+		LEB128Info contentLength = reader.readNext(LEB128Info::unsigned);
+		reader.setPointerIndex(reader.getPointerIndex() + contentLength.asLong());
+
+		BinaryReader sectionReader = reader.clone(sectionOffset);
+
+		if (id >= WasmNameSubsectionId.values().length) {
+			return new WasmNameUnknownSubsection(sectionReader);
+		}
+
+		switch (WasmNameSubsectionId.values()[id]) {
+		case NAME_MODULE:
+			return new WasmNameModuleSubsection(sectionReader);
+		case NAME_FUNCTION:
+			return new WasmNameMapSubsection("function", sectionReader);
+		case NAME_LOCAL:
+			return new WasmNameLocalSubsection(sectionReader);
+		case NAME_LABELS:
+			// TODO: not supported at the moment
+			return new WasmNameUnknownSubsection(sectionReader);
+		case NAME_TYPE:
+			return new WasmNameMapSubsection("type", sectionReader);
+		case NAME_TABLE:
+			return new WasmNameMapSubsection("table", sectionReader);
+		case NAME_MEMORY:
+			return new WasmNameMapSubsection("memory", sectionReader);
+		case NAME_GLOBAL:
+			return new WasmNameMapSubsection("global", sectionReader);
+		case NAME_ELEM:
+			return new WasmNameMapSubsection("elem", sectionReader);
+		case NAME_DATA:
+			return new WasmNameMapSubsection("data", sectionReader);
+		default:
+			return new WasmNameUnknownSubsection(sectionReader);
+		}
+	}
+
+	protected WasmNameSubsection(BinaryReader reader) throws IOException {
+		sectionOffset = reader.getPointerIndex();
+		id = reader.readNextUnsignedByte();
+		contentLength = reader.readNext(LEB128Info::unsigned);
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureBuilder builder = new StructureBuilder(getName());
+		builder.add(BYTE, "id");
+		builder.addUnsignedLeb128(contentLength, "size");
+		addToStructure(builder);
+		return builder.toStructure();
+	}
+
+	public abstract String getName();
+
+	protected abstract void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException;
+
+	public WasmNameSubsectionId getId() {
+		if (id < WasmNameSubsectionId.values().length) {
+			return WasmNameSubsectionId.values()[id];
+		}
+		return null;
+	}
+
+	public long getSectionOffset() {
+		return sectionOffset;
+	}
+
+	public long getContentSize() {
+		return contentLength.asLong();
+	}
+
+	public long getSectionSize() {
+		return 1 + contentLength.getLength() + contentLength.asLong();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameUnknownSubsection.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameUnknownSubsection.java
new file mode 100644
index 0000000000..f45569779f
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmNameUnknownSubsection.java
@@ -0,0 +1,45 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+
+public class WasmNameUnknownSubsection extends WasmNameSubsection {
+	byte[] contents;
+
+	public WasmNameUnknownSubsection(BinaryReader reader) throws IOException {
+		super(reader);
+		if (getContentSize() == 0) {
+			contents = new byte[0];
+		} else {
+			contents = reader.readNextByteArray((int) getContentSize());
+		}
+	}
+
+	@Override
+	public void addToStructure(StructureBuilder builder) throws DuplicateNameException, IOException {
+		builder.addArray(BYTE, (int) getContentSize(), "unknown" + id);
+	}
+
+	@Override
+	public String getName() {
+		return ".name.unknown" + id;
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmResizableLimits.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmResizableLimits.java
new file mode 100644
index 0000000000..cbf1bb7a32
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmResizableLimits.java
@@ -0,0 +1,62 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.LEB128Info;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.data.DataType;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+
+public class WasmResizableLimits implements StructConverter {
+
+	private int flags;
+	private LEB128Info initial;
+	private LEB128Info maximum;
+
+	public WasmResizableLimits(BinaryReader reader) throws IOException {
+		flags = reader.readNextUnsignedByte();
+		initial = reader.readNext(LEB128Info::unsigned);
+		if (flags == 1) {
+			maximum = reader.readNext(LEB128Info::unsigned);
+		}
+	}
+
+	public long getInitial() {
+		return initial.asLong();
+	}
+
+	public long getMaximum() {
+		if (maximum != null) {
+			return maximum.asLong();
+		}
+		return -1;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureBuilder builder = new StructureBuilder("limits");
+		builder.add(BYTE, "flags");
+		builder.addUnsignedLeb128(initial, "initial");
+		if (maximum != null) {
+			builder.addUnsignedLeb128(maximum, "maximum");
+		}
+		return builder.toStructure();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmTableType.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmTableType.java
new file mode 100644
index 0000000000..5dcad9f8cb
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/format/sections/structures/WasmTableType.java
@@ -0,0 +1,56 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.format.sections.structures;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.data.DataType;
+import ghidra.util.exception.DuplicateNameException;
+import wasm.format.StructureBuilder;
+import wasm.format.WasmEnums.ValType;
+
+public class WasmTableType implements StructConverter {
+
+	private ValType elemType;
+	private WasmResizableLimits limits;
+
+	public WasmTableType(BinaryReader reader) throws IOException {
+		elemType = ValType.fromByte(reader.readNextUnsignedByte());
+		limits = new WasmResizableLimits(reader);
+	}
+
+	public ValType getElementType() {
+		return elemType;
+	}
+
+	public DataType getElementDataType() {
+		return elemType.asDataType();
+	}
+
+	public WasmResizableLimits getLimits() {
+		return limits;
+	}
+
+	@Override
+	public DataType toDataType() throws DuplicateNameException, IOException {
+		StructureBuilder builder = new StructureBuilder("table_type");
+		builder.add(BYTE, "element_type");
+		builder.add(limits, "limits");
+		return builder.toStructure();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/InjectPayloadWasmEntry.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/InjectPayloadWasmEntry.java
new file mode 100644
index 0000000000..eccbe957a4
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/InjectPayloadWasmEntry.java
@@ -0,0 +1,62 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.pcode;
+
+import ghidra.program.model.address.Address;
+import ghidra.program.model.lang.InjectContext;
+import ghidra.program.model.lang.InjectPayloadCallother;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.pcode.PcodeOp;
+import wasm.WasmLoader;
+import wasm.analysis.WasmAnalysis;
+import wasm.analysis.WasmFuncSignature;
+import wasm.format.WasmEnums.ValType;
+
+/**
+ * The function entry injection for a Wasm function. We inject code to copy from
+ * the artificial "inputs" registers into the real "locals" registers.
+ */
+public class InjectPayloadWasmEntry extends InjectPayloadCallother {
+
+	public InjectPayloadWasmEntry(String sourceName) {
+		super(sourceName);
+	}
+
+	@Override
+	public PcodeOp[] getPcode(Program program, InjectContext con) {
+		PcodeOpEmitter ops = new PcodeOpEmitter(program.getLanguage(), con.baseAddr);
+
+		WasmAnalysis state = WasmAnalysis.getState(program);
+		Address funcBase = program.getFunctionManager().getFunctionContaining(con.baseAddr).getEntryPoint();
+		WasmFuncSignature sig = state.getFunctionByAddress(funcBase);
+		if (sig == null || sig.isImport()) {
+			return ops.getPcodeOps();
+		}
+
+		Address inputBase = program.getRegister("i0").getAddress();
+		Address localsBase = program.getRegister("l0").getAddress();
+		ValType[] params = sig.getParams();
+		ValType[] locals = sig.getLocals();
+		for (int i = 0; i < params.length; i++) {
+			ops.emitCopy(inputBase.add(i * WasmLoader.REG_SIZE), localsBase.add(i * WasmLoader.REG_SIZE), params[i].getSize());
+		}
+		Address zero = program.getAddressFactory().getConstantAddress(0L);
+		for (int i = params.length; i < locals.length; i++) {
+			ops.emitCopy(zero, localsBase.add(i * WasmLoader.REG_SIZE), locals[i].getSize());
+		}
+		return ops.getPcodeOps();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/InjectPayloadWasmPop.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/InjectPayloadWasmPop.java
new file mode 100644
index 0000000000..57219cd2ec
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/InjectPayloadWasmPop.java
@@ -0,0 +1,74 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.pcode;
+
+import ghidra.program.model.address.Address;
+import ghidra.program.model.lang.InjectContext;
+import ghidra.program.model.lang.InjectPayloadCallother;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.pcode.PcodeOp;
+import wasm.WasmLoader;
+import wasm.analysis.WasmAnalysis;
+import wasm.analysis.WasmFunctionAnalysis;
+import wasm.analysis.WasmFunctionAnalysis.StackEffect;
+import wasm.format.WasmEnums.ValType;
+
+/**
+ * Handle variable-length pops from the stack to registers. We use this to
+ * handle branches (popping block arguments to temporary registers), function
+ * calls (popping function arguments to input registers), and function return
+ * (popping return values to output registers).
+ */
+public class InjectPayloadWasmPop extends InjectPayloadCallother {
+
+	public InjectPayloadWasmPop(String sourceName) {
+		super(sourceName);
+	}
+
+	@Override
+	public PcodeOp[] getPcode(Program program, InjectContext con) {
+		PcodeOpEmitter ops = new PcodeOpEmitter(program.getLanguage(), con.baseAddr);
+
+		long regoffset = con.inputlist.get(0).getOffset();
+		Address baseAddress = program.getAddressFactory().getAddressSpace("register").getAddress(regoffset);
+
+		WasmAnalysis state = WasmAnalysis.getState(program);
+		WasmFunctionAnalysis funcAnalysis;
+		try {
+			funcAnalysis = state.getFunctionAnalysis(
+					program.getFunctionManager().getFunctionContaining(con.baseAddr).getEntryPoint());
+		} catch (Exception e) {
+			return ops.getPcodeOps();
+		}
+		if (funcAnalysis == null) {
+			return ops.getPcodeOps();
+		}
+
+		StackEffect stackEffect = funcAnalysis.getStackEffect(con.baseAddr);
+		if (stackEffect == null) {
+			return ops.getPcodeOps();
+		}
+
+		long stackHeight = stackEffect.getPopHeight();
+		ValType[] todo = stackEffect.getToPop();
+		Address stackAddress = program.getRegister("s0").getAddress().add(stackHeight * WasmLoader.REG_SIZE);
+		for (int i = 0; i < todo.length; i++) {
+			ops.emitCopy(stackAddress.add(i * WasmLoader.REG_SIZE), baseAddress.add(i * WasmLoader.REG_SIZE), todo[i].getSize());
+		}
+
+		return ops.getPcodeOps();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/InjectPayloadWasmPush.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/InjectPayloadWasmPush.java
new file mode 100644
index 0000000000..18b1ebeff7
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/InjectPayloadWasmPush.java
@@ -0,0 +1,73 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.pcode;
+
+import ghidra.program.model.address.Address;
+import ghidra.program.model.lang.InjectContext;
+import ghidra.program.model.lang.InjectPayloadCallother;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.pcode.PcodeOp;
+import wasm.WasmLoader;
+import wasm.analysis.WasmAnalysis;
+import wasm.analysis.WasmFunctionAnalysis;
+import wasm.analysis.WasmFunctionAnalysis.StackEffect;
+import wasm.format.WasmEnums.ValType;
+
+/**
+ * Handle variable-length pushes from the stack to registers. We use this to
+ * handle branches (pushing block arguments from temporary registers) and
+ * function calls (pushing function return values from output registers).
+ */
+public class InjectPayloadWasmPush extends InjectPayloadCallother {
+
+	public InjectPayloadWasmPush(String sourceName) {
+		super(sourceName);
+	}
+
+	@Override
+	public PcodeOp[] getPcode(Program program, InjectContext con) {
+		PcodeOpEmitter ops = new PcodeOpEmitter(program.getLanguage(), con.baseAddr);
+
+		long regoffset = con.inputlist.get(0).getOffset();
+		Address baseAddress = program.getAddressFactory().getAddressSpace("register").getAddress(regoffset);
+
+		WasmAnalysis state = WasmAnalysis.getState(program);
+		WasmFunctionAnalysis funcAnalysis;
+		try {
+			funcAnalysis = state.getFunctionAnalysis(
+					program.getFunctionManager().getFunctionContaining(con.baseAddr).getEntryPoint());
+		} catch (Exception e) {
+			return ops.getPcodeOps();
+		}
+		if (funcAnalysis == null) {
+			return ops.getPcodeOps();
+		}
+
+		StackEffect stackEffect = funcAnalysis.getStackEffect(con.baseAddr);
+		if (stackEffect == null) {
+			return ops.getPcodeOps();
+		}
+
+		long stackHeight = stackEffect.getPushHeight();
+		ValType[] todo = stackEffect.getToPush();
+		Address stackAddress = program.getRegister("s0").getAddress().add(stackHeight * WasmLoader.REG_SIZE);
+		for (int i = 0; i < todo.length; i++) {
+			ops.emitCopy(baseAddress.add(i * WasmLoader.REG_SIZE), stackAddress.add(i * WasmLoader.REG_SIZE), todo[i].getSize());
+		}
+
+		return ops.getPcodeOps();
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/PcodeInjectLibraryWasm.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/PcodeInjectLibraryWasm.java
new file mode 100644
index 0000000000..d93ea9c7b7
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/PcodeInjectLibraryWasm.java
@@ -0,0 +1,53 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.pcode;
+
+import ghidra.app.plugin.processors.sleigh.SleighLanguage;
+import ghidra.program.model.lang.InjectPayload;
+import ghidra.program.model.lang.PcodeInjectLibrary;
+
+public class PcodeInjectLibraryWasm extends PcodeInjectLibrary {
+
+	public PcodeInjectLibraryWasm(SleighLanguage l) {
+		super(l);
+	}
+
+	public PcodeInjectLibraryWasm(PcodeInjectLibraryWasm op2) {
+		super(op2);
+	}
+
+	@Override
+	public PcodeInjectLibrary clone() {
+		return new PcodeInjectLibraryWasm(this);
+	}
+
+	@Override
+	public InjectPayload allocateInject(String sourceName, String name, int tp) {
+		if (tp == InjectPayload.CALLOTHERFIXUP_TYPE) {
+			switch (name) {
+			case "funcEntryCallOther":
+				return new InjectPayloadWasmEntry(sourceName);
+			case "popCallOther":
+			case "callEpilogueCallOther":
+			case "callPrologueCallOther":
+				return new InjectPayloadWasmPop(sourceName);
+			case "pushCallOther":
+				return new InjectPayloadWasmPush(sourceName);
+			}
+		}
+		return super.allocateInject(sourceName, name, tp);
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/PcodeOpEmitter.java b/Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/PcodeOpEmitter.java
new file mode 100644
index 0000000000..5f9edb034d
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/main/java/wasm/pcode/PcodeOpEmitter.java
@@ -0,0 +1,70 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package wasm.pcode;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import ghidra.program.model.address.Address;
+import ghidra.program.model.lang.Language;
+import ghidra.program.model.lang.Register;
+import ghidra.program.model.pcode.PcodeOp;
+import ghidra.program.model.pcode.Varnode;
+
+public class PcodeOpEmitter {
+	private Language language;
+	private Address baseAddress;
+	private List<PcodeOp> ops = new ArrayList<>();
+
+	public PcodeOpEmitter(Language language, Address baseAddress) {
+		this.language = language;
+		this.baseAddress = baseAddress;
+	}
+
+	public PcodeOp[] getPcodeOps() {
+		if (ops.size() == 0) {
+			// Work around Ghidra issue #3389: decompiler can crash if injection produces an
+			// empty array
+			emitNop();
+		}
+		return ops.toArray(new PcodeOp[0]);
+	}
+
+	private PcodeOp newOp(int opcode) {
+		PcodeOp op = new PcodeOp(baseAddress, ops.size(), opcode);
+		ops.add(op);
+		return op;
+	}
+
+	private Varnode getRegister(String name) {
+		Register register = language.getRegister(name);
+		return new Varnode(register.getAddress(), register.getNumBytes());
+	}
+
+	public void emitNop() {
+		PcodeOp op = newOp(PcodeOp.COPY);
+		Varnode lrVarnode = getRegister("LR");
+		op.setInput(lrVarnode, 0);
+		op.setOutput(lrVarnode);
+	}
+
+	public void emitCopy(Address fromAddr, Address toAddr, int size) {
+		/* toAddr = fromAddr */
+		PcodeOp op = newOp(PcodeOp.COPY);
+		op.setInput(new Varnode(fromAddr, size), 0);
+		op.setOutput(new Varnode(toAddr, size));
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WasmEmulatorTestAdapter.java b/Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WasmEmulatorTestAdapter.java
new file mode 100644
index 0000000000..a7bb91df0e
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WasmEmulatorTestAdapter.java
@@ -0,0 +1,150 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.test.processors;
+
+import ghidra.app.plugin.core.analysis.AutoAnalysisManager;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.data.CategoryPath;
+import ghidra.program.model.data.DataTypeComponent;
+import ghidra.program.model.data.Structure;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.mem.Memory;
+import ghidra.program.model.mem.MemoryBlock;
+import ghidra.program.util.GhidraProgramUtilities;
+import ghidra.test.processors.support.EmulatorTestRunner;
+import ghidra.test.processors.support.PCodeTestControlBlock;
+import ghidra.test.processors.support.ProcessorEmulatorTestAdapter;
+import ghidra.util.task.TaskMonitor;
+
+public abstract class WasmEmulatorTestAdapter extends ProcessorEmulatorTestAdapter {
+
+	private static final String[] REG_DUMP_SET = new String[] {};
+	private static final byte[] MAIN_CONTROL_BLOCK_MAGIC = "AbCdEFgH".getBytes();
+	private static final byte[] GROUP_CONTROL_BLOCK_MAGIC = "aBcDefGh".getBytes();
+
+	public WasmEmulatorTestAdapter(String name, String languageID, String compilerSpecID) throws Exception {
+		super(name, languageID, compilerSpecID, REG_DUMP_SET);
+		setIgnoredBlocks(".module");
+	}
+
+	private static int getStructureComponent(Structure testInfoStruct, String fieldName) {
+		for (DataTypeComponent component : testInfoStruct.getDefinedComponents()) {
+			if (fieldName.equals(component.getFieldName())) {
+				return component.getOffset();
+			}
+		}
+		throw new RuntimeException(fieldName + " field not found within " +
+				testInfoStruct.getName() + " structure definition");
+	}
+
+	private Address findBytes(Memory memory, Address startAddr, Address endAddr, byte[] bytes) throws Exception {
+		return memory.findBytes(startAddr, endAddr, bytes, null, true, TaskMonitor.DUMMY);
+	}
+
+	private Address readPointer(Program program, Address address) throws Exception {
+		int pointerSize = program.getDefaultPointerSize();
+		long offset = pointerSize == 4 ? (long) program.getMemory().getInt(address)
+				: program.getMemory().getLong(address);
+		return program.getAddressFactory().getDefaultAddressSpace().getAddress(offset);
+	}
+
+	private void writePointer(Program program, Address address, Address target) throws Exception {
+		int pointerSize = program.getDefaultPointerSize();
+		if (pointerSize == 4) {
+			program.getMemory().setInt(address, (int) target.getOffset());
+		} else {
+			program.getMemory().setLong(address, target.getOffset());
+		}
+	}
+
+	private void mungeFuncPointer(Program program, Address address) throws Exception {
+		long index = readPointer(program, address).getOffset();
+		Address tableAddress = program.getAddressFactory().getAddressSpace("table")
+				.getAddress(index * program.getDefaultPointerSize());
+		Address funcAddress = readPointer(program, tableAddress);
+		writePointer(program, address, funcAddress);
+	}
+
+	private void mungeFuncTable(Program program, Address tableAddress, int funcOffset, int funcSize) throws Exception {
+		while (true) {
+			Address functionAddress = readPointer(program, tableAddress.add(funcOffset));
+			if (functionAddress.getOffset() == 0)
+				break;
+			mungeFuncPointer(program, tableAddress.add(funcOffset));
+			tableAddress = tableAddress.add(funcSize);
+		}
+	}
+
+	@Override
+	protected void postImport(Program program) throws Exception {
+		/*
+		 * munge in-memory function pointer addresses so they point to the actual code.
+		 * The better way to handle this would be to override readCodePointer...
+		 */
+		Memory memory = program.getMemory();
+		MemoryBlock memory0 = memory.getBlock(".memory0");
+		Structure functionInfoStruct = (Structure) testInfoStruct.getDataTypeManager().getDataType(CategoryPath.ROOT,
+				"FunctionInfo");
+		int mainArrayOffset = getStructureComponent(testInfoStruct, "funcInfoArrayPtr");
+		int groupArrayOffset = getStructureComponent(groupInfoStruct, "funcInfoArrayPtr");
+		int funcOffset = getStructureComponent(functionInfoStruct, "func");
+		int funcSize = functionInfoStruct.getLength();
+
+		Address mainControlBlock = findBytes(memory, memory0.getStart(), memory0.getEnd(), MAIN_CONTROL_BLOCK_MAGIC);
+		mungeFuncPointer(program, mainControlBlock.add(getStructureComponent(testInfoStruct, "onPass")));
+		mungeFuncPointer(program, mainControlBlock.add(getStructureComponent(testInfoStruct, "onError")));
+		mungeFuncPointer(program, mainControlBlock.add(getStructureComponent(testInfoStruct, "onDone")));
+		mungeFuncPointer(program, mainControlBlock.add(getStructureComponent(testInfoStruct, "sprintf5")));
+		Address mainFuncTable = readPointer(program, mainControlBlock.add(mainArrayOffset));
+		mungeFuncTable(program, mainFuncTable, funcOffset, funcSize);
+
+		Address start = memory0.getStart();
+		while (true) {
+			Address groupControlBlock = findBytes(memory, start, memory0.getEnd(), GROUP_CONTROL_BLOCK_MAGIC);
+			if (groupControlBlock == null) {
+				break;
+			}
+			Address groupFuncTable = readPointer(program, groupControlBlock.add(groupArrayOffset));
+			// XXX hack: we can't munge the whole table because they'll get called from assembly,
+			// so only munge the first entry which points to the group Main and gets read by
+			// PCodeTestGroupControlBlock. Only table indices  1 and above are used by the emulated
+			// code, so this munge is safe (if hackish)
+			mungeFuncPointer(program, groupFuncTable.add(funcOffset));
+			start = groupControlBlock.add(GROUP_CONTROL_BLOCK_MAGIC.length);
+		}
+
+		/* Run analysis now so that all the code segments are properly defined */
+		setAnalysisOptions(program.getOptions(Program.ANALYSIS_PROPERTIES));
+		GhidraProgramUtilities.markProgramAnalyzed(program);
+		AutoAnalysisManager analysisMgr = AutoAnalysisManager.getAnalysisManager(program);
+		analysisMgr.cancelQueuedTasks(); // GhidraProject import utility jumped the gun with analysis initialization
+		analysisMgr.initializeOptions();
+		analysisMgr.reAnalyzeAll(null);
+		analysisMgr.startAnalysis(TaskMonitor.DUMMY); // method blocks during analysis
+	}
+
+	@Override
+	protected void analyze(Program program, PCodeTestControlBlock testControlBlock) throws Exception {
+		/* Nothing: we ran analysis already */
+	}
+
+	@Override
+	protected void initializeState(EmulatorTestRunner testRunner, Program program) throws Exception {
+		super.initializeState(testRunner, program);
+		MemoryBlock memory0 = program.getMemory().getBlock(".memory0");
+		testRunner.setRegister("SP", memory0.getEnd().add(0x10000).getOffset());
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WebAssembly_O0_EmulatorTest.java b/Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WebAssembly_O0_EmulatorTest.java
new file mode 100644
index 0000000000..aa67d46b39
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WebAssembly_O0_EmulatorTest.java
@@ -0,0 +1,38 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.test.processors;
+
+import ghidra.test.processors.support.ProcessorEmulatorTestAdapter;
+import junit.framework.Test;
+
+public class WebAssembly_O0_EmulatorTest extends WasmEmulatorTestAdapter {
+
+	private static final String LANGUAGE_ID = "Wasm:LE:32:default";
+	private static final String COMPILER_SPEC_ID = "default";
+
+	public WebAssembly_O0_EmulatorTest(String name) throws Exception {
+		super(name, LANGUAGE_ID, COMPILER_SPEC_ID);
+	}
+
+	@Override
+	protected String getProcessorDesignator() {
+		return "WebAssembly_LLVM_O0";
+	}
+
+	public static Test suite() {
+		return ProcessorEmulatorTestAdapter.buildEmulatorTestSuite(WebAssembly_O0_EmulatorTest.class);
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WebAssembly_O3_EmulatorTest.java b/Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WebAssembly_O3_EmulatorTest.java
new file mode 100644
index 0000000000..65ebbbc0dc
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WebAssembly_O3_EmulatorTest.java
@@ -0,0 +1,38 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.test.processors;
+
+import ghidra.test.processors.support.ProcessorEmulatorTestAdapter;
+import junit.framework.Test;
+
+public class WebAssembly_O3_EmulatorTest extends WasmEmulatorTestAdapter {
+
+	private static final String LANGUAGE_ID = "Wasm:LE:32:default";
+	private static final String COMPILER_SPEC_ID = "default";
+
+	public WebAssembly_O3_EmulatorTest(String name) throws Exception {
+		super(name, LANGUAGE_ID, COMPILER_SPEC_ID);
+	}
+
+	@Override
+	protected String getProcessorDesignator() {
+		return "WebAssembly_LLVM_O3";
+	}
+
+	public static Test suite() {
+		return ProcessorEmulatorTestAdapter.buildEmulatorTestSuite(WebAssembly_O3_EmulatorTest.class);
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WebAssembly_SIMD_O0_EmulatorTest.java b/Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WebAssembly_SIMD_O0_EmulatorTest.java
new file mode 100644
index 0000000000..e718cb52cf
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WebAssembly_SIMD_O0_EmulatorTest.java
@@ -0,0 +1,38 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.test.processors;
+
+import ghidra.test.processors.support.ProcessorEmulatorTestAdapter;
+import junit.framework.Test;
+
+public class WebAssembly_SIMD_O0_EmulatorTest extends WasmEmulatorTestAdapter {
+
+	private static final String LANGUAGE_ID = "Wasm:LE:32:default";
+	private static final String COMPILER_SPEC_ID = "default";
+
+	public WebAssembly_SIMD_O0_EmulatorTest(String name) throws Exception {
+		super(name, LANGUAGE_ID, COMPILER_SPEC_ID);
+	}
+
+	@Override
+	protected String getProcessorDesignator() {
+		return "WebAssembly_SIMD_LLVM_O0";
+	}
+
+	public static Test suite() {
+		return ProcessorEmulatorTestAdapter.buildEmulatorTestSuite(WebAssembly_SIMD_O0_EmulatorTest.class);
+	}
+}
diff --git a/Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WebAssembly_SIMD_O3_EmulatorTest.java b/Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WebAssembly_SIMD_O3_EmulatorTest.java
new file mode 100644
index 0000000000..8226b35947
--- /dev/null
+++ b/Ghidra/Processors/WebAssembly/src/test.processors/java/ghidra/test/processors/WebAssembly_SIMD_O3_EmulatorTest.java
@@ -0,0 +1,38 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.test.processors;
+
+import ghidra.test.processors.support.ProcessorEmulatorTestAdapter;
+import junit.framework.Test;
+
+public class WebAssembly_SIMD_O3_EmulatorTest extends WasmEmulatorTestAdapter {
+
+	private static final String LANGUAGE_ID = "Wasm:LE:32:default";
+	private static final String COMPILER_SPEC_ID = "default";
+
+	public WebAssembly_SIMD_O3_EmulatorTest(String name) throws Exception {
+		super(name, LANGUAGE_ID, COMPILER_SPEC_ID);
+	}
+
+	@Override
+	protected String getProcessorDesignator() {
+		return "WebAssembly_SIMD_LLVM_O3";
+	}
+
+	public static Test suite() {
+		return ProcessorEmulatorTestAdapter.buildEmulatorTestSuite(WebAssembly_SIMD_O3_EmulatorTest.class);
+	}
+}
-- 
2.44.0

