From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Johannes Obermayr <johannesobermayr@gmx.de>
Date: Tue, 22 Apr 2025 22:56:17 +0200
Subject: [PATCH] 2266: Better decompilation of DOS era interrupts

---
 Ghidra/Processors/x86/certification.manifest  |   1 +
 Ghidra/Processors/x86/data/languages/ia.sinc  | 371 +++++++++++++++++-
 .../x86/ghidra_scripts/InterruptContext.java  | 118 ++++++
 3 files changed, 488 insertions(+), 2 deletions(-)
 create mode 100644 Ghidra/Processors/x86/ghidra_scripts/InterruptContext.java

diff --git a/Ghidra/Processors/x86/certification.manifest b/Ghidra/Processors/x86/certification.manifest
index c150f1550e..62da5d42e3 100644
--- a/Ghidra/Processors/x86/certification.manifest
+++ b/Ghidra/Processors/x86/certification.manifest
@@ -100,5 +100,6 @@ data/patterns/x86gcc_patterns.xml||GHIDRA||||END|
 data/patterns/x86gcc_prepatterns.xml||GHIDRA||||END|
 data/patterns/x86win_patterns.xml||GHIDRA||||END|
 data/patterns/x86win_prepatterns.xml||GHIDRA||||END|
+ghidra_scripts/InterruptContext.java||GHIDRA||||END|
 src/main/java/ghidra/app/plugin/core/analysis/DOSInterruptAnalyzer.java||GHIDRA||||END|
 src/main/java/ghidra/app/plugin/core/analysis/InterruptAnalyzer.java||GHIDRA||||END|
diff --git a/Ghidra/Processors/x86/data/languages/ia.sinc b/Ghidra/Processors/x86/data/languages/ia.sinc
index ebcc9ee2a6..1d353868bc 100644
--- a/Ghidra/Processors/x86/data/languages/ia.sinc
+++ b/Ghidra/Processors/x86/data/languages/ia.sinc
@@ -468,8 +468,10 @@ define context contextreg
   evexBType=(47,47)     # Used for Disp8*N (see table 2-34 in 325462-sdm-vol-1-2abcd-3abcd-4.pdf)
   evexTType=(44,47)     # Used for Disp8*N (see table 2-35 in 325462-sdm-vol-1-2abcd-3abcd-4.pdf)
   evexDisp8=(44,46)
-  reservedHigh=(48,63)  # reserved for future use
 
+  ctxAX = (48,63)
+    ctxAH = (48,55)     # Vice-versa since Sleigh is BE
+    ctxAL = (56,63)
 ;
 
 
@@ -3658,7 +3660,372 @@ enterFrames: low5 is low5 { tmp:1 = low5; export tmp; }
 
 :INT1           is vexMode=0 & byte=0xf1                            { tmp:1 = 0x1; intloc:$(SIZE) = swi(tmp); call [intloc]; return [0:1]; }
 :INT3           is vexMode=0 & byte=0xcc                            { tmp:1 = 0x3; intloc:$(SIZE) = swi(tmp); call [intloc]; return [0:1]; }
-:INT imm8       is vexMode=0 & byte=0xcd; imm8                      { tmp:1 = imm8; intloc:$(SIZE) = swi(tmp); call [intloc]; }
+
+define pcodeop SET_VIDEO_MODE;
+:INT" 10"  is vexMode=0 & byte=0xcd; byte=0x10 & ctxAH=0x00
+{
+  AL = SET_VIDEO_MODE(AL);
+}
+
+define pcodeop SET_TEXTMODE_CURSOR_SHAPE;
+:INT" 10"  is vexMode=0 & byte=0xcd; byte=0x10 & ctxAH=0x01
+{
+  SET_TEXTMODE_CURSOR_SHAPE(CH, CL);
+}
+
+define pcodeop VESA_SET_SUPERVGA_VIDEO_MODE;
+:INT" 10"  is vexMode=0 & byte=0xcd; byte=0x10 & ctxAX=0x4f02
+{
+  local tmp:4 = segment(ES, DI);
+  AX = VESA_SET_SUPERVGA_VIDEO_MODE(BX, tmp);
+}
+
+define pcodeop VESA_SUPERVGA_CPU_VIDEO_MEMORY_CONTROL;
+:INT" 10"  is vexMode=0 & byte=0xcd; byte=0x10 & ctxAX=0x4f05
+{
+  local res:7 = VESA_SUPERVGA_CPU_VIDEO_MEMORY_CONTROL(BH, DX);
+  AX = res[0,16];
+  BL = res[16,8];
+  DX = res[24,16];
+  ES = res[40,16];
+}
+
+define pcodeop TOPVIEW_UPDATE_SCREEN_FROM_SHADOW_BUFFER;
+:INT" 10"  is vexMode=0 & byte=0xcd; byte=0x10 & ctxAH=0xff
+{
+  local tmp:4 = segment(ES, DI);
+  TOPVIEW_UPDATE_SCREEN_FROM_SHADOW_BUFFER(tmp, CX);
+}
+
+define pcodeop GET_BIOS_TYPE;
+:INT" 15"  is vexMode=0 & byte=0xcd; byte=0x15 & ctxAH=0x49 & ctxAL=0x00
+{
+  local res:5 = GET_BIOS_TYPE();
+  AX = res[0,16];
+  BL = res[16,8];
+  CF = res[24,1];
+}
+
+define pcodeop SELECT_SERIAL_INTERFACE;
+:INT" 15"  is vexMode=0 & byte=0xcd; byte=0x15 & ctxAH=0x49 & ctxAL != 0x00
+{
+  SELECT_SERIAL_INTERFACE(AL);
+}
+
+define pcodeop STDIN_W_ECHO;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x01
+{
+  AL = STDIN_W_ECHO();
+}
+
+define pcodeop STDOUT;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x02
+{
+  STDOUT(DL);
+}
+
+define pcodeop STDIN_WO_ECHO;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x08
+{
+  AL = STDIN_WO_ECHO();
+}
+
+define pcodeop DOS_PRINT_STRING;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x09
+{
+  local tmp:4 = segment(DS, DX);
+  DOS_PRINT_STRING(tmp);
+}
+
+define pcodeop GET_CURRENT_DISK;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x19
+{
+  AL = GET_CURRENT_DISK();
+}
+
+define pcodeop SET_DISK_TRANSFER_AREA;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x1a
+{
+  local tmp:4 = segment(DS, DX);
+  SET_DISK_TRANSFER_AREA(tmp);
+}
+
+define pcodeop PARSE_FILENAME;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x29
+{
+  local tmp1:4 = segment(ES, DI);
+  local tmp2:4 = segment(DS, SI);
+  AL = PARSE_FILENAME(tmp1, tmp2, AL);
+}
+
+define pcodeop GET_DATE;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x2a
+{
+  local res:5 = GET_DATE();
+  CX = res[0,16];
+  DH = res[16,8];
+  DL = res[24,8];
+  AL = res[32,8];
+}
+
+define pcodeop GET_TIME;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x2c
+{
+  local res:4 = GET_TIME();
+  CH = res[0,8];
+  CL = res[8,8];
+  DH = res[16,8];
+  DL = res[24,8];
+}
+
+define pcodeop GET_DOS_VERSION_NUMBER;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x30
+{
+  AX = GET_DOS_VERSION_NUMBER(AL);
+}
+
+define pcodeop GET_INTERRUPT_VECTOR;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x35
+{
+  local res:4 = GET_INTERRUPT_VECTOR(AL);
+  BX = res[0,16];
+  ES = res[16,16];
+}
+
+define pcodeop CREATE_DIR;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x39
+{
+  local tmp:4 = segment(DS, DX);
+  local res:3 = CREATE_DIR(tmp);
+  AX = res[0,16];
+  CF = res[16,1];
+}
+
+define pcodeop REMOVE_DIR;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x3a
+{
+  local tmp:4 = segment(DS, DX);
+  local res:3 = REMOVE_DIR(tmp);
+  AX = res[0,16];
+  CF = res[16,1];
+}
+
+define pcodeop SET_CURRENT_DIR;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x3b
+{
+  local tmp:4 = segment(DS, DX);
+  local res:3 = SET_CURRENT_DIR(tmp);
+  AX = res[0,16];
+  CF = res[16,1];
+}
+
+define pcodeop CREATE_FILE;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x3c
+{
+  local tmp:4 = segment(DS, DX);
+  local res:3 = CREATE_FILE(tmp, CX);
+  AX = res[0,16];
+  CF = res[16,1];
+}
+
+define pcodeop OPEN_FILE;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x3d
+{
+  local tmp:4 = segment(DS, DX);
+  local res:3 = OPEN_FILE(tmp, AL, CL);
+  AX = res[0,16];
+  CF = res[16,1];
+}
+
+define pcodeop CLOSE_FILE;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x3e
+{
+  local res:3 = CLOSE_FILE(BX);
+  AX = res[0,16];
+  CF = res[16,1];
+}
+
+define pcodeop READ_FILE;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x3f
+{
+  local tmp:4 = segment(DS, DX);
+  local res:3 = READ_FILE(BX, tmp, CX);
+  AX = res[0,16];
+  CF = res[16,1];
+}
+
+define pcodeop WRITE_FILE;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x40
+{
+  local tmp:4 = segment(DS, DX);
+  local res:3 = WRITE_FILE(BX, tmp, CX);
+  AX = res[0,16];
+  CF = res[16,1];
+}
+
+define pcodeop DELETE_FILE;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x41
+{
+  local tmp:4 = segment(DS, DX);
+  local res:3 = DELETE_FILE(tmp, CL);
+  AX = res[0,16];
+  CF = res[16,1];
+}
+
+define pcodeop LSEEK;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x42
+{
+  local tmp:4 = segment(DS, DX);
+  local res:5 = LSEEK(BX, AL, tmp);
+  AX = res[0,16];
+  DX = res[16,16];
+  CF = res[32,1];
+}
+
+define pcodeop GET_FILE_ATTRIBUTES;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x43
+{
+  local tmp:4 = segment(DS, DX);
+  local res:5 = GET_FILE_ATTRIBUTES(tmp);
+  AX = res[0,16];
+  CX = res[16,16];
+  CF = res[32,1];
+}
+
+define pcodeop GET_DEVICE_INFORMATION;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAX=0x4400
+{
+  local res:5 = GET_DEVICE_INFORMATION(BX);
+  AX = res[0,16];
+  DX = res[16,16];
+  CF = res[32,1];
+}
+
+define pcodeop GET_CURRENT_DIR;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x47
+{
+  local res:7 = GET_CURRENT_DIR(DL);
+  SI = res[0,16];
+  DS = res[16,16];
+  AX = res[32,16];
+  CF = res[48,1];
+}
+
+define pcodeop ALLOCATE_MEMORY;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x48
+{
+  local res:5 = ALLOCATE_MEMORY(BX);
+  AX = res[0,16];
+  BX = res[16,16];
+  CF = res[32,1];
+}
+
+define pcodeop FREE_MEMORY;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x49
+{
+  local res:3 = FREE_MEMORY(ES);
+  AX = res[0,16];
+  CF = res[16,1];
+}
+
+define pcodeop RESIZE_MEMORY_BLOCK;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x4a
+{
+  local res:5 = RESIZE_MEMORY_BLOCK(BX, ES);
+  AX = res[0,16];
+  BX = res[16,16];
+  CF = res[32,1];
+}
+
+define pcodeop EXEC_PROGRAM;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x4b
+{
+  local path:4 = segment(DS, DX);
+  local block:4 = segment(ES, BX);
+  local res:3 = EXEC_PROGRAM(path, block, AL);
+  AX = res[0,16];
+  CF = res[16,1];
+}
+
+define pcodeop END_PROCESS;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x4c
+{
+  END_PROCESS(AL);
+}
+
+define pcodeop GET_RETURN_CODE;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x4d
+{
+  AX = GET_RETURN_CODE();
+}
+
+define pcodeop FIND_FIRST;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x4e
+{
+  local tmp:4 = segment(DS, DX);
+  local res:3 = FIND_FIRST(tmp, CX);
+  AX = res[0,16];
+  CF = res[16,1];
+}
+
+define pcodeop FIND_NEXT;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x4f
+{
+  local res:3 = FIND_NEXT();
+  AX = res[0,16];
+  CF = res[16,1];
+}
+
+define pcodeop GET_EXTENDED_COUNTRY_INFORMATION;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x65
+{
+  local tmp:4 = segment(ES, DI);
+  local res:3 = GET_EXTENDED_COUNTRY_INFORMATION(AL, BX, DX, tmp, CX);
+  AX = res[0,16];
+  CF = res[16,1];
+}
+
+define pcodeop COMMIT_FILE;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0x68
+{
+  local res:3 = COMMIT_FILE(BX);
+  AX = res[0,16];
+  CF = res[16,1];
+}
+
+define pcodeop FILE_SERVER_FILE_COPY;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAH=0xf3
+{
+  local tmp:4 = segment(ES, DI);
+  DX = FILE_SERVER_FILE_COPY(tmp, AX, BX, CX, DX);
+}
+
+define pcodeop TOPWARE_GET_SYSTEM_INFORMATION;
+:INT" 21"  is vexMode=0 & byte=0xcd; byte=0x21 & ctxAX=0xff00
+{
+  BX = TOPWARE_GET_SYSTEM_INFORMATION(CL);
+}
+
+define pcodeop CDROM_INSTALLATION_CHECK;
+:INT" 2f"  is vexMode=0 & byte=0xcd; byte=0x2f & ctxAX=0x1500
+{
+  BX = CDROM_INSTALLATION_CHECK();
+}
+
+define pcodeop DPMI_GET_SEGMENT_BASE_ADDRESS;
+:INT" 31"  is vexMode=0 & byte=0xcd; byte=0x31 & ctxAX=0x0006
+{
+  local res:4 = DPMI_GET_SEGMENT_BASE_ADDRESS(BX);
+  DX = res[0,16];
+  CX = res[16,16];
+}
+
+:INT imm8 is vexMode=0 & byte=0xcd; imm8
+{
+  local tmp:1 = imm8;
+  swi(tmp, AH, AL);
+}
+
 :INTO           is vexMode=0 & byte=0xce & bit64=0
 {
   tmp:1 = 0x4;
diff --git a/Ghidra/Processors/x86/ghidra_scripts/InterruptContext.java b/Ghidra/Processors/x86/ghidra_scripts/InterruptContext.java
new file mode 100644
index 0000000000..dc11fc3ffa
--- /dev/null
+++ b/Ghidra/Processors/x86/ghidra_scripts/InterruptContext.java
@@ -0,0 +1,118 @@
+// @category Analysis
+// @author Johannes Obermayr <johannesobermayr@gmx.de> (with Google Gemini)
+
+import ghidra.app.script.GhidraScript;
+import ghidra.program.model.lang.Register;
+import ghidra.program.model.lang.RegisterValue;
+import ghidra.program.model.listing.Instruction;
+import ghidra.program.model.listing.CodeUnit;
+import ghidra.program.model.scalar.Scalar;
+import ghidra.program.model.address.Address;
+import java.math.BigInteger;
+
+public class InterruptContext extends GhidraScript {
+
+    @Override
+    protected void run() throws Exception {
+        if (currentProgram == null) return;
+
+        Register ctxAx = currentProgram.getProgramContext().getRegister("ctxAX");
+        Register ctxAh = currentProgram.getProgramContext().getRegister("ctxAH");
+        Register ctxAl = currentProgram.getProgramContext().getRegister("ctxAL");
+
+        if (ctxAx == null || ctxAh == null || ctxAl == null) {
+            printerr("Error: One of the context registers (ctxAX, ctxAH, ctxAL) wasn't found!\nDo you use correct Sleigh file.");
+            return;
+        }
+
+        Instruction inst = getFirstInstruction();
+        int countAuto = 0;
+        int countManual = 0;
+
+        while (inst != null && !monitor.isCancelled()) {
+            if (inst.getMnemonicString().startsWith("INT")) {
+                Address addr = inst.getAddress();
+
+                Long finalAH = null;
+                Long finalAL = null;
+
+                // Look 15 instructions back
+                Instruction prev = getInstructionBefore(inst);
+                for (int i = 0; i < 15 && prev != null; i++) {
+                    String mnem = prev.getMnemonicString();
+
+                    if (mnem.startsWith("MOV") || mnem.startsWith("XOR")) {
+                        Object[] ops = prev.getOpObjects(0);
+                        if (ops.length > 0 && ops[0] instanceof Register) {
+                            Register reg = (Register) ops[0];
+                            long val = 0;
+                            boolean isValueKnown = false;
+
+                            Scalar s = prev.getScalar(1);
+                            if (s != null) {
+                                val = s.getValue();
+                                isValueKnown = true;
+                            } else if (mnem.startsWith("XOR")) {
+                                Object[] srcOps = prev.getOpObjects(1);
+                                if (srcOps.length > 0 && srcOps[0].equals(reg)) {
+                                    val = 0;
+                                    isValueKnown = true;
+                                }
+                            }
+
+                            if (isValueKnown) {
+                                String regName = reg.getName();
+                                if (regName.equals("AX")) {
+                                    if (finalAH == null) finalAH = (val >> 8) & 0xFF;
+                                    if (finalAL == null) finalAL = val & 0xFF;
+                                } else if (regName.equals("AH")) {
+                                    if (finalAH == null) finalAH = val & 0xFF;
+                                } else if (regName.equals("AL")) {
+                                    if (finalAL == null) finalAL = val & 0xFF;
+                                }
+                            }
+                        }
+                    }
+
+                    if (finalAH != null && finalAL != null) break;
+
+                    // Warn for CALL or JUMP
+                    if (prev.getFlowType().isCall() || (prev.getFlowType().isJump() && !prev.getFlowType().isConditional())) {
+                        break;
+                    }
+                    prev = getInstructionBefore(prev);
+                }
+
+                if (finalAH != null) {
+                    // Set automatically
+                    long alValue = (finalAL != null) ? finalAL : 0;
+                    long fullAxValue = (finalAH << 8) | alValue;
+
+                    applyContext(addr, ctxAx, ctxAh, ctxAl, fullAxValue, finalAH, alValue);
+                    countAuto++;
+                } else {
+                    setPreComment(addr, "!!! MANUAL CONTEXT REQUIRED !!!\n" +
+                                        "AX/AH/AL couldn't be defined due to CALL or JMP.\n" +
+                                        "Set 'ctxAX', 'ctxAH', 'ctxAL' with 'Register Values'.");
+                    countManual++;
+                    println("Warning: Manual customization required at " + addr + ".");
+                }
+            }
+            inst = getInstructionAfter(inst.getAddress());
+        }
+        println(String.format("Analysis finished. Automatically: %d, Manually required: %d", countAuto, countManual));
+    }
+
+    private void applyContext(Address addr, Register ax, Register ah, Register al, long valAx, long valAh, long valAl) throws Exception {
+        // Clear listing to avoid ContextChangeException
+        clearListing(addr, addr.add(currentProgram.getListing().getInstructionAt(addr).getLength() - 1));
+
+        RegisterValue rvAX = new RegisterValue(ax, BigInteger.valueOf(valAx));
+
+        currentProgram.getProgramContext().setRegisterValue(addr, addr, rvAX);
+
+        //println(String.format("Set AX=0x%x (AH=0x%x,AL=0x%x) at ", valAx, valAh, valAl) + addr);
+
+        disassemble(addr);
+    }
+}
-- 
2.45.1

