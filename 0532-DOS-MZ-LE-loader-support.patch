From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Mariusz Zaborski <oshogbo@vexillium.org>
Date: Sun, 22 Sep 2019 23:29:50 +0200
Subject: [PATCH] 0532: DOS MZ LE loader support

see: https://github.com/oshogbo/ghidra-lx-loader
---
 .../ghidra/app/util/bin/format/lx/LX.java     | 252 ++++++++++++++++++
 .../util/bin/format/lx/LXFixupPageTable.java  |  46 ++++
 .../bin/format/lx/LXFixupRecordTable.java     | 169 ++++++++++++
 .../app/util/bin/format/lx/LXHeader.java      | 243 +++++++++++++++++
 .../app/util/bin/format/lx/LXLoader.java      | 168 ++++++++++++
 .../util/bin/format/lx/LXObjectPageTable.java |  66 +++++
 .../app/util/bin/format/lx/LXObjectTable.java |  91 +++++++
 .../util/bin/format/lx/LinearExecutable.java  |  36 ---
 8 files changed, 1035 insertions(+), 36 deletions(-)
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LX.java
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXFixupPageTable.java
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXFixupRecordTable.java
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXHeader.java
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXLoader.java
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXObjectPageTable.java
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXObjectTable.java
 delete mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LinearExecutable.java

diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LX.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LX.java
new file mode 100644
index 0000000000..ad349ca0b0
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LX.java
@@ -0,0 +1,252 @@
+/*-
+ * Copyright 2019 Mariusz Zaborski <oshogbo@FreeBSD.org>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package lx;
+
+import java.io.IOException;
+import java.util.Iterator;
+
+import ghidra.app.util.bin.BinaryReader;
+
+public class LX {
+	private long base_addr;
+	private LXHeader header;
+	private LXObjectTable []object_table;
+	private LXObjectPageTable []object_page_table;
+	private LXFixupPageTable []fixup_page_table;
+
+	protected LXObjectTable[] loadObjectTable(BinaryReader reader) throws IOException {
+		/*
+		 * [Doc]
+		 * public long object_table_offset;		 40h
+		 * public long objects_in_module;		 44h
+		 */
+		LXObjectTable []opt = new LXObjectTable[(int)header.objects_in_module];
+
+		reader.setPointerIndex(base_addr + header.object_table_offset);
+		for (int i = 0; i < (int)header.objects_in_module; i++) {
+			opt[i] = new LXObjectTable(reader);
+		}
+
+		return opt;
+	}
+
+	protected LXObjectPageTable[] loadObjectPageTable(BinaryReader reader) throws IOException {
+		/*
+		 * [Doc]
+		 * public long	module_of_pages;		14h
+		 * public long object_iter_page_offset;		4ch
+		 */
+		LXObjectPageTable []opt = new LXObjectPageTable[(int)header.module_of_pages];
+
+		reader.setPointerIndex(base_addr + header.object_page_table_offset);
+		for (int i = 0; i < (int)header.module_of_pages; i++) {
+			opt[i] = new LXObjectPageTable(reader, header.isLe());
+		}
+
+		return opt;
+	}
+
+	protected LXFixupPageTable[] loadFixupPageTable(BinaryReader reader) throws IOException {
+		/*
+		 * [Doc]
+		 * This table is parallel to the Object Page Table, except that
+		 * there is one  additional entry in this table to indicate the
+		 * end of the Fixup Record Table.
+		 * public long	module_of_pages;		14h
+		 *
+		 * public long fixup_page_table_offset;		68h
+		 */
+		LXFixupPageTable []fpt = new LXFixupPageTable[(int)header.module_of_pages + 1];
+
+		reader.setPointerIndex(base_addr + header.fixup_page_table_offset);
+		for (int i = 0; i < (int)header.module_of_pages + 1; i++) {
+			fpt[i] = new LXFixupPageTable(reader);
+		}
+
+		return fpt;
+	}
+
+	protected void loadFixupRecordTable(BinaryReader reader) throws IOException {
+		/*
+		 * [Doc]
+		 * public long fixup_record_table_offset;	6Ch
+		 */
+		LXFixupRecordTable frt;
+		LXObjectTable ot;
+		long start, end, base_offset;
+		int page_end_i;
+
+		for (int i = 0; i < (int)header.objects_in_module; i++) {
+			ot = getLXObjectTable(i);
+			page_end_i = getPageEndIndex(ot);
+
+			for (int oi = (int)ot.page_table_index; oi < page_end_i; oi++) {
+				start = base_addr + header.fixup_record_table_offset + fixup_page_table[oi].offset;
+				end = base_addr + header.fixup_record_table_offset + fixup_page_table[oi + 1].offset;
+				base_offset = (oi - ot.page_table_index) * header.page_size;
+
+				reader.setPointerIndex(start);
+				while (start < end) {
+					frt = new LXFixupRecordTable(reader, base_offset);
+					ot.appendFixupTable(frt);
+					start += frt.getSizeInFile();
+				}
+			}
+		}
+	}
+
+	public LX(BinaryReader reader, long base_addr, long exeoffset) throws IOException {
+		this.base_addr = base_addr;
+		reader.setPointerIndex(base_addr);
+
+		header = new LXHeader(reader);
+		/*
+		 * data_pages_offset contains the offset relative to the exe start
+		 * in an MZ/LE, add the offset to the beginning of the embedded exe.
+		 */
+		header.data_pages_offset += exeoffset;
+
+		object_table = loadObjectTable(reader);
+		object_page_table = loadObjectPageTable(reader);
+		fixup_page_table = loadFixupPageTable(reader);
+		loadFixupRecordTable(reader);
+	}
+
+	public LXHeader getHeader() {
+		return header;
+	}
+
+	public LXObjectTable getLXObjectTable(int i) {
+		return object_table[i];
+	}
+
+	public LXObjectPageTable getLXObjectPageTable(int oi) {
+		return object_page_table[oi];
+	}
+
+	public long sizeOfLXObjectTable() {
+		return object_table.length;
+	}
+
+	private long getPageFileOffset(int oi) {
+		LXObjectPageTable opt = getLXObjectPageTable(oi);
+
+		if (header.isLe())
+			return (opt.page_num-1) * header.page_size + header.data_pages_offset;
+
+		return (opt.page_data_offset + opt.data_size - 1) *
+				header.page_size + header.data_pages_offset;
+	}
+
+	private long getPageFileSize(LXObjectTable ohdr, int oi, long datapos) {
+		assert(oi + 1 <= header.module_of_pages);
+
+		if (oi + 1 == header.module_of_pages)
+			return Math.min(ohdr.virtual_size - datapos, header.page_offset_shift);
+		return Math.min(ohdr.virtual_size - datapos, header.page_size);
+	}
+
+	private int getPageEndIndex(LXObjectTable ohdr) {
+		return (int)Math.min(ohdr.page_table_index + ohdr.page_table_entries, header.module_of_pages);
+	}
+
+	/* Can I do it better in java? ... */
+	private void emitU16(byte []data, int offset, long val) {
+		data[offset] = (byte)((val) & 0xFF);
+		data[offset + 1] = (byte)((val >> 8) & 0xFF);
+	}
+	private void emitU32(byte []data, int offset, long val) {
+		data[offset] = (byte)((val) & 0xFF);
+		data[offset + 1] = (byte)((val >> 8) & 0xFF);
+		data[offset + 2] = (byte)((val >> 16) & 0xFF);
+		data[offset + 3] = (byte)((val >> 24) & 0xFF);
+	}
+	/* ... Probably */
+
+	private void applyFixups(LXObjectTable ot, byte []data) {
+		Iterator<LXFixupRecordTable> itr = ot.fixupTableIterator();
+		LXFixupRecordTable frt;
+		long memAddr;
+
+		while (itr.hasNext()) {
+			frt = itr.next();
+
+			if (frt.getSourceType() == 0x02) {
+				/* XXX: What supposed should I do? */
+				continue;
+			}
+
+			memAddr = getLXObjectTable((int)frt.object).reloc_base_addr + frt.trgoff;
+
+			for (int i = 0; i < frt.getDSTOffsetCount(); i++) {
+				if (data.length < frt.getDSTOffset(i)) {
+					/* XXX: What supposed should I do? */
+					/*
+					 * [DOC]
+					 * Note that for fixups that  cross page  boundaries, a
+					 * separate  fixup  record is  specified for each page.
+					 * An offset is still used for the 2nd  page but it now
+					 * becomes a negative offset since the fixup originated
+					 * on  the  preceding page.  (For  example, if only the
+					 * last one byte of a 32-bit address is on the page  to
+					 * be fixed up, then the offset would  have  a value of
+					 * -3.)
+					 */
+					continue;
+				}
+
+				switch (frt.getSourceType()) {
+				case 0x05: /* 16-bit */
+					emitU16(data, frt.getDSTOffset(i), memAddr);
+					break;
+				case 0x06: /* 16:32 bit Pointer */
+					/* XXX: What todo ? */
+					emitU32(data, frt.getDSTOffset(i), memAddr);
+					break;
+				case 0x07: /* 32-bit */
+					emitU32(data, frt.getDSTOffset(i), memAddr);
+					break;
+				case 0x08: /* 32-bit Self-relative offset fixup */
+					emitU32(data, frt.getDSTOffset(i), frt.getDSTOffset(i) + frt.trgoff);
+					break;
+				}
+			}
+		}
+	}
+
+	public byte[] readObjectData(BinaryReader reader, LXObjectTable ot) throws IOException {
+		byte []data = new byte[(int)ot.virtual_size];
+		int page_end_i = getPageEndIndex(ot);
+		int datapos = 0;
+
+		for (int oi = (int)ot.page_table_index; oi < page_end_i; oi++) {
+			int rsize = (int)getPageFileSize(ot, oi, datapos);
+			byte []xdata = reader.readByteArray(getPageFileOffset(oi), rsize);
+
+			System.arraycopy(xdata, 0, data, datapos, rsize);
+			datapos += rsize;
+		}
+
+		applyFixups(ot, data);
+
+		return data;
+	}
+
+	public long getEIPAddress() {
+		return getLXObjectTable((int)header.eip_object).reloc_base_addr + header.eip;
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXFixupPageTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXFixupPageTable.java
new file mode 100644
index 0000000000..9dfcf2a827
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXFixupPageTable.java
@@ -0,0 +1,46 @@
+/*-
+ * Copyright 2019 Mariusz Zaborski <oshogbo@FreeBSD.org>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package lx;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+
+/*
+ * [Doc]
+ *
+ *                  +-----+-----+-----+-----+
+ * Logical Page #1  |  OFFSET FOR PAGE #1   |
+ *                  +-----+-----+-----+-----+
+ * Logical Page #2  |  OFFSET FOR PAGE #2   |
+ *                  +-----+-----+-----+-----+
+ *                          . . .
+ *                  +-----+-----+-----+-----+
+ * Logical Page #n  |  OFFSET FOR PAGE #n   |
+ *                  +-----+-----+-----+-----+
+ *                  |OFF TO END OF FIXUP REC|   This is equal to:
+ *                  +-----+-----+-----+-----+   Offset for page #n + Size
+ *                                              of fixups for page #n
+ */
+
+
+public class LXFixupPageTable {
+	public long offset;
+
+	public LXFixupPageTable(BinaryReader reader) throws IOException {
+		offset = reader.readNextUnsignedInt();
+	}
+}
\ No newline at end of file
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXFixupRecordTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXFixupRecordTable.java
new file mode 100644
index 0000000000..2e64d98b3e
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXFixupRecordTable.java
@@ -0,0 +1,169 @@
+/*-
+ * Copyright 2019 Mariusz Zaborski <oshogbo@FreeBSD.org>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package lx;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+
+public class LXFixupRecordTable {
+	/*
+	 *         +-----+-----+-----+-----+
+	 *     00h | SRC |FLAGS|SRCOFF/CNT*|
+	 *	   +-----+-----+-----+-----+-----+-----+
+	 * 03h/04h |           TARGET DATA *           |
+	 *         +-----+-----+-----+-----+-----+-----+
+	 *         | SRCOFF1 @ |   . . .   | SRCOFFn @ |
+	 *         +-----+-----+----   ----+-----+-----+
+	 */
+
+	public byte src;
+	public byte flags;
+	public int srcoff_count;
+	public long object;
+	public long trgoff;
+
+	/* My private one.*/
+	private long size = 4;
+	private int dstOffset[];
+
+    public LXFixupRecordTable(BinaryReader reader, long offsetBase) throws IOException {
+	src = reader.readNextByte();
+	flags = reader.readNextByte();
+
+	/*
+	 * [Doc]
+	 * 20h = Source List flag.
+	 *
+	 * When  the  'Source  List'  Flag is set,  the
+	 * SRCOFF field  is compressed  to  a byte  and
+	 * contains the number of source offsets.
+	 */
+	if ((src & 0x20) == 0x20) {
+		srcoff_count = reader.readNextByte();
+		size += 1;
+	} else {
+		srcoff_count = reader.readNextUnsignedShort();
+		size += 2;
+	}
+
+	/*
+	 * Source type.
+	 * Supporting:
+	 * 05h = 16-bit Offset fixup (16-bits).
+	 * 06h = 16:32 Pointer fixup (48-bits).
+         * 07h = 32-bit Offset fixup (32-bits).
+         * 08h = 32-bit Self-relative offset fixup
+         * 20h = Source List Flag.
+         *
+         * XXX:
+         * 02h = 16-bit Selector fixup (16-bits).
+         * 10h = Fixup to Alias Flag.
+		 */
+	switch (getSourceType()) {
+	case 0x02:
+	case 0x05:
+	case 0x06:
+	case 0x07:
+	case 0x08:
+		break;
+	default:
+		throw new UnknownError("Unsupported fixup source: " + getSourceType());
+	}
+
+	/*
+	 * Supported flags 0x10 and 0x40.
+	 */
+	if ((flags & ~0x50) != 0) {
+		throw new UnknownError("Unsupported target flags: " + flags);
+	}
+
+	/*
+	 * [Doc]
+	 * 40h = 16-bit Object Number/Module Ordinal Flag.
+	 * When  set,  the   object  number  or  module
+	 * ordinal number  is 16-bits, otherwise  it is
+	 * 8-bits.
+	 */
+        if ((flags & 0x40) == 0x40) {
+		object = reader.readNextUnsignedShort();
+		size += 2;
+        } else {
+		object = reader.readNextByte();
+		size += 1;
+        }
+        object -= 1;
+
+        /*
+         * [Doc] [Target offset.]
+         * It  is  not  present  when  the
+         * Source Type  specifies a 16-bit Selector fixup (02h).
+         */
+        if (getSourceType() == 0x2) {
+		return;
+        }
+
+        /*
+         * [Doc]
+	 * 10h = 32-bit Target Offset Flag.
+         * When  set, the  target  offset  is  32-bits,
+         * otherwise it is 16-bits.
+         */
+        if ((flags & 0x10) == 0x10) {
+		trgoff = reader.readNextUnsignedInt();
+		size += 4;
+        } else {
+		trgoff = reader.readNextUnsignedShort();
+		size += 2;
+        }
+
+        /*
+	 * [Doc]
+         * 20h = When  the  'Source  List'  Flag is set,  the
+         * SRCOFF field contains the number of source offsets, and a
+         * list  of source  offsets  follows the end of
+         * fixup  record (after  the  optional additive
+         * value).
+         */
+        if ((src & 0x20) == 0x20) {
+            this.dstOffset = new int[srcoff_count];
+            for (int i = 0; i < srcoff_count; i++) {
+                int offset = reader.readNextUnsignedShort();
+                this.dstOffset[i] = (int)offsetBase + offset;
+            }
+        } else {
+            this.dstOffset = new int[1];
+            this.dstOffset[0] = (int)offsetBase + srcoff_count;
+        }
+    }
+
+    public long getSizeInFile() {
+	return size;
+    }
+
+    public int getSourceType() {
+	return src & 0xF;
+    }
+
+    public int getDSTOffsetCount() {
+	return dstOffset.length;
+    }
+
+    public int getDSTOffset(int index) {
+	return dstOffset[index];
+    }
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXHeader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXHeader.java
new file mode 100644
index 0000000000..51e4e724ab
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXHeader.java
@@ -0,0 +1,243 @@
+/*-
+ * Copyright 2019 Mariusz Zaborski <oshogbo@FreeBSD.org>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package lx;
+
+import java.io.IOException;
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.StructConverter;
+import ghidra.program.model.data.DataType;
+import ghidra.program.model.data.Structure;
+import ghidra.program.model.data.StructureDataType;
+
+/*
+ * [Doc]
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     00h | "L"   "X" |B-ORD|W-ORD|     FORMAT LEVEL      |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     08h | CPU TYPE  |  OS TYPE  |    MODULE VERSION     |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     10h |     MODULE FLAGS      |   MODULE # OF PAGES   |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     18h |     EIP OBJECT #      |          EIP          |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     20h |     ESP OBJECT #      |          ESP          |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     28h |       PAGE SIZE       |   PAGE OFFSET SHIFT   |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     30h |  FIXUP SECTION SIZE   | FIXUP SECTION CHECKSUM|
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     38h |  LOADER SECTION SIZE  |LOADER SECTION CHECKSUM|
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     40h |    OBJECT TABLE OFF   |  # OBJECTS IN MODULE  |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     48h | OBJECT PAGE TABLE OFF | OBJECT ITER PAGES OFF |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     50h | RESOURCE TABLE OFFSET |#RESOURCE TABLE ENTRIES|
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     58h | RESIDENT NAME TBL OFF |   ENTRY TABLE OFFSET  |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     60h | MODULE DIRECTIVES OFF | # MODULE DIRECTIVES   |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     68h | FIXUP PAGE TABLE OFF  |FIXUP RECORD TABLE OFF |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     70h | IMPORT MODULE TBL OFF | # IMPORT MOD ENTRIES  |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     78h |  IMPORT PROC TBL OFF  | PER-PAGE CHECKSUM OFF |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     80h |   DATA PAGES OFFSET   |    #PRELOAD PAGES     |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     88h | NON-RES NAME TBL OFF  | NON-RES NAME TBL LEN  |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     90h | NON-RES NAME TBL CKSM |   AUTO DS OBJECT #    |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     98h |    DEBUG INFO OFF     |    DEBUG INFO LEN     |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     A0h |   #INSTANCE PRELOAD   |   #INSTANCE DEMAND    |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     A8h |       HEAPSIZE        |
+ *         +-----+-----+-----+-----+
+ */
+
+public class LXHeader implements StructConverter {
+	public String signature;				/* 00h */
+	public byte b_ord;					/* 02h */
+	public byte w_ord;					/* 03h */
+	public long format_level;				/* 04h */
+	public int  cpu_type;					/* 08h */
+	public int  os_type;					/* 0Ah */
+	public long module_version;				/* 0Ch */
+	public long module_flag;				/* 10h */
+	public long module_of_pages;				/* 14h */
+	public long eip_object;					/* 18h */
+	public long eip;					/* 1Ch */
+	public long esp_object;					/* 20h */
+	public long esp;					/* 24h */
+	public long page_size;					/* 28h */
+	/*
+	 * ? bytes on the last page?
+	 * http://faydoc.tripod.com/formats/exe-LE.htm
+	 */
+	public long page_offset_shift;				/* 2Ch */
+	public long fixup_section_size	;			/* 30h */
+	public long fixup_section_check_sum;			/* 34h */
+	public long loader_section_size;			/* 38h */
+	public long loader_section_check_sum;			/* 3Ch */
+	public long object_table_offset;			/* 40h */
+	public long objects_in_module;				/* 44h */
+	public long object_page_table_offset;			/* 48h */
+	public long object_iter_page_offset;			/* 4ch */
+	public long resource_table_offset;			/* 50h */
+	public long resource_table_entries;			/* 54h */
+	public long residance_name_tbl_offset;			/* 58h */
+	public long entry_table_offset	;			/* 5Ch */
+	public long module_directives_offset;			/* 60h */
+	public long module_directives_count;			/* 64h */
+	public long fixup_page_table_offset;			/* 68h */
+	public long fixup_record_table_offset;			/* 6Ch */
+	public long import_module_name_table_offset;		/* 70h */
+	public long import_module_name_entry_count;		/* 74h */
+	public long import_procedure_name_table_offset;		/* 78h */
+	public long per_page_checksum_offset;			/* 7Ch */
+	public long data_pages_offset;				/* 80h */
+	public long preload_pages;				/* 84h */
+	public long non_resident_name_tvl_offset;		/* 88h */
+	public long non_resident_name_tbl_len;			/* 8Ch */
+	public long non_resident_name_tbl_cksm;			/* 90h */
+	public long auto_ds_object;				/* 94h */
+	public long debug_info_offset;				/* 98h */
+	public long debug_info_len;				/* 9Ch */
+	public long instance_preload;				/* A0h */
+	public long instance_demand;				/* A4h */
+	public long heapsize;					/* A8h */
+
+	public boolean isLe() {
+		return signature.equals("LE");
+	}
+
+	public LXHeader(BinaryReader reader) throws IOException {
+		signature = reader.readNextAsciiString(2);
+		if (!signature.equals("LX") && !signature.equals("LE")) {
+			throw new UnknownError("Unknwon file format: " + signature);
+		}
+
+		b_ord = reader.readNextByte();
+		if (b_ord != 0) {
+			throw new UnknownError("Unsuported big endian");
+		}
+		w_ord = reader.readNextByte();
+		if (w_ord != 0) {
+			throw new UnknownError("Unsuported big endian");
+		}
+		format_level = reader.readNextUnsignedInt();
+		if (w_ord != 0) {
+			throw new UnknownError("Unsuported format lvl");
+		}
+		cpu_type = reader.readNextUnsignedShort();
+		os_type = reader.readNextUnsignedShort();
+		module_version = reader.readNextUnsignedInt();
+		module_flag = reader.readNextUnsignedInt();
+		module_of_pages = reader.readNextUnsignedInt();
+		eip_object = reader.readNextUnsignedInt() - 1;
+		eip = reader.readNextUnsignedInt();
+		esp_object = reader.readNextUnsignedInt();
+		esp = reader.readNextUnsignedInt();
+		page_size = reader.readNextUnsignedInt();
+		page_offset_shift = reader.readNextUnsignedInt();
+		fixup_section_size = reader.readNextUnsignedInt();
+		fixup_section_check_sum = reader.readNextUnsignedInt();
+		loader_section_size = reader.readNextUnsignedInt();
+		loader_section_check_sum = reader.readNextUnsignedInt();
+		object_table_offset = reader.readNextUnsignedInt();
+		objects_in_module = reader.readNextUnsignedInt();
+		object_page_table_offset = reader.readNextUnsignedInt();
+		object_iter_page_offset = reader.readNextUnsignedInt();
+		resource_table_offset = reader.readNextUnsignedInt();
+		resource_table_entries = reader.readNextUnsignedInt();
+		residance_name_tbl_offset = reader.readNextUnsignedInt();
+		entry_table_offset = reader.readNextUnsignedInt();
+		module_directives_offset = reader.readNextUnsignedInt();
+		module_directives_count = reader.readNextUnsignedInt();
+		fixup_page_table_offset = reader.readNextUnsignedInt();
+		fixup_record_table_offset = reader.readNextUnsignedInt();
+		import_module_name_table_offset = reader.readNextUnsignedInt();
+		import_module_name_entry_count = reader.readNextUnsignedInt();
+		import_procedure_name_table_offset = reader.readNextUnsignedInt();
+		per_page_checksum_offset = reader.readNextUnsignedInt();
+		data_pages_offset = reader.readNextUnsignedInt();
+		preload_pages = reader.readNextUnsignedInt();
+		non_resident_name_tvl_offset = reader.readNextUnsignedInt();
+		non_resident_name_tbl_len = reader.readNextUnsignedInt();
+		non_resident_name_tbl_cksm = reader.readNextUnsignedInt();
+		auto_ds_object = reader.readNextUnsignedInt();
+		debug_info_offset = reader.readNextUnsignedInt();
+		debug_info_len = reader.readNextUnsignedInt();
+		instance_preload = reader.readNextUnsignedInt();
+		instance_demand = reader.readNextUnsignedInt();
+		heapsize = reader.readNextUnsignedInt();
+	}
+
+	public DataType toDataType() {
+		Structure struct = new StructureDataType("LXHeader_t", 0);
+		struct.add(ASCII, 2, "signature", null);
+		struct.add(DWORD, 1, "b_ord", null);
+		struct.add(DWORD, 1, "w_ord", null);
+		struct.add(DWORD, 4, "format_level", null);
+		struct.add(DWORD, 2, "cpu_type", null);
+		struct.add(DWORD, 2, "os_type", null);
+		struct.add(DWORD, 4, "module_version", null);
+		struct.add(DWORD, 4, "module_flag", null);
+		struct.add(DWORD, 4, "module_of_pages", null);
+		struct.add(DWORD, 4, "eip_object", null);
+		struct.add(DWORD, 4, "eip", null);
+		struct.add(DWORD, 4, "esp_object", null);
+		struct.add(DWORD, 4, "esp", null);
+		struct.add(DWORD, 4, "page_size", null);
+		struct.add(DWORD, 4, "page_offset_shift", null);
+		struct.add(DWORD, 4, "fixup_section_size", null);
+		struct.add(DWORD, 4, "fixup_section_check_sum", null);
+		struct.add(DWORD, 4, "loader_section_size", null);
+		struct.add(DWORD, 4, "loader_section_check_sum", null);
+		struct.add(DWORD, 4, "object_table_offset", null);
+		struct.add(DWORD, 4, "objects_in_module", null);
+		struct.add(DWORD, 4, "object_page_table_offset", null);
+		struct.add(DWORD, 4, "object_iter_page_offset", null);
+		struct.add(DWORD, 4, "resource_table_offset", null);
+		struct.add(DWORD, 4, "resource_table_entries", null);
+		struct.add(DWORD, 4, "residance_name_tbl_offset", null);
+		struct.add(DWORD, 4, "entry_table_offset", null);
+		struct.add(DWORD, 4, "module_directives_offset", null);
+		struct.add(DWORD, 4, "module_directives_count", null);
+		struct.add(DWORD, 4, "fixup_page_table_offset", null);
+		struct.add(DWORD, 4, "fixup_record_table_offset", null);
+		struct.add(DWORD, 4, "import_module_name_table_offset", null);
+		struct.add(DWORD, 4, "import_module_name_entry_count", null);
+		struct.add(DWORD, 4, "import_procedure_name_table_offset", null);
+		struct.add(DWORD, 4, "per_page_checksum_offset", null);
+		struct.add(DWORD, 4, "data_pages_offset", null);
+		struct.add(DWORD, 4, "preload_pages", null);
+		struct.add(DWORD, 4, "non_resident_name_tvl_offset", null);
+		struct.add(DWORD, 4, "non_resident_name_tbl_len", null);
+		struct.add(DWORD, 4, "non_resident_name_tbl_cksm", null);
+		struct.add(DWORD, 4, "auto_ds_object", null);
+		struct.add(DWORD, 4, "debug_info_offset", null);
+		struct.add(DWORD, 4, "debug_info_len", null);
+		struct.add(DWORD, 4, "instance_preload", null);
+		struct.add(DWORD, 4, "instance_demand", null);
+		struct.add(DWORD, 4, "heapsize", null);
+		return struct;
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXLoader.java
new file mode 100644
index 0000000000..7fb3c95b25
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXLoader.java
@@ -0,0 +1,168 @@
+/*-
+ * Copyright 2019 Mariusz Zaborski <oshogbo@FreeBSD.org>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package lx;
+
+import java.io.IOException;
+import java.util.*;
+
+import ghidra.app.util.Option;
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.ByteProvider;
+import ghidra.app.util.importer.MessageLog;
+import ghidra.app.util.opinion.AbstractLibrarySupportLoader;
+import ghidra.app.util.opinion.LoadSpec;
+import ghidra.program.flatapi.FlatProgramAPI;
+import ghidra.program.model.lang.LanguageCompilerSpecPair;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.mem.MemoryBlock;
+import ghidra.util.Msg;
+import ghidra.util.exception.CancelledException;
+import ghidra.util.task.TaskMonitor;
+
+public class LXLoader extends AbstractLibrarySupportLoader {
+
+	public long 						exeoffset;
+	public long 						linoffset;
+
+
+	@Override
+	public String getName() {
+		return "Linear eXecutable Module Format";
+	}
+
+	public boolean findStartOffset(BinaryReader reader) throws IOException {
+		String signature;
+		long 	datalen;
+		long 	offset;
+		int		exelen, tmp;
+
+
+		// skip any stub data
+		offset = 0;
+		exeoffset = 0;
+		datalen = reader.length();
+
+		while(datalen > 2)
+		{
+			signature = reader.readAsciiString(offset, 2);
+			/* Standalone LE/LX file */
+			if ("LE".equals(signature) || "LX".equals(signature)) {
+				linoffset = offset;
+				return true;
+			}
+
+			if("MZ".equals(signature))
+			{
+				/* save the start of this exe file as the last exe offset */
+				exeoffset = offset;
+				/* got an embedded LE */
+				if(reader.readByte(offset + 0x18) >= 0x40) {
+
+					offset += reader.readUnsignedInt(offset + 0x3C);
+
+					continue;
+				}
+
+				/*  mz stub header, skip */
+				exelen = reader.readUnsignedShort(offset + 0x04);
+				exelen *= 512;
+				tmp = reader.readUnsignedShort(offset + 0x02);
+				if(tmp != 0)
+					exelen -= (512 - tmp);
+
+				offset += exelen;
+				datalen -= exelen;
+			}
+			else if("BW".equals(signature))
+			{
+				/*
+				 * DOS/4G Executable
+				 * exp stub header, skip
+				 */
+				exelen = reader.readUnsignedShort(offset + 0x04);
+				exelen *= 512;
+				tmp = reader.readUnsignedShort(offset + 0x02);
+				if(tmp != 0)
+					exelen += tmp;
+
+				offset += exelen;
+				datalen -= exelen;
+			}
+			else
+				/* unknown/invalid stub header signature */
+				break;
+		}
+
+		/* no linear executable found */
+		return false;
+	}
+
+	@Override
+	public Collection<LoadSpec> findSupportedLoadSpecs(ByteProvider provider) throws IOException {
+		BinaryReader reader = new BinaryReader(provider, true);
+
+		// skip any stub data
+		// no linear executable found
+		if (!findStartOffset(reader))
+			return List.of();
+
+		return List.of(new LoadSpec(this, 0, new LanguageCompilerSpecPair("x86:LE:32:default", "gcc"), true));
+	}
+
+	@Override
+	protected void load(ByteProvider provider, LoadSpec loadSpec, List<Option> options,
+			Program program, TaskMonitor monitor, MessageLog log)
+			throws CancelledException, IOException {
+		LX lx;
+		long base_addr;
+		BinaryReader reader = new BinaryReader(provider, true);
+		FlatProgramAPI api = new FlatProgramAPI(program, monitor);
+
+
+	    if(!findStartOffset(reader))
+		throw new CancelledException();
+
+	    base_addr = linoffset;
+
+
+		/* Parse LX/LE. */
+		lx = new LX(reader, base_addr, exeoffset);
+
+		/* Create segments. */
+		for (int hoi = 0; hoi < lx.sizeOfLXObjectTable(); hoi++) {
+			LXObjectTable ohdr = lx.getLXObjectTable(hoi);
+			String name = ohdr.getName() + Integer.toString(hoi + 1);
+			MemoryBlock block;
+			byte []data;
+
+			if (!lx.getHeader().isLe() && !ohdr.objectHasPreloadPages())
+				continue;
+
+			data = lx.readObjectData(reader, ohdr);
+
+			try {
+				block = api.createMemoryBlock(name, api.toAddr(ohdr.reloc_base_addr), data, false);
+				ohdr.setObjectPermissions(block);
+			} catch (Exception e) {
+				Msg.error(this, e.getMessage());
+			}
+		}
+
+		api.addEntryPoint(api.toAddr(lx.getEIPAddress()));
+		api.disassemble(api.toAddr(lx.getEIPAddress()));
+		api.createFunction(api.toAddr(lx.getEIPAddress()), "_entry");
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXObjectPageTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXObjectPageTable.java
new file mode 100644
index 0000000000..da65bc149d
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXObjectPageTable.java
@@ -0,0 +1,66 @@
+/*-
+ * Copyright 2019 Mariusz Zaborski <oshogbo@FreeBSD.org>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package lx;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+
+/*
+ * [Doc]
+ * XXX: WTF???? This doesn't seem right.
+ *        63                     32 31       16 15         0
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     00h |    PAGE DATA OFFSET   | DATA SIZE |   FLAGS   |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ * More reliable looks:
+ *        32                      16           8           0
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     00h |    PAGE DATA OFFSET   | DATA SIZE |   FLAGS   |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *
+ *
+ */
+public class LXObjectPageTable {
+	// LX format
+	public long page_data_offset;
+	public int data_size;
+
+	// LE format
+	public long page_num;
+
+	public int flags;
+
+	public LXObjectPageTable(BinaryReader reader, boolean bisLe) throws IOException {
+
+		if (bisLe) {
+			page_num = reader.readNextUnsignedByte();
+			page_num = page_num << 8;
+			page_num |= reader.readNextUnsignedByte();
+			page_num = page_num << 8;
+			page_num |= reader.readNextUnsignedByte();
+		} else {
+			page_data_offset = reader.readNextShort();
+			data_size = reader.readNextUnsignedByte();
+		}
+		flags = reader.readNextUnsignedByte();
+
+		if (flags > 4) {
+			throw new UnknownError("Wrong flags" + Integer.toString(flags));
+		}
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXObjectTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXObjectTable.java
new file mode 100644
index 0000000000..4269f36383
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LXObjectTable.java
@@ -0,0 +1,91 @@
+/*-
+ * Copyright 2019 Mariusz Zaborski <oshogbo@FreeBSD.org>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package lx;
+
+import java.io.IOException;
+import java.util.Iterator;
+import java.util.LinkedList;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.program.model.mem.MemoryBlock;
+
+/*
+ * [Doc]
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     00h |     VIRTUAL SIZE      |    RELOC BASE ADDR    |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     08h |     OBJECT FLAGS      |    PAGE TABLE INDEX   |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ *     10h |  # PAGE TABLE ENTRIES |       RESERVED        |
+ *         +-----+-----+-----+-----+-----+-----+-----+-----+
+ */
+
+public class LXObjectTable {
+	/* Struct ones. */
+	public long virtual_size;
+	public long reloc_base_addr;
+	public long object_flags;
+	public long page_table_index;
+	public long page_table_entries;
+	public long reserved;
+
+	/* My private ones. */
+	private LinkedList<LXFixupRecordTable> fixups_for_opbject = new LinkedList<LXFixupRecordTable>();
+
+	public LXObjectTable(BinaryReader reader) throws IOException {
+		virtual_size = reader.readNextUnsignedInt();
+		reloc_base_addr = reader.readNextUnsignedInt();
+		object_flags = reader.readNextUnsignedInt();
+		page_table_index = reader.readNextUnsignedInt() - 1;
+		page_table_entries = reader.readNextUnsignedInt();
+		reserved = reader.readNextUnsignedInt();
+	}
+
+	public boolean isReadable() {
+		return (object_flags & 0x01) == 0x01;
+	}
+
+	public boolean isWritable() {
+		return (object_flags & 0x02) == 0x02;
+	}
+
+	public boolean isExecutable() {
+		return (object_flags & 0x04) == 0x04;
+	}
+
+	public boolean objectHasPreloadPages() {
+		return (object_flags & 0x40) == 0x40;
+	}
+
+	public String getName() {
+		return isExecutable() ? "cseg" : "dseg";
+	}
+
+	public void setObjectPermissions(MemoryBlock block) {
+		block.setRead(isReadable());
+		block.setWrite(isWritable());
+		block.setExecute(isExecutable());
+	}
+
+	public void appendFixupTable(LXFixupRecordTable fr) {
+		fixups_for_opbject.add(fr);
+	}
+
+	public Iterator<LXFixupRecordTable> fixupTableIterator() {
+		return fixups_for_opbject.iterator();
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LinearExecutable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LinearExecutable.java
deleted file mode 100644
index 9aa17702b3..0000000000
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/lx/LinearExecutable.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/* ###
- * IP: GHIDRA
- * REVIEWED: YES
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *      http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package ghidra.app.util.bin.format.lx;
-
-import ghidra.app.util.bin.ByteProvider;
-import ghidra.util.exception.NotYetImplementedException;
-
-/**
- * A class to manage loading Linear Executables (LX).
- * 
- * NOTE: this is not implemented yet.
- */
-public class LinearExecutable {
-	/**
-	 * The magic number for LX executables.
-	 */
-    public final static short IMAGE_LX_SIGNATURE = 0x584c; //LX
-
-    public LinearExecutable(ByteProvider bp) {
-        throw new NotYetImplementedException();
-    }
-}
-- 
2.45.1

