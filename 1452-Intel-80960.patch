From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: mumbel <22204578+mumbel@users.noreply.github.com>
Date: Sun, 21 Nov 2021 12:49:38 -0600
Subject: [PATCH] 1452: Intel 80960

squash i960

cspec
---
 Ghidra/Processors/i960/Module.manifest        |    0
 Ghidra/Processors/i960/build.gradle           |   27 +
 Ghidra/Processors/i960/certification.manifest |   12 +
 .../Processors/i960/data/languages/i960.cspec |  121 +
 .../Processors/i960/data/languages/i960.ldefs |   29 +
 .../i960/data/languages/i960.opinion          |   16 +
 .../Processors/i960/data/languages/i960.pspec |   43 +
 .../Processors/i960/data/languages/i960.sinc  | 1958 +++++++++++++++++
 .../i960/data/languages/i960.slaspec          |    4 +
 .../i960/data/patterns/i960_patterns.xml      |   50 +
 .../i960/data/patterns/patternconstraints.xml |    5 +
 Ghidra/Processors/i960/scripts/scrape.py      | 1163 ++++++++++
 .../format/elf/extend/I960_ElfExtension.java  |   27 +
 .../I960_ElfRelocationConstants.java          |   27 +
 .../relocation/I960_ElfRelocationHandler.java |  104 +
 .../test/processors/I960_O0_EmulatorTest.java |   39 +
 .../test/processors/I960_O3_EmulatorTest.java |   39 +
 17 files changed, 3664 insertions(+)
 create mode 100644 Ghidra/Processors/i960/Module.manifest
 create mode 100644 Ghidra/Processors/i960/build.gradle
 create mode 100644 Ghidra/Processors/i960/certification.manifest
 create mode 100644 Ghidra/Processors/i960/data/languages/i960.cspec
 create mode 100644 Ghidra/Processors/i960/data/languages/i960.ldefs
 create mode 100644 Ghidra/Processors/i960/data/languages/i960.opinion
 create mode 100644 Ghidra/Processors/i960/data/languages/i960.pspec
 create mode 100644 Ghidra/Processors/i960/data/languages/i960.sinc
 create mode 100644 Ghidra/Processors/i960/data/languages/i960.slaspec
 create mode 100644 Ghidra/Processors/i960/data/patterns/i960_patterns.xml
 create mode 100644 Ghidra/Processors/i960/data/patterns/patternconstraints.xml
 create mode 100644 Ghidra/Processors/i960/scripts/scrape.py
 create mode 100644 Ghidra/Processors/i960/src/main/java/ghidra/app/util/bin/format/elf/extend/I960_ElfExtension.java
 create mode 100644 Ghidra/Processors/i960/src/main/java/ghidra/app/util/bin/format/elf/relocation/I960_ElfRelocationConstants.java
 create mode 100644 Ghidra/Processors/i960/src/main/java/ghidra/app/util/bin/format/elf/relocation/I960_ElfRelocationHandler.java
 create mode 100644 Ghidra/Processors/i960/src/test.processors/java/ghidra/test/processors/I960_O0_EmulatorTest.java
 create mode 100644 Ghidra/Processors/i960/src/test.processors/java/ghidra/test/processors/I960_O3_EmulatorTest.java

diff --git a/Ghidra/Processors/i960/Module.manifest b/Ghidra/Processors/i960/Module.manifest
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/Ghidra/Processors/i960/build.gradle b/Ghidra/Processors/i960/build.gradle
new file mode 100644
index 0000000000..d3daf860b0
--- /dev/null
+++ b/Ghidra/Processors/i960/build.gradle
@@ -0,0 +1,27 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+apply from: "$rootProject.projectDir/gradle/distributableGhidraModule.gradle"
+apply from: "$rootProject.projectDir/gradle/javaProject.gradle"
+apply from: "$rootProject.projectDir/gradle/jacocoProject.gradle"
+apply from: "$rootProject.projectDir/gradle/javaTestProject.gradle"
+apply from: "$rootProject.projectDir/gradle/processorProject.gradle"
+apply plugin: 'eclipse'
+eclipse.project.name = 'Processors i960'
+
+
+dependencies {
+	api project(':Base')
+}
diff --git a/Ghidra/Processors/i960/certification.manifest b/Ghidra/Processors/i960/certification.manifest
new file mode 100644
index 0000000000..dddb98acf4
--- /dev/null
+++ b/Ghidra/Processors/i960/certification.manifest
@@ -0,0 +1,12 @@
+##VERSION: 2.0
+Module.manifest||GHIDRA||||END|
+data/languages/i960.cspec||GHIDRA||||END|
+data/languages/i960.ldefs||GHIDRA||||END|
+data/languages/i960.opinion||GHIDRA||||END|
+data/languages/i960.pspec||GHIDRA||||END|
+data/languages/i960.sinc||GHIDRA||||END|
+data/languages/i960.slaspec||GHIDRA||||END|
+data/patterns/patternconstraints.xml||GHIDRA||||END|
+data/patterns/i960_patterns.xml||GHIDRA||||END|
+scripts/scrape.py||GHIDRA||||END|
+src/main/java/ghidra/app/util/bin/format/elf/extend/I960_ElfExtension.java||GHIDRA||||END|
diff --git a/Ghidra/Processors/i960/data/languages/i960.cspec b/Ghidra/Processors/i960/data/languages/i960.cspec
new file mode 100644
index 0000000000..d0f3510949
--- /dev/null
+++ b/Ghidra/Processors/i960/data/languages/i960.cspec
@@ -0,0 +1,121 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<compiler_spec>
+  <data_organization>
+    <absolute_max_alignment value="0" />
+    <machine_alignment value="8" />
+    <default_alignment value="1" />
+    <default_pointer_alignment value="4" />
+    <pointer_size value="4" />
+    <short_size value="2" />
+    <integer_size value="4" />
+    <long_size value="4" />
+    <long_long_size value="8" />
+    <float_size value="4" />
+    <double_size value="8" />
+    <size_alignment_map>
+      <entry size="1" alignment="1" />
+      <entry size="2" alignment="2" />
+      <entry size="4" alignment="4" />
+      <entry size="8" alignment="4" />
+    </size_alignment_map>
+  </data_organization>
+  <global>
+    <range space="ram"/>
+    <!-- <register name="g0" /> -->
+    <!-- <register name="g1" /> -->
+    <!-- <register name="g2" /> -->
+    <!-- <register name="g3" /> -->
+    <!-- <register name="g4" /> -->
+    <!-- <register name="g5" /> -->
+    <!-- <register name="g6" /> -->
+    <!-- <register name="g7" /> -->
+    <!-- <register name="g8" /> -->
+    <!-- <register name="g9" /> -->
+    <!-- <register name="g10" /> -->
+    <!-- <register name="g11" /> -->
+    <!-- Up to 12 parameters can be passed by value -->
+    <register name="g12" />
+    <register name="g13" />
+    <register name="g14" />
+    <register name="fp" />
+    <register name="pc" />
+    <register name="ac" />
+    <register name="tc" />
+  </global>
+  <returnaddress>
+    <register name="rip"/>
+  </returnaddress>
+  <!-- <stackpointer register="sp" space="ram" growth="positive"/> -->
+  <stackpointer register="sp" space="ram" growth="positive"/>
+  <default_proto>
+    <prototype name="__stdcall" extrapop="0" stackshift="64">
+      <input>
+        <pentry minsize="1" maxsize="4">
+          <register name="g0"/>
+        </pentry>
+        <pentry minsize="1" maxsize="4">
+          <register name="g1"/>
+        </pentry>
+        <pentry minsize="1" maxsize="4">
+          <register name="g2"/>
+        </pentry>
+        <pentry minsize="1" maxsize="4">
+          <register name="g3"/>
+        </pentry>
+        <pentry minsize="1" maxsize="4">
+          <register name="g4"/>
+        </pentry>
+        <pentry minsize="1" maxsize="4">
+          <register name="g5"/>
+        </pentry>
+        <pentry minsize="1" maxsize="4">
+          <register name="g6"/>
+        </pentry>
+        <pentry minsize="1" maxsize="4">
+          <register name="g7"/>
+        </pentry>
+        <pentry minsize="1" maxsize="4">
+          <register name="g8"/>
+        </pentry>
+        <pentry minsize="1" maxsize="4">
+          <register name="g9"/>
+        </pentry>
+        <pentry minsize="1" maxsize="4">
+          <register name="g10"/>
+        </pentry>
+        <pentry minsize="1" maxsize="4">
+          <register name="g11"/>
+        </pentry>
+      </input>
+      <output>
+        <pentry minsize="1" maxsize="4">
+          <register name="g0"/>
+        </pentry>
+        <pentry minsize="5" maxsize="8">
+          <addr space="join" piece1="g1" piece2="g0" />
+        </pentry>
+	<!-- TODO  g2 and g3 -->
+      </output>
+      <unaffected>
+        <register name="fp"/>
+        <register name="pfp"/>
+        <register name="sp"/>
+        <register name="rip"/>
+        <register name="r3"/>
+        <register name="r4"/>
+        <register name="r5"/>
+        <register name="r6"/>
+        <register name="r7"/>
+        <register name="r8"/>
+        <register name="r9"/>
+        <register name="r10"/>
+        <register name="r11"/>
+        <register name="r12"/>
+        <register name="r13"/>
+        <register name="r14"/>
+        <register name="r15"/>
+      </unaffected>
+    </prototype>
+  </default_proto>
+</compiler_spec>
diff --git a/Ghidra/Processors/i960/data/languages/i960.ldefs b/Ghidra/Processors/i960/data/languages/i960.ldefs
new file mode 100644
index 0000000000..ad22b352ec
--- /dev/null
+++ b/Ghidra/Processors/i960/data/languages/i960.ldefs
@@ -0,0 +1,29 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<language_definitions>
+
+  <language processor="i960"
+            endian="little"
+            size="32"
+            variant="default"
+            version="1.2"
+            slafile="i960.sla"
+            processorspec="i960.pspec"
+            id="i960:LE:32:default">
+    <description>i960 80960</description>
+    <compiler name="default" spec="i960.cspec" id="default"/>
+  </language>
+  <language processor="i960"
+            endian="big"
+            instructionEndian="little"
+            size="32"
+            variant="lebe"
+            version="1.2"
+            slafile="i960.sla"
+            processorspec="i960.pspec"
+            id="i960:LEBE:32:lebe">
+    <description>i960 80960 LE instruction and BE data</description>
+    <compiler name="default" spec="i960.cspec" id="default"/>
+  </language>
+
+</language_definitions>
diff --git a/Ghidra/Processors/i960/data/languages/i960.opinion b/Ghidra/Processors/i960/data/languages/i960.opinion
new file mode 100644
index 0000000000..559996c50c
--- /dev/null
+++ b/Ghidra/Processors/i960/data/languages/i960.opinion
@@ -0,0 +1,16 @@
+<opinions>
+    <constraint loader="Executable and Linking Format (ELF)" compilerSpecID="default">
+        <constraint primary="19" processor="i960"  endian="little" />
+    </constraint>
+        <constraint loader="Common Object File Format (COFF)" compilerSpecID="default">
+	<!-- CORE/CORE1 0x1000 -->
+	<!-- KB/SB      0x2000 -->
+	<!-- CA/CX      0x5000 -->
+	<!-- KA/SA      0x6000 -->
+	<!-- JX         0x7000 -->
+	<!-- HX         0x8000 -->
+	<!-- CORE2      0x9000 -->
+        <constraint primary="352" processor="i960"  endian="little" /> <!-- RO text -->
+	<constraint primary="353" processor="i960"  endian="little" /> <!-- RW text -->
+    </constraint>
+</opinions>
diff --git a/Ghidra/Processors/i960/data/languages/i960.pspec b/Ghidra/Processors/i960/data/languages/i960.pspec
new file mode 100644
index 0000000000..d1e44c9015
--- /dev/null
+++ b/Ghidra/Processors/i960/data/languages/i960.pspec
@@ -0,0 +1,43 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<processor_spec>
+  <programcounter register="ip"/>
+
+  <default_symbols>
+    <symbol name="DLMCON" address="ram:0xFF008100" />
+    <symbol name="LMADR0" address="ram:0xFF008108" />
+    <symbol name="LMMR0" address="ram:0xFF00810C" />
+    <symbol name="LMADR1" address="ram:0xFF008110" />
+    <symbol name="LMMR1" address="ram:0xFF008114" />
+    <symbol name="IPB0" address="ram:0xFF008400" />
+    <symbol name="IPB1" address="ram:0xFF008404" />
+    <symbol name="DAB0" address="ram:0xFF008420" />
+    <symbol name="DAB1" address="ram:0xFF008424" />
+    <symbol name="BPCON" address="ram:0xFF008440" />
+    <symbol name="IPND" address="ram:0xFF008500" />
+    <symbol name="IMSK" address="ram:0xFF008504" />
+    <symbol name="ICON" address="ram:0xFF008510" />
+    <symbol name="IMAP0" address="ram:0xFF008520" />
+    <symbol name="IMAP1" address="ram:0xFF008524" />
+    <symbol name="IMAP2" address="ram:0xFF008528" />
+    <symbol name="PMCON0_1" address="ram:0xFF008600" />
+    <symbol name="PMCON2_3" address="ram:0xFF008608" />
+    <symbol name="PMCON4_5" address="ram:0xFF008610" />
+    <symbol name="PMCON6_7" address="ram:0xFF008618" />
+    <symbol name="PMCON8_9" address="ram:0xFF008620" />
+    <symbol name="PMCON10_11" address="ram:0xFF008628" />
+    <symbol name="PMCON12_13" address="ram:0xFF008630" />
+    <symbol name="PMCON14_15" address="ram:0xFF008638" />
+    <symbol name="BCON" address="ram:0xFF0086FC" />
+    <symbol name="PRCB" address="ram:0xFF008700" />
+    <symbol name="ISP" address="ram:0xFF008704" />
+    <symbol name="SSP" address="ram:0xFF008708" />
+    <symbol name="DEVICEID" address="ram:0xFF008710" />
+    <symbol name="TRR0" address="ram:0xFF000300" />
+    <symbol name="TCR0" address="ram:0xFF000304" />
+    <symbol name="TMR0" address="ram:0xFF000308" />
+    <symbol name="TRR1" address="ram:0xFF000310" />
+    <symbol name="TCR1" address="ram:0xFF000314" />
+    <symbol name="TMR1" address="ram:0xFF000318" />
+  </default_symbols>
+</processor_spec>
diff --git a/Ghidra/Processors/i960/data/languages/i960.sinc b/Ghidra/Processors/i960/data/languages/i960.sinc
new file mode 100644
index 0000000000..434ae77b2f
--- /dev/null
+++ b/Ghidra/Processors/i960/data/languages/i960.sinc
@@ -0,0 +1,1958 @@
+# i960 / 80960
+
+define alignment=4;
+
+define space ram type=ram_space size=4 default;
+
+define space register type=register_space size=4;
+
+#TODO  slaspec or context value instead?
+@define SALIGN 4
+
+# Local Registers
+# r0  - pfp - previous frame pointer
+# r1  - sp  - stack pointer
+# r2  - rip - return instruction pointer
+define register offset=0x00 size=4 [ pfp sp rip r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 ];
+
+# Global Registers
+# g15 - fp  - frame pointer
+define register offset=0x40 size=4 [ g0 g1 g2 g3 g4 g5 g6 g7 g8 g9 g10 g11 g12 g13 g14 fp ];
+
+# SF
+define register offset=0x100 size=4 [ sf0 sf1 sf2 sf3 sf4 sf5 sf6 sf7 sf8 sf9 sf10 sf11 sf12 sf13 sf14 sf15 sf16 sf17 sf18 sf19 sf20 sf21 sf22 sf23 sf24 sf25 sf26 sf27 sf28 sf29 sf30 sf31 ];
+
+# 80-bit registers  extended-real format
+define register offset=0x300 size=10 [ fp0 fp1 fp2 fp3 ];
+
+define register offset=0x200 size=4 [ pc ac ip tc ];
+
+
+# PFP return status
+# 000 - local/super call from super, local return
+# 001 - fault call, fault return
+# 011 - super call from user, trace enabled, super return, trace enable, PC=0 mode=0
+# 100 - reserved
+# 101 - reserved
+# 110 - stopped-interrupt call, stopped-interrupt return
+# 111 - interrupt call, interrupt return
+
+
+# PC  Process Controls Register
+# PC [0,1] # Trace-Enable Bit
+# PC [1,1] # Execution-Mode Flag
+# PC [9,1] # Resume
+# PC [10,1] # Trace-Fault-Pending
+# PC [13,1] # State Flag
+# PC [16,5] # Priority Field
+# PC [21,11] # internal state
+
+# AC  Arithmetic Controls Register
+# AC [0,3] # Condition Code Bits
+# AC [3,4] # Arithmetic status
+# AC [8,1] # Integer-Overflow Flag
+# AC [12,1] # Integer Overflow Mask Bit
+# AC [15,1] # No-Imprecise-Faults Bit
+# AC [16,1] # Floating overflow flag
+# AC [17,1] # Floating underflow flag
+# AC [18,1] # Floating invalid-op flag
+# AC [19,1] # Floating zero-divide flag
+# AC [20,1] # Floating inexct flag
+# AC [24,1] # Floating overflow mask
+# AC [25,1] # Floating underflow mask
+# AC [26,1] # Floating invalid-op mask
+# AC [27,1] # Floating zero-divide mask
+# AC [28,1] # Floating inexact mask
+# AC [29,1] # Floating-Point Normalizing Mode
+# AC [30,2] # Floating-Point Rounding Control
+
+# TC Trace-Controls
+# TC[1,1] # instruction trace mode
+# TC[2,1] # branch trace mode
+# TC[3,1] # call trace mode
+# TC[4,1] # return trace mode
+# TC[5,1] # prereturn trace mode
+# TC[6,1] # supervise trace mode
+# TC[7,1] # breakpoint trace mode
+# TC[17,1] # instruction trace event
+# TC[18,1] # branch trace event
+# TC[19,1] # call trace event
+# TC[20,1] # return trace event
+# TC[21,1] # prereturn trace event
+# TC[22,1] # supervisor trace event
+# TC[23,1] # breakpoint trace event
+
+# condition codes
+# 010 true
+# 000 false
+# 000 unordered
+# 001 gt
+# 010 eq
+# 011 gte
+# 100 lt
+# 101 ne
+# 110 lte
+# 111 ordered
+# 01X carry out
+# 0X1 overflow
+
+# arithmetic status, s=sign
+# s000 Zero
+# s001 Denom
+# s010 Normal
+# s011 inf
+# s100 quiet
+# s101 signal
+# s110 resv
+
+
+define token instr (32)
+  op2731=(27,31)
+  op2431=(24,31)
+  op2426=(24,26)
+  op1923=(19,23)
+  freg1923=(19,23)
+  reg1923=(19,23)
+  sfr1923=(19,23)
+  freg1418=(14,18)
+  reg1418=(14,18)
+  sfr1418=(14,18)
+  op1418=(14,18)
+  M1=(13,13)
+  m3=(13,13)
+  m2=(12,12)
+  m1=(11,11)
+  op0710=(7,10)
+  s2=(6,6)
+  s1=(5,5)
+  freg0004=(0,4)
+  reg0004=(0,4)
+  sfr0004=(0,4)
+  op0004=(0,4)
+  sop0212=(2,12) signed
+  t=(1,1)
+  S2=(0,0)
+  sop0223=(2,23) signed
+  op0000=(0,0)
+  mode1213=(12,13)
+  mode1011=(10,11)
+  offset0011=(0,11)
+  op0709=(7,9)
+  op0506=(5,6)
+;
+
+
+define token instr2 (32)
+  sop3263=(0,31) signed
+  op3263=(0,31)
+;
+
+attach variables [ reg0004 reg1418 reg1923 ]
+                 [ pfp sp rip r3 r4 r5 r6 r7 r8 r9 r10 r11 r12 r13 r14 r15 g0 g1 g2 g3 g4 g5 g6 g7 g8 g9 g10 g11 g12 g13 g14 fp ];
+
+attach variables [ sfr0004 sfr1418 sfr1923 ]
+                 [ sf0 sf1 sf2 sf3 sf4 sf5 sf6 sf7 sf8 sf9 sf10 sf11 sf12 sf13 sf14 sf15 sf16 sf17 sf18 sf19 sf20 sf21 sf22 sf23 sf24 sf25 sf26 sf27 sf28 sf29 sf30 sf31 ];
+
+attach variables [ freg0004 freg1418 freg1923 ]
+                 [ fp0 fp1 fp2 fp3 _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ ];
+
+
+macro f_cmp_set_ac(v0, v1) {
+	ac[2,1] = v0 f< v1;
+	ac[1,1] = v0 f== v1;
+	ac[0,1] = v0 f> v1;
+}
+
+macro s_cmp_set_ac(v0, v1) {
+	ac[2,1] = v0 s< v1;
+	ac[1,1] = v0 == v1;
+	ac[0,1] = v0 s> v1;
+}
+
+macro cmp_set_ac(v0, v1) {
+	ac[2,1] = v0 <  v1;
+	ac[1,1] = v0 == v1;
+	ac[0,1] = v0 >  v1;
+}
+
+#TODO  does it make sense to make macros for 4-byte?
+
+macro l_copy_efa_to_reg(sefa, dreg) {
+	*[register]:4 (dreg + 0x0) = *[ram]:4 (sefa + 0x0);
+	*[register]:4 (dreg + 0x4) = *[ram]:4 (sefa + 0x4);
+}
+
+macro t_copy_efa_to_reg(sefa, dreg) {
+	l_copy_efa_to_reg(sefa, dreg);
+	*[register]:4 (dreg + 0x8) = *[ram]:4 (sefa + 0x8);
+}
+
+macro q_copy_efa_to_reg(sefa, dreg) {
+	t_copy_efa_to_reg(sefa, dreg);
+	*[register]:4 (dreg + 0xc) = *[ram]:4 (sefa + 0xc);
+}
+
+macro l_copy_reg_to_efa(sreg, defa) {
+	*[ram]:4 (defa + 0x0) = *[register]:4 (sreg + 0x0);
+	*[ram]:4 (defa + 0x4) = *[register]:4 (sreg + 0x4);
+}
+
+macro t_copy_reg_to_efa(sreg, defa) {
+	l_copy_reg_to_efa(sreg, defa);
+	*[ram]:4 (defa + 0x8) = *[register]:4 (sreg + 0x8);
+}
+
+macro q_copy_reg_to_efa(sreg, defa) {
+	t_copy_reg_to_efa(sreg, defa);
+	*[ram]:4 (defa + 0xc) = *[register]:4 (sreg + 0xc);
+}
+
+macro l_copy_reg_to_reg(sreg, dreg) {
+	*[register]:4 (dreg + 0x0) = *[register]:4 (sreg + 0x0);
+	*[register]:4 (dreg + 0x4) = *[register]:4 (sreg + 0x4);
+}
+
+macro t_copy_reg_to_reg(sreg, dreg) {
+	l_copy_reg_to_reg(sreg, dreg);
+	*[register]:4 (dreg + 0x8) = *[register]:4 (sreg + 0x8);
+}
+
+macro q_copy_reg_to_reg(sreg, dreg) {
+	t_copy_reg_to_reg(sreg, dreg);
+	*[register]:4 (dreg + 0xc) = *[register]:4 (sreg + 0xc);
+}
+
+macro l_copy_efa_to_efa(sefa, defa) {
+	*[ram]:4 (defa + 0x0) = *[ram]:4 (sefa + 0x0);
+	*[ram]:4 (defa + 0x4) = *[ram]:4 (sefa + 0x4);
+}
+
+macro t_copy_efa_to_efa(sefa, defa) {
+	l_copy_efa_to_efa(sefa, defa);
+	*[ram]:4 (defa + 0x8) = *[ram]:4 (sefa + 0x8);
+}
+
+macro q_copy_efa_to_efa(sefa, defa) {
+	t_copy_efa_to_efa(sefa, defa);
+	*[ram]:4 (defa + 0xc) = *[ram]:4 (sefa + 0xc);
+}
+
+macro l_copy_lit_to_reg(slit, dreg) {
+	*[register]:4 (dreg + 0x0) = slit[0,32];
+	*[register]:4 (dreg + 0x4) = slit[32,32];
+}
+
+macro t_copy_lit_to_reg(slit, dreg) {
+	l_copy_lit_to_reg(slit, dreg);
+	*[register]:4 (dreg + 0x8) = slit[64,32];
+}
+
+macro q_copy_lit_to_reg(slit, dreg) {
+	t_copy_lit_to_reg(slit, dreg);
+	*[register]:4 (dreg + 0xc) = slit[96,32];
+}
+
+macro l_copy_reg_to_lit(sreg, dlit) {
+	dlit = zext(*[register]:4 (sreg + 0x0));
+	dlit = dlit | zext((*[register]:4 (sreg + 0x0)) << 32);
+}
+
+macro t_copy_reg_to_lit(sreg, dlit) {
+	l_copy_reg_to_lit(sreg, dlit);
+	dlit = dlit | zext((*[register]:4 (sreg + 0x0)) << 64);
+}
+
+macro q_copy_reg_to_lit(sreg, dlit) {
+	t_copy_reg_to_lit(sreg, dlit);
+	dlit = dlit | zext((*[register]:4 (sreg + 0x0)) << 96);
+}
+
+
+
+regS1:  op0004  is op0004  & m1=1 & s1=0 { local tmp:4 = op0004; export tmp; }
+regS1:  reg0004 is reg0004 & m1=0 & s1=0 { export reg0004; }
+regS1:  sfr0004 is sfr0004 & m1=0 & s1=1 { export sfr0004; }
+
+regS2:  op1418  is op1418  & m2=1 & s2=0 { local tmp:4 = op1418; export tmp; }
+regS2:  reg1418 is reg1418 & m2=0 & s2=0 { export reg1418; }
+regS2:  sfr1418 is sfr1418 & m2=0 & s2=1 { export sfr1418; }
+
+regS2l: op1418  is op1418  & m2=1 & s2=0 { local tmp:8 = op1418; export tmp; }
+regS2l: reg1418 is reg1418 & m2=0 & s2=0 { local tmp:4 = &reg1418; export *[register]:8 tmp; }
+regS2l: sfr1418 is sfr1418 & m2=0 & s2=1 { local tmp:4 = &sfr1418; export *[register]:8 tmp; }
+
+regSD:  reg1923 is reg1923 & m3=0 { export reg1923; }
+#TODO  This looks awful to handle
+# regSDl: reg1923 is reg1923 & m3=0 { local tmp:4 = &reg1923; export *[register]:8 tmp; }
+# regSDq: reg1923 is reg1923 & m3=0 { local tmp:4 = &reg1923; export *[register]:12 tmp; }
+
+#SEE  Encoding of Src1 and Src2 Fields in REG Format
+#     Same encoding is used for COBR
+#TODO The FP encoding still looks off and probably needs the same table look ups
+#     as fregS1
+cobrS1: reg1923 is reg1923 & M1=0 & S2=0 { export reg1923; }
+cobrS2: reg1418 is reg1418 & M1=0 & S2=0 { export reg1418; }
+cobrSD: reg1923 is reg1923 & M1=0 & S2=0 { export reg1923; }
+
+cobrS1: op1923  is op1923  & M1=1 & S2=0 { local tmp:4 = op1923; export tmp; }
+cobrS2: reg1418 is reg1418 & M1=1 & S2=0 { export reg1418; }
+
+cobrS1: sfr1923 is sfr1923 & M1=0 & S2=1 { export sfr1923; }
+cobrS2: sfr1418 is sfr1418 & M1=0 & S2=1 { export sfr1418; }
+#TODO  not sure if this can happend
+cobrSD: sfr1923 is sfr1923 & M1=0 & S2=1 { export sfr1923; }
+
+cobrS1: op1923  is op1923  & M1=1 & S2=1 & t=0 { local tmp:4 = op1923; export tmp; }
+cobrS2: sfr1418 is sfr1418 & M1=1 & S2=1 & t=0 { export sfr1418; }
+
+
+# reals: 1 reg (Real), 2 regs (Long Real), or 3 regs (Extended Real)
+
+#TODO  int2float is not correct, maybe float2float?
+fregS1:  reg0004 is  reg0004 & m1=0 & s1=0 { local tmp:10 = int2float(reg0004); export tmp; }
+fregS1: freg0004 is freg0004 & m1=1 & s1=0 & op0004 < 4 { local tmp:10 = freg0004; export tmp; }
+fregS1: "+0.0" is m1=1 & s1=0 & op0004=0x10 { local tmp:10 = int2float(0:1); export tmp; }
+fregS1: "+1.0" is m1=1 & s1=0 & op0004=0x16 { local tmp:10 = int2float(1:1); export tmp; }
+fregS1l:  reg0004 is  reg0004 & m1=0 & s1=0 { local reg:4 = &reg0004; local val:8 = *[register]:8 reg; local tmp:10 = int2float(val); export tmp; }
+fregS1l: freg0004 is freg0004 & m1=1 & s1=0 & op0004 < 4 { local tmp:10 = freg0004; export tmp; }
+fregS1l: "+0.0" is m1=1 & s1=0 & op0004=0x10 { local tmp:10 = int2float(0:1); export tmp; }
+fregS1l: "+1.0" is m1=1 & s1=0 & op0004=0x16 { local tmp:10 = int2float(1:1); export tmp; }
+fregS1e:  reg0004 is  reg0004 & m1=0 & s1=0 { local reg:4 = &reg0004; local val:12 = *[register]:12 reg; local tmp:10 = int2float(val); export tmp; }
+fregS1e: freg0004 is freg0004 & m1=1 & s1=0 & op0004 < 4 { local tmp:10 = freg0004; export tmp; }
+fregS1e: "+0.0" is m1=1 & s1=0 & op0004=0x10 { local tmp:10 = int2float(0:1); export tmp; }
+fregS1e: "+1.0" is m1=1 & s1=0 & op0004=0x16 { local tmp:10 = int2float(1:1); export tmp; }
+
+
+fregS2:  reg1418 is  reg1418 & m2=0 & s2=0 { local tmp:10 = int2float(reg1418); export tmp; }
+fregS2: freg1418 is freg1418 & m2=1 & s2=0 & op1418 < 4 { local tmp:10 = freg1418; export tmp; }
+fregS2: "+0.0" is m2=1 & s2=0 & op1418=0x10 { local tmp:10 = int2float(0:1); export tmp; }
+fregS2: "+1.0" is m2=1 & s2=0 & op1418=0x16 { local tmp:10 = int2float(1:1); export tmp; }
+fregS2l:  reg1418 is  reg1418 & m2=0 & s2=0 { local reg:4 = &reg1418; local val:8 = *[register]:8 reg; local tmp:10 = int2float(val); export tmp; }
+fregS2l: freg1418 is freg1418 & m2=1 & s2=0 & op1418 < 4 { local tmp:10 = freg1418; export tmp; }
+fregS2l: "+0.0" is m2=1 & s2=0 & op1418=0x10 { local tmp:10 = int2float(0:1); export tmp; }
+fregS2l: "+1.0" is m2=1 & s2=0 & op1418=0x16 { local tmp:10 = int2float(1:1); export tmp; }
+fregS2e:  reg1418 is  reg1418 & m2=0 & s2=0 { local reg:4 = &reg1418; local val:12 = *[register]:12 reg; local tmp:10 = int2float(val); export tmp; }
+fregS2e: freg1418 is freg1418 & m2=1 & s2=0 & op1418 < 4 { local tmp:10 = freg1418; export tmp; }
+fregS2e: "+0.0" is m2=1 & s2=0 & op1418=0x10 { local tmp:10 = int2float(0:1); export tmp; }
+fregS2e: "+1.0" is m2=1 & s2=0 & op1418=0x16 { local tmp:10 = int2float(1:1); export tmp; }
+
+#TODO  This looks awful to handle
+fregSD:  reg1923 is  reg1923 & m3=0 { local tmp:4 = &reg1923; export *[register]:10 tmp; }
+fregSD: freg1923 is freg1923 & m3=1 & op1923 < 4 { export freg1923; }
+
+fregSDl:  reg1923 is  reg1923 & m3=0 { local tmp:10 = int2float(reg1923); export tmp; }
+fregSDl: freg1923 is freg1923 & m3=1 & op1923 < 4 { local tmp:10 = freg1923; export tmp; }
+
+fregSDe:  reg1923 is  reg1923 & m3=0 { local tmp:10 = int2float(reg1923); export tmp; }
+fregSDe: freg1923 is freg1923 & m3=1 & op1923 < 4 { local tmp:10 = freg1923; export tmp; }
+
+
+scale: imm is (op0709=0|op0709=1|op0709=2|op0709=3|op0709=4) & op0709 [ imm = 1 << op0709; ] { export *[const]:4 imm; }
+
+efa: offset0011 is offset0011 & mode1213=0 { local tmp:4 = offset0011; export tmp;}
+efa: op3263 is mode1213=3 & mode1011=0 & op0506=0 ; op3263 { local tmp:4 = op3263; export tmp; }
+
+efa: offset0011 (reg1418) is offset0011 & reg1418 & mode1213=2 { local tmp:4 = reg1418 + offset0011; export tmp; }
+efa: (reg1418) is reg1418 & mode1213=1 & mode1011=0 & op0506=0 { local tmp:4 = reg1418; export tmp; }
+efa: reloc (ip) is ip & mode1213=1 & mode1011=1 & op0506=0 ; sop3263 [ reloc = sop3263 + 8; ] { local tmp:4 = reloc + inst_start; export tmp; }
+efa: (reg1418) [reg0004 * scale] is scale & reg0004 & reg1418  & mode1213=1 & mode1011=3 & op0506=0 { local tmp:4 = (scale * reg0004) + reg1418; export tmp; }
+efa: sop3263 (reg1418) is reg1418 & mode1213=3 & mode1011=1 & op0506=0 ; sop3263 { local tmp:4 = sop3263 + reg1418; export tmp; }
+efa: sop3263 [reg0004 * scale] is reg0004 & scale & mode1213=3 & mode1011=2 & op0506=0 ; sop3263 { local tmp:4 = sop3263 + (reg0004 * scale); export tmp; }
+efa: sop3263 (reg1418) [reg0004 * scale] is reg1418 & reg0004 & scale & mode1213=3 & mode1011=3 & op0506=0 ; sop3263 { local tmp:4 = sop3263 + reg1418 + (reg0004 * scale); export tmp; }
+
+
+
+disp0212: reloc is sop0212 [ reloc = ((sop0212 << 2) + inst_start) & 0xfffffffc; ] { export *[ram]:4 reloc; }
+
+disp0223: reloc is sop0223 [ reloc = ((sop0223 << 2) + inst_start) & 0xfffffffc; ] { export *[ram]:4 reloc; }
+
+# conditions
+cc: "no" is op2426=0 { local tmp:1 = 0; export tmp; }
+cc: "g"  is op2426=1 { local tmp:1 = (ac[0,1] == 1); export tmp; }
+cc: "e"  is op2426=2 { local tmp:1 = (ac[1,1] == 1); export tmp; }
+cc: "ge" is op2426=3 { local tmp:1 = ((ac[0,1] | ac[1,1]) == 1); export tmp; }
+cc: "l"  is op2426=4 { local tmp:1 = (ac[2,1] == 1); export tmp; }
+cc: "ne" is op2426=5 { local tmp:1 = ((ac[0,1] | ac[2,1]) == 1); export tmp; }
+cc: "le" is op2426=6 { local tmp:1 = ((ac[1,1] | ac[2,1]) == 1); export tmp; }
+cc: "o"  is op2426=7 { local tmp:1 = 1; export tmp; }
+
+
+define pcodeop atan;
+define pcodeop cos;
+define pcodeop sin;
+define pcodeop tan;
+define pcodeop log2;
+define pcodeop flushreg;
+define pcodeop syscall;
+define pcodeop syncf;
+define pcodeop scanbit;
+define pcodeop spanbit;
+define pcodeop send;
+define pcodeop fault;
+
+# addc
+:addc regS1, regS2, regSD is op2431=0x5b & op0710=0x0 & regS1 & regS2 & regSD
+{
+	local tmp:5 = zext(regS1) + zext(regS2) + zext(ac[1,1]);
+	ac[0,3] = 0;
+	ac[0,1] = (regS1[31,1] == regS2[31,1]) & (regS2[31,1] != tmp[31,1]);
+	ac[1,1] = tmp[32,1];
+	regSD = tmp:4;
+}
+
+
+# addi
+:addi regS1, regS2, regSD is op2431=0x59 & op0710=0x1 & regS1 & regS2 & regSD
+{
+	ac[8,1] = scarry(regS1, regS2);
+	regSD = regS1 + regS2;
+}
+
+
+# addino      op2431=0x78
+# addig       op2431=0x79
+# addie       op2431=0x7a
+# addige      op2431=0x7b
+# addil       op2431=0x7c
+# addine      op2431=0x7d
+# addile      op2431=0x7e
+# addio       op2431=0x7f
+:addi^cc regS1, regS2, regSD is op2731=0b01111 & cc & op0710=0x1 & regS1 & regS2 & regSD
+{
+	if (!cc) goto inst_next;
+	ac[8,1] = scarry(regS1, regS2);
+	regSD = regS1 + regS2;
+}
+
+
+# addo
+:addo regS1, regS2, regSD is op2431=0x59 & op0710=0x0 & regS1 & regS2 & regSD
+{
+	regSD = regS1 + regS2;
+}
+
+
+# addono      op2431=0x78
+# addog       op2431=0x79
+# addoe       op2431=0x7a
+# addoge      op2431=0x7b
+# addol       op2431=0x7c
+# addone      op2431=0x7d
+# addole      op2431=0x7e
+# addoo       op2431=0x7f
+:addo^cc regS1, regS2, regSD is op2731=0b01111 & cc & op0710=0x0 & regS1 & regS2 & regSD
+{
+	if (!cc) goto inst_next;
+	regSD = regS1 + regS2;
+}
+
+
+# addr
+:addr fregS1, fregS2, fregSD is op2431=0x78 & op0710=0xf & fregS1 & fregS2 & fregSD
+{
+	fregSD = fregS1 f+ fregS2;
+}
+
+
+# addrl  8,8,8
+:addrl fregS1l, fregS2l, fregSDl is op2431=0x79 & op0710=0xf & fregS1l & fregS2l & fregSDl
+{
+	fregSDl = fregS1l f+ fregS2l;
+}
+
+
+# alterbit
+:alterbit regS1, regS2, regSD is op2431=0x58 & op0710=0xf & regS1 & regS2 & regSD
+{
+	local bitpos = 1 << regS1;
+	local tmp0:4 = regS2 & ~bitpos;
+	local tmp1:4 = regS2 | bitpos;
+	regSD = tmp1;
+	if (ac[1,1]) goto inst_next;
+	regSD = tmp0;
+}
+
+
+# and
+:and regS1, regS2, regSD is op2431=0x58 & op0710=0x1 & regS1 & regS2 & regSD
+{
+	regSD = regS2 & regS1;
+}
+
+
+# andnot
+:andnot regS1, regS2, regSD is op2431=0x58 & op0710=0x2 & regS1 & regS2 & regSD
+{
+	regSD = regS2 & ~regS1;
+}
+
+
+# atadd
+:atadd regS1, regS2, regSD is op2431=0x61 & op0710=0x2 & regS1 & regS2 & regSD
+{
+	local addr:4 = regS1 & 0xfffffffc;
+	local tmp:4 = *[ram]:4 addr;
+	*[ram]:4 addr = (tmp + regS2);
+	regSD = tmp;
+}
+
+
+# atanr
+:atanr fregS1, fregS2, fregSD is op2431=0x68 & op0710=0x0 & fregS1 & fregS2 & fregSD
+{
+	local tmp:10 = fregS2 f/ fregS1;
+	fregSD = atan(tmp);
+}
+
+
+# atanrl  8,8,8
+:atanrl fregS1l, fregS2l, fregSDl is op2431=0x69 & op0710=0x0 & fregS1l & fregS2l & fregSDl
+{
+	local tmp:10 = fregS2l f/ fregS1l;
+	fregSDl = atan(tmp);
+}
+
+
+# atmod
+:atmod regS1, regS2, regSD is op2431=0x61 & op0710=0x0 & regS1 & regS2 & regSD
+{
+	local addr = regS1 & 0xfffffffc;
+	local tmp:4 = *[ram]:4 addr;
+	*[ram]:4 addr = (tmp & ~regS2) | (regSD & regS2);
+	regSD = tmp;
+}
+
+
+# b
+:b disp0223 is op2431=0x8 & op0000=0x0 & disp0223
+{
+	goto disp0223;
+}
+
+
+# bal
+:bal disp0223 is op2431=0xb & op0000=0x0 & disp0223
+{
+	g14 = inst_next;
+	goto disp0223;
+}
+
+
+# balx
+:balx efa, reg1923 is ( op2431=0x85 & reg1923 ) ... & efa
+{
+	local ea:4 = efa;
+	reg1923 = inst_next;
+	goto [ea];
+}
+
+
+# bbc
+:bbc cobrS1, cobrS2, disp0212 is op2431=0x30 & cobrS1 & cobrS2 & disp0212
+{
+	ac[0,3] = 2;
+	if (((1<<cobrS1) & cobrS2) != 0) goto disp0212;
+	ac[1,1] = 0;
+}
+
+
+# bbs
+:bbs cobrS1, cobrS2, disp0212 is op2431=0x37 & cobrS1 & cobrS2 & disp0212
+{
+	ac[0,3] = 2;
+	if (((1<<cobrS1) & cobrS2) == 0) goto disp0212;
+	ac[1,1] = 0;
+}
+
+
+# bno      op2431=0x10
+# bg       op2431=0x11
+# be       op2431=0x12
+# bge      op2431=0x13
+# bl       op2431=0x14
+# bne      op2431=0x15
+# ble      op2431=0x16
+# bo       op2431=0x17
+:b^cc disp0223 is op2731=0b00010 & cc & op0000=0x0 & disp0223
+{
+	if (cc) goto disp0223;
+}
+
+
+# bswap
+:bswap regS1, regSD is op2431=0x5a & op0710=0xd & regS1 & regSD
+{
+	local tmp:4 = regS1;
+	regSD = ((tmp & 0xff) << 24) | ((tmp & 0xff00) << 8) | ((tmp & 0xff0000) >> 8) | ((tmp & 0xff000000) >> 24);
+}
+
+
+# bx
+:bx efa is ( op2431=0x84 ) ... & efa
+{
+	goto [efa];
+}
+
+# Local Call Operation  ( call or callx )
+# 1. Stores the RIP in current local-register r2.
+# 2. Allocates a new set of local registers for the called procedure.
+# 3. Allocates a new frame on the procedure stack.
+# 4. Changes the instruction pointer to point to the first instruction in the called procedure.
+# 5. Stores the PFP in new local-register rOo
+# 6. Stores the FP for the new frame in global register g15.
+# 7. Allocates a save area for the new local registers in the new stack frame.
+# 8. Stores the SP in new local-register r1
+
+# Local Return Operation
+# 1. Sets the FP in global register g15 to the value of the PFP in current local-register rOo
+# 2. Deallocates the current local registers for the procedure that initiated the return and
+#    switches to the local registers assigned to the procedure being returned to.
+# 3. Deallocates the stack frame for the procedure that initiated the return.
+# 4. Sets the IP to the value of the RIP in new local~register r2.
+
+macro alloc_register_set() {
+	local regtmp = &pfp;
+	local alignfp = fp & 0xffffffc0;
+	*[ram]:0x40 alignfp = *[register]:0x40 regtmp;
+}
+
+macro dealloc_register_set() {
+	local regtmp = &pfp;
+	local alignfp = fp & 0xffffffc0;
+	*[register]:0x40 regtmp = *[ram]:0x40 alignfp;
+}
+
+
+# call
+:call disp0223 is op2431=0x9 & op0000=0x0 & disp0223
+{
+	local temp:4 = (sp + ($(SALIGN) * 16 - 1)) & ~($(SALIGN) * 16 - 1);
+	rip = inst_next;
+	alloc_register_set();
+	ip = disp0223;
+	pfp = fp;
+	fp = temp;
+	sp = temp + 64;
+	call disp0223;
+}
+
+
+# calls
+:calls regS1 is op2431=0x66 & op0710=0x0 & regS1
+{
+	#TODO  impl
+	syscall(regS1);
+}
+
+
+# callx
+:callx efa is ( op2431=0x86 ) ... & efa
+{
+	local temp:4 = (sp + ($(SALIGN) * 16 - 1)) & ~($(SALIGN) * 16 - 1);
+	local targ:4 = efa;
+	rip = inst_next;
+	alloc_register_set();
+	ip = targ;
+	pfp = fp;
+	fp = temp;
+	sp = temp + 64;
+	call [targ];
+}
+
+
+# chkbit
+:chkbit regS1, regS2 is op2431=0x5a & op0710=0xe & regS1 & regS2
+{
+	ac[0,3] = 0;
+	ac[1,1] = 0 != (regS2 & (1 << regS1));
+}
+
+
+# arithmetic-status bits 3 to 6
+# s -sign
+# classr
+:classr fregS1 is op2431=0x68 & op0710=0xf & fregS1 unimpl
+
+
+# classrl  8
+:classrl fregS1l is op2431=0x69 & op0710=0xf & fregS1l unimpl
+
+
+# clrbit
+:clrbit regS1, regS2, regSD is op2431=0x58 & op0710=0xc & regS1 & regS2 & regSD
+{
+	regSD = regS2 & ~(1 << regS1);
+}
+
+
+# cmpdeci
+:cmpdeci regS1, regS2, regSD is op2431=0x5a & op0710=0x7 & regS1 & regS2 & regSD
+{
+	s_cmp_set_ac(regS1, regS2);
+	regSD = regS2 - 1;
+}
+
+
+# cmpdeco
+:cmpdeco regS1, regS2, regSD is op2431=0x5a & op0710=0x6 & regS1 & regS2 & regSD
+{
+	cmp_set_ac(regS1, regS2);
+	regSD = regS2 - 1;
+}
+
+
+# cmpi
+:cmpi regS1, regS2 is op2431=0x5a & op0710=0x1 & regS1 & regS2
+{
+	s_cmp_set_ac(regS1, regS2);
+}
+
+
+# cmpib
+:cmpib regS1, regS2 is op2431=0x59 & op0710=0x5 & regS1 & regS2
+{
+	s_cmp_set_ac(regS1:1, regS2:1);
+}
+
+
+# cmpibno      op2431=0x38
+# cmpibg       op2431=0x39
+# cmpibe       op2431=0x3a
+# cmpibge      op2431=0x3b
+# cmpibl       op2431=0x3c
+# cmpibne      op2431=0x3d
+# cmpible      op2431=0x3e
+# cmpibo       op2431=0x3f
+:cmpib^cc cobrS1, cobrS2, disp0212 is op2731=0b00111 & cc & cobrS1 & cobrS2 & disp0212
+{
+	s_cmp_set_ac(cobrS1, cobrS2);
+	build cc;
+	if (cc) goto disp0212;
+}
+
+
+# cmpinci
+:cmpinci regS1, regS2, regSD is op2431=0x5a & op0710=0x5 & regS1 & regS2 & regSD
+{
+	s_cmp_set_ac(regS1, regS2);
+	regSD = regS2 + 1;
+}
+
+
+# cmpinco
+:cmpinco regS1, regS2, regSD is op2431=0x5a & op0710=0x4 & regS1 & regS2 & regSD
+{
+	cmp_set_ac(regS1, regS2);
+	regSD = regS2 + 1;
+}
+
+
+# cmpis
+:cmpis regS1, regS2 is op2431=0x59 & op0710=0x7 & regS1 & regS2
+{
+	s_cmp_set_ac(regS1:2, regS2:2);
+}
+
+
+# cmpo
+:cmpo regS1, regS2 is op2431=0x5a & op0710=0x0 & regS1 & regS2
+{
+	cmp_set_ac(regS1, regS2);
+}
+
+
+# cmpob
+:cmpob regS1, regS2 is op2431=0x59 & op0710=0x4 & regS1 & regS2
+{
+	cmp_set_ac(regS1:1, regS2:1);
+}
+
+
+# cmpobno      op2431=0x30
+# cmpobg       op2431=0x31
+# cmpobe       op2431=0x32
+# cmpobge      op2431=0x33
+# cmpobl       op2431=0x34
+# cmpobne      op2431=0x35
+# cmpoble      op2431=0x36
+# cmpobo       op2431=0x37
+:cmpob^cc cobrS1, cobrS2, disp0212 is op2731=0b00110 & cc & cobrS1 & cobrS2 & disp0212
+{
+	cmp_set_ac(cobrS1, cobrS2);
+	build cc;
+	if (cc) goto disp0212;
+}
+
+
+# cmpor
+:cmpor fregS1, fregS2 is op2431=0x68 & op0710=0x4 & fregS1 & fregS2
+{
+	ac[0,3] = 0;
+	if (nan(fregS1) || nan(fregS2)) goto inst_next;
+	f_cmp_set_ac(fregS1, fregS2);
+}
+
+
+# cmporl  8,8
+:cmporl fregS1l, fregS2l is op2431=0x69 & op0710=0x4 & fregS1l & fregS2l
+{
+	ac[0,3] = 0;
+	if (nan(fregS1l) || nan(fregS2l)) goto inst_next;
+	f_cmp_set_ac(fregS1l, fregS2l);
+}
+
+
+# cmpos
+:cmpos regS1, regS2 is op2431=0x59 & op0710=0x6 & regS1 & regS2
+{
+	s_cmp_set_ac(regS1:2, regS2:2);
+}
+
+
+# cmpr
+:cmpr fregS1, fregS2 is op2431=0x68 & op0710=0x5 & fregS1 & fregS2
+{
+	#TODO  figure out the difference between cmpor
+	ac[0,3] = 0;
+	if (nan(fregS1) || nan(fregS2)) goto inst_next;
+	f_cmp_set_ac(fregS1, fregS2);
+}
+
+
+# cmprl  8,8
+:cmprl fregS1l, fregS2l is op2431=0x69 & op0710=0x5 & fregS1l & fregS2l
+{
+	#TODO  figure out the difference between cmpor
+	ac[0,3] = 0;
+	if (nan(fregS1l) || nan(fregS2l)) goto inst_next;
+	f_cmp_set_ac(fregS1l, fregS2l);
+}
+
+
+# cmpstr
+:cmpstr regS1, regS2, regSD is op2431=0x60 & op0710=0x3 & regS1 & regS2 & regSD
+{
+	local length:4 = regSD;
+	local pos:4 = 0;
+	ac[0,3] = 2;
+    <next_byte>
+	if (length == pos) goto inst_next;
+	pos = pos + 1;
+	local tmpA:1 = *[ram]:1 (regS1 + pos);
+	local tmpB:1 = *[ram]:1 (regS2 + pos);
+	if (tmpA == tmpB) goto <next_byte>;
+	ac[0,1] = tmpA > tmpB;
+	ac[2,1] = tmpA < tmpB;
+}
+
+
+# concmpi
+:concmpi regS1, regS2 is op2431=0x5a & op0710=0x3 & regS1 & regS2
+{
+	if (ac[2,1]) goto inst_next;
+	ac[2,1] = 0;
+	ac[1,1] = regS1 s<= regS2;
+	ac[0,1] = regS1 s> regS2;
+}
+
+
+# concmpo
+:concmpo regS1, regS2 is op2431=0x5a & op0710=0x2 & regS1 & regS2
+{
+	if (ac[2,1]) goto inst_next;
+	ac[2,1] = 0;
+	ac[1,1] = regS1 <= regS2;
+	ac[0,1] = regS1 > regS2;
+}
+
+
+# condrec
+:condrec regS1, regSD is op2431=0x64 & op0710=0x6 & regS1 & regSD unimpl
+
+
+# condwait
+:condwait regS1 is op2431=0x66 & op0710=0x8 & regS1 unimpl
+
+
+# cosr
+:cosr fregS1, fregSD is op2431=0x68 & op0710=0xd & fregS1 & fregSD
+{
+	fregSD = cos(fregS1);
+}
+
+
+# cosrl  8,8
+:cosrl fregS1l, fregSDl is op2431=0x69 & op0710=0xd & fregS1l & fregSDl
+{
+	fregSDl = cos(fregS1l);
+}
+
+
+# cpyrsre
+:cpyrsre fregS1e, fregS2e, fregSDe is op2431=0x6e & op0710=0x3 & fregS1e & fregS2e & fregSDe
+{
+	local tmp = fregS2e;
+	fregSDe = abs(fregS1e);
+	if (tmp f< 0) goto inst_next;
+	fregSDe = f- fregSDe;
+}
+
+
+# cpysre
+:cpysre fregS1e, fregS2e, fregSDe is op2431=0x6e & op0710=0x2 & fregS1e & fregS2e & fregSDe
+{
+	local tmp = fregS2e;
+	fregSDe = abs(fregS1e);
+	if (tmp f> 0) goto inst_next;
+	fregSDe = f- fregSDe;
+}
+
+
+# cvtadr  4,8
+:cvtadr regS1, regSD is op2431=0x67 & op0710=0x2 & regS1 & regSD unimpl
+
+
+# cvtilr
+:cvtilr regS1, fregSDl is op2431=0x67 & op0710=0x5 & regS1 & fregSDl & m1=0
+{
+	local tmp:8 = 0;
+	l_copy_reg_to_lit(regS1, tmp);
+	fregSDl = int2float(tmp);
+}
+:cvtilr op0004, fregSDl is op2431=0x67 & op0710=0x5 & op0004 & fregSDl & m1=1
+{
+	local tmp:8 = op0004;
+	fregSDl = int2float(tmp);
+}
+
+
+# cvtir
+:cvtir regS1, fregSD is op2431=0x67 & op0710=0x4 & regS1 & fregSD
+{
+	fregSD = int2float(regS1);
+}
+
+
+# cvtri
+:cvtri fregS1, regSD is op2431=0x6c & op0710=0x0 & fregS1 & regSD
+{
+	#TODO  rounding
+	#TODO  same sizes
+	local tmp:10 = floor(fregS1);
+	regSD = tmp:4;
+}
+
+
+# cvtril  4,8
+:cvtril fregS1l, regSD is op2431=0x6c & op0710=0x1 & fregS1l & regSD
+{
+	#TODO  rounding
+	#TODO  same sizes
+	local tmp:10 = floor(fregS1l);
+	regSD = tmp:4;
+}
+
+# cvtzri
+:cvtzri fregS1, regSD is op2431=0x6c & op0710=0x2 & fregS1 & regSD
+{
+	regSD = trunc(fregS1);
+}
+
+
+# cvtzril  4,8
+:cvtzril fregS1l, regSD is op2431=0x6c & op0710=0x3 & fregS1l & regSD
+{
+	regSD = trunc(fregS1l);
+}
+
+
+# daddc
+:daddc regS1, regS2, regSD is op2431=0x64 & op0710=0x2 & regS1 & regS2 & regSD
+{
+	local tmp:4 = (0xf & regS1) + (0xf & regS2) + zext(ac[1,1]);
+	regSD = (0xfffffff0 & regS2) | (0xf & tmp);
+	ac[2,1] = 0;
+	ac[1,1] = tmp[4,1];
+	ac[0,1] = 0;
+}
+
+
+# dcctl
+:dcctl regS1, regS2, regSD is op2431=0x65 & op0710=0xc & regS1 & regS2 & regSD unimpl
+
+
+# dcinva  1
+:dcinva efa is ( op2431=0xac ) ... & efa unimpl
+
+
+# divi
+:divi regS1, regS2, regSD is op2431=0x74 & op0710=0xb & regS1 & regS2 & regSD
+{
+	#TODO  flags
+	regSD = regS2 s/ regS1;
+}
+
+
+# divo
+:divo regS1, regS2, regSD is op2431=0x70 & op0710=0xb & regS1 & regS2 & regSD
+{
+	regSD = regS2 / regS1;
+}
+
+
+# divr
+:divr fregS1, fregS2, fregSD is op2431=0x78 & op0710=0xb & fregS1 & fregS2 & fregSD
+{
+	fregSD = fregS2 f/ fregS1;
+}
+
+
+# divrl  8,8,8
+:divrl fregS1l, fregS2l, fregSDl is op2431=0x79 & op0710=0xb & fregS1l & fregS2l & fregSDl
+{
+	fregSDl = fregS2l f/ fregS1l;
+}
+
+
+# dmovt
+:dmovt regS1, regSD is op2431=0x64 & op0710=0x4 & regS1 & regSD
+{
+	regSD = regS1;
+	ac[2,1] = 0;
+	ac[1,1] = (regSD[0,8] < 0x30 && regSD[0,8] > 0x39);
+	ac[0,1] = 0;
+}
+
+
+# dsubc
+:dsubc regS1, regS2, regSD is op2431=0x64 & op0710=0x3 & regS1 & regS2 & regSD
+{
+	local tmp:4 = (0xf & regS2) - (0xf & regS1) - 1 + zext(ac[1,1]);
+	regSD = (0xfffffff0 & regS2) | (0xf & tmp);
+	ac[2,1] = 0;
+	ac[1,1] = tmp[31,1];
+	ac[0,1] = 0;
+}
+
+
+# ediv  4,8,4
+:ediv regS1, regS2l, regSD is op2431=0x67 & op0710=0x1 & regS1 & regS2l & regSD
+{
+	local dividend:8 = regS2l;
+	local divisor:8 = zext(regS1);
+	local remainder:8 = dividend % divisor;
+	local quotient:8 = dividend / divisor;
+	regSD = remainder:4;
+	local dst:4 = &regSD;
+	*[register]:4 (dst + 4) = quotient:4;
+}
+
+
+# emul  4,4,8
+:emul regS1, regS2, regSD is op2431=0x67 & op0710=0x0 & regS1 & regS2 & regSD
+{
+	local tmp:8 = zext(regS1) * zext(regS2);
+	local dst:4 = &regSD;
+	*[register]:8 dst = tmp;
+}
+
+
+# eshro
+:eshro regS1, regS2l, regSD is op2431=0x5d & op0710=0x8 & regS1 & regS2l & regSD
+{
+	local tmp:8 = regS2l >> regS1[0,5];
+	regSD = tmp:4;
+}
+
+# expr
+:expr fregS1, fregSD is op2431=0x68 & op0710=0x9 & fregS1 & fregSD unimpl
+
+
+# exprl  8,8
+:exprl fregS1l, fregSDl is op2431=0x69 & op0710=0x9 & fregS1l & fregSDl unimpl
+
+
+# extract
+:extract regS1, regS2, regSD is op2431=0x65 & op0710=0x1 & regS1 & regS2 & regSD unimpl
+
+
+
+
+# faultno      op2431=0x18
+# faultg       op2431=0x19
+# faulte       op2431=0x1a
+# faultge      op2431=0x1b
+# faultl       op2431=0x1c
+# faultne      op2431=0x1d
+# faultle      op2431=0x1e
+# faulto       op2431=0x1f
+:fault^cc is op2731=0b00011 & cc & op0000=0x0
+{
+	#TODO  this is probably super broken
+	if (!cc) goto inst_next;
+	fault();
+}
+
+
+# fill
+:fill regS1, regS2, regSD is op2431=0x61 & op0710=0x7 & regS1 & regS2 & regSD unimpl
+
+
+# flushreg
+:flushreg  is op2431=0x66 & op0710=0xd
+{
+	# all local-register sets except the current, written to associate stack frame
+	flushreg();
+}
+
+
+# fmark
+:fmark  is op2431=0x66 & op0710=0xc unimpl
+
+
+# halt
+:halt regS1 is op2431=0x65 & op0710=0xd & regS1 unimpl
+
+
+# icctl
+:icctl regS1, regS2, regSD is op2431=0x65 & op0710=0xb & regS1 & regS2 & regSD unimpl
+
+
+# inspacc
+:inspacc regS1, regSD is op2431=0x61 & op0710=0x3 & regS1 & regSD unimpl
+
+
+# intctl
+:intctl regS1, regSD is op2431=0x65 & op0710=0x8 & regS1 & regSD unimpl
+
+
+# intdis
+:intdis  is op2431=0x5b & op0710=0x4 unimpl
+
+
+# inten
+:inten  is op2431=0x5b & op0710=0x5 unimpl
+
+
+# ld
+:ld efa, reg1923 is ( op2431=0x90 & reg1923 ) ... & efa
+{
+	reg1923 = *[ram]:4 efa;
+}
+
+
+# lda
+:lda efa, reg1923 is ( op2431=0x8c & reg1923 ) ... & efa
+{
+	reg1923 = efa;
+}
+
+
+# ldib
+:ldib efa, reg1923 is ( op2431=0xc0 & reg1923 ) ... & efa
+{
+	reg1923 = sext(*[ram]:1 efa);
+}
+
+
+# ldis
+:ldis efa, reg1923 is ( op2431=0xc8 & reg1923 ) ... & efa
+{
+	reg1923 = sext(*[ram]:2 efa);
+}
+
+
+# ldl
+:ldl efa, reg1923 is ( op2431=0x98 & reg1923 ) ... & efa
+{
+	local dst:4 = &reg1923;
+	l_copy_efa_to_reg(efa, dst);
+}
+
+
+# ldob
+:ldob efa, reg1923 is ( op2431=0x80 & reg1923 ) ... & efa
+{
+	reg1923 = zext(*[ram]:1 efa);
+}
+
+
+# ldos
+:ldos efa, reg1923 is ( op2431=0x88 & reg1923 ) ... & efa
+{
+	reg1923 = zext(*[ram]:2 efa);
+}
+
+
+# ldphy
+:ldphy regS1, regSD is op2431=0x61 & op0710=0x4 & regS1 & regSD unimpl
+
+
+# ldq
+:ldq efa, reg1923 is ( op2431=0xb0 & reg1923 ) ... & efa
+{
+	local dst:4 = &reg1923;
+	q_copy_efa_to_reg(efa, dst);
+}
+
+
+# ldt
+:ldt efa, reg1923 is ( op2431=0xa0 & reg1923 ) ... & efa
+{
+	local dst:4 = &reg1923;
+	t_copy_efa_to_reg(efa, dst);
+}
+
+
+# ldtime  8
+:ldtime regSD is op2431=0x67 & op0710=0x3 & regSD unimpl
+
+
+# logbnr
+:logbnr fregS1, fregSD is op2431=0x68 & op0710=0xa & fregS1 & fregSD
+{
+	fregSD = log2(fregS1);
+}
+
+
+# logbnrl  8,8
+:logbnrl fregS1l, fregSDl is op2431=0x69 & op0710=0xa & fregS1l & fregSDl
+{
+	fregSDl = log2(fregS1l);
+}
+
+
+# logepr
+:logepr fregS1, fregS2, fregSD is op2431=0x68 & op0710=0x1 & fregS1 & fregS2 & fregSD
+{
+	fregSD = fregS2 f* log2(fregS1 f+ 1);
+}
+
+
+# logeprl  8,8,8
+:logeprl fregS1l, fregS2l, fregSDl is op2431=0x69 & op0710=0x1 & fregS1l & fregS2l & fregSDl
+{
+	fregSDl = fregS2l f* log2(fregS1l f+ 1);
+}
+
+
+# logr
+:logr fregS1, fregS2, fregSD is op2431=0x68 & op0710=0x2 & fregS1 & fregS2 & fregSD
+{
+	fregSD = fregS2 f* log2(fregS1);
+}
+
+
+# logrl  8,8,8
+:logrl fregS1l, fregS2l, fregSDl is op2431=0x69 & op0710=0x2 & fregS1l & fregS2l & fregSDl
+{
+	fregSDl = fregS2l f* log2(fregS1l);
+}
+
+
+# mark
+:mark  is op2431=0x66 & op0710=0xb unimpl
+
+
+# modac
+:modac regS1, regS2, regSD is op2431=0x64 & op0710=0x5 & regS1 & regS2 & regSD
+{
+	local tmp:4 = ac;
+	ac = (regS2 & regS1) | (ac & ~regS1);
+	regSD = tmp;
+}
+
+
+# modi
+:modi regS1, regS2, regSD is op2431=0x74 & op0710=0x9 & regS1 & regS2 & regSD
+{
+	#TODO  flags
+	regSD = regS2 s/ regS1;
+}
+
+
+# modify
+:modify regS1, regS2, regSD is op2431=0x65 & op0710=0x0 & regS1 & regS2 & regSD
+{
+	regSD = (regS2 & regS1) | (regSD & ~regS1);
+}
+
+
+# modpc
+:modpc regS1, regS2, regSD is op2431=0x65 & op0710=0x5 & regS1 & regS2 & regSD
+{
+	local mask = regS2;
+	local src_dest = regS1;
+	regSD = inst_next;
+	if (0 == mask) goto inst_next;
+	regSD = (mask & src_dest) | (regSD & ~mask);
+	goto [regSD];
+}
+
+
+# modtc
+:modtc regS1, regS2, regSD is op2431=0x65 & op0710=0x4 & regS1 & regS2 & regSD
+{
+	local mode_bits:4 = 0x000000FE;
+	local event_flags:4 = 0x0F000000;
+	local temp:4 = tc;
+	local tempa:4 = (event_flags & tc & regS1) | (mode_bits & regS1);
+	tc = (tempa & regS2) | (tc & ~tempa);
+	regSD = temp;
+}
+
+
+# mov
+:mov regS1, regSD is op2431=0x5c & op0710=0xc & regS1 & regSD
+{
+	regSD = regS1;
+}
+
+
+# movl
+:movl regS1, regSD is op2431=0x5d & op0710=0xc & regS1 & regSD & m1=0
+{
+	#TODO  better handle lit vs reg
+	local dst:4 = &regSD;
+	local src:4 = &regS1;
+	l_copy_reg_to_reg(src, dst);
+}
+:movl op0004, regSD is op2431=0x5d & op0710=0xc & op0004 & regSD & m1=1
+{
+	#TODO  better handle lit vs reg
+	local dst:4 = &regSD;
+	local src:8 = op0004;
+	l_copy_lit_to_reg(src, dst);
+}
+
+
+# movq
+:movq regS1, regSD is op2431=0x5f & op0710=0xc & regS1 & regSD & m1=0
+{
+	#TODO  better handle lit vs reg
+	local dst:4 = &regSD;
+	local src:4 = &regS1;
+	q_copy_reg_to_reg(src, dst);
+}
+:movq op0004, regSD is op2431=0x5f & op0710=0xc & op0004 & regSD & m1=1
+{
+	#TODO  better handle lit vs reg
+	local dst:4 = &regSD;
+	local src:16 = op0004;
+	q_copy_lit_to_reg(src, dst);
+}
+
+
+# movqstr
+:movqstr regS1, regS2, regSD is op2431=0x60 & op0710=0x4 & regS1 & regS2 & regSD
+{
+	local length:4 = regSD;
+	local pos:4 = 0;
+    <next_byte>
+	if (pos == length) goto inst_next;
+	*[ram]:1 (regS1 + pos) = *[ram]:1 (regS2 + pos);
+	pos = pos + 1;
+	goto <next_byte>;
+}
+
+
+# movr
+:movr fregS1, fregSD is op2431=0x6c & op0710=0x9 & fregS1 & fregSD
+{
+	fregSD = fregS1;
+}
+
+
+# movre
+:movre fregS1e, fregSDe is op2431=0x6e & op0710=0x1 & fregS1e & fregSDe
+{
+	fregSDe = fregS1e;
+}
+
+
+# movrl  8,8
+:movrl fregS1l, fregSDl is op2431=0x6d & op0710=0x9 & fregS1l & fregSDl
+{
+	fregSDl = fregS1l;
+}
+
+
+# movstr
+:movstr regS1, regS2, regSD is op2431=0x60 & op0710=0x5 & regS1 & regS2 & regSD
+{
+	local length:4 = regSD;
+	local pos:4 = 0;
+	if (regS2 > regS1) goto <prev_byte>;
+    <next_byte>
+	if (pos == length) goto inst_next;
+	*[ram]:1 (regS1 + pos) = *[ram]:1 (regS2 + pos);
+	pos = pos + 1;
+	goto <next_byte>;
+    <prev_byte>
+	if (length == 0) goto inst_next;
+	length = length - 1;
+	*[ram]:1 (regS1 + length) = *[ram]:1 (regS2 + length);
+	goto <prev_byte>;
+}
+
+
+# movt
+:movt regS1, regSD is op2431=0x5e & op0710=0xc & regS1 & regSD & m1=0
+{
+	#TODO  better handle lit vs reg
+	local dst:4 = &regSD;
+	local src:4 = &regS1;
+	t_copy_reg_to_reg(src, dst);
+}
+:movt op0004, regSD is op2431=0x5e & op0710=0xc & op0004 & regSD & m1=1
+{
+	#TODO  better handle lit vs reg
+	local dst:4 = &regSD;
+	local src:12 = op0004;
+	t_copy_lit_to_reg(src, dst);
+}
+
+
+# muli
+:muli regS1, regS2, regSD is op2431=0x74 & op0710=0x1 & regS1 & regS2 & regSD
+{
+	#TODO  flags
+	regSD = regS1 * regS2;
+}
+
+
+# mulo
+:mulo regS1, regS2, regSD is op2431=0x70 & op0710=0x1 & regS1 & regS2 & regSD
+{
+	regSD = regS1 * regS2;
+}
+
+
+# mulr
+:mulr fregS1, fregS2, fregSD is op2431=0x78 & op0710=0xc & fregS1 & fregS2 & fregSD
+{
+	fregSD = fregS2 f* fregS1;
+}
+
+
+# mulrl  8,8,8
+:mulrl fregS1l, fregS2l, fregSDl is op2431=0x79 & op0710=0xc & fregS1l & fregS2l & fregSDl
+{
+	fregSDl = fregS2l f* fregS1l;
+}
+
+
+# nand
+:nand regS1, regS2, regSD is op2431=0x58 & op0710=0xe & regS1 & regS2 & regSD
+{
+	regSD = ~regS1 | ~regS2;
+}
+
+
+# nor
+:nor regS1, regS2, regSD is op2431=0x58 & op0710=0x8 & regS1 & regS2 & regSD
+{
+	regSD = ~regS2 & ~regS1;
+}
+
+
+# not
+:not regS1, regSD is op2431=0x58 & op0710=0xa & regS1 & regSD
+{
+	regSD = ~regS1;
+}
+
+
+# notand
+:notand regS1, regS2, regSD is op2431=0x58 & op0710=0x4 & regS1 & regS2 & regSD
+{
+	regSD = ~regS2 & regS1;
+}
+
+
+# notbit
+:notbit regS1, regS2, regSD is op2431=0x58 & op0710=0x0 & regS1 & regS2 & regSD
+{
+	regSD = regS2 ^ (1 << regS1);
+}
+
+
+# notor
+:notor regS1, regS2, regSD is op2431=0x58 & op0710=0xd & regS1 & regS2 & regSD
+{
+	regSD = ~regS2 | regS1;
+}
+
+
+# or
+:or regS1, regS2, regSD is op2431=0x58 & op0710=0x7 & regS1 & regS2 & regSD
+{
+	regSD = regS2 | regS1;
+}
+
+
+# ornot
+:ornot regS1, regS2, regSD is op2431=0x58 & op0710=0xb & regS1 & regS2 & regSD
+{
+	regSD = regS2 | ~regS1;
+}
+
+
+# receive
+:receive regS1, regSD is op2431=0x65 & op0710=0x6 & regS1 & regSD unimpl
+
+
+# remi
+:remi regS1, regS2, regSD is op2431=0x74 & op0710=0x8 & regS1 & regS2 & regSD
+{
+	#TODO  flags
+	regSD = regS2 s% regS2;
+}
+
+
+# remo
+:remo regS1, regS2, regSD is op2431=0x70 & op0710=0x8 & regS1 & regS2 & regSD
+{
+	regSD = regS2 % regS1;
+}
+
+
+# remr
+:remr fregS1, fregS2, fregSD is op2431=0x68 & op0710=0x3 & fregS1 & fregS2 & fregSD unimpl
+
+
+# remrl  8,8,8
+:remrl fregS1l, fregS2l, fregSDl is op2431=0x69 & op0710=0x3 & fregS1l & fregS2l & fregSDl unimpl
+
+
+# resumprcs
+:resumprcs regS1 is op2431=0x66 & op0710=0x4 & regS1 unimpl
+
+
+# ret
+:ret  is op2431=0xa & op0000=0x0
+{
+	#TODO  handle return status
+	fp = pfp;
+	dealloc_register_set();
+	ip = rip;
+	return [ip];
+}
+
+
+# rotate
+:rotate regS1, regS2, regSD is op2431=0x59 & op0710=0xd & regS1 & regS2 & regSD
+{
+	local length = regS1 % 32;
+	regSD = (regS2 << (32 - length)) | (regS2 >> length);
+}
+
+
+# roundr
+:roundr fregS1, fregSD is op2431=0x68 & op0710=0xb & fregS1 & fregSD
+{
+	fregSD = int2float(round(fregS1));
+}
+
+
+# roundrl  8,8
+:roundrl fregS1l, fregSDl is op2431=0x69 & op0710=0xb & fregS1l & fregSDl
+{
+	fregSDl = int2float(round(fregS1l));
+}
+
+
+# saveprcs
+:saveprcs  is op2431=0x66 & op0710=0x6 unimpl
+
+
+# scaler
+:scaler regS1, fregS2, fregSD is op2431=0x67 & op0710=0x7 & regS1 & fregS2 & fregSD
+{
+	local tmp:4 = 1 << regS1;
+	fregSD = fregS2 f* int2float(tmp);
+}
+
+
+# scalerl  4,8,8
+:scalerl regS1, fregS2l, fregSDl is op2431=0x67 & op0710=0x6 & regS1 & fregS2l & fregSDl
+{
+	local tmp:4 = 1 << regS1;
+	fregSDl = fregS2l f* int2float(tmp);
+}
+
+
+# scanbit
+:scanbit regS1, regSD is op2431=0x64 & op0710=0x1 & regS1 & regSD
+{
+	#TODO  this is probably similar to other count leading zero type instructions
+	regSD = 0xffffffff;
+	ac[0,3] = 0;
+	if (regS1 == 0) goto inst_next;
+	regSD = scanbit(regS1);
+	ac[0,3] = 2;
+}
+
+
+# scanbyte
+:scanbyte regS1, regS2 is op2431=0x5a & op0710=0xc & regS1 & regS2
+{
+	ac[0,3] = 0;
+	local code = (regS1[24,8] == regS2[24,8]) ||
+		     (regS1[16,8] == regS2[16,8]) ||
+		     (regS1[8,8] == regS2[8,8]) ||
+		     (regS1[0,8] == regS2[0,8]);
+	ac[1,1] = code;
+}
+
+
+# schedprcs
+:schedprcs regS1 is op2431=0x66 & op0710=0x5 & regS1 unimpl
+
+
+# sdma
+:sdma regS1, regS2, regSD is op2431=0x63 & op0710=0x0 & regS1 & regS2 & regSD unimpl
+
+
+# selno      op2431=0x78
+# selg       op2431=0x79
+# sele       op2431=0x7a
+# selge      op2431=0x7b
+# sell       op2431=0x7c
+# selne      op2431=0x7d
+# selle      op2431=0x7e
+# selo       op2431=0x7f
+:sel^cc regS1, regS2, regSD is op2731=0b01111 & cc & op0710=0x4 & regS1 & regS2 & regSD
+{
+	regSD = regS1;
+	if (!cc) goto inst_next;
+	regSD = regS2;
+}
+
+
+# send
+:send regS1, regS2, regSD is op2431=0x66 & op0710=0x2 & regS1 & regS2 & regSD
+{
+	#TODO  not sure
+	send(regS1, regS2, regSD);
+}
+
+
+# sendserv
+:sendserv regS1 is op2431=0x66 & op0710=0x3 & regS1 unimpl
+
+
+# setbit
+:setbit regS1, regS2, regSD is op2431=0x58 & op0710=0x3 & regS1 & regS2 & regSD
+{
+	regSD = regS2 | (1 << regS1);
+}
+
+
+# shli
+:shli regS1, regS2, regSD is op2431=0x59 & op0710=0xe & regS1 & regS2 & regSD
+{
+	#TODO  overflow
+	regSD = regS2 << regS1;
+}
+
+
+# shlo
+:shlo regS1, regS2, regSD is op2431=0x59 & op0710=0xc & regS1 & regS2 & regSD
+{
+	regSD = regS2 << regS1;
+}
+
+
+# shrdi
+:shrdi regS1, regS2, regSD is op2431=0x59 & op0710=0xa & regS1 & regS2 & regSD
+{
+	#TODO  are there flags here?
+	regSD = regS2 / (1 << regS1);
+}
+
+
+# shri
+:shri regS1, regS2, regSD is op2431=0x59 & op0710=0xb & regS1 & regS2 & regSD
+{
+	#TODO  flags
+	regSD = regS2 s>> regS1;
+}
+
+
+# shro
+:shro regS1, regS2, regSD is op2431=0x59 & op0710=0x8 & regS1 & regS2 & regSD
+{
+	regSD = regS2 >> regS1;
+}
+
+
+# signal
+:signal regS1 is op2431=0x66 & op0710=0xa & regS1 unimpl
+
+
+# sinr
+:sinr fregS1, fregSD is op2431=0x68 & op0710=0xc & fregS1 & fregSD
+{
+	fregSD = sin(fregS1);
+}
+
+
+# sinrl  8,8
+:sinrl fregS1l, fregSDl is op2431=0x69 & op0710=0xc & fregS1l & fregSDl
+{
+	fregSDl = sin(fregS1l);
+}
+
+
+# spanbit
+:spanbit regS1, regSD is op2431=0x64 & op0710=0x0 & regS1 & regSD
+{
+	ac[0,3] = 0;
+	regSD = 0xffffffff;
+	if (regS1 == 0xffffffff) goto inst_next;
+	regSD = spanbit(regS1);
+	ac[0,3] = 2;
+}
+
+
+# sqrtr
+:sqrtr fregS1, fregSD is op2431=0x68 & op0710=0x8 & fregS1 & fregSD
+{
+	fregSD = sqrt(fregS1);
+}
+
+
+# sqrtrl  8,8
+:sqrtrl fregS1l, fregSDl is op2431=0x69 & op0710=0x8 & fregS1l & fregSDl
+{
+	fregSDl = sqrt(fregS1l);
+}
+
+
+# st
+:st reg1923, efa is ( op2431=0x92 & reg1923 ) ... & efa
+{
+	*[ram]:4 efa = reg1923;
+}
+
+
+# stib
+:stib reg1923, efa is ( op2431=0xc2 & reg1923 ) ... & efa
+{
+	*[ram]:1 efa = reg1923:1;
+}
+
+
+# stis
+:stis reg1923, efa is ( op2431=0xca & reg1923 ) ... & efa
+{
+	*[ram]:2 efa = reg1923:2;
+}
+
+
+# stl
+:stl reg1923, efa is ( op2431=0x9a & reg1923 ) ... & efa
+{
+	local src:4 = &reg1923;
+	l_copy_reg_to_efa(src, efa);
+}
+
+
+# stob
+:stob reg1923, efa is ( op2431=0x82 & reg1923 ) ... & efa
+{
+	*[ram]:1 efa = reg1923:1;
+}
+
+
+# stos
+:stos reg1923, efa is ( op2431=0x8a & reg1923 ) ... & efa
+{
+	*[ram]:2 efa = reg1923:2;
+}
+
+
+# stq
+:stq reg1923, efa is ( op2431=0xb2 & reg1923 ) ... & efa
+{
+	local src:4 = &reg1923;
+	q_copy_reg_to_efa(src, efa);
+}
+
+
+# stt
+:stt reg1923, efa is ( op2431=0xa2 & reg1923 ) ... & efa
+{
+	local src:4 = &reg1923;
+	t_copy_reg_to_efa(src, efa);
+}
+
+
+# subc
+:subc regS1, regS2, regSD is op2431=0x5b & op0710=0x2 & regS1 & regS2 & regSD
+{
+	local tmp:4 = zext(ac[1,1]);
+	ac[2,1] = 0;
+	ac[1,1] = ((regS1 - 1) + tmp) > regS2;
+	ac[0,1] = ((regS1 - 1) + tmp) s> regS2;
+	regSD = regS2 + (regS1 - 1) + tmp;
+}
+
+
+# subi
+:subi regS1, regS2, regSD is op2431=0x59 & op0710=0x3 & regS1 & regS2 & regSD
+{
+	#TODO  flags
+	regSD = regS2 - regS1;
+}
+
+
+# subino      op2431=0x78
+# subig       op2431=0x79
+# subie       op2431=0x7a
+# subige      op2431=0x7b
+# subil       op2431=0x7c
+# subine      op2431=0x7d
+# subile      op2431=0x7e
+# subio       op2431=0x7f
+:subi^cc regS1, regS2, regSD is op2731=0b01111 & cc & op0710=0x3 & regS1 & regS2 & regSD
+{
+	if (!cc) goto inst_next;
+	ac[8,1] = sborrow(regS2, regS1);
+	regSD = regS2 - regS1;
+}
+
+
+# subo
+:subo regS1, regS2, regSD is op2431=0x59 & op0710=0x2 & regS1 & regS2 & regSD
+{
+	regSD = regS2 - regS1;
+}
+
+
+# subono      op2431=0x78
+# subog       op2431=0x79
+# suboe       op2431=0x7a
+# suboge      op2431=0x7b
+# subol       op2431=0x7c
+# subone      op2431=0x7d
+# subole      op2431=0x7e
+# suboo       op2431=0x7f
+:subo^cc regS1, regS2, regSD is op2731=0b01111 & cc & op0710=0x2 & regS1 & regS2 & regSD
+{
+	if (!cc) goto inst_next;
+	regSD = regS2 - regS1;
+}
+
+
+# subr
+:subr fregS1, fregS2, fregSD is op2431=0x78 & op0710=0xd & fregS1 & fregS2 & fregSD
+{
+	fregSD = fregS2 f- fregS1;
+}
+
+
+# subrl  8,8,8
+:subrl fregS1l, fregS2l, fregSDl is op2431=0x79 & op0710=0xd & fregS1l & fregS2l & fregSDl
+{
+	fregSDl = fregS2l f- fregS1l;
+}
+
+
+# syncf
+:syncf  is op2431=0x66 & op0710=0xf
+{
+	syncf();
+}
+
+
+# synld
+:synld regS1, regSD is op2431=0x61 & op0710=0x5 & regS1 & regSD
+{
+	#TODO  this might need work
+	regSD = *[ram]:4 regS1;
+	ac[0,3] = 2;
+}
+
+
+# synmov
+:synmov regS1, regS2 is op2431=0x60 & op0710=0x0 & regS1 & regS2
+{
+	#TODO  this might need work
+	*[ram]:4 regS1 = *[ram]:4 regS2;
+}
+
+
+# synmovl
+:synmovl regS1, regS2 is op2431=0x60 & op0710=0x1 & regS1 & regS2
+{
+	#TODO  this might need work
+	l_copy_efa_to_efa(regS2, regS1);
+}
+
+
+# synmovq
+:synmovq regS1, regS2 is op2431=0x60 & op0710=0x2 & regS1 & regS2
+{
+	#TODO  this might need work
+	q_copy_efa_to_efa(regS2, regS1);
+}
+
+
+# syscall
+:syscall  is op2431=0x1 & op0000=0x0 unimpl
+
+
+# sysctl
+:sysctl regS1, regS2, regSD is op2431=0x65 & op0710=0x9 & regS1 & regS2 & regSD unimpl
+
+
+# tanr
+:tanr fregS1, fregSD is op2431=0x68 & op0710=0xe & fregS1 & fregSD
+{
+	fregSD = tan(fregS1);
+}
+
+
+# tanrl  8,8
+:tanrl fregS1l, fregSDl is op2431=0x69 & op0710=0xe & fregS1l & fregSDl
+{
+	fregSDl = tan(fregS1l);
+}
+
+
+# testno      op2431=0x20
+# testg       op2431=0x21
+# teste       op2431=0x22
+# testge      op2431=0x23
+# testl       op2431=0x24
+# testne      op2431=0x25
+# testle      op2431=0x26
+# testo       op2431=0x27
+:test^cc cobrSD is op2731=0b00100 & cc & cobrSD
+{
+	cobrSD = zext(cc);
+}
+
+
+# udma
+:udma  is op2431=0x63 & op0710=0x1 unimpl
+
+
+# wait
+:wait regS1 is op2431=0x66 & op0710=0x9 & regS1 unimpl
+
+
+# xnor
+:xnor regS1, regS2, regSD is op2431=0x58 & op0710=0x9 & regS1 & regS2 & regSD
+{
+	regSD = ~(regS1 ^ regS2);
+}
+
+
+# xor
+:xor regS1, regS2, regSD is op2431=0x58 & op0710=0x6 & regS1 & regS2 & regSD
+{
+	regSD = regS1 ^ regS2;
+}
diff --git a/Ghidra/Processors/i960/data/languages/i960.slaspec b/Ghidra/Processors/i960/data/languages/i960.slaspec
new file mode 100644
index 0000000000..e273a361d6
--- /dev/null
+++ b/Ghidra/Processors/i960/data/languages/i960.slaspec
@@ -0,0 +1,4 @@
+
+define endian=little;
+
+@include "i960.sinc"
diff --git a/Ghidra/Processors/i960/data/patterns/i960_patterns.xml b/Ghidra/Processors/i960/data/patterns/i960_patterns.xml
new file mode 100644
index 0000000000..d8a3a14d18
--- /dev/null
+++ b/Ghidra/Processors/i960/data/patterns/i960_patterns.xml
@@ -0,0 +1,50 @@
+<patternlist>
+  <patternpairs totalbits="32" postbits="16">
+    <prepatterns>
+      <data>00000000 00000000 00000000 00001010</data> <!-- ret -->
+      <data>.00..... ..0100.. ........ 10000100</data> <!-- bx (reg) -->
+    </prepatterns>
+    <postpatterns>
+      <!--  76543210 54321098 32109876 10987654 -->
+      <data>........ ..00.... ........ 10001100</data> <!-- lda offset, reg -->
+      <data>........ ..10.... ........ 10001100</data> <!-- lda offset(reg), reg -->
+      <data>.00..... ..0100.. ........ 10001100</data> <!-- lda (reg), reg -->
+      <data>.00..... ..0101.. ........ 10001100 ........ ........ ........ ........</data> <!-- lda disp+8(ip), reg -->
+      <data>.00..... ..0111.. ........ 10001100</data> <!-- lda (reg1)[reg2*scale], reg -->
+      <data>.00..... ..1100.. ........ 10001100 ........ ........ ........ ........</data> <!-- lda disp, reg -->
+      <data>.00..... ..1101.. ........ 10001100 ........ ........ ........ ........</data> <!-- lda disp(reg), reg -->
+      <data>.00..... ..1110.. ........ 10001100 ........ ........ ........ ........</data> <!-- lda disp[reg*scale], reg -->
+      <data>.00..... ..1111.. ........ 10001100 ........ ........ ........ ........</data> <!-- lda disp(reg1)[reg2*scale], reg -->
+      <data>........ ..00.... ........ 10010000</data> <!-- ld offset, reg -->
+      <data>........ ..10.... ........ 10010000</data> <!-- ld offset(reg), reg -->
+      <data>.00..... ..0100.. ........ 10010000</data> <!-- ld (reg), reg -->
+      <data>.00..... ..0101.. ........ 10010000 ........ ........ ........ ........</data> <!-- ld disp+8(ip), reg -->
+      <data>.00..... ..0111.. ........ 10010000</data> <!-- ld (reg1)[reg2*scale], reg -->
+      <data>.00..... ..1100.. ........ 10010000 ........ ........ ........ ........</data> <!-- ld disp, reg -->
+      <data>.00..... ..1101.. ........ 10010000 ........ ........ ........ ........</data> <!-- ld disp(reg), reg -->
+      <data>.00..... ..1110.. ........ 10010000 ........ ........ ........ ........</data> <!-- ld disp[reg*scale], reg -->
+      <data>.00..... ..1111.. ........ 10010000 ........ ........ ........ ........</data> <!-- ld disp(reg1)[reg2*scale], reg -->
+      <data>........ ..00.... ........ 10000000</data> <!-- ldob offset, reg -->
+      <data>........ ..10.... ........ 10000000</data> <!-- ldob offset(reg), reg -->
+      <data>.00..... ..0100.. ........ 10000000</data> <!-- ldob (reg), reg -->
+      <data>.00..... ..0101.. ........ 10000000 ........ ........ ........ ........</data> <!-- ldob disp+8(ip), reg -->
+      <data>.00..... ..0111.. ........ 10000000</data> <!-- ldob (reg1)[reg2*scale], reg -->
+      <data>.00..... ..1100.. ........ 10000000 ........ ........ ........ ........</data> <!-- ldob disp, reg -->
+      <data>.00..... ..1101.. ........ 10000000 ........ ........ ........ ........</data> <!-- ldob disp(reg), reg -->
+      <data>.00..... ..1110.. ........ 10000000 ........ ........ ........ ........</data> <!-- ldob disp[reg*scale], reg -->
+      <data>.00..... ..1111.. ........ 10000000 ........ ........ ........ ........</data> <!-- ldob disp(reg1)[reg2*scale], reg -->
+      <data>........ ..00.... ........ 10001000</data> <!-- ldos offset, reg -->
+      <data>........ ..10.... ........ 10001000</data> <!-- ldos offset(reg), reg -->
+      <data>.00..... ..0100.. ........ 10001000</data> <!-- ldos (reg), reg -->
+      <data>.00..... ..0101.. ........ 10001000 ........ ........ ........ ........</data> <!-- ldos disp+8(ip), reg -->
+      <data>.00..... ..0111.. ........ 10001000</data> <!-- ldos (reg1)[reg2*scale], reg -->
+      <data>.00..... ..1100.. ........ 10001000 ........ ........ ........ ........</data> <!-- ldos disp, reg -->
+      <data>.00..... ..1101.. ........ 10001000 ........ ........ ........ ........</data> <!-- ldos disp(reg), reg -->
+      <data>.00..... ..1110.. ........ 10001000 ........ ........ ........ ........</data> <!-- ldos disp[reg*scale], reg -->
+      <data>.00..... ..1111.. ........ 10001000 ........ ........ ........ ........</data> <!-- ldos disp(reg1)[reg2*scale], reg -->
+      <data>000..... 01001000 00001000 01011001</data> <!-- addo lit, sp, sp -->
+      <data>0....... .....110 .1...... 01011100</data> <!-- mov src, <r10-r15> -->
+      <funcstart/>
+    </postpatterns>
+  </patternpairs>
+</patternlist>
diff --git a/Ghidra/Processors/i960/data/patterns/patternconstraints.xml b/Ghidra/Processors/i960/data/patterns/patternconstraints.xml
new file mode 100644
index 0000000000..dccafdd731
--- /dev/null
+++ b/Ghidra/Processors/i960/data/patterns/patternconstraints.xml
@@ -0,0 +1,5 @@
+<patternconstraints>
+  <language id="i960:LE:*:*">
+    <patternfile>i960_patterns.xml</patternfile>
+  </language>
+</patternconstraints>
diff --git a/Ghidra/Processors/i960/scripts/scrape.py b/Ghidra/Processors/i960/scripts/scrape.py
new file mode 100644
index 0000000000..e4f9582108
--- /dev/null
+++ b/Ghidra/Processors/i960/scripts/scrape.py
@@ -0,0 +1,1163 @@
+#!/usr/bin/env python
+"""Scrape the 2.30 binutils source code for 80960 (i960)"""
+
+import sys
+import struct
+
+print("# i960 / 80960\n\n")
+print("define endian=little;\n")
+print("define alignment=4;\n")
+print("define space ram type=ram_space size=4 default;\n")
+print("define space register type=register_space size=4;\n\n")
+
+
+
+# global g0-g15, local r0-r15
+# g15 == fp
+# r0 == pfp (previous frame pointer)
+# r1 == sp
+# r2 == rip
+# sf0 (IPND)
+# sf1 (IMSK)
+# sf2 (DMAC)
+registers = [
+    "pfp", "sp",  "rip", "r3",  "r4",  "r5",  "r6",  "r7",
+    "r8",  "r9",  "r10", "r11", "r12", "r13", "r14", "r15",
+    "g0",  "g1",  "g2",  "g3",  "g4",  "g5",  "g6",  "g7",
+    "g8",  "g9",  "g10", "g11", "g12", "g13", "g14", "fp"
+]
+
+print("define register offset=0 size=4 [ %s ];\n\n" % ' '.join(registers))
+
+sfregisters = [
+    "sf0", "sf1", "sf2", "sf3", "sf4", "sf5", "sf6", "sf7",
+    "sf8", "sf9", "sf10", "sf11", "sf12", "sf13", "sf14", "sf15",
+    "sf16", "sf17", "sf18", "sf19", "sf20", "sf21", "sf22", "sf23",
+    "sf24", "sf25", "sf26", "sf27", "sf28", "sf29", "sf30", "sf31"
+]
+print("define register offset=0x100 size=4 [ %s ];\n\n" % ' '.join(sfregisters))
+
+# ip - instruction pointer
+# ac - arithmetic controls
+#    - AC.nif = 15 - no-imprecise-faults
+#    - AC.om = 12 - integer overflow mask bit
+#    - AC.of = 8 - integer overflow flag
+#    - AC.cc = cc2 = 2
+#            = cc1 = 1
+#            = cc0 = 0
+#    true/fale ===  010/000
+#    unordered(false)/greater than(true)/equal/less than === 000/001/010/100
+#    carryout/overflow === 01x/0x1
+# pc - process controls
+# tc - trace controls
+stateregisters = [
+    "pc",  "ac",  "ip",  "tc",
+]
+print("define register offset=0x200 size=4 [ %s ];\n\n" % ' '.join(stateregisters))
+
+fpregisters = [
+    "fp0", "fp1", "fp2", "fp3"
+]
+
+print("define register offset=0x300 size=4 [ %s ];\n\n\n" % ' '.join(fpregisters))
+
+
+
+# instruction token
+print("define token instr (32)")
+print("  op2431=(24,31)")
+print("  reg1923=(19,23)")
+print("  reg1923l=(19,23)")
+print("  reg1923tq=(19,23)")
+print("  sfr1923=(19,23)")
+print("  sfr1923l=(19,23)")
+print("  sfr1923tq=(19,23)")
+print("  fp1923=(19,23)")
+print("  op1923=(19,23)")
+print("  reg1418=(14,18)")
+print("  reg1418l=(14,18)")
+print("  reg1418tq=(14,18)")
+print("  sfr1418=(14,18)")
+print("  sfr1418l=(14,18)")
+print("  sfr1418tq=(14,18)")
+print("  fp1418=(14,18)")
+print("  op1418=(14,18)")
+print("  m2=(13,13)")
+print("  m1=(12,12)")
+print("  m0=(11,11)")
+print("  op0710=(7,10)")
+print("  s1=(6,6)")
+print("  s0=(5,5)")
+print("  reg0004=(0,4)")
+print("  reg0004l=(0,4)")
+print("  reg0004tq=(0,4)")
+print("  sfr0004=(0,4)")
+print("  sfr0004l=(0,4)")
+print("  sfr0004tq=(0,4)")
+print("  fp0004=(0,4)")
+print("  op0004=(0,4)")
+print("  disp0212=(2,12)")
+print("  t=(1,1)")
+print("  s2=(0,0)")
+print("  disp0223=(2,23)")
+print("  op0000=(0,0)")
+print("  mode1213=(12,13)")
+print("  mode1011=(10,11)")
+print("  offset0011=(0,11)")
+print("  scale=(7,9)")
+print("  op0506=(5,6)")
+print(";\n\n")
+
+# displacement token
+print("define token instr2 (32)\n  disp0031=(0,31)\n;\n\n\n")
+
+print("attach variables [ reg0004 reg1418 reg1923 ]")
+print("                 [ %s ];\n" % (' '.join(registers)))
+print("attach variables [ reg0004l reg1418l reg1923l ]")
+print("                 [ %s _ ];\n" % (' _ '.join(registers[::2])))
+print("attach variables [ reg0004tq reg1418tq reg1923tq ]")
+print("                 [ %s _ _ _];\n\n" % (' _ _ _ '.join(registers[::4])))
+
+print("attach variables [ sfr0004 sfr1418 sfr1923 ]")
+print("                 [ %s ];\n" % (' '.join(sfregisters)))
+print("attach variables [ sfr0004l sfr1418l sfr1923l ]")
+print("                 [ %s _ ];\n" % (' _ '.join(sfregisters[::2])))
+print("attach variables [ sfr0004tq sfr1418tq sfr1923tq ]")
+print("                 [ %s _ _ _ ];\n\n" % (' _ _ _ '.join(sfregisters[::4])))
+
+regtok = [["reg0004", "reg1418", "reg1923"],["reg0004l", "reg1418l", "reg1923l"],None,["reg0004tq", "reg1418tq", "reg1923tq"]]
+sfrtok = [["sfr0004", "sfr1418", "sfr1923"],["sfr0004l", "sfr1418l", "sfr1923l"],None,["sfr0004tq", "sfr1418tq", "sfr1923tq"]]
+fptok = ["fp0004", "fp1418", "fp1923"]
+littok = ["op0004", "op1418", "op1923"]
+
+# The constructors for global or local registers, floating point, special, or literal
+# MMMSST
+# 32121
+# REG
+# xx0x0- src1 is global or local reg
+# xx1x0- src1 is a literal
+# xx0x1- src1 is a sfr
+# xx1x1- reserved
+# x0x0x- src2 is a global or local reg
+# x1x0x- src2 is a literal
+# x0x1x- src2 is a sfr
+# x1x1x- reserved
+# 0xxxx- src/dst is a global or local reg
+# COBR
+# --00-x src1 src2 and dst are global or local reg
+# --10-x src1 is a literal, src2 and dst are global or local reg
+# --01-x src1 is a global or local reg, src2 and dst are sfr
+# --11-0 src1 is a literal, src2 and dst are sfr
+# COBR / CTRL
+# --x-x0 outcome predicted true
+# --x-x1 outcome predicted false
+print("\n\n")
+
+print("regS1: reg0004 is reg0004 & m2 & m1 & m0=0 & s1 & s0=0 { export reg0004; }")
+print("regS1l: reg0004l is reg0004l & m2 & m1 & m0=0 & s1 & s0=0 { export reg0004l; }")
+print("regS1tq: reg0004tq is reg0004tq & m2 & m1 & m0=0 & s1 & s0=0 { export reg0004tq; }")
+print("regS1: op0004 is op0004 & m2 & m1 & m0=1 & s1 & s0=0 { export op0004; }")
+print("regS1: sfr0004 is sfr0004 & m2 & m1 & m0=0 & s1 & s0=1 { export sfr0004; }")
+print("regS1l: sfr0004l is sfr0004l & m2 & m1 & m0=0 & s1 & s0=1 { export sfr0004l; }")
+print("regS1tq: sfr0004tq is sfr0004tq & m2 & m1 & m0=0 & s1 & s0=1 { export sfr0004tq; }")
+
+print("regS2: reg1418 is reg1418 & m2 & m1=0 & m0 & s1=0 & s0 { export reg1418; }")
+print("regS2l: reg1418l is reg1418l & m2 & m1=0 & m0 & s1=0 & s0 { export reg1418l; }")
+print("regS2tq: reg1418tq is reg1418tq & m2 & m1=0 & m0 & s1=0 & s0 { export reg1418tq; }")
+print("regS2: op1418 is op1418 & m2 & m1=1 & m0 & s1=0 & s0 { export op1418; }")
+print("regS2: sfr1418 is sfr1418 & m2 & m1=0 & m0 & s1=1 & s0 { export sfr1418; }")
+print("regS2l: sfr1418l is sfr1418l & m2 & m1=0 & m0 & s1=1 & s0 { export sfr1418l; }")
+print("regS2tq: sfr1418tq is sfr1418tq & m2 & m1=0 & m0 & s1=1 & s0 { export sfr1418tq; }")
+
+print("regSD: reg1923 is reg1923 & m2=0 & m1 & m0 & s1 & s0 { export reg1923; }")
+print("regSDl: reg1923l is reg1923l & m2=0 & m1 & m0 & s1 & s0 { export reg1923l; }")
+print("regSDtq: reg1923tq is reg1923tq & m2=0 & m1 & m0 & s1 & s0 { export reg1923tq; }")
+
+
+print("cobrS1: reg0004 is reg0004 & m0=0 & s1=0 & t { export reg0004; }")
+print("cobrS1l: reg0004l is reg0004 & m0=0 & s1=0 & t { export reg0004l; }")
+print("cobrS1tq: reg0004tq is reg0004 & m0=0 & s1=0 & t { export reg0004tq; }")
+print("cobrS2: reg1418 is reg1418 & m0=0 & s1=0 & t { export reg1418; }")
+print("cobrS2l: reg1418l is reg1418l & m0=0 & s1=0 & t { export reg1418l; }")
+print("cobrS2tq: reg1418tq is reg1418tq & m0=0 & s1=0 & t { export reg1418tq; }")
+print("cobrSD:  reg1923 is reg1923 & m0=0 & s1=0 & t { export reg1923; }")
+print("cobrSDl:  reg1923l is reg1923l & m0=0 & s1=0 & t { export reg1923l; }")
+print("cobrSDtq:  reg1923tq is reg1923tq & m0=0 & s1=0 & t { export reg1923tq; }")
+
+print("cobrS1: op0004 is op0004 & m0=1 & s1=0 & t { export op0004; }")
+print("cobrS2: reg1418 is reg1418 & m0=1 & s1=0 & t { export reg1418; }")
+print("cobrS2l: reg1418l is reg1418l & m0=1 & s1=0 & t { export reg1418l; }")
+print("cobrS2tq: reg1418tq is reg1418tq & m0=1 & s1=0 & t { export reg1418tq; }")
+print("cobrSD:  reg1923 is reg1923 & m0=1 & s1=0 & t { export reg1923; }")
+print("cobrSDl:  reg1923l is reg1923l & m0=1 & s1=0 & t { export reg1923l; }")
+print("cobrSDtq:  reg1923tq is reg1923tq & m0=1 & s1=0 & t { export reg1923tq; }")
+
+print("cobrS1: reg0004 is reg0004 & m0=0 & s1=1 & t { export reg0004; }")
+print("cobrS1l: reg0004l is reg0004l & m0=0 & s1=1 & t { export reg0004l; }")
+print("cobrS1tq: reg0004tq is reg0004tq & m0=0 & s1=1 & t { export reg0004tq; }")
+print("cobrS2: sfr1418 is sfr1418 & m0=0 & s1=1 & t { export sfr1418; }")
+print("cobrS2l: sfr1418l is sfr1418l & m0=0 & s1=1 & t { export sfr1418l; }")
+print("cobrS2tq: sfr1418tq is sfr1418tq & m0=0 & s1=1 & t { export sfr1418tq; }")
+print("cobrSD:  sfr1923 is sfr1923 & m0=0 & s1=1 & t { export sfr1923; }")
+print("cobrSDl:  sfr1923l is sfr1923l & m0=0 & s1=1 & t { export sfr1923l; }")
+print("cobrSDtq:  sfr1923tq is sfr1923tq & m0=0 & s1=1 & t { export sfr1923tq; }")
+
+print("cobrS1: op0004 is op0004 & m0=1 & s1=0 & t=0 { export op0004; }")
+print("cobrS2: sfr1418 is sfr1418 & m0=1 & s1=1 & t=0 { export sfr1418; }")
+print("cobrS2l: sfr1418l is sfr1418l & m0=1 & s1=1 & t=0 { export sfr1418l; }")
+print("cobrS2tq: sfr1418tq is sfr1418tq & m0=1 & s1=1 & t=0 { export sfr1418tq; }")
+print("cobrSD:  sfr1923 is sfr1923 & m0=1 & s1=1 & t=0 { export sfr1923; }")
+print("cobrSDl:  sfr1923l is sfr1923l & m0=1 & s1=1 & t=0 { export sfr1923l; }")
+print("cobrSDtq:  sfr1923tq is sfr1923tq & m0=1 & s1=1 & t=0 { export sfr1923tq; }")
+
+print("\n\n")
+
+I_BASE	=0x01	#/* 80960 base instruction set	*/
+I_CX	=0x02	#/* 80960Cx instruction		*/
+I_DEC	=0x04	#/* Decimal instruction		*/
+I_FP	=0x08	#/* Floating point instruction	*/
+I_KX	=0x10	#/* 80960Kx instruction		*/
+I_MIL	=0x20	#/* Military instruction		*/
+I_CASIM	=0x40	#/* CA simulator instruction	*/
+I_CX2	=0x80	#/* Cx/Jx/Hx instructions	*/
+I_JX	=0x100	#/* Jx/Hx instruction		*/
+I_HX	=0x200	#/* Hx instructions		*/
+
+
+# SEE D-2
+
+# opcode  displacement  T  0
+# 31..24  23..2         1  0
+CTRL	=0
+
+# opcode  src1   src2  M  displacement  T  S2
+# 31..24  23.19  18.14 13 12.........2  1  0
+COBR	=1
+COJ	=2
+
+# opcode  src/dst  src2  mode  opcode  sflags src1
+# 31..24  23...19  18.14 13.11 10...7  6....5 4..0
+REG	=3
+
+# MEMA
+# opcode  src/dst  abase  mode  offset0011
+# 31..24  23...19  18.14  13.12 11...0
+
+# MEMB -  ATTN: can be followed by 4 bytes
+# opcode  src/dst  abase  mode  mode  scale  00  index
+# 31..24  23...19  18.14  13.12 11.10 9...7  6.5 4...0
+
+# SEE D-4
+# 00   "offset0011"                   - MEMA
+# 10   "offset0011(reg)"              - MEMA
+# 0100 "(reg)"                    - MEMB
+# 0101 "disp + 8 (ip)"            - MEMB + disp
+# 0110 reserved
+# 0111 "(reg1)[reg2 * scale]"     - MEMB
+# 1100 "disp"                     - MEMB + disp
+# 1101 "disp(reg)"                - MEMB + disp
+# 1110 "disp[reg * scale]"        - MEMB + disp
+# 1111 "disp(reg1)[reg2 * scale]" - MEMB + disp
+MEM1	=4
+MEM2	=5
+MEM4	=6
+MEM8	=7
+MEM12	=8
+MEM16	=9
+FBRA	=10
+CALLJ	=11
+
+
+M = 0x7f
+
+# special function register (sf0 ... sf2)
+SFR	=0x10		#/* Mask for the "sfr-OK" bit */
+# literal of the range 0 ... 31
+LIT	=0x08		#/* Mask for the "literal-OK" bit */
+#
+FP	=0x04		#/* Mask for "floating-point-OK" bit */
+
+
+
+class OP():
+    """Describes an operand to be used in the display and
+    the bit pattern.
+     * TODO  memory
+     * registers
+     * literal
+     * special function register
+     * floating point
+    """
+    def __init__(self,align,lit,fp,sfr):
+        self.align = align
+        self.lit = lit != 0
+        self.fp = fp != 0
+        self.sfr = sfr != 0 | (align != 0)
+        self._index = None
+        self._total = None
+        self._fmt = None
+
+    def val(self):
+        sizes = ["", "l", 0, "tq"]
+        if self._total == 3:
+            position = ["S1", "S2", "SD"]
+        elif self._total == 2:
+            position = ["S1", "SD"]
+        elif self._total == 1:
+            position = ["SD"]
+        else:
+            raise ValueError("bad total number %d" % (self._total))
+
+        if self._fmt == REG:
+            return "reg" + position[self._index] + sizes[self.align]
+        elif self._fmt == COBR:
+            return "cobr" + position[self._index] + sizes[self.align]
+        elif self._fmt in [MEM1,MEM2,MEM4,MEM8,MEM12,MEM16]:
+            return "reg1923" + sizes[self.align]
+        else:
+            _ = "oper%x%x%x_%x%x%x%x" % (self._fmt, self._index, self._total,
+                                         self.align, self.lit, self.fp, self.sfr)
+            # print("# RETURNING: %s" % (_))
+            return None
+
+    @property
+    def index(self):
+        return self._index
+    @property
+    def total(self):
+        return self._total
+    @property
+    def fmt(self):
+        return self._fmt
+    @index.setter
+    def index(self, val):
+        self._index = val
+    @total.setter
+    def total(self, val):
+        self._total = val
+    @fmt.setter
+    def fmt(self, val):
+        self._fmt = val
+
+
+
+def R():
+    return OP( 0, 0,   0,  0   )
+def RS():
+    return OP( 0, 0,   0,  SFR )
+def RL():
+    return OP( 0, LIT, 0,  0   )
+def RSL():
+    return OP( 0, LIT, 0,  SFR )
+def F():
+    return OP( 0, 0,   FP, 0   )
+def FL():
+    return OP( 0, LIT, FP, 0   )
+def R2():
+    return OP( 1, 0,   0,  0   )
+def RL2():
+    return OP( 1, LIT, 0,  0   )
+def F2():
+    return OP( 1, 0,   FP, 0   )
+def FL2():
+    return OP( 1, LIT, FP, 0   )
+def R4():
+    return OP( 3, 0,   0,  0   )
+def RL4():
+    return OP( 3, LIT, 0,  0   )
+def F4():
+    return OP( 3, 0,   FP, 0   )
+def FL4():
+    return OP( 3, LIT, FP, 0   )
+
+# SEE E-1
+
+
+#TODO  these should probably only be included in the table constructors
+#      for the operands
+def M1(opc):
+    opc.bitpattern["m0"]=1
+def M2(opc):
+    opc.bitpattern["m1"]=1
+def M3(opc):
+    opc.bitpattern["m2"]=1
+def S1(opc):
+    opc.bitpattern["s0"]=1
+def S2(opc):
+    opc.bitpattern["s1"]=1
+
+def COBR_OPC(opc):
+    """generate the 8-bit opcode for COBR format"""
+    opc.bitpattern["op2431"] = opc.op
+
+def REG_OPC(opc):
+    """generate the 12-bit opcode for a REG format"""
+    opc.bitpattern["op2431"] = (opc.op >> 4) & 0xff
+    opc.bitpattern["op0710"] = opc.op & 0x0f
+
+def R_0(opc):
+    """No operands"""
+    # REG_OPC(opc)
+    M1(opc)
+    M2(opc)
+    M3(opc)
+
+
+def R_1(opc):
+    """1 operand: src1"""
+    # REG_OPC(opc)
+    M2(opc)
+    M3(opc)
+
+def R_1D(opc):
+    """1 operand: dst"""
+    # REG_OPC(opc)
+    M1(opc)
+    M2(opc)
+
+def R_2(opc):
+    """2 ops: src1/src2"""
+    # REG_OPC(opc)
+    M3(opc)
+
+def R_2D(opc):
+    """2 ops: src1/dst"""
+    # REG_OPC(opc)
+    M2(opc)
+
+def R_3(opc):
+    """3 operands"""
+    # REG_OPC(opc)
+
+
+global_tables = []
+
+
+def do_global(tbl):
+    """print the tbl"""
+    if tbl in ["m0", "m1", "m2", "s0", "s1", "disp0212", "disp0223", "op2431", "op0710", "op0000"]:
+        return ""
+    elif tbl.startswith("regS") or tbl.startswith("regSD") or tbl.startswith("reg1923") or tbl.startswith("cobr"):
+        return ""
+    elif tbl.startswith("oper"):
+        tables = []
+        # "oper%x%x%x_%x%x%x%x" % (fmt, index, total, self.align, self.lit, self.fp, self.sfr)
+        fmt = int(tbl[4], 16)
+        index = int(tbl[5], 10)
+        total = int(tbl[6], 10)
+        align = int(tbl[8], 10)
+        lit = int(tbl[9], 10)
+        fp = int(tbl[10], 10)
+        sfr = int(tbl[11], 10)
+
+        # every oper* is a REG
+        if index == 2:
+            tmpA = "%s: %s is %s & m%d=0 { export %s; }"
+            tmpB =(tbl,regtok[align][index],regtok[align][index],index,regtok[align][index])
+            tables.append(tmpA % tmpB)
+        else:
+            tmpA = "%s: %s is %s & m%d=0 & s%d=0 { export %s; }"
+            tmpB =(tbl,regtok[align][index],regtok[align][index],index,index,regtok[align][index])
+            tables.append(tmpA % tmpB)
+        if sfr:
+            if index == 2:
+                tmpA = "%s: %s is %s & m%d=1 { export %s; }"
+                tmpB =(tbl,sfrtok[align][index],sfrtok[align][index],index,sfrtok[align][index])
+                tables.append(tmpA % tmpB)
+            else:
+                tmpA = "%s: %s is %s & m%d=0 & s%d=1 { export %s; }"
+                tmpB =(tbl,sfrtok[align][index],sfrtok[align][index],index,index,sfrtok[align][index])
+                tables.append(tmpA % tmpB)
+        #TODO  need a FP manual, not doing this now
+        # if fp:
+        #     tmpA = "%s: %s is %s & m%d=0 & s%d=0 { export %s; }"
+        #     tmpB =(tbl,sfrtok[index],sfrtok[index],index,index,sfrtok[index])
+        #     tables.append(tmpA % tmpB)
+        if lit:
+            if index == 2:
+                tmpA = "%s: %s is %s & m%d=1 { export %s; }"
+                tmpB =(tbl,littok[index],littok[index],index,littok[index])
+                tables.append(tmpA % tmpB)
+            else:
+                tmpA = "%s: %s is %s & m%d=1 & s%d=0 { export %s; }"
+                tmpB =(tbl,littok[index],littok[index],index,index,littok[index])
+                tables.append(tmpA % tmpB)
+
+        return '\n'.join(tables)
+    elif tbl.startswith("efa"):
+        """handle efa1, 2, 4, 8, 12, and 16"""
+        # subtables could be useful here, at least reg*scal
+        size = tbl[3:]
+        efa = []
+        # offset0011
+        tmpA = "%s: offset0011 is offset0011 & mode1213=0 { export *[ram]:%s offset0011; }"
+        tmpB = (tbl, size)
+        efa.append(tmpA % tmpB)
+        # offset0011(reg)
+        tmpA = "%s: offset0011 (reg1418) is offset0011 & reg1418 & mode1213=2 { local tmp:4 = reg1418 + offset0011; export *[ram]:%s tmp; }"
+        tmpB = (tbl, size)
+        efa.append(tmpA % tmpB)
+        # (reg)
+        tmpA = "%s: (reg1418) is reg1418 & mode1213=1 & mode1011=0 & op0506=0 { local tmp:4 = reg1418; export *[ram]:%s tmp; }"
+        tmpB = (tbl, size)
+        efa.append(tmpA % tmpB)
+        # disp + 8 (ip)
+        tmpA = "%s: reloc (ip) is ip & mode1213=1 & mode1011=1 & op0506=0 ; disp0031 [ reloc = disp0031 + 8; ] { local tmp:4 = reloc + inst_start; export *[ram]:%s tmp; }"
+        tmpB = (tbl, size)
+        efa.append(tmpA % tmpB)
+        # (reg1)[reg2 * scale]
+        tmpA = "%s: (reg1418) [reg0004 * scale] is scale & reg0004 & reg1418  & mode1213=1 & mode1011=3 & op0506=0 { local tmp:4 = (scale * reg0004) + reg1418; export *[ram]:%s tmp; }"
+        tmpB = (tbl, size)
+        efa.append(tmpA % tmpB)
+        # disp
+        tmpA = "%s: disp0031 is mode1213=3 & mode1011=0 & op0506=0 ; disp0031 { local tmp:4 = disp0031; export *[ram]:%s tmp; }"
+        tmpB = (tbl, size)
+        efa.append(tmpA % tmpB)
+        # disp (reg)
+        tmpA = "%s: disp0031 (reg1418) is reg1418 & mode1213=3 & mode1011=1 & op0506=0 ; disp0031 { local tmp:4 = disp0031 + reg1418; export *[ram]:%s tmp; }"
+        tmpB = (tbl, size)
+        efa.append(tmpA % tmpB)
+        # disp[reg * scale]
+        tmpA = "%s: disp0031 [reg0004 * scale] is reg0004 & scale & mode1213=3 & mode1011=2 & op0506=0 ; disp0031 { local tmp:4 = disp0031 + (reg0004 * scale); export *[ram]:%s tmp; }"
+        tmpB = (tbl, size)
+        efa.append(tmpA % tmpB)
+        # disp(reg)[reg * scale]
+        tmpA = "%s: disp0031 (reg1418) [reg0004 * scale] is reg1418 & reg0004 & scale & mode1213=3 & mode1011=3 & op0506=0 ; disp0031 { local tmp:4 = disp0031 + reg1418 + (reg0004 * scale); export *[ram]:%s tmp; }"
+        tmpB = (tbl, size)
+        efa.append(tmpA % tmpB)
+        return '\n'.join(efa)
+    else:
+        return "%s: is unimpl" % tbl
+
+
+class Opcode():
+    def __init__(self, x):
+        self.op_parse = x[0]
+        self.op = x[1]
+        self.name = x[2]
+        self.iclass = x[3]
+        self.fmt = x[4]
+        self.num_ops = x[5]
+        self.operand = x[6]
+        for _ in range(self.num_ops):
+            if isinstance(self.operand[_], OP):
+                self.operand[_].fmt = self.fmt
+                self.operand[_].index = _
+                self.operand[_].total = self.num_ops
+        self.operands = []
+        self.bitpattern = {}
+
+        # do stuff
+        self.parse()
+        return
+
+    def __str__(self):
+        tmp = []
+        efa = None
+        for k,v in self.bitpattern.items():
+            if isinstance(k, str) and v is None:
+                tmp.append("%s" % (k))
+            elif isinstance(k, str):
+                tmp.append("%s=0x%x" % (k,v))
+            else:
+                tmp.append("op%02d%02d=0x%x" % (k[0], k[1], v))
+        tmp2 = []
+        for x in range(len(self.operands)):
+            _ = self.operands[x]
+            if isinstance(_, OP):
+                # print("# tmp2 %s" % _.val())
+                newbit = _.val()
+                if newbit:
+                    tmp2.append(newbit)
+                    tmp.append(newbit)
+            else:
+                if _.startswith("efa"):
+                    efa = _
+                else:
+                    tmp.append(_)
+                tmp2.append(_)
+
+        # print("# %r" % (tmp))
+        bitpattern = " & ".join(tmp)
+        if efa:
+            bitpattern = "( %s ) ... & %s" % (bitpattern, efa)
+        return ":%s %s is %s unimpl" % (self.name, ", ".join(tmp2), bitpattern)
+
+    def CTRL_parse(self):
+        """Add a targ that is -2**23 to 2**23-4 disp"""
+        self.bitpattern["op2431"] = self.op
+        if self.num_ops == 1:
+            self.operands.append("disp0223")
+        elif self.num_ops == 0:
+            pass
+        else:
+            print("badness in CTRL parse")
+            sys.exit(1)
+        self.bitpattern["op0000"]=0
+        return
+    def COBR_parse(self):
+        """Add a dst reg or src1, src2, and targ"""
+        self.bitpattern["op2431"] = self.op
+        if self.num_ops == 1:
+            self.operands.append(self.operand[0])
+        elif self.num_ops == 3:
+            self.operands.append(self.operand[0])
+            self.operands.append(self.operand[1])
+            self.operands.append("disp0212")
+        else:
+            print("badness in cobr")
+            sys.exit(1)
+    def COJ_parse(self):
+        pass
+
+    def REG_parse(self):
+        """src1=op0004, src2=op1418, src/dst=op1923"""
+
+        self.bitpattern["op2431"] = (self.op >> 4) & 0xff
+        self.bitpattern["op0710"] = self.op & 0x0f
+
+        reg0 = self.operand[0]
+        reg1 = self.operand[1]
+        reg2 = self.operand[2]
+
+        if self.num_ops == 0:
+            return
+        elif self.num_ops == 1:
+            if not isinstance(reg0, OP) or isinstance(reg1, OP) or isinstance(reg2, OP):
+                print("badness 1 reg" % (self.name))
+                sys.exit(1)
+            if "m1" in self.bitpattern.keys() and "m2" in self.bitpattern.keys():
+                reg0.total = 3
+            elif "m0" in self.bitpattern.keys() and "m1" in self.bitpattern.keys():
+                reg0.total = 1
+            self.operands.append(reg0)
+        elif self.num_ops == 2:
+            if not isinstance(reg0, OP) or not isinstance(reg1, OP) or isinstance(reg2, OP):
+                print("badness 2 reg %s" % (self.name))
+                sys.exit(1)
+            self.operands.append(reg0)
+            if "m2" in self.bitpattern.keys():
+                # this is a hack, but this is the decision between using 1923 and 1418
+                reg1.total = 3
+            self.operands.append(reg1)
+        elif self.num_ops == 3:
+            if not isinstance(reg0, OP) or not isinstance(reg1, OP) or not isinstance(reg2, OP):
+                print("badness 3 reg %s" % (self.name))
+                sys.exit(1)
+            self.operands.append(reg0)
+            self.operands.append(reg1)
+            self.operands.append(reg2)
+        else:
+            print("badness in REG_parse")
+            sys.exit(1)
+        return
+
+    def MEM1_parse(self):
+        """Add an effective address argument, operates on 1-byte"""
+        self.bitpattern["op2431"] = self.op
+        if self.num_ops == 2:
+            if isinstance(self.operand[0], OP):
+                self.operands.append(self.operand[0])
+            else:
+                self.operands.append("efa1")
+            if isinstance(self.operand[1], OP):
+                self.operands.append(self.operand[1])
+            else:
+                self.operands.append("efa1")
+        elif self.num_ops == 1:
+            if isinstance(self.operand[0], OP):
+                self.operands.append(self.operand[0])
+            else:
+                self.operands.append("efa1")
+        else:
+            print("badness in MEM1 parse %s" % self)
+            sys.exit(1)
+    def MEM2_parse(self):
+        """Add an effective address argument, operates on 2-byte"""
+        self.bitpattern["op2431"] = self.op
+        if self.num_ops != 2:
+            print("badness in MEM2 parse")
+            sys.exit(1)
+        if isinstance(self.operand[0], OP):
+                self.operands.append(self.operand[0])
+        else:
+            self.operands.append("efa2")
+        if isinstance(self.operand[1], OP):
+            self.operands.append(self.operand[1])
+        else:
+            self.operands.append("efa2")
+    def MEM4_parse(self):
+        """Add an effective address argument, operates on 4-byte"""
+        self.bitpattern["op2431"] = self.op
+        if self.num_ops != 2:
+            print("badness in MEM4 parse")
+            sys.exit(1)
+        if isinstance(self.operand[0], OP):
+                self.operands.append(self.operand[0])
+        else:
+            self.operands.append("efa4")
+        if isinstance(self.operand[1], OP):
+            self.operands.append(self.operand[1])
+        else:
+            self.operands.append("efa4")
+    def MEM8_parse(self):
+        """Add an effective address argument, operates on 8-byte"""
+        self.bitpattern["op2431"] = self.op
+        if self.num_ops != 2:
+            print("badness in MEM8 parse")
+            sys.exit(1)
+        if isinstance(self.operand[0], OP):
+                self.operands.append(self.operand[0])
+        else:
+            self.operands.append("efa8")
+        if isinstance(self.operand[1], OP):
+            self.operands.append(self.operand[1])
+        else:
+            self.operands.append("efa8")
+    def MEM12_parse(self):
+        """Add an effective address argument, operates on 12-byte"""
+        self.bitpattern["op2431"] = self.op
+        if self.num_ops != 2:
+            print("badness in MEM12 parse")
+            sys.exit(1)
+        if isinstance(self.operand[0], OP):
+                self.operands.append(self.operand[0])
+        else:
+            self.operands.append("efa12")
+        if isinstance(self.operand[1], OP):
+            self.operands.append(self.operand[1])
+        else:
+            self.operands.append("efa12")
+    def MEM16_parse(self):
+        """Add an effective address argument, operates on 16-byte"""
+        self.bitpattern["op2431"] = self.op
+        if self.num_ops != 2:
+            print("badness in MEM16 parse")
+            sys.exit(1)
+        if isinstance(self.operand[0], OP):
+                self.operands.append(self.operand[0])
+        else:
+            self.operands.append("efa16")
+        if isinstance(self.operand[1], OP):
+            self.operands.append(self.operand[1])
+        else:
+            self.operands.append("efa16")
+    # def FBRA_parse(self):
+    #     pass
+    # def CALLJ_parse(self):
+    #     pass
+
+    def parse(self):
+        # broke this
+        # self.op_parse(self)
+        if self.op_parse in [R_0, R_1, R_1D, R_2, R_2D, R_3]:
+            self.op_parse(self)
+
+        if self.fmt == CTRL: self.CTRL_parse()
+        elif self.fmt == COBR: self.COBR_parse()
+        elif self.fmt == COJ: self.COJ_parse()
+        elif self.fmt == REG: self.REG_parse()
+        elif self.fmt == MEM1: self.MEM1_parse()
+        elif self.fmt == MEM2: self.MEM2_parse()
+        elif self.fmt == MEM4: self.MEM4_parse()
+        elif self.fmt == MEM8: self.MEM8_parse()
+        elif self.fmt == MEM12: self.MEM12_parse()
+        elif self.fmt == MEM16: self.MEM16_parse()
+        # elif self.fmt == FBRA: self.FBRA_parse()
+        # elif self.fmt == CALLJ: self.CALLJ_parse()
+        else:
+            print("badness %r" % (self.fmt))
+            sys.exit(1)
+        global global_tables
+
+        for k,v in self.bitpattern.items():
+            if isinstance(k, str):
+                global_tables.append("%s" % (k))
+            else:
+                global_tables.append("op%02d%02d" % (k[0], k[1]))
+        for x in range(len(self.operands)):
+            _ = self.operands[x]
+            if isinstance(_, OP):
+                new_global = _.val()
+                if new_global:
+                    global_tables.append(new_global)
+            else:
+                global_tables.append(_)
+        global_tables = list(set(global_tables))
+
+        return
+
+    def __lt__(self, other):
+        return self.name < other.name
+    def __eq__(self, other):
+        return self.name == other.name
+    def __gt__(self, other):
+        return self.name > other.name
+
+
+opcodes = [
+	# /* callj default=='call' */
+	# ( COBR_OPC, 0x09, "callj",	I_BASE,	CALLJ, 	1, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x08, "b",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x09, "call",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x0a, "ret",		I_BASE,	CTRL, 	0, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x0b, "bal",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x10, "bno",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	# /* bf same as bno */
+	# ( COBR_OPC, 0x10, "bf",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	# /* bru same as bno */
+	# ( COBR_OPC, 0x10, "bru",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x11, "bg",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	# /* brg same as bg */
+	# ( COBR_OPC, 0x11, "brg",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x12, "be",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	# /* bre same as be */
+	# ( COBR_OPC, 0x12, "bre",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x13, "bge",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	# /* brge same as bge */
+	# ( COBR_OPC, 0x13, "brge",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x14, "bl",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	# /* brl same as bl */
+	# ( COBR_OPC, 0x14, "brl",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x15, "bne",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	# /* brlg same as bne */
+	# ( COBR_OPC, 0x15, "brlg",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x16, "ble",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	# /* brle same as ble */
+	# ( COBR_OPC, 0x16, "brle",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x17, "bo",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	# /* bt same as bo */
+	# ( COBR_OPC, 0x17, "bt",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	# /* bro same as bo */
+	# ( COBR_OPC, 0x17, "bro",		I_BASE,	CTRL, 	1, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x18, "faultno",	I_BASE,	CTRL, 	0, ( 0, 0, 0 ) ),
+	# /* faultf same as faultno */
+	# ( COBR_OPC, 0x18, "faultf",	I_BASE,	CTRL, 	0, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x19, "faultg",	I_BASE,	CTRL, 	0, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x1a, "faulte",	I_BASE,	CTRL, 	0, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x1b, "faultge",	I_BASE,	CTRL, 	0, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x1c, "faultl",	I_BASE,	CTRL, 	0, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x1d, "faultne",	I_BASE,	CTRL, 	0, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x1e, "faultle",	I_BASE,	CTRL, 	0, ( 0, 0, 0 ) ),
+	( COBR_OPC, 0x1f, "faulto",	I_BASE,	CTRL, 	0, ( 0, 0, 0 ) ),
+	# /* faultt syn for faulto */
+	# ( COBR_OPC, 0x1f, "faultt",	I_BASE,	CTRL, 	0, ( 0, 0, 0 ) ),
+
+	( COBR_OPC, 0x01, "syscall",	I_CASIM,CTRL, 	0, ( 0, 0, 0 ) ),
+
+	# /* If a COBR (or COJ) has 3 operands, the last one is always a
+	# * displacement and does not appear explicitly in the table.
+	# */
+
+	( COBR_OPC, 0x20, "testno",	I_BASE,	COBR,	1, ( R(), 0, 0 )	),
+	( COBR_OPC, 0x21, "testg",	I_BASE,	COBR,	1, ( R(), 0, 0 )	),
+	( COBR_OPC, 0x22, "teste",	I_BASE,	COBR,	1, ( R(), 0, 0 )	),
+	( COBR_OPC, 0x23, "testge",	I_BASE,	COBR,	1, ( R(), 0, 0 )	),
+	( COBR_OPC, 0x24, "testl",	I_BASE,	COBR,	1, ( R(), 0, 0 )	),
+	( COBR_OPC, 0x25, "testne",	I_BASE,	COBR,	1, ( R(), 0, 0 )	),
+	( COBR_OPC, 0x26, "testle",	I_BASE,	COBR,	1, ( R(), 0, 0 )	),
+	( COBR_OPC, 0x27, "testo",	I_BASE,	COBR,	1, ( R(), 0, 0 )	),
+	( COBR_OPC, 0x30, "bbc",		I_BASE,	COBR,	3, ( RL(), RS(), 0 ) ),
+	( COBR_OPC, 0x31, "cmpobg",	I_BASE,	COBR,	3, ( RL(), RS(), 0 ) ),
+	( COBR_OPC, 0x32, "cmpobe",	I_BASE,	COBR,	3, ( RL(), RS(), 0 ) ),
+	( COBR_OPC, 0x33, "cmpobge",	I_BASE,	COBR,	3, ( RL(), RS(), 0 ) ),
+	( COBR_OPC, 0x34, "cmpobl",	I_BASE,	COBR,	3, ( RL(), RS(), 0 ) ),
+	( COBR_OPC, 0x35, "cmpobne",	I_BASE,	COBR,	3, ( RL(), RS(), 0 ) ),
+	( COBR_OPC, 0x36, "cmpoble",	I_BASE,	COBR,	3, ( RL(), RS(), 0 ) ),
+	( COBR_OPC, 0x37, "bbs",		I_BASE,	COBR,	3, ( RL(), RS(), 0 ) ),
+	( COBR_OPC, 0x38, "cmpibno",	I_BASE,	COBR,	3, ( RL(), RS(), 0 ) ),
+	( COBR_OPC, 0x39, "cmpibg",	I_BASE,	COBR,	3, ( RL(), RS(), 0 ) ),
+	( COBR_OPC, 0x3a, "cmpibe",	I_BASE,	COBR,	3, ( RL(), RS(), 0 ) ),
+	( COBR_OPC, 0x3b, "cmpibge",	I_BASE,	COBR,	3, ( RL(), RS(), 0 ) ),
+	( COBR_OPC, 0x3c, "cmpibl",	I_BASE,	COBR,	3, ( RL(), RS(), 0 ) ),
+	( COBR_OPC, 0x3d, "cmpibne",	I_BASE,	COBR,	3, ( RL(), RS(), 0 ) ),
+	( COBR_OPC, 0x3e, "cmpible",	I_BASE,	COBR,	3, ( RL(), RS(), 0 ) ),
+	( COBR_OPC, 0x3f, "cmpibo",	I_BASE,	COBR,	3, ( RL(), RS(), 0 ) ),
+        # COJ is just COBR with 'j' instead of 'b', this is an de-optimization instruction
+	# ( REG_OPC, 0x310, "cmpojg",	I_BASE,	COJ,	3, ( RL(), RS(), 0 ) ),
+	# ( REG_OPC, 0x320, "cmpoje",	I_BASE,	COJ,	3, ( RL(), RS(), 0 ) ),
+	# ( REG_OPC, 0x330, "cmpojge",	I_BASE,	COJ,	3, ( RL(), RS(), 0 ) ),
+	# ( REG_OPC, 0x340, "cmpojl",	I_BASE,	COJ,	3, ( RL(), RS(), 0 ) ),
+	# ( REG_OPC, 0x350, "cmpojne",	I_BASE,	COJ,	3, ( RL(), RS(), 0 ) ),
+	# ( REG_OPC, 0x360, "cmpojle",	I_BASE,	COJ,	3, ( RL(), RS(), 0 ) ),
+	# ( REG_OPC, 0x380, "cmpijno",	I_BASE,	COJ,	3, ( RL(), RS(), 0 ) ),
+	# ( REG_OPC, 0x390, "cmpijg",	I_BASE,	COJ,	3, ( RL(), RS(), 0 ) ),
+	# ( REG_OPC, 0x3a0, "cmpije",	I_BASE,	COJ,	3, ( RL(), RS(), 0 ) ),
+	# ( REG_OPC, 0x3b0, "cmpijge",	I_BASE,	COJ,	3, ( RL(), RS(), 0 ) ),
+	# ( REG_OPC, 0x3c0, "cmpijl",	I_BASE,	COJ,	3, ( RL(), RS(), 0 ) ),
+	# ( REG_OPC, 0x3d0, "cmpijne",	I_BASE,	COJ,	3, ( RL(), RS(), 0 ) ),
+	# ( REG_OPC, 0x3e0, "cmpijle",	I_BASE,	COJ,	3, ( RL(), RS(), 0 ) ),
+	# ( REG_OPC, 0x3f0, "cmpijo",	I_BASE,	COJ,	3, ( RL(), RS(), 0 ) ),
+
+	( REG_OPC, 0x80, "ldob",		I_BASE,	MEM1,	2, ( M,  R(),  0 ) ),
+	( REG_OPC, 0x82, "stob",		I_BASE,	MEM1,	2, ( R(),  M,  0 ) ),
+	( REG_OPC, 0x84, "bx",		I_BASE,	MEM1,	1, ( M,  0,  0 ) ),
+	( REG_OPC, 0x85, "balx",		I_BASE,	MEM1,	2, ( M,  R(),  0 ) ),
+	( REG_OPC, 0x86, "callx",	I_BASE,	MEM1,	1, ( M,  0,  0 ) ),
+	( REG_OPC, 0x88, "ldos",		I_BASE,	MEM2,	2, ( M,  R(),  0 ) ),
+	( REG_OPC, 0x8a, "stos",		I_BASE,	MEM2,	2, ( R(),  M,  0 ) ),
+	( REG_OPC, 0x8c, "lda",		I_BASE,	MEM1,	2, ( M,  R(),  0 ) ),
+	( REG_OPC, 0x90, "ld",		I_BASE,	MEM4,	2, ( M,  R(),  0 ) ),
+	( REG_OPC, 0x92, "st",		I_BASE,	MEM4,	2, ( R(),  M,  0 ) ),
+	( REG_OPC, 0x98, "ldl",		I_BASE,	MEM8,	2, ( M,  R2(), 0 ) ),
+	( REG_OPC, 0x9a, "stl",		I_BASE,	MEM8,	2, ( R2(), M,  0 ) ),
+	( REG_OPC, 0xa0, "ldt",		I_BASE,	MEM12,	2, ( M,  R4(), 0 ) ),
+	( REG_OPC, 0xa2, "stt",		I_BASE,	MEM12,	2, ( R4(), M,  0 ) ),
+	( REG_OPC, 0xb0, "ldq",		I_BASE,	MEM16,	2, ( M,  R4(), 0 ) ),
+	( REG_OPC, 0xb2, "stq",		I_BASE,	MEM16,	2, ( R4(), M,  0 ) ),
+	( REG_OPC, 0xc0, "ldib",		I_BASE,	MEM1,	2, ( M,  R(),  0 ) ),
+	( REG_OPC, 0xc2, "stib",		I_BASE,	MEM1,	2, ( R(),  M,  0 ) ),
+	( REG_OPC, 0xc8, "ldis",		I_BASE,	MEM2,	2, ( M,  R(),  0 ) ),
+	( REG_OPC, 0xca, "stis",		I_BASE,	MEM2,	2, ( R(),  M,  0 ) ),
+
+	( R_3, 0x580, "notbit",	I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x581, "and",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x582, "andnot",	I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x583, "setbit",	I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x584, "notand",	I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x586, "xor",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x587, "or",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x588, "nor",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x589, "xnor",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_2D, 0x58a, "not",		I_BASE,	REG,	2, ( RSL(), RS(), 0 ) ),
+	( R_3, 0x58b, "ornot",	I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x58c, "clrbit",	I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x58d, "notor",	I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x58e, "nand",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x58f, "alterbit",	I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x590, "addo",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x591, "addi",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x592, "subo",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x593, "subi",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x598, "shro",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x59a, "shrdi",	I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x59b, "shri",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x59c, "shlo",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x59d, "rotate",	I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x59e, "shli",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_2, 0x5a0, "cmpo",		I_BASE,	REG,	2, ( RSL(), RSL(), 0 ) ),
+	( R_2, 0x5a1, "cmpi",		I_BASE,	REG,	2, ( RSL(), RSL(), 0 ) ),
+	( R_2, 0x5a2, "concmpo",	I_BASE,	REG,	2, ( RSL(), RSL(), 0 ) ),
+	( R_2, 0x5a3, "concmpi",	I_BASE,	REG,	2, ( RSL(), RSL(), 0 ) ),
+	( R_3, 0x5a4, "cmpinco",	I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x5a5, "cmpinci",	I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x5a6, "cmpdeco",	I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x5a7, "cmpdeci",	I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_2, 0x5ac, "scanbyte",	I_BASE,	REG,	2, ( RSL(), RSL(), 0 ) ),
+	( R_2, 0x5ae, "chkbit",	I_BASE,	REG,	2, ( RSL(), RSL(), 0 ) ),
+	( R_3, 0x5b0, "addc",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x5b2, "subc",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_2D, 0x5cc, "mov",		I_BASE,	REG,	2, ( RSL(), RS(), 0 ) ),
+	( R_2D, 0x5dc, "movl",		I_BASE,	REG,	2, ( RL2(), R2(), 0 ) ),
+	( R_2D, 0x5ec, "movt",		I_BASE,	REG,	2, ( RL4(), R4(), 0 ) ),
+	( R_2D, 0x5fc, "movq",		I_BASE,	REG,	2, ( RL4(), R4(), 0 ) ),
+	( R_3, 0x610, "atmod",	I_BASE,	REG,	3, ( RS(), RSL(), R() ) ),
+	( R_3, 0x612, "atadd",	I_BASE,	REG,	3, ( RS(), RSL(), RS() ) ),
+	( R_2D, 0x640, "spanbit",	I_BASE,	REG,	2, ( RSL(), RS(), 0 ) ),
+	( R_2D, 0x641, "scanbit",	I_BASE,	REG,	2, ( RSL(), RS(), 0 ) ),
+	( R_3, 0x645, "modac",	I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x650, "modify",	I_BASE,	REG,	3, ( RSL(), RSL(), R() ) ),
+	( R_3, 0x651, "extract",	I_BASE,	REG,	3, ( RSL(), RSL(), R() ) ),
+	( R_3, 0x654, "modtc",	I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x655, "modpc",	I_BASE,	REG,	3, ( RSL(), RSL(), R() ) ),
+	( R_1, 0x660, "calls",	I_BASE,	REG,	1, ( RSL(), 0, 0 ) ),
+	( R_0, 0x66b, "mark",		I_BASE,	REG,	0, ( 0, 0, 0 )	),
+	( R_0, 0x66c, "fmark",	I_BASE,	REG,	0, ( 0, 0, 0 )	),
+	( R_0, 0x66d, "flushreg",	I_BASE,	REG,	0, ( 0, 0, 0 )	),
+	( R_0, 0x66f, "syncf",	I_BASE,	REG,	0, ( 0, 0, 0 )	),
+	( R_3, 0x670, "emul",		I_BASE,	REG,	3, ( RSL(), RSL(), R2() ) ),
+	( R_3, 0x671, "ediv",		I_BASE,	REG,	3, ( RSL(), RL2(), RS() ) ),
+	( R_2D, 0x672, "cvtadr",	I_CASIM,REG, 	2, ( RL(), R2(), 0 ) ),
+	( R_3, 0x701, "mulo",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x708, "remo",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x70b, "divo",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x741, "muli",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x748, "remi",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x749, "modi",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x74b, "divi",		I_BASE,	REG,	3, ( RSL(), RSL(), RS() ) ),
+
+	# /* Floating-point instructions */
+
+	( R_2D, 0x674, "cvtir",	I_FP,	REG,	2, ( RL(), F(), 0 ) ),
+	( R_2D, 0x675, "cvtilr",	I_FP,	REG,	2, ( RL(), F(), 0 ) ),
+	( R_3, 0x676, "scalerl",	I_FP,	REG,	3, ( RL(), FL2(), F2() ) ),
+	( R_3, 0x677, "scaler",	I_FP,	REG,	3, ( RL(), FL(), F() ) ),
+	( R_3, 0x680, "atanr",	I_FP,	REG,	3, ( FL(), FL(), F() ) ),
+	( R_3, 0x681, "logepr",	I_FP,	REG,	3, ( FL(), FL(), F() ) ),
+	( R_3, 0x682, "logr",		I_FP,	REG,	3, ( FL(), FL(), F() ) ),
+	( R_3, 0x683, "remr",		I_FP,	REG,	3, ( FL(), FL(), F() ) ),
+	( R_2, 0x684, "cmpor",	I_FP,	REG,	2, ( FL(), FL(), 0 ) ),
+	( R_2, 0x685, "cmpr",		I_FP,	REG,	2, ( FL(), FL(), 0 ) ),
+	( R_2D, 0x688, "sqrtr",	I_FP,	REG,	2, ( FL(), F(), 0 ) ),
+	( R_2D, 0x689, "expr",		I_FP,	REG,	2, ( FL(), F(), 0 ) ),
+	( R_2D, 0x68a, "logbnr",	I_FP,	REG,	2, ( FL(), F(), 0 ) ),
+	( R_2D, 0x68b, "roundr",	I_FP,	REG,	2, ( FL(), F(), 0 ) ),
+	( R_2D, 0x68c, "sinr",		I_FP,	REG,	2, ( FL(), F(), 0 ) ),
+	( R_2D, 0x68d, "cosr",		I_FP,	REG,	2, ( FL(), F(), 0 ) ),
+	( R_2D, 0x68e, "tanr",		I_FP,	REG,	2, ( FL(), F(), 0 ) ),
+	( R_1, 0x68f, "classr",	I_FP,	REG,	1, ( FL(), 0, 0 )	),
+	( R_3, 0x690, "atanrl",	I_FP,	REG,	3, ( FL2(), FL2(), F2() ) ),
+	( R_3, 0x691, "logeprl",	I_FP,	REG,	3, ( FL2(), FL2(), F2() ) ),
+	( R_3, 0x692, "logrl",	I_FP,	REG,	3, ( FL2(), FL2(), F2() ) ),
+	( R_3, 0x693, "remrl",	I_FP,	REG,	3, ( FL2(), FL2(), F2() ) ),
+	( R_2, 0x694, "cmporl",	I_FP,	REG,	2, ( FL2(), FL2(), 0 ) ),
+	( R_2, 0x695, "cmprl",	I_FP,	REG,	2, ( FL2(), FL2(), 0 ) ),
+	( R_2D, 0x698, "sqrtrl",	I_FP,	REG,	2, ( FL2(), F2(), 0 ) ),
+	( R_2D, 0x699, "exprl",	I_FP,	REG,	2, ( FL2(), F2(), 0 ) ),
+	( R_2D, 0x69a, "logbnrl",	I_FP,	REG,	2, ( FL2(), F2(), 0 ) ),
+	( R_2D, 0x69b, "roundrl",	I_FP,	REG,	2, ( FL2(), F2(), 0 ) ),
+	( R_2D, 0x69c, "sinrl",	I_FP,	REG,	2, ( FL2(), F2(), 0 ) ),
+	( R_2D, 0x69d, "cosrl",	I_FP,	REG,	2, ( FL2(), F2(), 0 ) ),
+	( R_2D, 0x69e, "tanrl",	I_FP,	REG,	2, ( FL2(), F2(), 0 ) ),
+	( R_1, 0x69f, "classrl",	I_FP,	REG,	1, ( FL2(), 0, 0 ) ),
+	( R_2D, 0x6c0, "cvtri",	I_FP,	REG,	2, ( FL(), R(), 0 ) ),
+	( R_2D, 0x6c1, "cvtril",	I_FP,	REG,	2, ( FL(), R2(), 0 ) ),
+	( R_2D, 0x6c2, "cvtzri",	I_FP,	REG,	2, ( FL(), R(), 0 ) ),
+	( R_2D, 0x6c3, "cvtzril",	I_FP,	REG,	2, ( FL(), R2(), 0 ) ),
+	( R_2D, 0x6c9, "movr",		I_FP,	REG,	2, ( FL(), F(), 0 ) ),
+	( R_2D, 0x6d9, "movrl",	I_FP,	REG,	2, ( FL2(), F2(), 0 ) ),
+	( R_2D, 0x6e1, "movre",	I_FP,	REG,	2, ( FL4(), F4(), 0 ) ),
+	( R_3, 0x6e2, "cpysre",	I_FP,	REG,	3, ( FL4(), FL4(), F4() ) ),
+	( R_3, 0x6e3, "cpyrsre",	I_FP,	REG,	3, ( FL4(), FL4(), F4() ) ),
+	( R_3, 0x78b, "divr",		I_FP,	REG,	3, ( FL(), FL(), F() ) ),
+	( R_3, 0x78c, "mulr",		I_FP,	REG,	3, ( FL(), FL(), F() ) ),
+	( R_3, 0x78d, "subr",		I_FP,	REG,	3, ( FL(), FL(), F() ) ),
+	( R_3, 0x78f, "addr",		I_FP,	REG,	3, ( FL(), FL(), F() ) ),
+	( R_3, 0x79b, "divrl",	I_FP,	REG,	3, ( FL2(), FL2(), F2() ) ),
+	( R_3, 0x79c, "mulrl",	I_FP,	REG,	3, ( FL2(), FL2(), F2() ) ),
+	( R_3, 0x79d, "subrl",	I_FP,	REG,	3, ( FL2(), FL2(), F2() ) ),
+	( R_3, 0x79f, "addrl",	I_FP,	REG,	3, ( FL2(), FL2(), F2() ) ),
+
+	# /* These are the floating point branch instructions.  Each actually
+	# * generates 2 branch instructions:  the first a CTRL instruction with
+	# * the indicated opcode, and the second a 'bno'.
+	# */
+        #TODO  not gonna mess with macro instructions
+	# ( REG_OPC, 0x120, "brue",		I_FP,	FBRA, 	1, ( 0, 0, 0 )	),
+	# ( REG_OPC, 0x110, "brug",		I_FP,	FBRA, 	1, ( 0, 0, 0 )	),
+	# ( REG_OPC, 0x130, "bruge",	I_FP,	FBRA, 	1, ( 0, 0, 0 )	),
+	# ( REG_OPC, 0x140, "brul",		I_FP,	FBRA, 	1, ( 0, 0, 0 )	),
+	# ( REG_OPC, 0x160, "brule",	I_FP,	FBRA, 	1, ( 0, 0, 0 )	),
+	# ( REG_OPC, 0x150, "brulg",	I_FP,	FBRA, 	1, ( 0, 0, 0 )	),
+
+
+	# /* Decimal instructions */
+
+	( R_3, 0x642, "daddc",	I_DEC,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x643, "dsubc",	I_DEC,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_2D, 0x644, "dmovt",	I_DEC,	REG,	2, ( RSL(), RS(), 0 ) ),
+
+
+	# /* KX extensions */
+
+	( R_2, 0x600, "synmov",	I_KX,	REG,	2, ( R(),  R(), 0 ) ),
+	( R_2, 0x601, "synmovl",	I_KX,	REG,	2, ( R(),  R(), 0 ) ),
+	( R_2, 0x602, "synmovq",	I_KX,	REG,	2, ( R(),  R(), 0 ) ),
+	( R_2D, 0x615, "synld",	I_KX,	REG,	2, ( R(),  R(), 0 ) ),
+
+
+	# /* MC extensions */
+
+	( R_3, 0x603, "cmpstr",	I_MIL,	REG,	3, ( R(),  R(),  RL() ) ),
+	( R_3, 0x604, "movqstr",	I_MIL,	REG,	3, ( R(),  R(),  RL() ) ),
+	( R_3, 0x605, "movstr",	I_MIL,	REG,	3, ( R(),  R(),  RL() ) ),
+	( R_2D, 0x613, "inspacc",	I_MIL,	REG,	2, ( R(),  R(), 0 ) ),
+	( R_2D, 0x614, "ldphy",	I_MIL,	REG,	2, ( R(),  R(), 0 ) ),
+	( R_3, 0x617, "fill",		I_MIL,	REG,	3, ( R(),  RL(), RL() ) ),
+	( R_2D, 0x646, "condrec",	I_MIL,	REG,	2, ( R(),  R(), 0 ) ),
+	( R_2D, 0x656, "receive",	I_MIL,	REG,	2, ( R(),  R(), 0 ) ),
+	( R_3, 0x662, "send",		I_MIL,	REG,	3, ( R(),  RL(), R() ) ),
+	( R_1, 0x663, "sendserv",	I_MIL,	REG,	1, ( R(), 0, 0 )	),
+	( R_1, 0x664, "resumprcs",	I_MIL,	REG,	1, ( R(), 0, 0 )	),
+	( R_1, 0x665, "schedprcs",	I_MIL,	REG,	1, ( R(), 0, 0 )	),
+	( R_0, 0x666, "saveprcs",	I_MIL,	REG,	0, ( 0, 0, 0 )	),
+	( R_1, 0x668, "condwait",	I_MIL,	REG,	1, ( R(), 0, 0 )	),
+	( R_1, 0x669, "wait",		I_MIL,	REG,	1, ( R(), 0, 0 )	),
+	( R_1, 0x66a, "signal",	I_MIL,	REG,	1, ( R(), 0, 0 )	),
+	( R_1D, 0x673, "ldtime",	I_MIL,	REG,	1, ( R2(), 0, 0 )	),
+
+
+	# /* CX extensions */
+
+	( R_3, 0x5d8, "eshro",	I_CX2,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x630, "sdma",		I_CX,	REG,	3, ( RSL(), RSL(), RL() ) ),
+	( R_3, 0x631, "udma",		I_CX,	REG,	0, ( 0, 0, 0 )	),
+	( R_3, 0x659, "sysctl",	I_CX2,	REG,	3, ( RSL(), RSL(), RL() ) ),
+
+
+	# /* Jx extensions.  */
+	( R_3, 0x780, "addono",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x790, "addog",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7a0, "addoe",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7b0, "addoge",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7c0, "addol",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7d0, "addone",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7e0, "addole",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7f0, "addoo",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x781, "addino",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x791, "addig",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7a1, "addie",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7b1, "addige",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7c1, "addil",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7d1, "addine",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7e1, "addile",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7f1, "addio",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+
+	( R_2D, 0x5ad, "bswap",	I_JX,	REG,	2, ( RSL(), RS(), 0 ) ),
+
+	( R_2, 0x594, "cmpob",	I_JX,	REG,	2, ( RSL(), RSL(), 0 ) ),
+	( R_2, 0x595, "cmpib",	I_JX,	REG,	2, ( RSL(), RSL(), 0 ) ),
+	( R_2, 0x596, "cmpos",	I_JX,	REG,	2, ( RSL(), RSL(), 0 ) ),
+	( R_2, 0x597, "cmpis",	I_JX,	REG,	2, ( RSL(), RSL(), 0 ) ),
+
+	( R_3, 0x784, "selno",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x794, "selg",		I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7a4, "sele",		I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7b4, "selge",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7c4, "sell",		I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7d4, "selne",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7e4, "selle",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7f4, "selo",		I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+
+	( R_3, 0x782, "subono",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x792, "subog",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7a2, "suboe",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7b2, "suboge",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7c2, "subol",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7d2, "subone",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7e2, "subole",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7f2, "suboo",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x783, "subino",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x793, "subig",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7a3, "subie",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7b3, "subige",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7c3, "subil",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7d3, "subine",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7e3, "subile",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_3, 0x7f3, "subio",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+
+	( R_3, 0x65c, "dcctl",	I_JX,	REG,	3, ( RSL(), RSL(), RL() ) ),
+	( R_3, 0x65b, "icctl",	I_JX,	REG,	3, ( RSL(), RSL(), RS() ) ),
+	( R_2D, 0x658, "intctl",	I_JX,	REG,	2, ( RSL(), RS(), 0 ) ),
+	( R_0, 0x5b4, "intdis",	I_JX,	REG,	0, (   0,  0, 0 ) ),
+	( R_0, 0x5b5, "inten",	I_JX,	REG,	0, (   0,  0, 0 ) ),
+	( R_0, 0x65d, "halt",		I_JX,	REG,	1, ( RSL(),  0, 0 ) ),
+
+	# /* Hx extensions.  */
+	( REG_OPC, 0xac, "dcinva",	I_HX,	MEM1,	1, (   M,  0, 0 ) ),
+]
+
+a = []
+for _ in opcodes:
+    opc = Opcode(_)
+    a.append(opc)
+a.sort()
+
+global_tables.sort()
+for _ in global_tables:
+    thing = do_global(_)
+    if len(thing) > 0:
+        print("%s\n\n" % thing)
+
+for _ in a:
+    print("# %s\n%s\n\n" % (_.name, _))
diff --git a/Ghidra/Processors/i960/src/main/java/ghidra/app/util/bin/format/elf/extend/I960_ElfExtension.java b/Ghidra/Processors/i960/src/main/java/ghidra/app/util/bin/format/elf/extend/I960_ElfExtension.java
new file mode 100644
index 0000000000..987c53e9c9
--- /dev/null
+++ b/Ghidra/Processors/i960/src/main/java/ghidra/app/util/bin/format/elf/extend/I960_ElfExtension.java
@@ -0,0 +1,27 @@
+package ghidra.app.util.bin.format.elf.extend;
+
+import ghidra.app.util.bin.format.elf.ElfConstants;
+import ghidra.app.util.bin.format.elf.ElfHeader;
+import ghidra.app.util.bin.format.elf.ElfLoadHelper;
+import ghidra.program.model.lang.Language;
+
+public class I960_ElfExtension extends ElfExtension {
+
+	@Override
+	public boolean canHandle(ElfHeader elf) {
+		return elf.e_machine() == ElfConstants.EM_960;
+	}
+
+	@Override
+	public boolean canHandle(ElfLoadHelper elfLoadHelper) {
+		Language language = elfLoadHelper.getProgram().getLanguage();
+		return canHandle(elfLoadHelper.getElfHeader()) &&
+			"I960".equals(language.getProcessor().toString());
+	}
+
+	@Override
+	public String getDataTypeSuffix() {
+		return "_I960";
+	}
+
+}
diff --git a/Ghidra/Processors/i960/src/main/java/ghidra/app/util/bin/format/elf/relocation/I960_ElfRelocationConstants.java b/Ghidra/Processors/i960/src/main/java/ghidra/app/util/bin/format/elf/relocation/I960_ElfRelocationConstants.java
new file mode 100644
index 0000000000..d27f0b3064
--- /dev/null
+++ b/Ghidra/Processors/i960/src/main/java/ghidra/app/util/bin/format/elf/relocation/I960_ElfRelocationConstants.java
@@ -0,0 +1,27 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.elf.relocation;
+
+public class I960_ElfRelocationConstants {
+	public static final int R_960_NONE = 0;
+	public static final int R_960_12 = 1;
+	public static final int R_960_32 = 2;
+	public static final int R_960_IP24 = 3;
+	public static final int R_960_SUB = 4;
+	public static final int R_960_OPTCALL = 5;
+	public static final int R_960_OPTCALLX = 6;
+	public static final int R_960_OPTCALLXA = 7;
+}
diff --git a/Ghidra/Processors/i960/src/main/java/ghidra/app/util/bin/format/elf/relocation/I960_ElfRelocationHandler.java b/Ghidra/Processors/i960/src/main/java/ghidra/app/util/bin/format/elf/relocation/I960_ElfRelocationHandler.java
new file mode 100644
index 0000000000..b879a9010b
--- /dev/null
+++ b/Ghidra/Processors/i960/src/main/java/ghidra/app/util/bin/format/elf/relocation/I960_ElfRelocationHandler.java
@@ -0,0 +1,104 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.elf.relocation;
+
+import ghidra.app.util.bin.format.elf.ElfConstants;
+import ghidra.app.util.bin.format.elf.ElfHeader;
+import ghidra.app.util.bin.format.elf.ElfRelocation;
+import ghidra.app.util.bin.format.elf.ElfSymbol;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.mem.Memory;
+import ghidra.program.model.mem.MemoryAccessException;
+import ghidra.program.model.reloc.RelocationResult;
+import ghidra.program.model.reloc.Relocation.Status;
+import ghidra.util.exception.NotFoundException;
+
+public class I960_ElfRelocationHandler extends ElfRelocationHandler {
+
+	@Override
+	public boolean canRelocate(ElfHeader elf) {
+		return elf.e_machine() == ElfConstants.EM_960;
+	}
+
+	@Override
+	public RelocationResult relocate(ElfRelocationContext elfRelocationContext, ElfRelocation relocation, Address relocationAddress)
+			throws MemoryAccessException, NotFoundException {
+		if (!canRelocate(elfRelocationContext.getElfHeader())) {
+			return RelocationResult.FAILURE;
+		}
+		int type = relocation.getType();
+		if (I960_ElfRelocationConstants.R_960_NONE == type) {
+			return RelocationResult.FAILURE;
+		}
+
+		Program program = elfRelocationContext.getProgram();
+		Memory memory = program.getMemory();
+
+		ElfSymbol sym = null;
+		long symbolValue = 0;
+		Address symbolAddr = null;
+		String symbolName = null;
+		int symbolIndex = relocation.getSymbolIndex();
+		if (symbolIndex != 0) {
+			sym = elfRelocationContext.getSymbol(symbolIndex);
+		}
+
+		if (null != sym) {
+			symbolAddr = elfRelocationContext.getSymbolAddress(sym);
+			symbolValue = elfRelocationContext.getSymbolValue(sym);
+			symbolName = sym.getNameAsString();
+		}
+
+		int byteLength = 4; // most relocations affect 4-bytes (change if different)
+
+		switch (type) {
+		default:
+			markAsUnhandled(program, relocationAddress, type, symbolIndex, symbolName, elfRelocationContext.getLog());
+			return RelocationResult.SKIPPED;
+		case I960_ElfRelocationConstants.R_960_12:
+			markAsWarning(program, relocationAddress, "R_960_12", symbolName, symbolIndex,
+					"TODO, needs support ", elfRelocationContext.getLog());
+			return RelocationResult.UNSUPPORTED;
+		case I960_ElfRelocationConstants.R_960_32:
+			markAsWarning(program, relocationAddress, "R_960_32", symbolName, symbolIndex,
+					"TODO, needs support ", elfRelocationContext.getLog());
+			return RelocationResult.UNSUPPORTED;
+		case I960_ElfRelocationConstants.R_960_IP24:
+			markAsWarning(program, relocationAddress, "R_960_IP24", symbolName, symbolIndex,
+					"TODO, needs support ", elfRelocationContext.getLog());
+			return RelocationResult.UNSUPPORTED;
+		case I960_ElfRelocationConstants.R_960_SUB:
+			markAsWarning(program, relocationAddress, "R_960_SUB", symbolName, symbolIndex,
+					"TODO, needs support ", elfRelocationContext.getLog());
+			return RelocationResult.UNSUPPORTED;
+		case I960_ElfRelocationConstants.R_960_OPTCALL:
+			markAsWarning(program, relocationAddress, "R_960_OPTCALL", symbolName, symbolIndex,
+					"TODO, needs support ", elfRelocationContext.getLog());
+			return RelocationResult.UNSUPPORTED;
+		case I960_ElfRelocationConstants.R_960_OPTCALLX:
+			markAsWarning(program, relocationAddress, "R_960_OPTCALLX", symbolName, symbolIndex,
+					"TODO, needs support ", elfRelocationContext.getLog());
+			return RelocationResult.UNSUPPORTED;
+		case I960_ElfRelocationConstants.R_960_OPTCALLXA:
+			markAsWarning(program, relocationAddress, "R_960_OPTCALLXA", symbolName, symbolIndex,
+					"TODO, needs support ", elfRelocationContext.getLog());
+			return RelocationResult.UNSUPPORTED;
+		}
+		//return new RelocationResult(Status.APPLIED, byteLength);
+	}
+
+}
diff --git a/Ghidra/Processors/i960/src/test.processors/java/ghidra/test/processors/I960_O0_EmulatorTest.java b/Ghidra/Processors/i960/src/test.processors/java/ghidra/test/processors/I960_O0_EmulatorTest.java
new file mode 100644
index 0000000000..b7bfadbc9f
--- /dev/null
+++ b/Ghidra/Processors/i960/src/test.processors/java/ghidra/test/processors/I960_O0_EmulatorTest.java
@@ -0,0 +1,39 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.test.processors;
+
+import ghidra.test.processors.support.ProcessorEmulatorTestAdapter;
+import junit.framework.Test;
+
+public class I960_O0_EmulatorTest extends ProcessorEmulatorTestAdapter {
+
+	private static final String LANGUAGE_ID = "i960:LE:32:default";
+	private static final String COMPILER_SPEC_ID = "default";
+	private static final String[] REG_DUMP_SET = new String[] {};
+
+	public I960_O0_EmulatorTest(String name) throws Exception {
+		super(name, LANGUAGE_ID, COMPILER_SPEC_ID, REG_DUMP_SET);
+	}
+
+	@Override
+	protected String getProcessorDesignator() {
+		return "i960_GCC_O0";
+	}
+
+	public static Test suite() {
+		return ProcessorEmulatorTestAdapter.buildEmulatorTestSuite(I960_O0_EmulatorTest.class);
+	}
+}
diff --git a/Ghidra/Processors/i960/src/test.processors/java/ghidra/test/processors/I960_O3_EmulatorTest.java b/Ghidra/Processors/i960/src/test.processors/java/ghidra/test/processors/I960_O3_EmulatorTest.java
new file mode 100644
index 0000000000..0f1621a34c
--- /dev/null
+++ b/Ghidra/Processors/i960/src/test.processors/java/ghidra/test/processors/I960_O3_EmulatorTest.java
@@ -0,0 +1,39 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.test.processors;
+
+import ghidra.test.processors.support.ProcessorEmulatorTestAdapter;
+import junit.framework.Test;
+
+public class I960_O3_EmulatorTest extends ProcessorEmulatorTestAdapter {
+
+	private static final String LANGUAGE_ID = "i960:LE:32:default";
+	private static final String COMPILER_SPEC_ID = "default";
+	private static final String[] REG_DUMP_SET = new String[] {};
+
+	public I960_O3_EmulatorTest(String name) throws Exception {
+		super(name, LANGUAGE_ID, COMPILER_SPEC_ID, REG_DUMP_SET);
+	}
+
+	@Override
+	protected String getProcessorDesignator() {
+		return "i960_GCC_O3";
+	}
+
+	public static Test suite() {
+		return ProcessorEmulatorTestAdapter.buildEmulatorTestSuite(I960_O3_EmulatorTest.class);
+	}
+}
-- 
2.45.1

