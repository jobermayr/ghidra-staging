From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Sigurdur Asgeirsson <siggi@undo.com>
Date: Sat, 5 Mar 2022 16:31:33 -0500
Subject: [PATCH] 4055: Add MC6800 processor specs.

Fix JSR/JMP to use EA rather than the dereferenced address.

Fix arithmetic shift right to keep MSB.

Rename OP2EA->EA2.

Revert "Fix arithmetic shift right to keep MSB.", the original implementation is just fine.

Fix spec ID.

Change to https://github.com/sigurasg/GhidraMC6800
---
 .../Processors/MC6800/certification.manifest  |  30 +
 .../MC6800/data/languages/hd6301.sinc         |  86 ++
 .../MC6800/data/languages/hd6301.slaspec      |  20 +
 .../MC6800/data/languages/mc6800.cspec        |  46 +
 .../MC6800/data/languages/mc6800.ldefs        |  69 ++
 .../MC6800/data/languages/mc6800.pspec        |  26 +
 .../MC6800/data/languages/mc6800.sinc         | 960 ++++++++++++++++++
 .../MC6800/data/languages/mc6800.slaspec      |  17 +
 .../MC6800/data/languages/mc6801.pspec        |  54 +
 .../MC6800/data/languages/mc6801.sinc         |  83 ++
 .../MC6800/data/languages/mc6801.slaspec      |  19 +
 .../MC6800/data/languages/mc68hc11.sinc       | 486 +++++++++
 .../MC6800/data/languages/mc68hc11.slaspec    |  21 +
 .../Processors/MC6800/data/manuals/README.txt |   4 +
 .../Processors/MC6800/data/manuals/mc6800.idx |  73 ++
 .../Processors/MC6800/data/manuals/mc6801.idx |  88 ++
 .../is/sort/mc6800/MC6800JSRAnalyzer.java     |  98 ++
 .../is/sort/mc6800/AbstractEmulatorTest.java  | 194 ++++
 .../sort/mc6800/AbstractIntegrationTest.java  |  77 ++
 .../src/test/java/is/sort/mc6800/CC.java      |  24 +
 .../is/sort/mc6800/DisassemblyCommonTest.java | 681 +++++++++++++
 .../is/sort/mc6800/DisassemblyHD6301Test.java |  73 ++
 .../is/sort/mc6800/DisassemblyMC6800Test.java |  49 +
 .../mc6800/DisassemblyMC6801CommonTest.java   |  94 ++
 .../is/sort/mc6800/DisassemblyMC6801Test.java |  41 +
 .../sort/mc6800/DisassemblyMC68HC11Test.java  | 414 ++++++++
 .../is/sort/mc6800/EmulatorHD6301Test.java    |  79 ++
 .../is/sort/mc6800/EmulatorMC6800Test.java    | 153 +++
 .../is/sort/mc6800/EmulatorMC6801Test.java    |  61 ++
 .../is/sort/mc6800/EmulatorMC68HC11Test.java  | 565 +++++++++++
 .../is/sort/mc6800/MC6800JSRAnalyzerTest.java |  44 +
 31 files changed, 4729 insertions(+)
 create mode 100644 Ghidra/Processors/MC6800/data/languages/hd6301.sinc
 create mode 100644 Ghidra/Processors/MC6800/data/languages/hd6301.slaspec
 create mode 100644 Ghidra/Processors/MC6800/data/languages/mc6800.cspec
 create mode 100644 Ghidra/Processors/MC6800/data/languages/mc6800.ldefs
 create mode 100644 Ghidra/Processors/MC6800/data/languages/mc6800.pspec
 create mode 100644 Ghidra/Processors/MC6800/data/languages/mc6800.sinc
 create mode 100644 Ghidra/Processors/MC6800/data/languages/mc6800.slaspec
 create mode 100644 Ghidra/Processors/MC6800/data/languages/mc6801.pspec
 create mode 100644 Ghidra/Processors/MC6800/data/languages/mc6801.sinc
 create mode 100644 Ghidra/Processors/MC6800/data/languages/mc6801.slaspec
 create mode 100644 Ghidra/Processors/MC6800/data/languages/mc68hc11.sinc
 create mode 100644 Ghidra/Processors/MC6800/data/languages/mc68hc11.slaspec
 create mode 100644 Ghidra/Processors/MC6800/data/manuals/README.txt
 create mode 100644 Ghidra/Processors/MC6800/data/manuals/mc6800.idx
 create mode 100644 Ghidra/Processors/MC6800/data/manuals/mc6801.idx
 create mode 100644 Ghidra/Processors/MC6800/src/main/java/is/sort/mc6800/MC6800JSRAnalyzer.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/AbstractEmulatorTest.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/AbstractIntegrationTest.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/CC.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyCommonTest.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyHD6301Test.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6800Test.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6801CommonTest.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6801Test.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC68HC11Test.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorHD6301Test.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC6800Test.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC6801Test.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC68HC11Test.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/MC6800JSRAnalyzerTest.java

diff --git a/Ghidra/Processors/MC6800/certification.manifest b/Ghidra/Processors/MC6800/certification.manifest
index f2d77d9f3d..3329d5c47d 100644
--- a/Ghidra/Processors/MC6800/certification.manifest
+++ b/Ghidra/Processors/MC6800/certification.manifest
@@ -21,4 +21,34 @@ data/languages/6x09_push.sinc||GHIDRA||||END|
 data/languages/H6309.slaspec||GHIDRA||||END|
 data/languages/mc146805e2.pspec||GHIDRA||||END|
 data/languages/mc146805e2.slaspec||GHIDRA||||END|
+data/languages/hd6301.sinc||Apache_License_2.0||||END|
+data/languages/hd6301.slaspec||Apache_License_2.0||||END|
+data/languages/mc6800.cspec||Apache_License_2.0||||END|
+data/languages/mc6800.ldefs||Apache_License_2.0||||END|
+data/languages/mc6800.pspec||Apache_License_2.0||||END|
+data/languages/mc6800.sinc||Apache_License_2.0||||END|
+data/languages/mc6800.slaspec||Apache_License_2.0||||END|
+data/languages/mc6801.pspec||Apache_License_2.0||||END|
+data/languages/mc6801.sinc||Apache_License_2.0||||END|
+data/languages/mc6801.slaspec||Apache_License_2.0||||END|
+data/languages/mc68hc11.sinc||Apache_License_2.0||||END|
+data/languages/mc68hc11.slaspec||Apache_License_2.0||||END|
 data/manuals/6809.idx||GHIDRA||||END|
+data/manuals/mc6800.idx||Apache_License_2.0||||END|
+data/manuals/mc6801.idx||Apache_License_2.0||||END|
+data/manuals/README.txt||Apache_License_2.0||||END|
+src/main/java/is/sort/mc6800/MC6800JSRAnalyzer.java||Apache_License_2.0||||END|
+src/test/java/is/sort/mc6800/AbstractEmulatorTest.java||Apache_License_2.0||||END|
+src/test/java/is/sort/mc6800/AbstractIntegrationTest.java||Apache_License_2.0||||END|
+src/test/java/is/sort/mc6800/CC.java||Apache_License_2.0||||END|
+src/test/java/is/sort/mc6800/DisassemblyCommonTest.java||Apache_License_2.0||||END|
+src/test/java/is/sort/mc6800/DisassemblyHD6301Test.java||Apache_License_2.0||||END|
+src/test/java/is/sort/mc6800/DisassemblyMC6800Test.java||Apache_License_2.0||||END|
+src/test/java/is/sort/mc6800/DisassemblyMC6801CommonTest.java||Apache_License_2.0||||END|
+src/test/java/is/sort/mc6800/DisassemblyMC6801Test.java||Apache_License_2.0||||END|
+src/test/java/is/sort/mc6800/DisassemblyMC68HC11Test.java||Apache_License_2.0||||END|
+src/test/java/is/sort/mc6800/EmulatorHD6301Test.java||Apache_License_2.0||||END|
+src/test/java/is/sort/mc6800/EmulatorMC6800Test.java||Apache_License_2.0||||END|
+src/test/java/is/sort/mc6800/EmulatorMC6801Test.java||Apache_License_2.0||||END|
+src/test/java/is/sort/mc6800/EmulatorMC68HC11Test.java||Apache_License_2.0||||END|
+src/test/java/is/sort/mc6800/MC6800JSRAnalyzerTest.java||Apache_License_2.0||||END|
diff --git a/Ghidra/Processors/MC6800/data/languages/hd6301.sinc b/Ghidra/Processors/MC6800/data/languages/hd6301.sinc
new file mode 100644
index 0000000000..95e7deb507
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/hd6301.sinc
@@ -0,0 +1,86 @@
+# Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+# 1-byte immediate operand.
+IMM1: "#"imm8 is imm8
+{
+    export &:1 imm8;
+}
+
+# 1-byte displacement operand.
+DISP1: imm8,X  is X; imm8
+{
+    local tmp:2 = imm8 + X;
+    export *:1 tmp;
+}
+# 1-byte memory operand.
+M1: imm8 is imm8
+{
+    export *:1 imm8;
+}
+
+:AIM IMM1, M1       is op=0x71; IMM1; M1
+{
+    logicalAnd(M1, IMM1);
+}
+
+:AIM IMM1, DISP1    is op=0x61; IMM1; DISP1
+{
+    logicalAnd(DISP1, IMM1);
+}
+
+:OIM IMM1, M1       is op=0x72; IMM1; M1
+{
+    logicalOr(M1, IMM1);
+}
+
+:OIM IMM1, DISP1    is op=0x62; IMM1; DISP1
+{
+    logicalOr(DISP1, IMM1);
+}
+
+:EIM IMM1, M1       is op=0x75; IMM1; M1
+{
+    logicalExclusiveOr(M1, IMM1);
+}
+
+:EIM IMM1, DISP1    is op=0x65; IMM1; DISP1
+{
+    logicalExclusiveOr(DISP1, IMM1);
+}
+
+:TIM IMM1, M1       is op=0x7B; IMM1; M1
+{
+    bitTest(M1, IMM1);
+}
+
+:TIM IMM1, DISP1    is op=0x6B; IMM1; DISP1
+{
+    bitTest(DISP1, IMM1);
+}
+
+:XGDX               is op=0x18
+ {
+    local tmp:2=X;
+    X=D;
+    D=tmp;
+ }
+
+:SLP                is op=0x1A
+{
+    # Sleeps the MPU, but for the purposes of analysis,
+    # execution continues after an interrupt, so this looks
+    # like a noop.
+    goto inst_next;
+}
diff --git a/Ghidra/Processors/MC6800/data/languages/hd6301.slaspec b/Ghidra/Processors/MC6800/data/languages/hd6301.slaspec
new file mode 100644
index 0000000000..7c8d501359
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/hd6301.slaspec
@@ -0,0 +1,20 @@
+# Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+@define HAS_D_REGISTER "1"
+@define HAS_2_BYTE_JSR_JMP "1"
+
+@include "mc6800.sinc"
+@include "mc6801.sinc"
+@include "hd6301.sinc"
diff --git a/Ghidra/Processors/MC6800/data/languages/mc6800.cspec b/Ghidra/Processors/MC6800/data/languages/mc6800.cspec
new file mode 100644
index 0000000000..0b48b14013
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/mc6800.cspec
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright 2022-2024 Sigurdur Asgeirsson <siggi@sort.is>
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+
+<compiler_spec>
+  <global>
+    <range space="RAM"/>
+  </global>
+  <stackpointer register="S" space="RAM" growth="negative"/>
+  <default_proto>
+    <prototype name="__stdcall" extrapop="2" stackshift="2">
+      <input>
+        <pentry minsize="1" maxsize="1">
+          <register name="A"/>
+        </pentry>
+        <pentry minsize="1" maxsize="1">
+          <register name="B"/>
+        </pentry>
+        <pentry minsize="1" maxsize="2">
+          <register name="X"/>
+        </pentry>
+      </input>
+      <output>
+        <pentry minsize="1" maxsize="1">
+          <register name="A"/>
+        </pentry>
+      </output>
+      <unaffected>
+        <register name="S"/>
+      </unaffected>
+    </prototype>
+  </default_proto>
+</compiler_spec>
diff --git a/Ghidra/Processors/MC6800/data/languages/mc6800.ldefs b/Ghidra/Processors/MC6800/data/languages/mc6800.ldefs
new file mode 100644
index 0000000000..8d9e4d272e
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/mc6800.ldefs
@@ -0,0 +1,69 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright 2022-2024 Sigurdur Asgeirsson <siggi@sort.is>
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+
+<language_definitions>
+  <language processor="MC6800"
+            endian="big"
+            size="16"
+            variant="default"
+            version="1.0"
+            slafile="mc6800.sla"
+            manualindexfile="../manuals/mc6800.idx"
+            processorspec="mc6800.pspec"
+            id="MC6800:BE:16:default">
+    <description>MC6800 Microprocessor</description>
+    <compiler name="default" spec="mc6800.cspec" id="default"/>
+    <external_name tool="IDA-PRO" name="MC6800"/>
+    <external_name tool="IDA-PRO" name="MC6802"/>
+    <external_name tool="IDA-PRO" name="MC6808"/>
+  </language>
+  <language processor="MC6801"
+            endian="big"
+            size="16"
+            variant="default"
+            version="1.0"
+            slafile="mc6801.sla"
+            manualindexfile="../manuals/mc6801.idx"
+            processorspec="mc6801.pspec"
+            id="MC6801:BE:16:default">
+    <description>MC6801 Microprocessor</description>
+    <compiler name="default" spec="mc6800.cspec" id="default"/>
+    <external_name tool="IDA-PRO" name="MC6801"/>
+  </language>
+  <language processor="HD6301"
+            endian="big"
+            size="16"
+            variant="default"
+            version="1.0"
+            slafile="hd6301.sla"
+            processorspec="mc6801.pspec"
+            id="HD6301:BE:16:default">
+    <description>HD6301 Microprocessor</description>
+    <compiler name="default" spec="mc6800.cspec" id="default"/>
+  </language>
+  <language processor="MC68HC11"
+            endian="big"
+            size="16"
+            variant="default"
+            version="1.0"
+            slafile="mc68hc11.sla"
+            processorspec="mc6801.pspec"
+            id="MC68HC11:BE:16:default">
+    <description>MC68HC11 Microprocessor</description>
+    <compiler name="default" spec="mc6800.cspec" id="default"/>
+  </language>
+</language_definitions>
diff --git a/Ghidra/Processors/MC6800/data/languages/mc6800.pspec b/Ghidra/Processors/MC6800/data/languages/mc6800.pspec
new file mode 100644
index 0000000000..1d2a22fdf7
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/mc6800.pspec
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright 2022-2024 Sigurdur Asgeirsson <siggi@sort.is>
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+
+<processor_spec>
+  <programcounter register="PC"/>
+  <default_symbols>
+    <symbol name="IRQ_VECTOR" address="0xFFF8" entry="true" type="code_ptr"/>
+    <symbol name="SWI_VECTOR" address="0xFFFA" entry="true" type="code_ptr"/>
+    <symbol name="NMI_VECTOR" address="0xFFFC" entry="true" type="code_ptr"/>
+    <symbol name="RST_VECTOR" address="0xFFFE" entry="true" type="code_ptr"/>
+  </default_symbols>
+</processor_spec>
diff --git a/Ghidra/Processors/MC6800/data/languages/mc6800.sinc b/Ghidra/Processors/MC6800/data/languages/mc6800.sinc
new file mode 100644
index 0000000000..784a2db9bd
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/mc6800.sinc
@@ -0,0 +1,960 @@
+# Copyright 2022-2024 Sigurdur Asgeirsson <siggi@sort.is>
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+define endian=big;
+define alignment=1;
+
+@define SWI_VECTOR  "0xFFFA"
+
+define space RAM     type=ram_space      size=2  default;
+define space register type=register_space size=1;
+
+# 8-bit registers A, B, CC
+define register offset=0x00 size=1 [ A B CC ];
+
+@ifdef HAS_D_REGISTER
+define register offset=0x00 size=2 [ D ];
+@endif
+
+# 16-bit registers:
+ #    PC: Program counter
+ #    S:  Stack pointer
+ #    X: IX index register
+#    Y: IY index register (MC68HC11)
+@ifdef HAS_Y_REGISTER
+define register offset=0x10 size=2 [ PC S X Y ];
+@else
+define register offset=0x10 size=2 [ PC S X ];
+@endif
+
+# Status bits in CC.
+define bitrange
+    C=CC[0,1] # C: Carry (or borrow) flag
+    V=CC[1,1] # V: Overflow flag
+    Z=CC[2,1] # Z: Zero result
+    N=CC[3,1] # N: Negative result (twos complement)
+    I=CC[4,1] # I: IRQ interrupt masked
+    H=CC[5,1] # H: Half carry flag
+;
+
+define token opbyte (8)
+    op        = (0,7)
+    addrMode  = (4,5)
+    acc_4     = (4,4)
+;
+
+define token data8 (8)
+    imm8      = (0,7)
+    simm8     = (0,7) signed
+;
+
+define token data (16)
+    imm16     = (0,15)
+;
+
+attach variables acc_4 [ A B ];
+
+################################################################
+# Constructors
+################################################################
+
+REL:  addr    is simm8  [ addr = inst_next + simm8; ]   { export *:2 addr; }
+
+# 1-byte operand, immediate/direct/indexed/extended addressing mode
+OP1: "#"imm8    is addrMode=0; imm8
+{
+    # For some reason this needs explicit sizing, or the p-code
+    # ends up picking up a zero value for all #imm8 operands.
+    export &:1 imm8;
+}
+OP1: imm8    is addrMode=1; imm8
+{
+    export *:1 imm8;
+}
+OP1: imm8,X  is addrMode=2 & X; imm8
+{
+    local tmp:2 = imm8 + X;
+    export *:1 tmp;
+}
+OP1: imm16    is addrMode=3; imm16
+{
+    export *:1 imm16;
+}
+
+# 2-byte operand, direct/indexed/extended addressing mode
+OP2: "#"imm16    is addrMode=0; imm16
+{
+    export &:2 imm16;
+}
+OP2: imm8    is addrMode=1; imm8
+{
+    export *:2 imm8;
+}
+OP2: imm8,X      is addrMode=2 & X; imm8
+{
+    local tmp:2 = X + imm8;
+    export *:2 tmp;
+}
+OP2: imm16      is addrMode=3; imm16
+{
+    export *:2 imm16;
+}
+
+@ifdef HAS_2_BYTE_JSR_JMP
+# This looks weird, but it is the only way I found to force the
+# disassembly to emit a single byte hex code.
+EA8: addr is imm8 [ addr = imm8 & 0xFF; ]
+{
+    export *:1 imm8;
+}
+@endif
+
+EA16: imm16 is imm16
+{
+    export *:1 imm16;
+}
+
+EAX: imm8,X is imm8 & X
+{
+    local tmp:2 = X + imm8;
+    export tmp;
+}
+
+
+################################################################
+# Macros
+################################################################
+
+macro setNZFlags(result)
+{
+    Z = (result == 0);
+    N = (result s< 0);
+}
+
+macro setHFlag(reg, op)
+{
+    local mask = 0x0F; # Low nibble mask
+
+    H = (((reg & mask) + (op & mask)) >> 4) & 1;
+}
+
+# Negate twos complement value in op.
+# P-code INT_2COMP.
+macro negate(op)
+{
+    op = -op;
+    V = (op == 0x80);
+    C = (op != 0);
+    setNZFlags(op);
+}
+
+# Logical complement of op. (0 => 1; 1 => 0)
+# P-code INT_NEGATE.
+macro complement(op)
+{
+    V = 0;
+    C = 1;
+    op = ~op;
+    setNZFlags(op);
+}
+
+macro logicalShiftRight(op)
+{
+    C = op & 1;
+    op = op >> 1;
+    Z = (op == 0);
+    N = 0;
+}
+
+macro rotateRightWithCarry(op)
+{
+    local carryOut = C << 7;
+    C = op & 1;
+    op = (op s>> 1) | carryOut;
+    setNZFlags(op);
+}
+
+macro rotateLeftWithCarry(op)
+{
+    local carryIn = C;
+    C = op >> 7;
+    op = (op << 1) | carryIn;
+    setNZFlags(op);
+}
+
+# Signed shift right.
+# P-code INT_SRIGHT.
+macro arithmeticShiftRight(op)
+{
+    C = op & 1;
+    op = (op s>> 1);
+    setNZFlags(op);
+}
+
+macro logicalShiftLeft(op)
+{
+    C = (op >> 7);
+    op = op << 1;
+    Z = (op == 0);
+    N = (op >> 7);
+}
+
+macro increment(op)
+{
+    V = (op == 0x7F);
+    op = op + 1;
+    setNZFlags(op);
+}
+
+macro decrement(op)
+{
+    V = (op == 0x80);
+    op = op - 1;
+    setNZFlags(op);
+}
+
+macro test(op)
+{
+    V = 0;
+    setNZFlags(op);
+}
+
+macro clear(op)
+{
+    op = 0;
+    N = 0;
+    Z = 1;
+    V = 0;
+    C = 0;
+}
+
+macro addition(reg, op)
+{
+    C = carry(reg, op);
+    V = scarry(reg, op);
+
+    reg = reg + op;
+
+    setNZFlags(reg);
+}
+
+macro additionWithCarry(reg, op)
+{
+    local carryIn = C;
+    local mask = 0x0F; # Low nibble mask
+    local tmpResult = reg + op;
+
+    H = (((reg & mask) + (op & mask) + carryIn) >> 4) & 1;
+    C = carry(reg, op) || carry(tmpResult, carryIn);
+    V = scarry(reg, op) ^^ scarry(tmpResult, carryIn);
+
+    reg = tmpResult + carryIn;
+
+    setNZFlags(reg);
+}
+
+macro subtraction(reg, op)
+{
+    V = sborrow(reg, op);
+    C = (reg < op);
+    reg = reg - op;
+    setNZFlags(reg);
+}
+
+macro subtractionWithCarry(reg, op)
+{
+    local carryIn = C;
+    local tmpResult = reg - op;
+
+    C = (reg < op) || (tmpResult < carryIn);
+    V = sborrow(reg, op) ^^ sborrow(tmpResult, carryIn);
+
+    reg = tmpResult - carryIn;
+
+    setNZFlags(reg);
+}
+
+macro compare(reg, op)
+{
+    V = sborrow(reg, op);
+    C = (reg < op);
+    local tmp = reg - op;
+    setNZFlags(tmp);
+}
+
+macro logicalAnd(reg, op)
+{
+    reg = reg & op;
+    setNZFlags(reg);
+    V = 0;
+}
+
+macro logicalOr(reg, op)
+{
+    reg = reg | op;
+    setNZFlags(reg);
+    V = 0;
+}
+
+macro logicalExclusiveOr(reg, op)
+{
+    reg = reg ^ op;
+    setNZFlags(reg);
+    V = 0;
+}
+
+macro bitTest(reg, op)
+{
+    local tmp = reg & op;
+    setNZFlags(tmp);
+    V = 0;
+}
+
+macro loadRegister(reg, op)
+{
+    reg = op;
+    setNZFlags(reg);
+    V = 0;
+}
+
+macro storeRegister(reg, op)
+{
+    op = reg;
+    setNZFlags(reg);
+    V = 0;
+}
+
+# Push 1 byte operand op
+macro Push1(reg, op)
+{
+    *:1 reg = op;
+    reg = reg - 1;
+}
+
+# Push 2 byte operand op
+macro Push2(reg, op)
+{
+    *:2 (reg - 1) = op;
+    reg = reg - 2;
+}
+
+# Pull 1 byte operand op
+macro Pull1(reg, op)
+{
+    reg = reg + 1;
+    op = *:1 reg;
+}
+
+# Pull 2 byte operand op
+macro Pull2(reg, op)
+{
+    reg = reg + 1;
+    op = *:2 reg;
+    reg = reg + 1;
+}
+
+macro PushEntireState()
+{
+    Push2(S, &:2 inst_next); # return PC address
+    Push2(S, X);
+    Push1(S, A);
+    Push1(S, B);
+    Push1(S, CC);
+}
+
+################################################################
+# Instructions
+################################################################
+
+################################################################
+# Opcode 0x00 - 0x0F, misc operations
+################################################################
+
+:NOP        is op=0x01
+{
+    # Intentional NOP.
+    goto inst_next;
+}
+
+:TAP        is op=0x06
+{
+    CC = A & 0x1F;
+}
+
+:TPA        is op=0x07
+{
+    A = CC;
+}
+
+:INX        is op=0x08
+{
+    X = X + 1;
+    Z = (X == 0);
+}
+
+:DEX        is op=0x09
+{
+    X = X - 1;
+    Z = (X == 0);
+}
+
+:CLV        is op=0x0A
+{
+    V = 0;
+}
+
+:SEV        is op=0x0B
+{
+    V = 1;
+}
+
+:CLC        is op=0x0C
+{
+    C = 0;
+}
+
+:SEC        is op=0x0D
+{
+    C = 1;
+}
+
+:CLI        is op=0x0E
+{
+    I = 0;
+}
+
+:SEI        is op=0x0F
+{
+    I = 1;
+}
+
+################################################################
+# Opcode 0x40 - 0x4F, register A addressing
+# Opcode 0x50 - 0x5F, register B addressing
+# Opcode 0x60 - 0x6F, indexed addressing
+# Opcode 0x70 - 0x7F, extended addressing
+################################################################
+
+:NEG^acc_4  is (op=0x40 | op=0x50) & acc_4
+{
+    negate(acc_4);
+}
+
+:NEG OP1    is (op=0x60 | op=0x70) ... & OP1
+{
+    negate(OP1);
+}
+
+:COM^acc_4  is (op=0x43 | op=0x53) & acc_4
+{
+    complement(acc_4);
+}
+
+:COM OP1    is (op=0x63 | op=0x73) ... & OP1
+{
+    complement(OP1);
+}
+
+:LSR^acc_4  is (op=0x44 | op=0x54) & acc_4
+{
+    logicalShiftRight(acc_4);
+}
+
+:LSR OP1    is (op=0x64 | op=0x74) ... & OP1
+{
+    logicalShiftRight(OP1);
+}
+
+:ROR^acc_4  is (op=0x46 | op=0x56) & acc_4
+{
+    rotateRightWithCarry(acc_4);
+}
+
+:ROR OP1    is (op=0x66 | op=0x76) ... & OP1
+{
+    rotateRightWithCarry(OP1);
+}
+
+:ASR^acc_4  is (op=0x47 | op=0x57) & acc_4
+{
+    arithmeticShiftRight(acc_4);
+}
+
+:ASR OP1    is (op=0x67 | op=0x77) ... & OP1
+{
+    arithmeticShiftRight(OP1);
+}
+
+:ASL^acc_4  is (op=0x48 | op=0x58) & acc_4
+{
+    logicalShiftLeft(acc_4);
+}
+
+:ASL OP1    is (op=0x68 | op=0x78) ... & OP1
+{
+    logicalShiftLeft(OP1);
+}
+
+:ROL^acc_4  is (op=0x49 | op=0x59) & acc_4
+{
+    rotateLeftWithCarry(acc_4);
+}
+
+:ROL OP1    is (op=0x69 | op=0x79) ... & OP1
+{
+    rotateLeftWithCarry(OP1);
+}
+
+:DEC^acc_4  is (op=0x4A | op=0x5A) & acc_4
+{
+    decrement(acc_4);
+}
+
+:DEC OP1    is (op=0x6A | op=0x7A) ... & OP1
+{
+    decrement(OP1);
+}
+
+:INC^acc_4  is (op=0x4C | op=0x5C) & acc_4
+{
+    increment(acc_4);
+}
+
+:INC OP1    is (op=0x6C | op=0x7C) ... & OP1
+{
+    increment(OP1);
+}
+
+:TST^acc_4  is (op=0x4D | op=0x5D) & acc_4
+{
+    test(acc_4);
+}
+
+:TST OP1    is (op=0x6D | op=0x7D) ... & OP1
+{
+    test(OP1);
+}
+
+:JMP EAX    is op=0x6E; EAX
+{
+    goto [EAX];
+}
+
+:JMP EA16   is op=0x7E; EA16
+{
+    goto EA16;
+}
+
+:CLR^acc_4  is (op=0x4F | op=0x5F) & acc_4
+{
+    clear(acc_4);
+}
+
+:CLR OP1    is (op=0x6F | op=0x7F) ... & OP1
+{
+    clear(OP1);
+}
+
+################################################################
+# Opcode 0x10 - 0x1F, misc. addressing
+################################################################
+
+:SBA        is op=0x10
+{
+    subtraction(A, B);
+}
+
+:CBA        is op=0x11
+{
+    compare(A, B);
+}
+
+:TAB        is op=0x16
+{
+    loadRegister(B, A);
+}
+
+:TBA        is op=0x17
+{
+    loadRegister(A, B);
+}
+
+:DAA        is op=0x19
+{
+    local highA:1 = A >> 4;
+    local lowA:1  = A & 0x0F;
+    local cc1 = (C == 1 | highA > 9 | (highA > 8) & (lowA > 9));
+    local cc2 = (H == 1 | lowA > 9);
+
+    if ( cc1 & cc2 )
+    goto <case1>;
+    if ( cc1 )
+    goto <case2>;
+    if ( cc2 )
+    goto <case3>;
+    goto <exitDAA>;
+
+    <case1>
+    C = carry(A, 0x66);
+    A = A + 0x66;
+    goto <exitDAA>;
+    <case2>
+    C = carry(A, 0x60);
+    A = A + 0x60;
+    goto <exitDAA>;
+    <case3>
+    C = carry(A, 0x06);
+    A = A + 0x06;
+    goto <exitDAA>;
+
+    <exitDAA>
+    setNZFlags(A);
+}
+
+:ABA        is op=0x1B
+{
+    addition(A, B);
+}
+
+################################################################
+# Opcode 0x20 - 0x2F, relative addressing
+################################################################
+
+:BRA REL    is op=0x20; REL
+{
+    goto REL;
+}
+
+:BHI REL    is op=0x22; REL
+{
+    if (C == 0 && Z == 0) goto REL;
+}
+
+:BLS REL    is op=0x23; REL
+{
+    if (C || Z) goto REL;
+}
+
+#:BHS REL    is op=0x24; REL # See BCC
+
+:BCC REL    is op=0x24; REL
+{
+    if (C == 0) goto REL;
+}
+
+#:BLO REL    is op=0x25; REL # see BCS
+
+:BCS REL    is op=0x25; REL
+{
+    if (C) goto REL;
+}
+
+:BNE REL    is op=0x26; REL
+{
+    if (Z == 0) goto REL;
+}
+
+:BEQ REL    is op=0x27; REL
+{
+    if (Z) goto REL;
+}
+
+:BVC REL    is op=0x28; REL
+{
+    if (V == 0) goto REL;
+}
+
+:BVS REL    is op=0x29; REL
+{
+    if (V) goto REL;
+}
+
+:BPL REL    is op=0x2A; REL
+{
+    if (N == 0) goto REL;
+}
+
+:BMI REL    is op=0x2B; REL
+{
+    if (N) goto REL;
+}
+
+:BGE REL    is op=0x2C; REL
+{
+    if (N == V) goto REL;
+}
+
+:BLT REL    is op=0x2D; REL
+{
+    if (N != V) goto REL;
+}
+
+:BGT REL    is op=0x2E; REL
+{
+    if ((Z == 0) && (N == V)) goto REL;
+}
+
+:BLE REL    is op=0x2F; REL
+{
+    if (Z || (N != V)) goto REL;
+}
+
+################################################################
+# Opcode 0x30 - 0x3F, misc. addressing
+################################################################
+
+:TSX        is op=0x30
+{
+    X = S + 1;
+}
+
+:INS        is op=0x31
+{
+    S = S + 1;
+}
+
+:PULA       is op=0x32
+{
+    Pull1(S, A);
+}
+
+:PULB       is op=0x33
+{
+    Pull1(S, B);
+}
+
+:DES        is op=0x34
+{
+    S = S - 1;
+}
+
+:TXS        is op=0x35
+{
+    S = X - 1;
+}
+
+:PSHA       is op=0x36
+{
+    Push1(S, A);
+}
+
+:PSHB       is op=0x37
+{
+    Push1(S, B);
+}
+
+:RTS        is op=0x39
+{
+    local addr:2;
+    Pull2(S, addr);
+    return [addr];
+}
+
+:RTI        is op=0x3B
+{
+    local addr:2;
+    Pull1(S, CC);
+    Pull1(S, B);
+    Pull1(S, A);
+    Pull2(S, X);
+    Pull2(S, addr);
+    return [addr];
+}
+
+:WAI        is op=0x3E
+{
+    PushEntireState();
+}
+
+:SWI        is op=0x3F
+{
+    PushEntireState();
+    I = 1;
+    # TODO(siggi): This doesn't look right - missing indirection?
+    tmp:2 = $(SWI_VECTOR);
+    call [tmp];
+}
+
+################################################################
+# Opcode 0x80 - 0x8F, immediate addressing
+# Opcode 0x90 - 0x9F, direct addressing
+# Opcode 0xA0 - 0xAF, indexed addressing
+# Opcode 0xB0 - 0xBF, extended addressing
+# Opcode 0xC0 - 0xCF, immediate addressing
+# Opcode 0xD0 - 0xDF, direct addressing
+# Opcode 0xE0 - 0xEF, indexed addressing
+# Opcode 0xF0 - 0xFF, extended addressing
+################################################################
+
+:SUBA OP1   is (op=0x80 | op=0x90 | op=0xA0 | op=0xB0) ... & OP1
+{
+    subtraction(A, OP1);
+}
+
+:SUBB OP1   is (op=0xC0 | op=0xD0 | op=0xE0 | op=0xF0) ... & OP1
+{
+    subtraction(B, OP1);
+}
+
+:CMPA OP1   is (op=0x81 | op=0x91 | op=0xA1 | op=0xB1) ... & OP1
+{
+    compare(A, OP1);
+}
+
+:CMPB OP1   is (op=0xC1 | op=0xD1 | op=0xE1 | op=0xF1) ... & OP1
+{
+    compare(B, OP1);
+}
+
+:SBCA OP1   is (op=0x82 | op=0x92 | op=0xA2 | op=0xB2) ... & OP1
+{
+    subtractionWithCarry(A, OP1);
+}
+
+:SBCB OP1   is (op=0xC2 | op=0xD2 | op=0xE2 | op=0xF2) ... & OP1
+{
+    subtractionWithCarry(B, OP1);
+}
+
+:ANDA OP1   is (op=0x84 | op=0x94 | op=0xA4 | op=0xB4) ... & OP1
+{
+    logicalAnd(A, OP1);
+}
+
+:ANDB OP1   is (op=0xC4 | op=0xD4 | op=0xE4 | op=0xF4) ... & OP1
+{
+    logicalAnd(B, OP1);
+}
+
+:BITA OP1   is (op=0x85 | op=0x95 | op=0xA5 | op=0xB5) ... & OP1
+{
+    bitTest(A, OP1);
+}
+
+:BITB OP1   is (op=0xC5 | op=0xD5 | op=0xE5 | op=0xF5) ... & OP1
+{
+    bitTest(B, OP1);
+}
+
+:LDAA OP1   is (op=0x86 | op=0x96 | op=0xA6 | op=0xB6) ... & OP1
+{
+    loadRegister(A, OP1);
+}
+
+:LDAB OP1   is (op=0xC6 | op=0xD6 | op=0xE6 | op=0xF6) ... & OP1
+{
+    loadRegister(B, OP1);
+}
+
+:STAA OP1   is (op=0x97 | op=0xA7 | op=0xB7) ... & OP1
+{
+    storeRegister(A, OP1);
+}
+
+:STAB OP1   is (op=0xD7 | op=0xE7 | op=0xF7) ... & OP1
+{
+    storeRegister(B, OP1);
+}
+
+:EORA OP1   is (op=0x88 | op=0x98 | op=0xA8 | op=0xB8) ... & OP1
+{
+    logicalExclusiveOr(A, OP1);
+}
+
+:EORB OP1   is (op=0xC8 | op=0xD8 | op=0xE8 | op=0xF8) ... & OP1
+{
+    logicalExclusiveOr(B, OP1);
+}
+
+:ADCA OP1   is (op=0x89 | op=0x99 | op=0xA9 | op=0xB9) ... & OP1
+{
+    additionWithCarry(A, OP1);
+}
+
+:ADCB OP1   is (op=0xC9 | op=0xD9 | op=0xE9 | op=0xF9) ... & OP1
+{
+    additionWithCarry(B, OP1);
+}
+
+:ORAA OP1   is (op=0x8A | op=0x9A | op=0xAA | op=0xBA) ... & OP1
+{
+    logicalOr(A, OP1);
+}
+
+:ORAB OP1   is (op=0xCA | op=0xDA | op=0xEA | op=0xFA) ... & OP1
+{
+    logicalOr(B, OP1);
+}
+
+:ADDA OP1   is (op=0x8B | op=0x9B | op=0xAB | op=0xBB) ... & OP1
+{
+    setHFlag(A, OP1);
+    addition(A, OP1);
+}
+
+:ADDB OP1   is (op=0xCB | op=0xDB | op=0xEB | op=0xFB) ... & OP1
+{
+    setHFlag(B, OP1);
+    addition(B, OP1);
+}
+
+:CPX OP2    is (op=0x8C | op=0x9C | op=0xAC | op=0xBC) ... & OP2
+{
+@ifdef HAS_BROKEN_CMPX
+    # Can't use the compare macro here because there is no carry.
+    V = sborrow(X, OP2);
+    local tmp = X - OP2;
+    setNZFlags(tmp);
+@else
+    compare(X, OP2);
+@endif
+}
+
+:BSR REL    is op=0x8D; REL
+{
+    Push2(S, &:2 inst_next);
+    call REL;
+}
+
+:JSR EAX    is op=0xAD; EAX
+{
+    Push2(S, &:2 inst_next);
+    call [EAX];
+}
+
+:JSR EA16   is op=0xBD; EA16
+{
+    Push2(S, &:2 inst_next);
+    call EA16;
+}
+
+:LDS OP2    is (op=0x8E | op=0x9E | op=0xAE | op=0xBE) ... & OP2
+{
+    loadRegister(S, OP2);
+}
+
+:LDX OP2    is (op=0xCE | op=0xDE | op=0xEE | op=0xFE) ... & OP2
+{
+    loadRegister(X, OP2);
+}
+
+:STS OP2    is (op=0x9F | op=0xAF | op=0xBF) ... & OP2
+{
+    storeRegister(S, OP2);
+}
+
+:STX OP2    is (op=0xDF | op=0xEF | op=0xFF) ... & OP2
+{
+    storeRegister(X, OP2);
+}
diff --git a/Ghidra/Processors/MC6800/data/languages/mc6800.slaspec b/Ghidra/Processors/MC6800/data/languages/mc6800.slaspec
new file mode 100644
index 0000000000..ac92564f38
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/mc6800.slaspec
@@ -0,0 +1,17 @@
+# Copyright 2022-2024 Sigurdur Asgeirsson <siggi@sort.is>
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+@define HAS_BROKEN_CMPX "1"
+
+@include "mc6800.sinc"
diff --git a/Ghidra/Processors/MC6800/data/languages/mc6801.pspec b/Ghidra/Processors/MC6800/data/languages/mc6801.pspec
new file mode 100644
index 0000000000..e932b02c7f
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/mc6801.pspec
@@ -0,0 +1,54 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright 2022-2024 Sigurdur Asgeirsson <siggi@sort.is>
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+
+<processor_spec>
+  <programcounter register="PC"/>
+
+  <default_memory_blocks>
+    <memory_block name="Internal Registers" start_address="RAM:0" length="0x20" initialized="false"/>
+  </default_memory_blocks>
+
+  <default_symbols>
+    <symbol name="P1DDR" address="0x00"/>
+    <symbol name="P2DDR" address="0x01"/>
+    <symbol name="P1DATA" address="0x02"/>
+    <symbol name="P2DATA" address="0x03"/>
+    <symbol name="P3DDR" address="0x04"/>
+    <symbol name="P4DDR" address="0x05"/>
+    <symbol name="P3DATA" address="0x06"/>
+    <symbol name="P4DATA" address="0x07"/>
+    <symbol name="TCSR" address="0x08"/>
+    <symbol name="TIMER" address="0x09"/>
+    <symbol name="OUTCMP" address="0x0B"/>
+    <symbol name="IMPCAP" address="0x0D"/>
+    <symbol name="P3SCR" address="0x0F"/>
+    <symbol name="RMCR" address="0x10"/>
+    <symbol name="TRCS" address="0x11"/>
+    <symbol name="RX" address="0x12"/>
+    <symbol name="TX" address="0x13"/>
+    <symbol name="RAMCR" address="0x14"/>
+
+    <symbol name="SCI_VECTOR" address="0xFFF0" entry="true" type="code_ptr"/>
+    <symbol name="TOF_VECTOR" address="0xFFF2" entry="true" type="code_ptr"/>
+    <symbol name="OCF_VECTOR" address="0xFFF4" entry="true" type="code_ptr"/>
+    <symbol name="ICF_VECTOR" address="0xFFF6" entry="true" type="code_ptr"/>
+    <symbol name="IRQ_VECTOR" address="0xFFF8" entry="true" type="code_ptr"/>
+    <symbol name="SWI_VECTOR" address="0xFFFA" entry="true" type="code_ptr"/>
+    <symbol name="NMI_VECTOR" address="0xFFFC" entry="true" type="code_ptr"/>
+    <symbol name="RST_VECTOR" address="0xFFFE" entry="true" type="code_ptr"/>
+  </default_symbols>
+</processor_spec>
diff --git a/Ghidra/Processors/MC6800/data/languages/mc6801.sinc b/Ghidra/Processors/MC6800/data/languages/mc6801.sinc
new file mode 100644
index 0000000000..2d36c1eff7
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/mc6801.sinc
@@ -0,0 +1,83 @@
+# Copyright 2022-2024 Sigurdur Asgeirsson <siggi@sort.is>
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+:ABX        is op=0x3A
+{
+    # No effect on flags.
+    X = X + zext(B);
+}
+
+:ADDD OP2   is (op=0xC3 | op=0xD3 | op=0xF3 | op=0xE3) ... & OP2
+{
+    addition(D, OP2);
+}
+
+:ASLD       is op=0x05
+{
+    C = D[15, 1];
+    D = D << 1;
+    Z = (D == 0);
+    N = D[15, 1];
+}
+
+:BRN        is op=0x21
+{
+    # Branch never is an elaborate NOP.
+    goto inst_next;
+}
+
+:JSR EA8    is op=0x9d; EA8
+{
+    Push2(S, &:2 inst_next);
+    call EA8;
+}
+
+:LDD OP2    is (op=0xCC | op=0xDC | op=0xFC | op=0xEC) ... & OP2
+{
+    loadRegister(D, OP2);
+}
+
+:LSRD       is op=0x04
+{
+    C = D[0, 1];
+    D = D << 1;
+    Z = (D == 0);
+    N = D[15, 1];
+}
+
+:MUL        is op=0x3D
+{
+    D = zext(A) * zext(B);
+    C = D[15,1];
+}
+
+:PSHX       is op=0x3C
+{
+    Push2(S, X);
+}
+
+:PULX       is op=0x38
+{
+    Pull2(S, X);
+}
+
+:STD OP2    is (op=0xDD | op=0xFD | op=0xED) ... & OP2
+{
+    storeRegister(D, OP2);
+}
+
+:SUBD OP2   is (op=0x83 | op=0x93 | op=0xB3 | op=0xA3) ... & OP2
+{
+    subtraction(D, OP2);
+}
diff --git a/Ghidra/Processors/MC6800/data/languages/mc6801.slaspec b/Ghidra/Processors/MC6800/data/languages/mc6801.slaspec
new file mode 100644
index 0000000000..04c9cab119
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/mc6801.slaspec
@@ -0,0 +1,19 @@
+# Copyright 2022-2024 Sigurdur Asgeirsson <siggi@sort.is>
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+@define HAS_D_REGISTER "1"
+@define HAS_2_BYTE_JSR_JMP "1"
+
+@include "mc6800.sinc"
+@include "mc6801.sinc"
diff --git a/Ghidra/Processors/MC6800/data/languages/mc68hc11.sinc b/Ghidra/Processors/MC6800/data/languages/mc68hc11.sinc
new file mode 100644
index 0000000000..4e22a1317d
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/mc68hc11.sinc
@@ -0,0 +1,486 @@
+# Copyright 2025 Sigurdur Asgeirsson <siggi@sort.is>
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+OP1Y: imm8,Y  is addrMode & Y; imm8
+{
+    local tmp:2 = imm8 + Y;
+    export *:1 tmp;
+}
+
+OP2Y: imm8,Y      is addrMode=2 & Y; imm8
+{
+    local tmp:2 = Y + imm8;
+    export *:2 tmp;
+}
+
+EAY: imm8,Y is imm8 & Y
+{
+    local tmp:2 = Y + imm8;
+    export tmp;
+}
+
+MASK: imm8          is imm8 {
+    export &:1 imm8;
+}
+
+OP1X: imm8,X  is addrMode & X; imm8
+{
+    local tmp:2 = imm8 + X;
+    export *:1 tmp;
+}
+
+
+# The 6800 instructions with imm,Y address mode.
+
+:NEG OP1Y               is op=0x18; op=0x60 ... & OP1Y
+{
+    negate(OP1Y);
+}
+
+:COM OP1Y               is op=0x18; op=0x63 ... & OP1Y
+{
+    complement(OP1Y);
+}
+
+:LSR OP1Y               is op=0x18; op=0x64 ... & OP1Y
+{
+    logicalShiftRight(OP1Y);
+}
+
+:ROR OP1Y               is op=0x18; op=0x66 ... & OP1Y
+{
+    rotateRightWithCarry(OP1Y);
+}
+
+:ASR OP1Y               is op=0x18; op=0x67 ... & OP1Y
+{
+    arithmeticShiftRight(OP1Y);
+}
+
+:ASL OP1Y               is op=0x18; op=0x68 ... & OP1Y
+{
+    logicalShiftLeft(OP1Y);
+}
+
+:ROL OP1Y               is op=0x18; op=0x69 ... & OP1Y
+{
+    rotateLeftWithCarry(OP1Y);
+}
+
+:DEC OP1Y               is op=0x18; op=0x6A ... & OP1Y
+{
+    decrement(OP1Y);
+}
+
+:INC OP1Y               is op=0x18; op=0x6C ... & OP1Y
+{
+    increment(OP1Y);
+}
+
+:TST OP1Y               is op=0x18; op=0x6D ... & OP1Y
+{
+    test(OP1Y);
+}
+
+:JMP EAY                is op=0x18; op=0x6E; EAY
+{
+    goto [EAY];
+}
+
+:JSR EAY                is op=0x18; op=0xAD; EAY
+{
+    local addr:2 = inst_next;
+    Push2(S, addr);
+    call [EAY];
+}
+
+:LDS OP2Y               is op=0x18; op=0xAE ... & OP2Y
+{
+    loadRegister(S, OP2Y);
+}
+
+:STS OP2Y               is op=0x18; op=0xAF ... & OP2Y
+{
+    storeRegister(S, OP2Y);
+}
+
+:STD OP2Y               is op=0x18; op=0xED ... & OP2Y
+{
+    storeRegister(D, OP2Y);
+}
+
+:SUBD OP2Y              is op=0x18; op=0xA3 ... & OP2Y
+{
+    subtraction(D, OP2Y);
+}
+
+:CLR OP1Y               is op=0x18; op=0x6F ... & OP1Y
+{
+    clear(OP1Y);
+}
+
+:SUBA OP1Y              is op=0x18; op=0xA0 ... & OP1Y
+{
+    subtraction(A, OP1Y);
+}
+
+:SUBB OP1Y              is op=0x18; op=0xE0 ... & OP1Y
+{
+    subtraction(B, OP1Y);
+}
+
+:CMPA OP1Y              is op=0x18; op=0xA1 ... & OP1Y
+{
+    compare(A, OP1Y);
+}
+
+:CMPB OP1Y              is op=0x18; op=0xE1 ... & OP1Y
+{
+    compare(B, OP1Y);
+}
+
+:SBCA OP1Y              is op=0x18; op=0xA2 ... & OP1Y
+{
+    subtractionWithCarry(A, OP1Y);
+}
+
+:SBCB OP1Y              is op=0x18; op=0xE2 ... & OP1Y
+{
+    subtractionWithCarry(B, OP1Y);
+}
+
+:ANDA OP1Y              is op=0x18; op=0xA4 ... & OP1Y
+{
+    logicalAnd(A, OP1Y);
+}
+
+:ANDB OP1Y              is op=0x18; op=0xE4 ... & OP1Y
+{
+    logicalAnd(B, OP1Y);
+}
+
+:BITA OP1Y              is op=0x18; op=0xA5 ... & OP1Y
+{
+    bitTest(A, OP1Y);
+}
+
+:BITB OP1Y              is op=0x18; op=0xE5 ... & OP1Y
+{
+    bitTest(B, OP1Y);
+}
+
+:LDAA OP1Y              is op=0x18; op=0xA6 ... & OP1Y
+{
+    loadRegister(A, OP1Y);
+}
+
+:LDAB OP1Y              is op=0x18; op=0xE6 ... & OP1Y
+{
+    loadRegister(B, OP1Y);
+}
+
+:STAA OP1Y              is op=0x18; op=0xA7 ... & OP1Y
+{
+    storeRegister(A, OP1Y);
+}
+
+:STAB OP1Y              is op=0x18; op=0xE7 ... & OP1Y
+{
+    storeRegister(B, OP1Y);
+}
+
+:EORA OP1Y              is op=0x18; op=0xA8 ... & OP1Y
+{
+    logicalExclusiveOr(A, OP1Y);
+}
+
+:EORB OP1Y              is op=0x18; op=0xE8 ... & OP1Y
+{
+    logicalExclusiveOr(B, OP1Y);
+}
+
+:ADCA OP1Y              is op=0x18; op=0xA9 ... & OP1Y
+{
+    additionWithCarry(A, OP1Y);
+}
+
+:ADCB OP1Y              is op=0x18; op=0xE9 ... & OP1Y
+{
+    additionWithCarry(B, OP1Y);
+}
+
+:ORAA OP1Y              is op=0x18; op=0xAA ... & OP1Y
+{
+    logicalOr(A, OP1Y);
+}
+
+:ORAB OP1Y              is op=0x18; op=0xEA ... & OP1Y
+{
+    logicalOr(B, OP1Y);
+}
+
+:ADDA OP1Y              is op=0x18; op=0xAB ... & OP1Y
+{
+    setHFlag(A, OP1Y);
+    addition(A, OP1Y);
+}
+
+:ADDB OP1Y              is op=0x18; op=0xEB ... & OP1Y
+{
+    setHFlag(B, OP1Y);
+    addition(B, OP1Y);
+}
+
+# The 6800 Y specific instructions.
+:INY                    is op=0x18; op=0x08
+{
+    Y = Y + 1;
+    Z = (Y == 0);
+}
+
+:DEY                    is op=0x18; op=0x09
+{
+    Y = Y - 1;
+    Z = (Y == 0);
+}
+
+:TSY                    is op=0x18; op=0x30
+{
+    Y = S + 1;
+}
+
+:TYS                    is op=0x18; op=0x35
+{
+    S = Y - 1;
+}
+
+:CPY OP2                is op=0x18; (op=0x8C | op=0x9C | op=0xBC) ... & OP2
+{
+    compare(Y, OP2);
+}
+:CPY OP2Y               is op=0x18; op=0xAC ... & OP2Y
+{
+    compare(Y, OP2Y);
+}
+:CPY OP2                is op=0x1A; op=0xAC ... & OP2
+{
+    compare(Y, OP2);
+}
+
+:LDY OP2                is op=0x18; (op=0xCE | op=0xDE | op=0xFE) ... & OP2
+{
+    loadRegister(Y, OP2);
+}
+:LDY OP2Y               is op=0x18; op=0xEE ... & OP2Y
+{
+    loadRegister(Y, OP2Y);
+}
+:LDY OP2                is op=0x1A; op=0xEE ... & OP2
+{
+    loadRegister(Y, OP2);
+}
+
+:STY OP2                is op=0x18; (op=0xDF | op=0xFF) ... & OP2
+{
+    storeRegister(Y, OP2);
+}
+:STY OP2Y               is op=0x18; op=0xEF ... & OP2Y
+{
+    storeRegister(Y, OP2Y);
+}
+:STY OP2                is op=0x1A; op=0xEF ... & OP2
+{
+    storeRegister(Y, OP2);
+}
+
+:ABY                    is op=0x18; op=0x3A
+{
+    # No effect on flags.
+    Y = Y + zext(B);
+}
+
+:PSHY                   is op=0x18; op=0x3C
+{
+    Push2(S, Y);
+}
+
+:PULY                   is op=0x18; op=0x38
+{
+    Pull2(S, Y);
+}
+
+# MC68HC11 specific instructions.
+
+:TEST                   is op=0x00 {
+    # This is a NOP for our purposes.
+    goto inst_next;
+}
+
+:IDIV                   is op=0x02 {
+    local num:2 = D;
+    local den:2 = X;
+
+    if (den == 0)
+        goto <divByZero>;
+
+    X = num / den;
+    D = num % den;
+    goto <setFlags>;
+
+    <divByZero>
+    X = 0xFFFF;
+
+    <setFlags>
+    Z = (X == 0);
+    V = 0;
+    C = (den == 0);
+}
+
+:FDIV                   is op=0x03 {
+    local num:4 = zext(D);
+    local den:4 = zext(X);
+
+    V = 0;
+
+    if (den == 0)
+        goto <divByZero>;
+
+    if (den <= num)
+        goto <overflow>;
+
+    local extNum:4 = num << 16;
+    local tmp:4;
+    tmp = extNum / den;
+    X = tmp:2;
+
+    tmp = extNum % den;
+    D = tmp:2;
+    goto <setFlags>;
+
+    <overflow>
+    V = 1;
+
+    <divByZero>
+    X = 0xFFFF;
+
+    <setFlags>
+    Z = (X == 0);
+    C = (den == 0);
+}
+
+:BRSET OP1 MASK REL     is op=0x12 ... & OP1; MASK; REL
+{
+    if ((OP1 & MASK) != 0)
+        goto REL;
+}
+# This opcode has the wrong addrMode for OP1.
+:BRSET OP1X MASK REL    is op=0x1E ... & OP1X; MASK; REL
+{
+    if ((OP1X & MASK) != 0)
+        goto REL;
+}
+:BRSET OP1Y MASK REL    is op=0x18; op=0x1E ... & OP1Y; MASK; REL
+{
+    if ((OP1Y & MASK) != 0)
+        goto REL;
+}
+
+:BRCLR OP1 MASK REL     is op=0x13 ... & OP1; MASK; REL
+{
+    if ((OP1 & MASK) == 0)
+        goto REL;
+}
+# This opcode has the wrong addrMode for OP1.
+:BRCLR OP1X MASK REL    is op=0x1F ... & OP1X ; MASK; REL
+{
+    if ((OP1X & MASK) == 0)
+        goto REL;
+}
+:BRCLR OP1Y MASK REL    is op=0x18; op=0x1F ... & OP1Y; MASK; REL
+{
+    if ((OP1Y & MASK:1) == 0)
+        goto REL;
+}
+
+:BSET   OP1 MASK        is op=0x14 ... & OP1; MASK {
+    OP1 = OP1 | MASK;
+}
+# This opcode has the wrong addrMode for OP1.
+:BSET OP1X MASK         is op=0x1C ... & OP1X; MASK {
+    OP1X = OP1X | MASK;
+}
+:BSET   OP1Y MASK       is op=0x18; op=0x1C ... & OP1Y; MASK {
+    OP1Y = OP1Y | MASK;
+}
+
+:BCLR   OP1 MASK        is op=0x15 ... & OP1; MASK {
+    OP1 = OP1 & ~MASK;
+}
+# This opcode has the wrong addrMode for OP1.
+:BCLR OP1X MASK         is op=0x1D ... & OP1X; MASK {
+    OP1X = OP1X & ~MASK;
+}
+:BCLR   OP1Y MASK       is op=0x18; op=0x1D ... & OP1Y; MASK {
+    OP1Y = OP1Y & ~MASK;
+}
+
+:XGDX                   is op=0x8F {
+    local tmp:2=X;
+    X=D;
+    D=tmp;
+}
+:XGDY                   is op=0x18; op=0x8F {
+    local tmp:2=Y;
+    Y=D;
+    D=tmp;
+}
+
+:STOP                   is op=0xCF {
+    # Treat as a NOP for disassembly and emulation?
+    goto inst_next;
+}
+
+# 6801 Y-specific instructions.
+
+:ADDD OP2Y              is op=0x18; op=0xE3 ... & OP2Y
+{
+    addition(D, OP2Y);
+}
+
+:LDD OP2Y               is op=0x18; op=0xEC ... & OP2Y
+{
+    loadRegister(D, OP2Y);
+}
+
+:CPD OP2                is op=0x1A; (op=0x83 | op=0x93 | op=0xA3 | op=0xB3) ... & OP2
+{
+    compare(D, OP2);
+}
+:CPD OP2Y               is op=0xCD; op=0xA3 ... & OP2Y
+{
+    compare(D, OP2Y);
+}
+
+:CPX OP2Y               is op=0xCD; op=0xAC ... & OP2Y
+{
+    compare(X, OP2Y);
+}
+
+:LDX OP2Y               is op=0xCD; op=0xEE ... & OP2Y {
+    loadRegister(X, OP2Y);
+}
+
+:STX OP2Y               is op=0xCD; op=0xEF ... & OP2Y {
+    storeRegister(X, OP2Y);
+}
diff --git a/Ghidra/Processors/MC6800/data/languages/mc68hc11.slaspec b/Ghidra/Processors/MC6800/data/languages/mc68hc11.slaspec
new file mode 100644
index 0000000000..29319d235c
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/mc68hc11.slaspec
@@ -0,0 +1,21 @@
+# Copyright 2025 Sigurdur Asgeirsson <siggi@sort.is>
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+@define HAS_D_REGISTER "1"
+@define HAS_2_BYTE_JSR_JMP "1"
+@define HAS_Y_REGISTER "1"
+
+@include "mc6800.sinc"
+@include "mc6801.sinc"
+@include "mc68hc11.sinc"
diff --git a/Ghidra/Processors/MC6800/data/manuals/README.txt b/Ghidra/Processors/MC6800/data/manuals/README.txt
new file mode 100644
index 0000000000..467034f869
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/manuals/README.txt
@@ -0,0 +1,4 @@
+Sadly it's not possible to specify a URL for processor manuals,
+but the MC6800 manual referenced in the index file is available at
+
+https://bitsavers.org/components/motorola/6800/Motorola_M6800_Programming_Reference_Manual_M68PRM(D)_Nov76.pdf
\ No newline at end of file
diff --git a/Ghidra/Processors/MC6800/data/manuals/mc6800.idx b/Ghidra/Processors/MC6800/data/manuals/mc6800.idx
new file mode 100644
index 0000000000..eef45a768b
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/manuals/mc6800.idx
@@ -0,0 +1,73 @@
+@mc6800.pdf [Motorola M6800 Programming Reference Manual M68PRM(D) Nov76]
+ABA, 36
+ADC, 37
+ADD, 38
+AND, 39
+ASL, 40
+ASR, 41
+BCC, 42
+BCS, 43
+BEQ, 44
+BGE, 45
+BGT, 46
+BHI, 47
+BIT, 48
+BLE, 49
+BLS, 50
+BLT, 51
+BMI, 52
+BNE, 53
+BPL, 54
+BRA, 55
+BSR, 56
+BVC, 57
+BVS, 58
+CBA, 59
+CLC, 60
+CLI, 61
+CLR, 62
+CLV, 63
+CMP, 64
+COM, 65
+CPX, 66
+DAA, 67
+DEC, 69
+DES, 70
+DEX, 71
+EOR, 72
+INC, 73
+INS, 74
+INX, 75
+JMP, 76
+JSR, 77
+LDA, 78
+LDS, 79
+LDX, 80
+LSR, 81
+NEG, 82
+NOP, 83
+ORA, 84
+PSH, 85
+PUL, 86
+ROL, 87
+ROR, 88
+RTI, 89
+RTS, 90
+SBA, 91
+SBC, 92
+SEC, 93
+SEI, 94
+SEV, 95
+STA, 96
+STS, 97
+STX, 98
+SUB, 99
+SWI, 100
+TAB, 102
+TAP, 103
+TBA, 104
+TPA, 105
+TST, 106
+TSX, 107
+TXS, 108
+WAI, 109
diff --git a/Ghidra/Processors/MC6800/data/manuals/mc6801.idx b/Ghidra/Processors/MC6800/data/manuals/mc6801.idx
new file mode 100644
index 0000000000..4acf4058e4
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/manuals/mc6801.idx
@@ -0,0 +1,88 @@
+@mc6801.pdf [MC6801RM_AD2_MC6801_Reference_Manual_May84.pdf]
+ABA, 270
+ABX, 271
+ADC, 272
+ADD, 273
+ADDD, 274
+AND, 275
+ASL, 276
+ASLD, 277
+ASR, 278
+BCC, 279
+BCS, 280
+BEQ, 281
+BGE, 282
+BGT, 283
+BHI, 284
+BHS, 285
+BIT, 286
+BLE, 287
+BLO, 288
+BLS, 289
+BLT, 290
+BMI, 291
+BNE, 292
+BPL, 293
+BRA, 294
+BRN, 295
+BSR, 296
+BVC, 297
+BVS, 298
+CBA, 299
+CLC, 300
+CLI, 301
+CLR, 302
+CLV, 303
+CMP, 304
+COM, 305
+CPX, 306
+DAA, 307
+DEC, 308
+DES, 309
+DEX, 310
+EOR, 311
+INC, 312
+INS, 313
+INX, 314
+JMP, 315
+JSR, 316
+LDA, 317
+LDD, 318
+LDS, 319
+LDX, 320
+LSL, 321
+LSLD, 322
+LSR, 323
+LSRD, 324
+MUL, 325
+NEG, 326
+NOP, 327
+ORA, 328
+PSH, 329
+PSHx, 330
+PUL, 331
+PULx, 332
+ROL, 333
+ROR, 334
+RTI, 335
+RTS, 336
+SBA, 337
+SBC, 338
+SEC, 339
+SEI, 340
+SEV, 341
+STA, 342
+STD, 343
+STS, 344
+STX, 345
+SUB, 346
+SUBD, 347
+SWI, 348
+TAB, 350
+TAP, 351
+TBA, 352
+TPA, 353
+TST, 354
+TSX, 355
+TXS, 356
+WAI, 357
diff --git a/Ghidra/Processors/MC6800/src/main/java/is/sort/mc6800/MC6800JSRAnalyzer.java b/Ghidra/Processors/MC6800/src/main/java/is/sort/mc6800/MC6800JSRAnalyzer.java
new file mode 100644
index 0000000000..ef4d6e509d
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/main/java/is/sort/mc6800/MC6800JSRAnalyzer.java
@@ -0,0 +1,98 @@
+// Copyright 2025 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import ghidra.app.services.AbstractAnalyzer;
+import ghidra.app.services.AnalyzerType;
+import ghidra.app.util.importer.MessageLog;
+import ghidra.program.model.address.AddressSetView;
+import ghidra.program.model.address.AddressSpace;
+import ghidra.program.model.listing.Program;
+import ghidra.util.exception.CancelledException;
+import ghidra.util.task.TaskMonitor;
+
+/**
+ * An analyzer that makes sure computed JSR instructions reference the called
+ * function as a primary reference, when Ghidra is able to infer the called
+ * function.
+ *
+ * When Ghidra can infer the value of the stack pointer and the X/Y register,
+ * a computed JSR instruction will have two references.
+ *  1. A write reference to the location in stack where the return address is stored.
+ *  2. A call reference to the called function.
+ *
+ * This would happen for example for the following code:
+ *   LDS #$07FF
+ *   LDX fn
+ *   JSR 0,X
+ *
+ * fn:
+ *   RTS
+ *
+ * By default Ghidra marks the write reference as primary, this analyzer
+ * changes that to make the call reference primary.
+ *
+ * Because this should be a fairly rare case for MC6800 programs, and because this
+ * might have unforseen side effects on non-MC6800 programs, this analyzer is not
+ * enabled by default.
+ */
+public class MC6800JSRAnalyzer extends AbstractAnalyzer {
+    public MC6800JSRAnalyzer() {
+        super("MC6800 JSR Analyzer",
+            "Makes sure computed JSR instructions reference the called function" +
+                " as a primary reference",
+            AnalyzerType.INSTRUCTION_ANALYZER);
+
+        // Allow one time analysis.
+        setSupportsOneTimeAnalysis(true);
+    }
+
+    @Override
+    public boolean getDefaultEnablement(Program program) {
+        return false;
+    }
+
+    @Override
+    public boolean canAnalyze(Program program) {
+        // Only analyze for 16 bit address spaces.
+        AddressSpace ram = program.getAddressFactory().getDefaultAddressSpace();
+        if (ram == null || ram.getSize() != 16) {
+            return false;
+        }
+
+        return true;
+    }
+
+    @Override
+    public boolean added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log)
+            throws CancelledException {
+        var instructions = program.getListing().getInstructions(set, true);
+        for (var instruction : instructions) {
+            monitor.checkCancelled();
+
+            var references = instruction.getReferencesFrom();
+            for (var reference : references) {
+                if (reference.getReferenceType().isCall()) {
+                    // Found an isCall reference.
+                    if (!reference.isPrimary()) {
+                        program.getReferenceManager().setPrimary(reference, true);
+                    }
+                }
+            }
+        }
+
+        return true;
+    }
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/AbstractEmulatorTest.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/AbstractEmulatorTest.java
new file mode 100644
index 0000000000..f0f083c5ab
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/AbstractEmulatorTest.java
@@ -0,0 +1,194 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import static org.junit.jupiter.api.Assertions.fail;
+
+import java.io.ByteArrayOutputStream;
+
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+
+import db.Transaction;
+import ghidra.app.emulator.EmulatorHelper;
+import ghidra.app.plugin.assembler.Assembler;
+import ghidra.app.plugin.assembler.Assemblers;
+import ghidra.pcode.memstate.MemoryFaultHandler;
+import ghidra.program.database.mem.MemoryMapDB;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.mem.MemoryBlock;
+import ghidra.util.exception.CancelledException;
+import ghidra.util.task.TaskMonitor;
+
+public abstract class AbstractEmulatorTest extends AbstractIntegrationTest {
+
+	public AbstractEmulatorTest(String lang) {
+		super(lang);
+
+		try (Transaction transaction = program.openTransaction("test")) {
+			MemoryMapDB mem = program.getMemory();
+			MemoryBlock block = mem.createUninitializedBlock("ram", address(0x0000), 0x10000, false);
+			mem.convertToInitialized(block, (byte) 0x00);
+
+			transaction.commit();
+		}
+		catch (Exception e) {
+			fail("Failed to create RAM.", e);
+		}
+	}
+
+	class FailOnMemoryFault implements MemoryFaultHandler {
+		@Override
+		public boolean uninitializedRead(Address address, int size, byte[] buf, int bufOffset) {
+			return false;
+		}
+
+		@Override
+		public boolean unknownAddress(Address address, boolean write) {
+			return false;
+		}
+	}
+
+	protected void assemble(int addr, String ... code) {
+		Transaction transaction = program.openTransaction("test");
+		Assembler asm = Assemblers.getAssembler(program);
+		try {
+			asm.assemble(address(addr), code);
+		}
+		catch (Exception e) {
+			fail("Assembly failed", e);
+			transaction.abort();
+			return;
+		}
+		transaction.commit();
+	}
+
+	protected void setA(int value) {
+		emulator.writeRegister("A", value);
+	}
+
+	protected void setB(int value) {
+		emulator.writeRegister("B", value);
+	}
+
+	protected void setD(int value) {
+		emulator.writeRegister("D", value);
+	}
+
+	protected void setCC(int value) {
+		emulator.writeRegister("CC", value);
+	}
+
+	protected void setX(int value) {
+		emulator.writeRegister("X", value);
+	}
+
+	protected void setY(int value) {
+		emulator.writeRegister("Y", value);
+	}
+
+	protected void setS(int value) {
+		emulator.writeRegister("S", value);
+	}
+
+	protected void setPC(int value) {
+		emulator.writeRegister("PC", value);
+	}
+
+	protected int getA() {
+		return emulator.readRegister("A").intValue();
+	}
+
+	protected int getB() {
+		return emulator.readRegister("B").intValue();
+	}
+
+	protected int getD() {
+		return emulator.readRegister("D").intValue();
+	}
+
+	protected int getCC() {
+		return emulator.readRegister("CC").intValue();
+	}
+
+	protected int getX() {
+		return emulator.readRegister("X").intValue();
+	}
+
+	protected int getY() {
+		return emulator.readRegister("Y").intValue();
+	}
+
+	protected int getS() {
+		return emulator.readRegister("S").intValue();
+	}
+
+	protected int getPC() {
+		return emulator.readRegister("PC").intValue();
+	}
+
+	protected void write(int addr, int... bytes) {
+		ByteArrayOutputStream stream = new ByteArrayOutputStream();
+		for (int v : bytes) {
+			stream.write(v);
+		}
+		emulator.writeMemory(address(addr), stream.toByteArray());
+	}
+
+	protected byte[] read(int addr, int length) {
+		return emulator.readMemory(address(addr), length);
+	}
+
+	protected byte readByte(int addr) {
+		return read(addr, 1)[0];
+	}
+
+	protected void step(int numInstructions) {
+		try {
+			for (int i = 0; i < numInstructions; ++i)
+				emulator.step(TaskMonitor.DUMMY);
+		}
+		catch (CancelledException e) {
+			fail("Failed to step.", e);
+		}
+	}
+
+	protected void step() {
+		step(1);
+	}
+
+	protected void stepFrom(int addr, int numInstructions) {
+		setPC(addr);
+		step(numInstructions);
+	}
+
+	protected void stepFrom(int addr) {
+		stepFrom(addr, 1);
+	}
+
+	@BeforeEach
+	public void beforeEach() {
+		emulator = new EmulatorHelper(program);
+		emulator.setMemoryFaultHandler(new FailOnMemoryFault());
+	}
+
+	@AfterEach
+	public void afterEach() {
+		emulator.dispose();
+		emulator = null;
+	}
+
+	private EmulatorHelper emulator = null;
+}
\ No newline at end of file
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/AbstractIntegrationTest.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/AbstractIntegrationTest.java
new file mode 100644
index 0000000000..94b291a5ef
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/AbstractIntegrationTest.java
@@ -0,0 +1,77 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.HexFormat;
+import java.util.Map;
+
+import generic.jar.ResourceFile;
+import generic.test.AbstractGTest;
+import generic.test.AbstractGenericTest;
+import ghidra.GhidraTestApplicationLayout;
+import ghidra.app.plugin.processors.sleigh.SleighLanguageProvider;
+import ghidra.framework.GModule;
+import ghidra.program.database.ProgramDB;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.lang.Language;
+import ghidra.program.model.lang.LanguageID;
+import utility.application.ApplicationLayout;
+
+public abstract class AbstractIntegrationTest extends AbstractGenericTest {
+
+	protected Address address(int addr) {
+		return language.getDefaultSpace().getAddress(addr);
+	}
+
+	public AbstractIntegrationTest(String lang) {
+		SleighLanguageProvider provider = SleighLanguageProvider.getSleighLanguageProvider();
+		this.language = provider.getLanguage(new LanguageID(lang));
+		ProgramDB program = null;
+		try {
+			program = new ProgramDB("test", language, language.getDefaultCompilerSpec(), this);
+		}
+		catch (IOException e) {
+		}
+		this.program = program;
+	}
+
+	@Override
+	protected ApplicationLayout createApplicationLayout() throws IOException {
+		return new TestApplicationLayout(new File(AbstractGTest.getTestDirectoryPath()));
+	}
+
+	// This is necessary to inject the build directory into the application layout.
+	private class TestApplicationLayout extends GhidraTestApplicationLayout {
+		public TestApplicationLayout(File path) throws IOException {
+			super(path);
+		}
+
+		@Override
+		public Map<String, GModule> findGhidraModules() throws IOException {
+			var ret = new HashMap<String, GModule>(super.findGhidraModules());
+
+			ret.put("6800", new GModule(applicationRootDirs, new ResourceFile("./build")));
+			return ret;
+		}
+	}
+
+	protected final Language language;
+	protected final ProgramDB program;
+	protected final HexFormat hexFormat =
+		HexFormat.ofDelimiter(", ").withPrefix("0x").withUpperCase();
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/CC.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/CC.java
new file mode 100644
index 0000000000..ac8787b175
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/CC.java
@@ -0,0 +1,24 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+public class CC {
+	public static final int C = 0x01;
+	public static final int V = 0x02;
+	public static final int Z = 0x04;
+	public static final int N = 0x08;
+	public static final int I = 0x10;
+	public static final int H = 0x20;
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyCommonTest.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyCommonTest.java
new file mode 100644
index 0000000000..686c1d9b81
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyCommonTest.java
@@ -0,0 +1,681 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.junit.jupiter.api.Test;
+import db.Transaction;
+import ghidra.program.disassemble.Disassembler;
+import ghidra.program.model.listing.CodeUnit;
+import ghidra.program.model.listing.Data;
+import ghidra.program.model.listing.Instruction;
+import ghidra.program.model.mem.MemoryBlock;
+import ghidra.util.task.TaskMonitor;
+
+public abstract class DisassemblyCommonTest extends AbstractIntegrationTest {
+	protected DisassemblyCommonTest(String lang) {
+		super(lang);
+	}
+
+	// The instructions are tested in the order of appearance in the
+	// Motorola M6800 Programming Reference Manual.
+	// http://www.bitsavers.org/components/motorola/6800/Motorola_M6800_Programming_Reference_Manual_M68PRM(D)_Nov76.pdf
+
+	@Test
+	public void ABA() {
+		assertDisassemblesTo("ABA", 0x1B);
+	}
+
+	@Test
+	public void ADC() {
+		assertDisassemblesTo("ADCA #0xa", 0x89, 0x0A);
+		assertDisassemblesTo("ADCA 0x000a", 0x99, 0x0A);
+		assertDisassemblesTo("ADCA 0x1234", 0xB9, 0x12, 0x34);
+		assertDisassemblesTo("ADCA 0xa,X", 0xA9, 0x0A);
+
+		assertDisassemblesTo("ADCB #0xa", 0xC9, 0x0A);
+		assertDisassemblesTo("ADCB 0x000a", 0xD9, 0x0A);
+		assertDisassemblesTo("ADCB 0x1234", 0xF9, 0x12, 0x34);
+		assertDisassemblesTo("ADCB 0xa,X", 0xE9, 0x0A);
+	}
+
+	@Test
+	public void ADD() {
+		assertDisassemblesTo("ADDA #0xa", 0x8B, 0x0A);
+		assertDisassemblesTo("ADDA 0x000a", 0x9B, 0x0A);
+		assertDisassemblesTo("ADDA 0x1234", 0xBB, 0x12, 0x34);
+		assertDisassemblesTo("ADDA 0xa,X", 0xAB, 0x0A);
+
+		assertDisassemblesTo("ADDB #0xa", 0xCB, 0x0A);
+		assertDisassemblesTo("ADDB 0x000a", 0xDB, 0x0A);
+		assertDisassemblesTo("ADDB 0x1234", 0xFB, 0x12, 0x34);
+		assertDisassemblesTo("ADDB 0xa,X", 0xEB, 0x0A);
+	}
+
+	@Test
+	public void AND() {
+		assertDisassemblesTo("ANDA #0xa", 0x84, 0x0A);
+		assertDisassemblesTo("ANDA 0x000a", 0x94, 0x0A);
+		assertDisassemblesTo("ANDA 0x1234", 0xB4, 0x12, 0x34);
+		assertDisassemblesTo("ANDA 0xa,X", 0xA4, 0x0A);
+
+		assertDisassemblesTo("ANDB #0xa", 0xC4, 0x0A);
+		assertDisassemblesTo("ANDB 0x000a", 0xD4, 0x0A);
+		assertDisassemblesTo("ANDB 0x1234", 0xF4, 0x12, 0x34);
+		assertDisassemblesTo("ANDB 0xa,X", 0xE4, 0x0A);
+	}
+
+	@Test
+	public void ASL() {
+		assertDisassemblesTo("ASLA", 0x48);
+		assertDisassemblesTo("ASLB", 0x58);
+		assertDisassemblesTo("ASL 0x1234", 0x78, 0x12, 0x34);
+		assertDisassemblesTo("ASL 0x12,X", 0x68, 0x12);
+	}
+
+	@Test
+	public void ASR() {
+		assertDisassemblesTo("ASRA", 0x47);
+		assertDisassemblesTo("ASRB", 0x57);
+		assertDisassemblesTo("ASR 0x1234", 0x77, 0x12, 0x34);
+		assertDisassemblesTo("ASR 0x12,X", 0x67, 0x12);
+	}
+
+	@Test
+	public void BCC() {
+		assertDisassemblesTo("BCC 0x0022", 0x24, 0x20);
+	}
+
+	@Test
+	public void BCS() {
+		assertDisassemblesTo("BCS 0x0022", 0x25, 0x20);
+	}
+
+	@Test
+	public void BEQ() {
+		assertDisassemblesTo("BEQ 0x0022", 0x27, 0x20);
+	}
+
+	@Test
+	public void BGE() {
+		assertDisassemblesTo("BGE 0x0022", 0x2C, 0x20);
+	}
+
+	@Test
+	public void BGT() {
+		assertDisassemblesTo("BGT 0x0022", 0x2E, 0x20);
+	}
+
+	@Test
+	public void BHI() {
+		assertDisassemblesTo("BHI 0x0022", 0x22, 0x20);
+	}
+
+	@Test
+	public void BIT() {
+		assertDisassemblesTo("BITA #0xab", 0x85, 0xAB);
+		assertDisassemblesTo("BITA 0x00ab", 0x95, 0xAB);
+		assertDisassemblesTo("BITA 0x1234", 0xB5, 0x12, 0x34);
+		assertDisassemblesTo("BITA 0xab,X", 0xA5, 0xAB);
+
+		assertDisassemblesTo("BITB #0xab", 0xC5, 0xAB);
+		assertDisassemblesTo("BITB 0x00ab", 0xD5, 0xAB);
+		assertDisassemblesTo("BITB 0x1234", 0xF5, 0x12, 0x34);
+		assertDisassemblesTo("BITB 0xab,X", 0xE5, 0xAB);
+	}
+
+	@Test
+	public void BLE() {
+		assertDisassemblesTo("BLE 0x0022", 0x2F, 0x20);
+	}
+
+	@Test
+	public void BLS() {
+		assertDisassemblesTo("BLS 0x0022", 0x23, 0x20);
+	}
+
+	@Test
+	public void BLT() {
+		assertDisassemblesTo("BLT 0x0022", 0x2D, 0x20);
+	}
+
+	@Test
+	public void BMI() {
+		assertDisassemblesTo("BMI 0x0022", 0x2B, 0x20);
+	}
+
+	@Test
+	public void BNE() {
+		assertDisassemblesTo("BNE 0x0022", 0x26, 0x20);
+	}
+
+	@Test
+	public void BPL() {
+		assertDisassemblesTo("BPL 0x0022", 0x2A, 0x20);
+	}
+
+	@Test
+	public void BRA() {
+		assertDisassemblesTo("BRA 0x0022", 0x20, 0x20);
+	}
+
+	@Test
+	public void BSR() {
+		assertDisassemblesTo("BSR 0x0022", 0x8D, 0x20);
+	}
+
+	@Test
+	public void BVC() {
+		assertDisassemblesTo("BVC 0x0022", 0x28, 0x20);
+	}
+
+	@Test
+	public void BVS() {
+		assertDisassemblesTo("BVS 0x0022", 0x29, 0x20);
+	}
+
+	@Test
+	public void CBA() {
+		assertDisassemblesTo("CBA", 0x11);
+	}
+
+	@Test
+	public void CLC() {
+		assertDisassemblesTo("CLC", 0x0C);
+	}
+
+	@Test
+	public void CLI() {
+		assertDisassemblesTo("CLI", 0x0E);
+	}
+
+	@Test
+	public void CLR() {
+		assertDisassemblesTo("CLRA", 0x4F);
+		assertDisassemblesTo("CLRB", 0x5F);
+		assertDisassemblesTo("CLR 0x1234", 0x7F, 0x12, 0x34);
+		assertDisassemblesTo("CLR 0x12,X", 0x6F, 0x12);
+	}
+
+	@Test
+	public void CLV() {
+		assertDisassemblesTo("CLV", 0x0A);
+	}
+
+	@Test
+	public void CMP() {
+		assertDisassemblesTo("CMPA #0xab", 0x81, 0xAB);
+		assertDisassemblesTo("CMPA 0x00ab", 0x91, 0xAB);
+		assertDisassemblesTo("CMPA 0x1234", 0xB1, 0x12, 0x34);
+		assertDisassemblesTo("CMPA 0xab,X", 0xA1, 0xAB);
+
+		assertDisassemblesTo("CMPB #0xab", 0xC1, 0xAB);
+		assertDisassemblesTo("CMPB 0x00ab", 0xD1, 0xAB);
+		assertDisassemblesTo("CMPB 0x1234", 0xF1, 0x12, 0x34);
+		assertDisassemblesTo("CMPB 0xab,X", 0xE1, 0xAB);
+	}
+
+	@Test
+	public void COM() {
+		assertDisassemblesTo("COMA", 0x43);
+		assertDisassemblesTo("COMB", 0x53);
+		assertDisassemblesTo("COM 0x1234", 0x73, 0x12, 0x34);
+		assertDisassemblesTo("COM 0x12,X", 0x63, 0x12);
+	}
+
+	@Test
+	public void CPX() {
+		assertDisassemblesTo("CPX #0x1234", 0x8C, 0x12, 0x34);
+		assertDisassemblesTo("CPX 0x00ab", 0x9C, 0xAB);
+		assertDisassemblesTo("CPX 0x1234", 0xBC, 0x12, 0x34);
+		assertDisassemblesTo("CPX 0x12,X", 0xAC, 0x12);
+	}
+
+	@Test
+	public void DAA() {
+		assertDisassemblesTo("DAA", 0x19);
+	}
+
+	@Test
+	public void DEC() {
+		assertDisassemblesTo("DECA", 0x4A);
+		assertDisassemblesTo("DECB", 0x5A);
+		assertDisassemblesTo("DEC 0x1234", 0x7A, 0x12, 0x34);
+		assertDisassemblesTo("DEC 0x12,X", 0x6A, 0x12);
+	}
+
+	@Test
+	public void DES() {
+		assertDisassemblesTo("DES", 0x34);
+	}
+
+	@Test
+	public void DEX() {
+		assertDisassemblesTo("DEX", 0x09);
+	}
+
+	@Test
+	public void EOR() {
+		assertDisassemblesTo("EORA #0xab", 0x88, 0xAB);
+		assertDisassemblesTo("EORA 0x00ab", 0x98, 0xAB);
+		assertDisassemblesTo("EORA 0x1234", 0xB8, 0x12, 0x34);
+		assertDisassemblesTo("EORA 0xab,X", 0xA8, 0xAB);
+
+		assertDisassemblesTo("EORB #0xab", 0xC8, 0xAB);
+		assertDisassemblesTo("EORB 0x00ab", 0xD8, 0xAB);
+		assertDisassemblesTo("EORB 0x1234", 0xF8, 0x12, 0x34);
+		assertDisassemblesTo("EORB 0xab,X", 0xE8, 0xAB);
+	}
+
+	@Test
+	public void INC() {
+		assertDisassemblesTo("INCA", 0x4C);
+		assertDisassemblesTo("INCB", 0x5C);
+		assertDisassemblesTo("INC 0x1234", 0x7C, 0x12, 0x34);
+		assertDisassemblesTo("INC 0x12,X", 0x6C, 0x12);
+	}
+
+	@Test
+	public void INS() {
+		assertDisassemblesTo("INS", 0x31);
+	}
+
+	@Test
+	public void INX() {
+		assertDisassemblesTo("INX", 0x08);
+	}
+
+	@Test
+	public void JMP() {
+		assertDisassemblesTo("JMP 0x1234", 0x7E, 0x12, 0x34);
+		assertDisassemblesTo("JMP 0x12,X", 0x6E, 0x12);
+	}
+
+	@Test
+	public void JSR() {
+		assertDisassemblesTo("JSR 0x1234", 0xBD, 0x12, 0x34);
+		assertDisassemblesTo("JSR 0x12,X", 0xAD, 0x12);
+	}
+
+	@Test
+	public void LDA() {
+		assertDisassemblesTo("LDAA #0xab", 0x86, 0xAB);
+		assertDisassemblesTo("LDAA 0x00ab", 0x96, 0xAB);
+		assertDisassemblesTo("LDAA 0x1234", 0xB6, 0x12, 0x34);
+		assertDisassemblesTo("LDAA 0xab,X", 0xA6, 0xAB);
+
+		assertDisassemblesTo("LDAB #0xab", 0xC6, 0xAB);
+		assertDisassemblesTo("LDAB 0x00ab", 0xD6, 0xAB);
+		assertDisassemblesTo("LDAB 0x1234", 0xF6, 0x12, 0x34);
+		assertDisassemblesTo("LDAB 0xab,X", 0xE6, 0xAB);
+	}
+
+	@Test
+	public void LDS() {
+		assertDisassemblesTo("LDS #0x1234", 0x8E, 0x12, 0x34);
+		assertDisassemblesTo("LDS 0x00ab", 0x9E, 0xAB);
+		assertDisassemblesTo("LDS 0x1234", 0xBE, 0x12, 0x34);
+		assertDisassemblesTo("LDS 0x12,X", 0xAE, 0x12);
+	}
+
+	@Test
+	public void LDX() {
+		assertDisassemblesTo("LDX #0x1234", 0xCE, 0x12, 0x34);
+		assertDisassemblesTo("LDX 0x00ab", 0xDE, 0xAB);
+		assertDisassemblesTo("LDX 0x1234", 0xFE, 0x12, 0x34);
+		assertDisassemblesTo("LDX 0x12,X", 0xEE, 0x12);
+	}
+
+	@Test
+	public void LSR() {
+		assertDisassemblesTo("LSRA", 0x44);
+		assertDisassemblesTo("LSRB", 0x54);
+		assertDisassemblesTo("LSR 0x1234", 0x74, 0x12, 0x34);
+		assertDisassemblesTo("LSR 0x12,X", 0x64, 0x12);
+	}
+
+	@Test
+	public void NEG() {
+		assertDisassemblesTo("NEGA", 0x40);
+		assertDisassemblesTo("NEGB", 0x50);
+		assertDisassemblesTo("NEG 0x1234", 0x70, 0x12, 0x34);
+		assertDisassemblesTo("NEG 0x12,X", 0x60, 0x12);
+	}
+
+	@Test
+	public void NOP() {
+		assertDisassemblesTo("NOP", 0x01);
+	}
+
+	@Test
+	public void ORA() {
+		assertDisassemblesTo("ORAA #0xab", 0x8A, 0xAB);
+		assertDisassemblesTo("ORAA 0x00ab", 0x9A, 0xAB);
+		assertDisassemblesTo("ORAA 0x1234", 0xBA, 0x12, 0x34);
+		assertDisassemblesTo("ORAA 0xab,X", 0xAA, 0xAB);
+
+		assertDisassemblesTo("ORAB #0xab", 0xCA, 0xAB);
+		assertDisassemblesTo("ORAB 0x00ab", 0xDA, 0xAB);
+		assertDisassemblesTo("ORAB 0x1234", 0xFA, 0x12, 0x34);
+		assertDisassemblesTo("ORAB 0xab,X", 0xEA, 0xAB);
+	}
+
+	@Test
+	public void PSH() {
+		assertDisassemblesTo("PSHA", 0x36);
+		assertDisassemblesTo("PSHB", 0x37);
+	}
+
+	@Test
+	public void PUL() {
+		assertDisassemblesTo("PULA", 0x32);
+		assertDisassemblesTo("PULB", 0x33);
+	}
+
+	@Test
+	public void ROL() {
+		assertDisassemblesTo("ROLA", 0x49);
+		assertDisassemblesTo("ROLB", 0x59);
+		assertDisassemblesTo("ROL 0x1234", 0x79, 0x12, 0x34);
+		assertDisassemblesTo("ROL 0x12,X", 0x69, 0x12);
+	}
+
+	@Test
+	public void ROR() {
+		assertDisassemblesTo("RORA", 0x46);
+		assertDisassemblesTo("RORB", 0x56);
+		assertDisassemblesTo("ROR 0x1234", 0x76, 0x12, 0x34);
+		assertDisassemblesTo("ROR 0x12,X", 0x66, 0x12);
+	}
+
+	@Test
+	public void RTI() {
+		assertDisassemblesTo("RTI", 0x3B);
+	}
+
+	@Test
+	public void RTS() {
+		assertDisassemblesTo("RTS", 0x39);
+	}
+
+	@Test
+	public void SBA() {
+		assertDisassemblesTo("SBA", 0x10);
+	}
+
+	@Test
+	public void SBC() {
+		assertDisassemblesTo("SBCA #0xa", 0x82, 0x0A);
+		assertDisassemblesTo("SBCA 0x000a", 0x92, 0x0A);
+		assertDisassemblesTo("SBCA 0x1234", 0xB2, 0x12, 0x34);
+		assertDisassemblesTo("SBCA 0xa,X", 0xA2, 0x0A);
+
+		assertDisassemblesTo("SBCB #0xa", 0xC2, 0x0A);
+		assertDisassemblesTo("SBCB 0x000a", 0xD2, 0x0A);
+		assertDisassemblesTo("SBCB 0x1234", 0xF2, 0x12, 0x34);
+		assertDisassemblesTo("SBCB 0xa,X", 0xE2, 0x0A);
+	}
+
+	@Test
+	public void SEC() {
+		assertDisassemblesTo("SEC", 0x0D);
+	}
+
+	@Test
+	public void SEI() {
+		assertDisassemblesTo("SEI", 0x0F);
+	}
+
+	@Test
+	public void SEV() {
+		assertDisassemblesTo("SEV", 0x0B);
+	}
+
+	@Test
+	public void STA() {
+		assertDisassemblesTo("STAA 0x000a", 0x97, 0x0A);
+		assertDisassemblesTo("STAA 0x1234", 0xB7, 0x12, 0x34);
+		assertDisassemblesTo("STAA 0xa,X", 0xA7, 0x0A);
+
+		assertDisassemblesTo("STAB 0x000a", 0xD7, 0x0A);
+		assertDisassemblesTo("STAB 0x1234", 0xF7, 0x12, 0x34);
+		assertDisassemblesTo("STAB 0xa,X", 0xE7, 0x0A);
+	}
+
+	@Test
+	public void STS() {
+		assertDisassemblesTo("STS 0x000a", 0x9F, 0x0A);
+		assertDisassemblesTo("STS 0x1234", 0xBF, 0x12, 0x34);
+		assertDisassemblesTo("STS 0xa,X", 0xAF, 0x0A);
+	}
+
+	@Test
+	public void STX() {
+		assertDisassemblesTo("STX 0x000a", 0xDF, 0x0A);
+		assertDisassemblesTo("STX 0x1234", 0xFF, 0x12, 0x34);
+		assertDisassemblesTo("STX 0xa,X", 0xEF, 0x0A);
+	}
+
+	@Test
+	public void SUB() {
+		assertDisassemblesTo("SUBA #0xa", 0x80, 0x0A);
+		assertDisassemblesTo("SUBA 0x000a", 0x90, 0x0A);
+		assertDisassemblesTo("SUBA 0x1234", 0xB0, 0x12, 0x34);
+		assertDisassemblesTo("SUBA 0xa,X", 0xA0, 0x0A);
+
+		assertDisassemblesTo("SUBB #0xa", 0xC0, 0x0A);
+		assertDisassemblesTo("SUBB 0x000a", 0xD0, 0x0A);
+		assertDisassemblesTo("SUBB 0x1234", 0xF0, 0x12, 0x34);
+		assertDisassemblesTo("SUBB 0xa,X", 0xE0, 0x0A);
+	}
+
+	@Test
+	public void SWI() {
+		assertDisassemblesTo("SWI", 0x3F);
+	}
+
+	@Test
+	public void TAB() {
+		assertDisassemblesTo("TAB", 0x16);
+	}
+
+	@Test
+	public void TAP() {
+		assertDisassemblesTo("TAP", 0x06);
+	}
+
+	@Test
+	public void TBA() {
+		assertDisassemblesTo("TBA", 0x17);
+	}
+
+	@Test
+	public void TPA() {
+		assertDisassemblesTo("TPA", 0x07);
+	}
+
+	@Test
+	public void TST() {
+		assertDisassemblesTo("TSTA", 0x4D);
+		assertDisassemblesTo("TSTB", 0x5D);
+		assertDisassemblesTo("TST 0x1234", 0x7D, 0x12, 0x34);
+		assertDisassemblesTo("TST 0x12,X", 0x6D, 0x12);
+	}
+
+	@Test
+	public void TSX() {
+		assertDisassemblesTo("TSX", 0x30);
+	}
+
+	@Test
+	public void TXS() {
+		assertDisassemblesTo("TXS", 0x35);
+	}
+
+	@Test
+	public void WAI() {
+		assertDisassemblesTo("WAI", 0x3E);
+	}
+
+	protected void assertInvalidExactOpcode(int... opCode) {
+		ByteArrayOutputStream stream = new ByteArrayOutputStream();
+		for (int arg : opCode) {
+			stream.write(arg);
+		}
+		CodeUnit codeUnit = disassemble(stream.toByteArray());
+		assertTrue(codeUnit instanceof Data);
+		assertEquals(opCode.length, codeUnit.getLength(), "Wrong data length.");
+	}
+
+	protected void assertInvalidOpcode(int... opCode) {
+		ByteArrayOutputStream stream = new ByteArrayOutputStream();
+		for (int arg : opCode) {
+			stream.write(arg);
+		}
+		// Extend the invalid opcode with extra bytes to verify that
+		// the disassembler does not try to use them.
+		stream.write(0x01);
+		stream.write(0x02);
+		stream.write(0x03);
+
+		byte[] bytes = stream.toByteArray();
+		CodeUnit codeUnit = disassemble(bytes);
+		assertTrue(codeUnit instanceof Data,
+			"Got " + codeUnit.toString() + " for " + hexFormat.formatHex(bytes));
+
+		assertEquals(1, codeUnit.getLength(), "Wrong data length.");
+	}
+
+	protected void assertValidOpcode(int... opCode) {
+		ByteArrayOutputStream stream = new ByteArrayOutputStream();
+		for (int arg : opCode) {
+			stream.write(arg);
+		}
+		// Extend the valid opcode with extra bytes in case
+		// the instruction has an argument.
+		stream.write(0x01);
+		stream.write(0x02);
+		stream.write(0x03);
+		stream.write(0x04);
+
+		byte[] bytes = stream.toByteArray();
+		CodeUnit codeUnit = disassemble(bytes);
+		assertTrue(codeUnit instanceof Instruction,
+			"Got " + codeUnit.toString() + " for " + hexFormat.formatHex(bytes));
+
+		assertTrue(codeUnit.getLength() >= opCode.length,
+			"Instruction too short: " + codeUnit.toString());
+	}
+
+	protected void assertValidOpcodes(Integer[] validOpcodes) {
+		for (int opcode : validOpcodes) {
+			assertValidOpcode(opcode);
+		}
+	}
+
+	protected void assertInvaldOpcodes(Integer[] invalidOpcodes) {
+		for (int opcode : invalidOpcodes) {
+			assertInvalidOpcode(opcode);
+		}
+	}
+
+	protected Integer[] complementOpcodes(Integer[] opcodes) {
+		Set<Integer> validSet = new HashSet<>(Arrays.asList(opcodes));
+		Set<Integer> complementSet = new HashSet<>();
+		for (int opcode = 0x00; opcode < 0x100; opcode++) {
+			if (!validSet.contains(opcode)) {
+				complementSet.add(opcode);
+			}
+		}
+		return complementSet.toArray(new Integer[complementSet.size()]);
+	}
+
+	protected void assertDisassemblesAt(String expected, int addr, int... code) {
+		ByteArrayOutputStream stream = new ByteArrayOutputStream();
+		for (int arg : code) {
+			stream.write(arg);
+		}
+
+		byte[] bytes = stream.toByteArray();
+		CodeUnit codeUnit = disassembleAt(addr, bytes);
+
+		assertNotNull(codeUnit);
+		assertTrue(codeUnit instanceof Instruction, "Not an instruction");
+
+		assertEquals(expected, codeUnit.toString());
+		assertEquals(bytes.length, codeUnit.getLength(), "Wrong instruction length.");
+	}
+
+	protected void assertDisassemblesTo(String expected, int... code) {
+		assertDisassemblesAt(expected, 0, code);
+	}
+
+	protected CodeUnit disassembleAt(int addr, byte[] bytes) {
+		try (Transaction transaction = program.openTransaction("disassemble")) {
+			ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
+			// Create an overlay block.
+			MemoryBlock block = program.getMemory()
+					.createInitializedBlock("test", address(addr), stream, bytes.length,
+						TaskMonitor.DUMMY,
+						true);
+
+			Disassembler disassembler =
+				Disassembler.getDisassembler(program, TaskMonitor.DUMMY, null);
+			disassembler.disassemble(block.getStart(),
+				program.getMemory().getLoadedAndInitializedAddressSet());
+			CodeUnit ret = program.getCodeManager().getCodeUnitAt(block.getStart());
+			transaction.commit();
+			return ret;
+		}
+		catch (Exception e) {
+			return null;
+		}
+	}
+
+	protected String[] getPcode(int addr, int... code) {
+		ByteArrayOutputStream stream = new ByteArrayOutputStream();
+		for (int arg : code) {
+			stream.write(arg);
+		}
+
+		byte[] bytes = stream.toByteArray();
+		CodeUnit codeUnit = disassembleAt(addr, bytes);
+
+		assertNotNull(codeUnit);
+		assertTrue(codeUnit instanceof Instruction, "Not an instruction");
+		assertEquals(bytes.length, codeUnit.getLength(), "Wrong instruction length.");
+
+		List<String> strings = new ArrayList<String>();
+		for (var op : ((Instruction) codeUnit).getPcode()) {
+			strings.add(op.toString());
+		}
+		return strings.toArray(new String[strings.size()]);
+	}
+
+	protected CodeUnit disassemble(byte[] bytes) {
+		return disassembleAt(0, bytes);
+	}
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyHD6301Test.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyHD6301Test.java
new file mode 100644
index 0000000000..02f5d9f80f
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyHD6301Test.java
@@ -0,0 +1,73 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import org.junit.jupiter.api.Test;
+
+public class DisassemblyHD6301Test extends DisassemblyMC6801CommonTest {
+	public DisassemblyHD6301Test() {
+		super("HD6301:BE:16:default");
+	}
+
+	@Test
+	public void AIM() {
+		assertDisassemblesTo("AIM #0x12,0x0034", 0x71, 0x12, 0x34);
+		assertDisassemblesTo("AIM #0x12,0x34,X", 0x61, 0x12, 0x34);
+	}
+
+	@Test
+	public void OIM() {
+		assertDisassemblesTo("OIM #0x12,0x0034", 0x72, 0x12, 0x34);
+		assertDisassemblesTo("OIM #0x12,0x34,X", 0x62, 0x12, 0x34);
+	}
+
+	@Test
+	public void EIM() {
+		assertDisassemblesTo("EIM #0x12,0x0034", 0x75, 0x12, 0x34);
+		assertDisassemblesTo("EIM #0x12,0x34,X", 0x65, 0x12, 0x34);
+	}
+
+	@Test
+	public void TIM() {
+		assertDisassemblesTo("TIM #0x12,0x0034", 0x7B, 0x12, 0x34);
+		assertDisassemblesTo("TIM #0x12,0x34,X", 0x6B, 0x12, 0x34);
+	}
+
+	@Test
+	public void XGDX() {
+		assertDisassemblesTo("XGDX", 0x18);
+	}
+
+	@Test
+	public void SLP() {
+		assertDisassemblesTo("SLP", 0x1A);
+	}
+
+	@Test
+	public void ValidInvalidOpCodes() {
+		Integer[] invalidOpcodes = {
+			0x00, 0x02, 0x03,
+			0x12, 0x13, 0x14, 0x15,
+			0x1C, 0x1D, 0x1E, 0x1F,
+			0x41, 0x42, 0x45, 0x4B, 0x4E,
+			0x51, 0x52, 0x55, 0x5B, 0x5E,
+			0x87, 0x8F,
+			0xC7, 0xCD, 0xCF
+		};
+
+		assertInvaldOpcodes(invalidOpcodes);
+		assertValidOpcodes(complementOpcodes(invalidOpcodes));
+	}
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6800Test.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6800Test.java
new file mode 100644
index 0000000000..6279dd9ba6
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6800Test.java
@@ -0,0 +1,49 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import org.junit.jupiter.api.Test;
+
+public class DisassemblyMC6800Test extends DisassemblyCommonTest {
+	public DisassemblyMC6800Test() {
+		super("MC6800:BE:16:default");
+	}
+
+	@Test
+	public void ValidInvalidOpCodes() {
+		Integer[] invalidOpcodes = {
+			0x00, 0x02, 0x03, 0x04, 0x05,
+			0x12, 0x13, 0x14, 0x15, 0x18,
+			0x1A, 0x1C, 0x1D, 0x1E, 0x1F,
+			0x21,
+			0x38, 0x3A, 0x3C, 0x3D,
+			0x41, 0x42, 0x45, 0x4B, 0x4E,
+			0x51, 0x52, 0x55, 0x5B, 0x5E,
+			0x61, 0x62, 0x65, 0x6B,
+			0x71, 0x72, 0x75, 0x7B,
+			0x83, 0x87, 0x8F,
+			0x93, 0x9D,
+			0xA3,
+			0xB3,
+			0xC3, 0xC7, 0xCC, 0xCD, 0xCF,
+			0xD3, 0xDC, 0xDD,
+			0xE3, 0xEC, 0xED,
+			0xF3, 0xFC, 0xFD
+		};
+
+		assertInvaldOpcodes(invalidOpcodes);
+		assertValidOpcodes(complementOpcodes(invalidOpcodes));
+	}
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6801CommonTest.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6801CommonTest.java
new file mode 100644
index 0000000000..caecf53854
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6801CommonTest.java
@@ -0,0 +1,94 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import org.junit.jupiter.api.Test;
+
+public abstract class DisassemblyMC6801CommonTest extends DisassemblyCommonTest {
+	public DisassemblyMC6801CommonTest(String lang) {
+		super(lang);
+	}
+
+	@Test
+	public void ABX() {
+		assertDisassemblesTo("ABX", 0x3A);
+	}
+
+	@Test
+	public void ADDD() {
+		assertDisassemblesTo("ADDD #0x1234", 0xC3, 0x12, 0x34);
+		assertDisassemblesTo("ADDD 0x00ab", 0xD3, 0xab);
+		assertDisassemblesTo("ADDD 0x1234", 0xF3, 0x12, 0x34);
+		assertDisassemblesTo("ADDD 0xab,X", 0xE3, 0xAB);
+	}
+
+	@Test
+	public void ASLD() {
+		assertDisassemblesTo("ASLD", 0x05);
+	}
+
+	@Override
+	@Test
+	public void JSR() {
+		// Test the MC6800 variants.
+		super.JSR();
+
+		// The direct JSR is first present in the MC6801.
+		assertDisassemblesTo("JSR 0xab", 0x9D, 0xAB);
+	}
+
+	@Test
+	public void LDD() {
+		assertDisassemblesTo("LDD #0x1234", 0xCC, 0x12, 0x34);
+		assertDisassemblesTo("LDD 0x00ab", 0xDC, 0xab);
+		assertDisassemblesTo("LDD 0x1234", 0xFC, 0x12, 0x34);
+		assertDisassemblesTo("LDD 0xab,X", 0xEC, 0xAB);
+	}
+
+	@Test
+	public void LSRD() {
+		assertDisassemblesTo("LSRD", 0x04);
+	}
+
+	@Test
+	public void MUL() {
+		assertDisassemblesTo("MUL", 0x3D);
+	}
+
+	@Test
+	public void PSHX() {
+		assertDisassemblesTo("PSHX", 0x3C);
+	}
+
+	@Test
+	public void PULX() {
+		assertDisassemblesTo("PULX", 0x38);
+	}
+
+	@Test
+	public void STD() {
+		assertDisassemblesTo("STD 0x00ab", 0xDD, 0xAB);
+		assertDisassemblesTo("STD 0x1234", 0xFD, 0x12, 0x34);
+		assertDisassemblesTo("STD 0xab,X", 0xED, 0xAB);
+	}
+
+	@Test
+	public void SUBD() {
+		assertDisassemblesTo("SUBD #0x1234", 0x83, 0x12, 0x34);
+		assertDisassemblesTo("SUBD 0x00ab", 0x93, 0xab);
+		assertDisassemblesTo("SUBD 0x1234", 0xB3, 0x12, 0x34);
+		assertDisassemblesTo("SUBD 0xab,X", 0xA3, 0xAB);
+	}
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6801Test.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6801Test.java
new file mode 100644
index 0000000000..a7f3bb528d
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6801Test.java
@@ -0,0 +1,41 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import org.junit.jupiter.api.Test;
+
+public class DisassemblyMC6801Test extends DisassemblyMC6801CommonTest {
+	public DisassemblyMC6801Test() {
+		super("MC6801:BE:16:default");
+	}
+
+	@Test
+	public void ValidInvalidOpCodes() {
+		Integer[] invalidOpcodes = {
+			0x00, 0x02, 0x03,
+			0x12, 0x13, 0x14, 0x15, 0x18,
+			0x1A, 0x1C, 0x1D, 0x1E, 0x1F,
+			0x41, 0x42, 0x45, 0x4B, 0x4E,
+			0x51, 0x52, 0x55, 0x5B, 0x5E,
+			0x61, 0x62, 0x65, 0x6B,
+			0x71, 0x72, 0x75, 0x7B,
+			0x87, 0x8F,
+			0xC7, 0xCD, 0xCF
+		};
+
+		assertInvaldOpcodes(invalidOpcodes);
+		assertValidOpcodes(complementOpcodes(invalidOpcodes));
+	}
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC68HC11Test.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC68HC11Test.java
new file mode 100644
index 0000000000..70af17d61e
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC68HC11Test.java
@@ -0,0 +1,414 @@
+// Copyright 2025 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import org.junit.jupiter.api.Test;
+
+public class DisassemblyMC68HC11Test extends DisassemblyMC6801CommonTest {
+	public DisassemblyMC68HC11Test() {
+		super("MC68HC11:BE:16:default");
+	}
+
+	// Test the indexed,Y addressing mode for the 6800 instructions.
+	@Test
+	public void ADC() {
+		super.ADC();
+		assertDisassemblesTo("ADCA 0xa,Y", 0x18, 0xA9, 0x0A);
+		assertDisassemblesTo("ADCB 0xa,Y", 0x18, 0xE9, 0x0A);
+	}
+
+	@Test
+	public void ADD() {
+		super.ADD();
+		assertDisassemblesTo("ADDA 0xa,Y", 0x18, 0xAB, 0x0A);
+		assertDisassemblesTo("ADDB 0xa,Y", 0x18, 0xEB, 0x0A);
+	}
+
+	@Test
+	public void AND() {
+		super.AND();
+		assertDisassemblesTo("ANDA 0xa,Y", 0x18, 0xA4, 0x0A);
+		assertDisassemblesTo("ANDB 0xa,Y", 0x18, 0xE4, 0x0A);
+	}
+
+	@Test
+	public void ASL() {
+		super.ASL();
+		assertDisassemblesTo("ASL 0x12,Y", 0x18, 0x68, 0x12);
+	}
+
+	@Test
+	public void ASR() {
+		assertDisassemblesTo("ASR 0x12,Y", 0x18, 0x67, 0x12);
+	}
+
+	@Test
+	public void BIT() {
+		super.BIT();
+		assertDisassemblesTo("BITA 0xab,Y", 0x18, 0xA5, 0xAB);
+		assertDisassemblesTo("BITB 0xab,Y", 0x18, 0xE5, 0xAB);
+	}
+
+	@Test
+	public void CLR() {
+		super.CLR();
+		assertDisassemblesTo("CLR 0x12,Y", 0x18, 0x6F, 0x12);
+	}
+
+	@Test
+	public void CMP() {
+		super.CMP();
+		assertDisassemblesTo("CMPA 0xab,Y", 0x18, 0xA1, 0xAB);
+		assertDisassemblesTo("CMPB 0xab,Y", 0x18, 0xE1, 0xAB);
+	}
+
+	@Test
+	public void COM() {
+		super.COM();
+		assertDisassemblesTo("COM 0x12,Y", 0x18, 0x63, 0x12);
+	}
+
+	@Test
+	public void DEC() {
+		super.DEC();
+		assertDisassemblesTo("DEC 0x12,Y", 0x18, 0x6A, 0x12);
+	}
+
+	@Test
+	public void EOR() {
+		super.EOR();
+		assertDisassemblesTo("EORA 0xab,Y", 0x18, 0xA8, 0xAB);
+		assertDisassemblesTo("EORB 0xab,Y", 0x18, 0xE8, 0xAB);
+	}
+
+	@Test
+	public void INC() {
+		super.INC();
+		assertDisassemblesTo("INC 0x12,Y", 0x18, 0x6C, 0x12);
+	}
+
+	@Test
+	public void JMP() {
+		super.JMP();
+		assertDisassemblesTo("JMP 0x12,Y", 0x18, 0x6E, 0x12);
+	}
+
+	@Test
+	public void JSR() {
+		super.JSR();
+		assertDisassemblesTo("JSR 0x12,Y", 0x18, 0xAD, 0x12);
+	}
+
+	@Test
+	public void LDA() {
+		super.LDA();
+		assertDisassemblesTo("LDAA 0xab,Y", 0x18, 0xA6, 0xAB);
+		assertDisassemblesTo("LDAB 0xab,Y", 0x18, 0xE6, 0xAB);
+	}
+
+	@Test
+	public void LDS() {
+		super.LDS();
+		assertDisassemblesTo("LDS 0x12,Y", 0x18, 0xAE, 0x12);
+	}
+
+	@Test
+	public void LSR() {
+		super.LSR();
+		assertDisassemblesTo("LSR 0x12,Y", 0x18, 0x64, 0x12);
+	}
+
+	@Test
+	public void NEG() {
+		super.NEG();
+		assertDisassemblesTo("NEG 0x12,Y", 0x18, 0x60, 0x12);
+	}
+
+	@Test
+	public void ORA() {
+		super.ORA();
+		assertDisassemblesTo("ORAA 0xab,Y", 0x18, 0xAA, 0xAB);
+		assertDisassemblesTo("ORAB 0xab,Y", 0x18, 0xEA, 0xAB);
+	}
+
+	@Test
+	public void ROL() {
+		super.ROL();
+		assertDisassemblesTo("ROL 0x12,Y", 0x18, 0x69, 0x12);
+	}
+
+	@Test
+	public void ROR() {
+		super.ROR();
+		assertDisassemblesTo("ROR 0x12,Y", 0x18, 0x66, 0x12);
+	}
+
+	@Test
+	public void SBC() {
+		super.SBC();
+		assertDisassemblesTo("SBCA 0xa,Y", 0x18, 0xA2, 0x0A);
+		assertDisassemblesTo("SBCB 0xa,Y", 0x18, 0xE2, 0x0A);
+	}
+
+	@Test
+	public void STA() {
+		super.STA();
+		assertDisassemblesTo("STAA 0xa,Y", 0x18, 0xA7, 0x0A);
+		assertDisassemblesTo("STAB 0xa,Y", 0x18, 0xE7, 0x0A);
+	}
+
+	@Test
+	public void STS() {
+		super.STS();
+		assertDisassemblesTo("STS 0xa,Y", 0x18, 0xAF, 0x0A);
+	}
+
+	@Test
+	public void SUB() {
+		super.SUB();
+		assertDisassemblesTo("SUBA 0xa,Y", 0x18, 0xA0, 0x0A);
+		assertDisassemblesTo("SUBB 0xa,Y", 0x18, 0xE0, 0x0A);
+	}
+
+	@Test
+	public void TST() {
+		super.TST();
+		assertDisassemblesTo("TST 0x12,Y", 0x18, 0x6D, 0x12);
+	}
+
+	// Test the 6801 specific imm,Y instructions.
+	@Test
+	public void ADDD() {
+		super.ADDD();
+		assertDisassemblesTo("ADDD 0xab,Y", 0x18, 0xE3, 0xAB);
+	}
+
+	@Test
+	public void LDD() {
+		super.LDD();
+		assertDisassemblesTo("LDD 0xab,Y", 0x18, 0xEC, 0xAB);
+	}
+
+	@Test
+	public void STD() {
+		super.STD();
+		assertDisassemblesTo("STD 0xab,Y", 0x18, 0xED, 0xAB);
+	}
+
+	@Test
+	public void SUBD() {
+		super.SUBD();
+		assertDisassemblesTo("SUBD 0xab,Y", 0x18, 0xA3, 0xAB);
+	}
+
+	// The 6800 Y-specific instructions.
+	@Test
+	public void INY() {
+		assertDisassemblesTo("INY", 0x18, 0x08);
+	}
+
+	@Test
+	public void TSY() {
+		assertDisassemblesTo("TSY", 0x18, 0x30);
+	}
+
+	@Test
+	public void TYS() {
+		assertDisassemblesTo("TYS", 0x18, 0x35);
+	}
+
+	@Test
+	public void CPY() {
+		assertDisassemblesTo("CPY #0x1234", 0x18, 0x8C, 0x12, 0x34);
+		assertDisassemblesTo("CPY 0x00ab", 0x18, 0x9C, 0xAB);
+		assertDisassemblesTo("CPY 0x1234", 0x18, 0xBC, 0x12, 0x34);
+		assertDisassemblesTo("CPY 0x12,Y", 0x18, 0xAC, 0x12);
+		assertDisassemblesTo("CPY 0x12,X", 0x1A, 0xAC, 0x12);
+	}
+
+	@Test
+	public void LDY() {
+		assertDisassemblesTo("LDY #0x1234", 0x18, 0xCE, 0x12, 0x34);
+		assertDisassemblesTo("LDY 0x00ab", 0x18, 0xDE, 0xAB);
+		assertDisassemblesTo("LDY 0x1234", 0x18, 0xFE, 0x12, 0x34);
+		assertDisassemblesTo("LDY 0x12,Y", 0x18, 0xEE, 0x12);
+		assertDisassemblesTo("LDY 0x12,X", 0x1A, 0xEE, 0x12);
+	}
+
+	@Test
+	public void STY() {
+		assertDisassemblesTo("STY 0x000a", 0x18, 0xDF, 0x0A);
+		assertDisassemblesTo("STY 0x1234", 0x18, 0xFF, 0x12, 0x34);
+		assertDisassemblesTo("STY 0xa,Y", 0x18, 0xEF, 0x0A);
+		assertDisassemblesTo("STY 0xa,X", 0x1A, 0xEF, 0x0A);
+	}
+
+	// Test 6801 Y-specific opcodes.
+	@Test
+	public void ABY() {
+		assertDisassemblesTo("ABY", 0x18, 0x3A);
+	}
+
+	@Test
+	public void PSHY() {
+		assertDisassemblesTo("PSHY", 0x18, 0x3C);
+	}
+
+	@Test
+	public void PULY() {
+		assertDisassemblesTo("PULY", 0x18, 0x38);
+	}
+
+	// Test 68HC11 specific instructions.
+	@Test
+	public void TEST() {
+		assertDisassemblesTo("TEST", 0x00);
+	}
+
+	@Test
+	public void IDIV() {
+		assertDisassemblesTo("IDIV", 0x02);
+	}
+
+	@Test
+	public void FDIV() {
+		assertDisassemblesTo("FDIV", 0x03);
+	}
+
+	@Test
+	public void BRSET() {
+		assertDisassemblesTo("BRSET 0x0012 0x23 0x0038", 0x12, 0x12, 0x23, 0x34);
+		assertDisassemblesTo("BRSET 0x12,X 0x23 0x0038", 0x1E, 0x12, 0x23, 0x34);
+		assertDisassemblesTo("BRSET 0x12,Y 0x23 0x0039", 0x18, 0x1E, 0x12, 0x23, 0x34);
+	}
+
+	@Test
+	public void BRCLR() {
+		assertDisassemblesTo("BRCLR 0x0012 0x23 0x0038", 0x13, 0x12, 0x23, 0x34);
+		assertDisassemblesTo("BRCLR 0x12,X 0x23 0x0038", 0x1F, 0x12, 0x23, 0x34);
+		assertDisassemblesTo("BRCLR 0x12,Y 0x23 0x0039", 0x18, 0x1F, 0x12, 0x23, 0x34);
+	}
+
+	@Test
+	public void BSET() {
+		assertDisassemblesTo("BSET 0x0012 0x23", 0x14, 0x12, 0x23);
+		assertDisassemblesTo("BSET 0x12,X 0x23", 0x1C, 0x12, 0x23);
+		assertDisassemblesTo("BSET 0x12,Y 0x23", 0x18, 0x1C, 0x12, 0x23);
+	}
+
+	@Test
+	public void BCLR() {
+		assertDisassemblesTo("BCLR 0x0012 0x23", 0x15, 0x12, 0x23);
+		assertDisassemblesTo("BCLR 0x12,X 0x23", 0x1D, 0x12, 0x23);
+		assertDisassemblesTo("BCLR 0x12,Y 0x23", 0x18, 0x1D, 0x12, 0x23);
+	}
+
+	@Test
+	public void CPD() {
+		assertDisassemblesTo("CPD #0x1234", 0x1A, 0x83, 0x12, 0x34);
+		assertDisassemblesTo("CPD 0x00ab", 0x1A, 0x93, 0xAB);
+		assertDisassemblesTo("CPD 0x1234", 0x1A, 0xB3, 0x12, 0x34);
+		assertDisassemblesTo("CPD 0x12,X", 0x1A, 0xA3, 0x12);
+		assertDisassemblesTo("CPD 0x12,Y", 0xCD, 0xA3, 0x12);
+	}
+
+	@Test
+	public void CPX() {
+		super.CPX();
+		assertDisassemblesTo("CPX 0x12,Y", 0xCD, 0xAC, 0x12);
+	}
+
+	public void LDX() {
+		super.LDX();
+		assertDisassemblesTo("LDX 0x12,Y", 0xCD, 0xEE, 0x12);
+	}
+
+	public void STX() {
+		super.STX();
+		assertDisassemblesTo("STX 0x12,Y", 0xCD, 0xEF, 0x12);
+	}
+
+	@Test
+	public void Page0OpCodes() {
+		Integer[] invalidOpcodes = {
+			0x18, 0x1A,
+			0x41, 0x42, 0x45, 0x4B, 0x4E,
+			0x51, 0x52, 0x55, 0x5B, 0x5E,
+			0x61, 0x62, 0x65, 0x6B,
+			0x71, 0x72, 0x75, 0x7B,
+			0x87,
+			0xC7, 0xCD
+		};
+		assertValidOpcodes(complementOpcodes(invalidOpcodes));
+		assertInvaldOpcodes(invalidOpcodes);
+	}
+
+	@Test
+	public void Page1OpCodes() {
+		Integer[] validOpcodes = {
+			0x08, 0x09,
+			0x1C, 0x1D, 0x1E, 0x1F,
+			0x30, 0x35, 0x38, 0x3A, 0x3C,
+			0x60, 0x63, 0x64, 0x66, 0x67, 0x68, 0x69, 0x6A, 0X6C, 0x6D, 0x6E, 0x6F,
+			0x8C, 0x8F,
+			0x9C,
+			0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD,
+			0xAE, 0xAF,
+			0xBC,
+			0xCE,
+			0xDE, 0xDF,
+			0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED,
+			0xEE, 0xEF,
+			0xFE, 0xFF
+		};
+		assertValidOpcodes(0x18, validOpcodes);
+		assertInvaldOpcodes(0x18, complementOpcodes(validOpcodes));
+	}
+
+	@Test
+	public void Page2OpCodes() {
+		Integer[] validOpcodes = {
+			0x83,
+			0x93,
+			0xA3, 0xAC,
+			0xB3,
+			0xEE, 0xEF,
+		};
+		assertValidOpcodes(0x1A, validOpcodes);
+		assertInvaldOpcodes(0x1A, complementOpcodes(validOpcodes));
+	}
+
+	@Test
+	public void Page3OpCodes() {
+		Integer[] validOpcodes = {
+			0xA3, 0xAC,
+			0xEE, 0xEF,
+		};
+		assertValidOpcodes(0xCD, validOpcodes);
+		assertInvaldOpcodes(0xCD, complementOpcodes(validOpcodes));
+	}
+
+	private void assertInvaldOpcodes(int prefix, Integer[] invalidOpcodes) {
+		for (int opcode : invalidOpcodes) {
+			assertInvalidOpcode(prefix, opcode);
+		}
+	}
+
+	private void assertValidOpcodes(int prefix, Integer[] validOpcodes) {
+		for (int opcode : validOpcodes) {
+			assertValidOpcode(prefix, opcode);
+		}
+	}
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorHD6301Test.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorHD6301Test.java
new file mode 100644
index 0000000000..504ca501e1
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorHD6301Test.java
@@ -0,0 +1,79 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import org.junit.jupiter.api.Test;
+
+public class EmulatorHD6301Test extends AbstractEmulatorTest {
+	public EmulatorHD6301Test() {
+		super("HD6301:BE:16:default");
+	}
+
+	@Test
+	public void AIM() {
+		assemble(0x0000,
+			"AIM #0xAA,0x0020",
+			"AIM #0x55,0x10,X");
+		// Set 0x20 to 0x0F.
+		write(0x0020, 0x0F);
+
+		setCC(0x00);
+		stepFrom(0x0000);
+		assertEquals(0, getCC());
+		assertEquals(0x0A, readByte(0x20));
+
+		setX(0x0010);
+		// Test the indexed variant.
+		stepFrom(0x0003);
+		assertEquals(CC.Z, getCC());
+		assertEquals(0x00, readByte(0x20));
+	}
+
+	@Test
+	public void TIM() {
+		assemble(0x0000,
+			"TIM #0xAA,0x0020",
+			"TIM #0xF0,0x10,X");
+		// Set 0x20 to 0x0F.
+		write(0x0020, 0x0F);
+
+		setCC(0x00);
+		stepFrom(0x0000);
+		assertEquals(0, getCC());
+		assertEquals(0x0F, readByte(0x20));
+
+		setX(0x0010);
+		// Test the indexed variant.
+		stepFrom(0x0003);
+		assertEquals(CC.Z, getCC());
+		assertEquals(0x0F, readByte(0x20));
+	}
+
+	@Test
+	public void XGDX() {
+		assemble(0x0000, "XGDX");
+
+		setCC(0x00);
+		setX(0xCAFE);
+		setD(0xBABE);
+		stepFrom(0x0000);
+
+		assertEquals(0xBABE, getX());
+		assertEquals(0xCAFE, getD());
+		assertEquals(0x00, getCC());
+	}
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC6800Test.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC6800Test.java
new file mode 100644
index 0000000000..c3bd4357b3
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC6800Test.java
@@ -0,0 +1,153 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+import org.junit.jupiter.api.Test;
+
+public class EmulatorMC6800Test extends AbstractEmulatorTest {
+	public EmulatorMC6800Test() {
+		super("MC6800:BE:16:default");
+	}
+
+	@Test
+	public void NOP() {
+		setA(0x00);
+		setB(0x00);
+		setCC(0x00);
+		setX(0x0000);
+		setS(0x0800);
+
+		assemble(0x0000, "NOP");
+		stepFrom(0x000);
+
+		assertEquals(getA(), 0x00);
+		assertEquals(getB(), 0x00);
+		assertEquals(getCC(), 0x00);
+		assertEquals(getX(), 0x0000);
+		assertEquals(getS(), 0x0800);
+		assertEquals(0x0001, getPC());
+	}
+
+	@Test
+	public void CPX() {
+		assemble(0x0000, "CPX #0x1234");
+
+		// Test the equals case.
+		setX(0x1234);
+		setCC(0x00);
+		stepFrom(0x0000);
+		assertEquals(0x1234, getX());
+		assertEquals(CC.Z, getCC());
+
+		// Test the negative overflow case, as per the
+		// programming manual the carry flag is
+		// unaffected.
+		setX(0x1233);
+		setCC(0x00);
+		stepFrom(0x0000);
+		assertEquals(CC.N, getCC());
+	}
+
+	@Test
+	public void BLT() throws Exception {
+		assemble(0x0100,
+			"CMPA 	#0x10",		// Equals case.
+			"BLT 	0x130");
+		assemble(0x0110,
+			"CMPA	#0x20",		// Less-than case.
+			"BLT 	0x130");
+		assemble(0x0120,
+			"CMPA	#0x0A",		// Greater-than case.
+			"BLT 	0x130");
+
+		setA(0x10);
+		stepFrom(0x0100, 2);
+		assertNotEquals(getPC(), 0x0130);
+
+		stepFrom(0x0110, 2);
+		assertEquals(getPC(), 0x0130);
+
+		stepFrom(0x0120, 2);
+		assertNotEquals(getPC(), 0x0130);
+	}
+
+	@Test
+	public void BGT() throws Exception {
+		assemble(0x0100,
+			"CMPA 	#0x10",		// Equals case.
+			"BGT 	0x130");
+		assemble(0x0110,
+			"CMPA	#0x20",		// Less-than case.
+			"BGT 	0x130");
+		assemble(0x0120,
+			"CMPA	#0x0A",		// Greater-than case.
+			"BGT 	0x130");
+
+		setA(0x10);
+		stepFrom(0x0100, 2);
+		assertNotEquals(getPC(), 0x0130);
+
+		stepFrom(0x0110, 2);
+		assertNotEquals(getPC(), 0x0130);
+
+		stepFrom(0x0120, 2);
+		assertEquals(getPC(), 0x0130);
+	}
+
+	@Test
+	public void BLE() throws Exception {
+		assemble(0x0100,
+			"CMPA 	#0x10",		// Equals case.
+			"BLE 	0x130");
+		assemble(0x0110,
+			"CMPA	#0x20",		// Less-than case.
+			"BLE 	0x130");
+		assemble(0x0120,
+			"CMPA	#0x0A",		// Greater-than case.
+			"BLE 	0x130");
+
+		setA(0x10);
+		stepFrom(0x0100, 2);
+		assertEquals(getPC(), 0x0130);
+
+		stepFrom(0x0110, 2);
+		assertEquals(getPC(), 0x0130);
+
+		stepFrom(0x0120, 2);
+		assertNotEquals(getPC(), 0x0130);
+	}
+
+	@Test
+	public void JSR() throws Exception {
+		// This is an indirect test of the Push2 macro in the language spec.
+		assemble(0x0200,
+			"JSR 0x0300");
+
+		setS(0x07FF);
+		stepFrom(0x0200, 1);
+		assertEquals(0x0300, getPC());
+		assertEquals(0x07FD, getS());
+
+		final int retAddr = 0x0203; // Address after JSR instruction.
+
+		// Per big-endian stack storage, the high order byte should be
+		// at the ToS.
+		byte[] retaddr = read(0x07FE, 2);
+		assertEquals(retAddr & 0xFF, retaddr[1]);
+		assertEquals(retAddr >> 8, retaddr[0]);
+	}
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC6801Test.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC6801Test.java
new file mode 100644
index 0000000000..5f0d2b549b
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC6801Test.java
@@ -0,0 +1,61 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import org.junit.jupiter.api.Test;
+
+public class EmulatorMC6801Test extends AbstractEmulatorTest {
+	public EmulatorMC6801Test() {
+		super("MC6801:BE:16:default");
+	}
+
+	@Test
+	public void CPX() {
+		assemble(0x0000, "CPX #0x1234");
+
+		// Test the equals case.
+		setX(0x1234);
+		setCC(0x00);
+		stepFrom(0x0000);
+		assertEquals(0x1234, getX());
+		assertEquals(CC.Z, getCC());
+
+		// Test the negative overflow case, as per the
+		// programming manual the carry flag is set,
+		// which is opposite to the 6800 behavior.
+		setX(0x1233);
+		setCC(0x00);
+		stepFrom(0x0000);
+		assertEquals(CC.N + CC.C, getCC());
+	}
+
+	@Test
+	public void JSR_Direct() {
+		assemble(0x0100, "JSR 0x23");
+		// Make sure this assembles to JSR direct.
+		byte[] instruction = read(0x100, 2);
+		assertEquals((byte) 0x9D, instruction[0]);
+		assertEquals(0x23, instruction[1]);
+
+		setS(0x07FF);
+		stepFrom(0x0100);
+		assertEquals(0x07FD, getS());
+		assertEquals(0x01, readByte(0x07FE));
+		assertEquals(0x02, readByte(0x07FF));
+		assertEquals(0x0023, getPC());
+	}
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC68HC11Test.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC68HC11Test.java
new file mode 100644
index 0000000000..fad05a1674
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC68HC11Test.java
@@ -0,0 +1,565 @@
+// Copyright 2025 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import org.junit.jupiter.api.Test;
+
+public class EmulatorMC68HC11Test extends AbstractEmulatorTest {
+    public EmulatorMC68HC11Test() {
+        super("MC68HC11:BE:16:default");
+    }
+
+    // TODO(siggi): Test Y instructions.
+    // TODO(siggi): Test BRSET/BRCLR instructions.
+    // TODO(siggi): Test BSET/BCLR instructions.
+
+    @Test
+    public void LDA_Y() {
+        assemble(0x0000, "LDAA 0x10,Y");
+
+        // Set memory at 0x1020 to 0x42
+        write(0x1020, 0x42);
+        setY(0x1010);
+        setCC(0xFF);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x42, getA());
+        assertEquals(0x00, getCC() & (CC.N | CC.Z | CC.V));
+    }
+
+    @Test
+    public void LDB_Y() {
+        assemble(0x0000, "LDAB 0x20,Y");
+
+        // Set memory at 0x2030 to 0xAB
+        write(0x2030, 0xAB);
+        setY(0x2010);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals(0xAB, getB());
+        assertEquals(CC.N, getCC() & (CC.N | CC.Z | CC.V));
+    }
+
+    @Test
+    public void STA_Y() {
+        assemble(0x0000, "STAA 0x15,Y");
+
+        setA(0x55);
+        setY(0x1000);
+        setCC(0xFF);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x55, readByte(0x1015));
+        assertEquals(0x00, getCC() & (CC.N | CC.Z | CC.V));
+    }
+
+    @Test
+    public void STB_Y() {
+        assemble(0x0000, "STAB 0x08,Y");
+
+        setB(0xCC);
+        setY(0x2000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals((byte) 0xCC, readByte(0x2008));
+        assertEquals(CC.N, getCC() & (CC.N | CC.Z | CC.V));
+    }
+
+    @Test
+    public void LDD_Y() {
+        assemble(0x0000, "LDD 0x0A,Y");
+
+        // Set memory at 0x100A-0x100B to 0x1234
+        write(0x100A, 0x12, 0x34);
+        setY(0x1000);
+        setCC(0xFF);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x1234, getD());
+        assertEquals(0x00, getCC() & (CC.N | CC.Z | CC.V));
+    }
+
+    @Test
+    public void STD_Y() {
+        assemble(0x0000, "STD 0x05,Y");
+
+        setD(0xABCD);
+        setY(0x2000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        byte[] result = read(0x2005, 2);
+        assertEquals((byte) 0xAB, result[0]);
+        assertEquals((byte) 0xCD, result[1]);
+        assertEquals(CC.N, getCC() & (CC.N | CC.Z | CC.V));
+    }
+
+    @Test
+    public void ADDA_Y() {
+        assemble(0x0000, "ADDA 0x12,Y");
+
+        write(0x1022, 0x10);
+        setA(0x20);
+        setY(0x1010);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x30, getA());
+        assertEquals(0x00, getCC() & (CC.N | CC.Z | CC.V | CC.C));
+    }
+
+    @Test
+    public void ADDB_Y() {
+        assemble(0x0000, "ADDB 0x08,Y");
+
+        write(0x2008, 0xFF);
+        setB(0x02);
+        setY(0x2000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x01, getB());
+        assertEquals(CC.C, getCC() & (CC.N | CC.Z | CC.V | CC.C));
+    }
+
+    @Test
+    public void ADDD_Y() {
+        assemble(0x0000, "ADDD 0x10,Y");
+
+        write(0x1010, 0x12, 0x34);
+        setD(0x1000);
+        setY(0x1000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x2234, getD());
+        assertEquals(0x00, getCC() & (CC.N | CC.Z | CC.V | CC.C));
+    }
+
+    @Test
+    public void SUBA_Y() {
+        assemble(0x0000, "SUBA 0x05,Y");
+
+        write(0x1005, 0x10);
+        setA(0x30);
+        setY(0x1000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x20, getA());
+        assertEquals(0x00, getCC() & (CC.N | CC.Z | CC.V | CC.C));
+    }
+
+    @Test
+    public void SUBD_Y() {
+        assemble(0x0000, "SUBD 0x20,Y");
+
+        write(0x2020, 0x10, 0x00);
+        setD(0x2000);
+        setY(0x2000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x1000, getD());
+        assertEquals(0x00, getCC() & (CC.N | CC.Z | CC.V | CC.C));
+    }
+
+    @Test
+    public void CMPA_Y() {
+        assemble(0x0000, "CMPA 0x08,Y");
+
+        write(0x1008, 0x42);
+        setA(0x42);
+        setY(0x1000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x42, getA());
+        assertEquals(CC.Z, getCC() & (CC.N | CC.Z | CC.V | CC.C));
+    }
+
+    @Test
+    public void ANDA_Y() {
+        assemble(0x0000, "ANDA 0x10,Y");
+
+        write(0x1010, 0x0F);
+        setA(0xFF);
+        setY(0x1000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x0F, getA());
+        assertEquals(0x00, getCC() & (CC.N | CC.Z | CC.V));
+    }
+
+    @Test
+    public void ORAA_Y() {
+        assemble(0x0000, "ORAA 0x05,Y");
+
+        write(0x1005, 0xF0);
+        setA(0x0F);
+        setY(0x1000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals(0xFF, getA());
+        assertEquals(CC.N, getCC() & (CC.N | CC.Z | CC.V));
+    }
+
+    @Test
+    public void EORA_Y() {
+        assemble(0x0000, "EORA 0x12,Y");
+
+        write(0x1012, 0xAA);
+        setA(0xFF);
+        setY(0x1000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x55, getA());
+        assertEquals(0x00, getCC() & (CC.N | CC.Z | CC.V));
+    }
+
+    @Test
+    public void JSR_Y() {
+        assemble(0x0000, "JSR 0x10,Y");
+
+        setY(0x1000);
+        setS(0x2000);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x1010, getPC());
+        assertEquals(0x1FFE, getS());
+        // Check return address on stack
+        byte[] stackData = read(0x1FFF, 2);
+        assertEquals((byte) 0x00, stackData[0]);
+        assertEquals((byte) 0x03, stackData[1]);
+    }
+
+    @Test
+    public void JMP_Y() {
+        assemble(0x0000, "JMP 0x20,Y");
+
+        setY(0x3000);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x3020, getPC());
+    }
+
+    @Test
+    public void ASL_Y() {
+        assemble(0x0000, "ASL 0x08,Y");
+
+        write(0x1008, 0x42);
+        setY(0x1000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals((byte) 0x84, readByte(0x1008));
+        assertEquals(CC.N, getCC() & (CC.N | CC.Z | CC.V | CC.C));
+    }
+
+    @Test
+    public void LSR_Y() {
+        assemble(0x0000, "LSR 0x10,Y");
+
+        write(0x1010, 0x81);
+        setY(0x1000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x40, readByte(0x1010));
+        assertEquals(CC.C, getCC() & (CC.N | CC.Z | CC.V | CC.C));
+    }
+
+    @Test
+    public void INC_Y() {
+        assemble(0x0000, "INC 0x05,Y");
+
+        write(0x1005, 0x7F);
+        setY(0x1000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals((byte) 0x80, readByte(0x1005));
+        assertEquals(CC.N | CC.V, getCC() & (CC.N | CC.Z | CC.V));
+    }
+
+    @Test
+    public void DEC_Y() {
+        assemble(0x0000, "DEC 0x0A,Y");
+
+        write(0x100A, 0x01);
+        setY(0x1000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x00, readByte(0x100A));
+        assertEquals(CC.Z, getCC() & (CC.N | CC.Z | CC.V));
+    }
+
+    @Test
+    public void CLR_Y() {
+        assemble(0x0000, "CLR 0x15,Y");
+
+        write(0x1015, 0xFF);
+        setY(0x1000);
+        setCC(CC.N | CC.V | CC.C);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x00, readByte(0x1015));
+        // CLR clears N,V,C and sets Z
+        assertEquals(CC.Z, getCC());
+    }
+
+    @Test
+    public void TST_Y() {
+        assemble(0x0000, "TST 0x08,Y");
+
+        write(0x1008, 0x00);
+        setY(0x1000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x00, readByte(0x1008));
+        assertEquals(CC.Z, getCC() & (CC.N | CC.Z | CC.V | CC.C));
+    }
+
+    @Test
+    public void NEG_Y() {
+        assemble(0x0000, "NEG 0x10,Y");
+
+        write(0x1010, 0x01);
+        setY(0x1000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals((byte) 0xFF, readByte(0x1010));
+        assertEquals(CC.N | CC.C, getCC() & (CC.N | CC.Z | CC.V | CC.C));
+    }
+
+    @Test
+    public void COM_Y() {
+        assemble(0x0000, "COM 0x12,Y");
+
+        write(0x1012, 0xAA);
+        setY(0x1000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x55, readByte(0x1012));
+        assertEquals(CC.C, getCC() & (CC.N | CC.Z | CC.V | CC.C));
+    }
+
+    @Test
+    public void LDY() {
+        assemble(0x0000,
+            "LDY #0x1234",
+            "LDY 0x0020",
+            "LDY 0x1234");
+
+        // Test immediate mode
+        setCC(0xFF);
+        stepFrom(0x0000);
+        assertEquals(0x1234, getY());
+        assertEquals(0x00, getCC() & (CC.N | CC.Z | CC.V));
+
+        // Test direct mode
+        write(0x0020, 0xAB, 0xCD);
+        setCC(0x00);
+        stepFrom(0x0004);
+        assertEquals(0xABCD, getY());
+        assertEquals(CC.N, getCC() & (CC.N | CC.Z | CC.V));
+
+        // Test extended mode
+        write(0x1234, 0x00, 0x00);
+        setCC(0xFF);
+        stepFrom(0x0007);
+        assertEquals(0x0000, getY());
+        assertEquals(CC.Z, getCC() & (CC.N | CC.Z | CC.V));
+    }
+
+    @Test
+    public void STY() {
+        assemble(0x0000,
+            "STY 0x0020",
+            "STY 0x1234");
+
+        // Test direct mode
+        setY(0x5678);
+        setCC(0x00);
+        stepFrom(0x0000);
+        byte[] result1 = read(0x0020, 2);
+        assertEquals((byte) 0x56, result1[0]);
+        assertEquals((byte) 0x78, result1[1]);
+        assertEquals(0x00, getCC() & (CC.N | CC.Z | CC.V));
+
+        // Test extended mode
+        setY(0x9ABC);
+        setCC(0x00);
+        stepFrom(0x0003);
+        byte[] result2 = read(0x1234, 2);
+        assertEquals((byte) 0x9A, result2[0]);
+        assertEquals((byte) 0xBC, result2[1]);
+        assertEquals(CC.N, getCC() & (CC.N | CC.Z | CC.V));
+    }
+
+    @Test
+    public void CPY() {
+        assemble(0x0000,
+            "CPY #0x1234",
+            "CPY 0x0020");
+
+        // Test immediate mode - equal
+        setY(0x1234);
+        setCC(0x00);
+        stepFrom(0x0000);
+        assertEquals(0x1234, getY());
+        assertEquals(CC.Z, getCC());
+
+        // Test direct mode - less than
+        write(0x0020, 0x20, 0x00);
+        setY(0x1000);
+        setCC(0x00);
+        stepFrom(0x0004);
+        assertEquals(0x1000, getY());
+        assertEquals(CC.N | CC.C, getCC());
+    }
+
+    @Test
+    public void LDS_Y() {
+        assemble(0x0000, "LDS 0x10,Y");
+
+        write(0x1010, 0x20, 0x00);
+        setY(0x1000);
+        setCC(0xFF);
+
+        stepFrom(0x0000);
+
+        assertEquals(0x2000, getS());
+        assertEquals(0x00, getCC() & (CC.N | CC.Z | CC.V));
+    }
+
+    @Test
+    public void STS_Y() {
+        assemble(0x0000, "STS 0x08,Y");
+
+        setS(0x3456);
+        setY(0x1000);
+        setCC(0x00);
+
+        stepFrom(0x0000);
+
+        byte[] result = read(0x1008, 2);
+        assertEquals((byte) 0x34, result[0]);
+        assertEquals((byte) 0x56, result[1]);
+        assertEquals(0x00, getCC() & (CC.N | CC.Z | CC.V));
+    }
+
+    @Test
+    public void IDIV() {
+        assemble(0x0000, "IDIV");
+
+        // Divide by zero.
+        setD(0xFFFF);
+        setX(0x0000);
+        setCC(CC.V);
+        stepFrom(0x0000);
+        assertEquals(getX(), 0xFFFF);
+        assertEquals(getCC(), CC.C);
+
+        // Normal divide.
+        setD(0x1234);
+        setX(0x0011);
+        stepFrom(0x0000);
+        assertEquals(getX(), 0x1234 / 0x0011);
+        assertEquals(getD(), 0x1234 % 0x0011);
+        assertEquals(getCC(), 0x00);
+
+        // Zero result.
+        // Normal divide.
+        setD(0x0000);
+        setX(0x0011);
+        stepFrom(0x0000);
+        assertEquals(getX(), 0);
+        assertEquals(getD(), 0);
+        assertEquals(getCC(), CC.Z);
+    }
+
+    @Test
+    public void FDIV() {
+        assemble(0x0000, "FDIV");
+
+        // Divide by zero.
+        setD(0xFFFF);
+        setX(0x0000);
+        setCC(CC.V);
+        stepFrom(0x0000);
+        assertEquals(getX(), 0xFFFF);
+        assertEquals(getCC(), CC.C);
+
+        // Overflow.
+        setD(0x1234);
+        setX(0x1233);
+        stepFrom(0x0000);
+        assertEquals(getX(), 0xFFFF);
+        assertEquals(getCC(), CC.V);
+
+        // Zero result.
+        setD(0x0000);
+        setX(0x0011);
+        stepFrom(0x0000);
+        assertEquals(getX(), 0);
+        assertEquals(getD(), 0);
+        assertEquals(getCC(), CC.Z);
+
+        // Normal divide.
+        setD(0x1234);
+        setX(0x1235);
+        stepFrom(0x0000);
+        assertEquals(getX(), (0x1234 << 16) / 0x1235);
+        assertEquals(getD(), (0x1234 << 16) % 0x1235);
+        assertEquals(getCC(), 0x00);
+    }
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/MC6800JSRAnalyzerTest.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/MC6800JSRAnalyzerTest.java
new file mode 100644
index 0000000000..d71802b441
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/MC6800JSRAnalyzerTest.java
@@ -0,0 +1,44 @@
+// Copyright 2025 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import org.junit.jupiter.api.Test;
+
+public class MC6800JSRAnalyzerTest extends AbstractEmulatorTest {
+    public MC6800JSRAnalyzerTest() {
+        super("MC6800:BE:16:default");
+    }
+
+    @Test
+    public void DefaultEnablement() {
+        MC6800JSRAnalyzer analyzer = new MC6800JSRAnalyzer();
+        assertFalse(analyzer.getDefaultEnablement(program));
+    }
+
+    @Test
+    public void canAnalyzeMC6800() {
+        MC6800JSRAnalyzer analyzer = new MC6800JSRAnalyzer();
+        assertTrue(analyzer.canAnalyze(program));
+    }
+
+    // TODO(siggi): Test the actual analysis.
+    //   This requires setting up a program with computed JSR instructions,
+    //   then performing whatever analysis is needed to create the references.
+    //   Finally running the analyzer and checking that the primary reference
+    //   is set correctly.
+}
-- 
2.45.1

