From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: astrelsky <ajs222@njit.edu>
Date: Thu, 18 Feb 2021 17:06:57 -0500
Subject: [PATCH] 2779: Prevent unaligned inputs from sharing storage

---
 .../Decompiler/src/decompile/cpp/fspec.cc     | 55 ++++++++++++++++---
 .../Decompiler/src/decompile/cpp/fspec.hh     |  3 +-
 .../Decompiler/src/decompile/cpp/translate.hh |  1 +
 .../ghidra/program/model/lang/ParamEntry.java |  2 +
 .../program/model/lang/ParamListStandard.java | 44 +++++++++++++--
 5 files changed, 92 insertions(+), 13 deletions(-)

diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.cc
index 80311c3ff..5443c4366 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.cc
@@ -166,6 +166,21 @@ bool ParamEntry::subsumesDefinition(const ParamEntry &op2) const
 
 {
   if ((type!=TYPE_UNKNOWN)&&(op2.type != type)) return false;
+  if (joinrec) {
+    if (op2.joinrec) {
+      for (const VarnodeData& var : op2.joinrec->getPieces()) {
+        bool contains = false;
+        const size_t len = joinrec->numPieces();
+        for (size_t i = 0; i < len && !contains; i++)
+          contains = joinrec->getPiece(i).contains(var);
+        if (!contains) return false;
+      }
+      return true;
+    }
+    VarnodeData v2{op2.spaceid, op2.addressbase, static_cast<uint4>(op2.size)};
+    for (const VarnodeData& v1 : joinrec->getPieces())
+      if (v1.contains(v2)) return true;
+  }
   if (spaceid != op2.spaceid) return false;
   if (op2.addressbase < addressbase) return false;
   if ((op2.addressbase+op2.size-1) > (addressbase+size-1)) return false;
@@ -655,9 +670,7 @@ int4 ParamListStandard::characterizeAsParam(const Address &loc,int4 size) const
 Address ParamListStandard::assignAddress(const Datatype *tp,vector<int4> &status) const
 
 {
-  list<ParamEntry>::const_iterator iter;
-  for(iter=entry.begin();iter!=entry.end();++iter) {
-    const ParamEntry &curEntry( *iter );
+  for(const ParamEntry &curEntry : entry) {
     int4 grp = curEntry.getGroup();
     if (status[grp]<0) continue;
     if ((curEntry.getType() != TYPE_UNKNOWN) && tp->getMetatype() != curEntry.getType())
@@ -665,16 +678,42 @@ Address ParamListStandard::assignAddress(const Datatype *tp,vector<int4> &status
 
     Address res = curEntry.getAddrBySlot(status[grp],tp->getAlignSize(),tp->getAlignment());
     if (res.isInvalid()) continue; // If -tp- doesn't fit an invalid address is returned
-    if (curEntry.isExclusion()) {
-      const vector<int4> &groupSet(curEntry.getAllGroups());
-      for(int4 j=0;j<groupSet.size();++j) 	// For an exclusion entry
-	status[groupSet[j]] = -1;		// some number of groups are taken up
-    }
+    if (curEntry.isExclusion()) consumeGroups(status, curEntry);
     return res;
   }
   return Address();		// Return invalid address to indicated we could not assign anything
 }
 
+static bool containsAny(const ParamEntry& p1,const ParamEntry& p2)
+
+{
+  for (const VarnodeData& v1 : p1.getJoinRecord()->getPieces())
+    for (const VarnodeData& v2 : p2.getJoinRecord()->getPieces())
+      if (v1.contains(v2)) return true;
+  return false;
+}
+
+void ParamListStandard::consumeGroups(vector<int4> &status,const ParamEntry &element) const
+
+{
+  const vector<int4> &groupSet(element.getAllGroups());
+  for(int4 i=0;i<groupSet.size();++i)	// For an exclusion entry
+    status[groupSet[i]] = -1;		// some number of groups are taken up
+
+  // any entries which this element contains must also be set as taken
+  for (const ParamEntry &e : entry) {
+    if (&e == &element) continue;
+    int4 group = e.getGroup();
+    if (status[group] < 0) continue;
+    if (element.contains(e) || e.contains(element)) {
+      status[group] -= 1;
+      continue;
+    }
+    if (element.getJoinRecord() && e.getJoinRecord())
+      if (containsAny(element, e)) status[group] -= 1;
+  }
+}
+
 void ParamListStandard::assignMap(const vector<Datatype *> &proto,TypeFactory &typefactory,vector<ParameterPieces> &res) const
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.hh
index 929f1eca6..97767c96d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.hh
@@ -110,7 +110,7 @@ private:
   int4 minsize;			///< Minimum bytes allowed for the logical value
   int4 alignment;		///< How much alignment (0 means only 1 logical value is allowed)
   int4 numslots;		///< (Maximum) number of slots that can store separate parameters
-  JoinRecord *joinrec;		///< Non-null if this is logical variable from joined pieces
+  JoinRecord *joinrec;		///< Non-null if this is a logical variable from joined pieces
   static const ParamEntry *findEntryByStorage(const list<ParamEntry> &entryList,const VarnodeData &vn);
   void resolveJoin(list<ParamEntry> &curList); 	///< Make adjustments for a \e join ParamEntry
   void resolveOverlap(list<ParamEntry> &curList);	///< Make adjustments for ParamEntry that overlaps others
@@ -581,6 +581,7 @@ protected:
 		   int4 groupid,bool normalstack,bool autokill,bool splitFloat,bool grouped);
   void parseGroup(Decoder &decoder,vector<EffectRecord> &effectlist,
 		  int4 groupid,bool normalstack,bool autokill,bool splitFloat);
+  void consumeGroups(vector<int4> &status,const ParamEntry &element) const;
 public:
   ParamListStandard(void) {}						///< Construct for use with decode()
   ParamListStandard(const ParamListStandard &op2);			///< Copy constructor
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/translate.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/translate.hh
index 83b87ee7d..3196be1fe 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/translate.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/translate.hh
@@ -205,6 +205,7 @@ public:
   const VarnodeData &getUnified(void) const { return unified; }		///< Get the Varnode whole
   Address getEquivalentAddress(uintb offset,int4 &pos) const;	///< Given offset in \e join space, get equivalent address of piece
   bool operator<(const JoinRecord &op2) const; ///< Compare records lexigraphically by pieces
+  const vector<VarnodeData> &getPieces() const { return pieces; } ///< Get an iterator over the const pieces
 };
 
 /// \brief Comparator for JoinRecord objects
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/ParamEntry.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/ParamEntry.java
index 2f39238b3..902567131 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/ParamEntry.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/ParamEntry.java
@@ -136,6 +136,8 @@ public class ParamEntry {
 		int first, replace;
 		Varnode vn = null;
 		Varnode[] res;
+		if (joinrec == null)
+			return null;
 		if (isBigEndian()) {
 			first = 0;
 			while (sz > 0) {
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/ParamListStandard.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/ParamListStandard.java
index 23b8c1669..cd5bf4c3c 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/ParamListStandard.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/ParamListStandard.java
@@ -104,10 +104,7 @@ public class ParamListStandard implements ParamList {
 				continue;	// -tp- does not fit in this entry
 			}
 			if (element.isExclusion()) {
-				for (int group : element.getAllGroups()) {
-					// For an exclusion entry
-					status[group] = -1;			// some number of groups are taken up
-				}
+				excludeGroups(status, element);
 				if (element.isFloatExtended()) {
 					sz = element.getSize();			// Still use the entire container size, when assigning storage
 				}
@@ -419,4 +416,43 @@ public class ParamListStandard implements ParamList {
 	public boolean isThisBeforeRetPointer() {
 		return thisbeforeret;
 	}
+
+	private void excludeGroups(int[] status, ParamEntry element) {
+		for (int group : element.getAllGroups()) {
+			// For an exclusion entry
+			status[group] = -1;			// some number of groups are taken up
+		}
+
+		// any entries which this element contains must also be set as taken
+		for (ParamEntry e : entry) {
+			if (e == element) {
+				continue;
+			}
+			int group = e.getGroup();
+			if (status[group] < 0) {
+				continue;
+			}
+			if (element.contains(e) || e.contains(element)) {
+				status[group] -= 1;
+				continue;
+			}
+			if (element.getJoinPieces(element.getSize()) != null && e.getJoinPieces(e.getSize()) != null) {
+				// contains only returns true if one contains all of the other
+				if (containsAny(element, e)) {
+					status[group] -= 1;
+				}
+			}
+		}
+	}
+
+	private static boolean containsAny(ParamEntry p1, ParamEntry p2) {
+		for (Varnode v1 : p1.getJoinPieces(p1.getSize())) {
+			for (Varnode v2 : p2.getJoinPieces(p2.getSize())) {
+				if (v1.contains(v2.getAddress())) {
+					return true;
+				}
+			}
+		}
+		return false;
+	}
 }
-- 
2.41.0

