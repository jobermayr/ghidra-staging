From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Joel Anderson <joelanderson333@gmail.com>
Date: Sat, 2 Oct 2021 22:37:04 -0400
Subject: [PATCH] 3472: align comments with code in decompiler

Add a configuration option for the decompiler to align
comments with code instead of using the fixed indentation setting.
---
 .../Decompiler/src/decompile/cpp/bfd_arch.cc  |   2 +-
 .../Decompiler/src/decompile/cpp/callgraph.cc |   4 +-
 .../src/decompile/cpp/ghidra_arch.cc          |  38 ++--
 .../src/decompile/cpp/ghidra_process.cc       |   2 +-
 .../Decompiler/src/decompile/cpp/jumptable.cc |  14 +-
 .../src/decompile/cpp/loadimage_xml.cc        |   4 +-
 .../Decompiler/src/decompile/cpp/options.cc   |  77 ++++----
 .../Decompiler/src/decompile/cpp/options.hh   |   6 +
 .../Decompiler/src/decompile/cpp/override.cc  |  14 +-
 .../src/decompile/cpp/prefersplit.cc          |   2 +-
 .../src/decompile/cpp/printlanguage.cc        |  19 +-
 .../src/decompile/cpp/printlanguage.hh        |   2 +
 .../Decompiler/src/decompile/cpp/raw_arch.cc  |   2 +-
 .../src/decompile/cpp/sleigh_arch.cc          |   8 +-
 .../Decompiler/src/decompile/cpp/varmap.cc    |   2 +-
 .../Decompiler/src/decompile/cpp/xml_arch.cc  |   2 +-
 .../DecompilePlugin/DecompilerOptions.html    |   9 +
 .../app/decompiler/DecompileOptions.java      |  31 ++++
 .../plugin/core/decompile/DecompilerTest.java |  77 +++++++-
 .../ghidra/program/model/pcode/ElementId.java | 168 +++++++++---------
 20 files changed, 315 insertions(+), 168 deletions(-)

diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/bfd_arch.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/bfd_arch.cc
index a3f111f17..3987da1f2 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/bfd_arch.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/bfd_arch.cc
@@ -21,7 +21,7 @@ namespace ghidra {
 // Constructing this object registers capability
 BfdArchitectureCapability BfdArchitectureCapability::bfdArchitectureCapability;
 
-ElementId ELEM_BFD_SAVEFILE = ElementId("bfd_savefile",238);
+ElementId ELEM_BFD_SAVEFILE = ElementId("bfd_savefile",240);
 
 BfdArchitectureCapability::BfdArchitectureCapability(void)
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/callgraph.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/callgraph.cc
index c7dfbea0b..fcb0eece9 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/callgraph.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/callgraph.cc
@@ -18,8 +18,8 @@
 
 namespace ghidra {
 
-ElementId ELEM_CALLGRAPH = ElementId("callgraph",226);
-ElementId ELEM_NODE = ElementId("node",227);
+ElementId ELEM_CALLGRAPH = ElementId("callgraph",228);
+ElementId ELEM_NODE = ElementId("node",229);
 
 void CallGraphEdge::encode(Encoder &encoder) const
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.cc
index 560c6708f..5a6cf32fd 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_arch.cc
@@ -27,25 +27,25 @@ namespace ghidra {
 
 //AttributeId ATTRIB_BADDATA = AttributeId("baddata",145);
 
-ElementId ELEM_COMMAND_ISNAMEUSED = ElementId("command_isnameused",239);
-ElementId ELEM_COMMAND_GETBYTES = ElementId("command_getbytes",240);
-ElementId ELEM_COMMAND_GETCALLFIXUP = ElementId("command_getcallfixup",241);
-ElementId ELEM_COMMAND_GETCALLMECH = ElementId("command_getcallmech",242);
-ElementId ELEM_COMMAND_GETCALLOTHERFIXUP = ElementId("command_getcallotherfixup",243);
-ElementId ELEM_COMMAND_GETCODELABEL = ElementId("command_getcodelabel",244);
-ElementId ELEM_COMMAND_GETCOMMENTS = ElementId("command_getcomments",245);
-ElementId ELEM_COMMAND_GETCPOOLREF = ElementId("command_getcpoolref",246);
-ElementId ELEM_COMMAND_GETDATATYPE = ElementId("command_getdatatype",247);
-ElementId ELEM_COMMAND_GETEXTERNALREF = ElementId("command_getexternalref",248);
-ElementId ELEM_COMMAND_GETMAPPEDSYMBOLS = ElementId("command_getmappedsymbols",249);
-ElementId ELEM_COMMAND_GETNAMESPACEPATH = ElementId("command_getnamespacepath",250);
-ElementId ELEM_COMMAND_GETPCODE = ElementId("command_getpcode",251);
-ElementId ELEM_COMMAND_GETPCODEEXECUTABLE = ElementId("command_getpcodeexecutable",252);
-ElementId ELEM_COMMAND_GETREGISTER = ElementId("command_getregister",253);
-ElementId ELEM_COMMAND_GETREGISTERNAME = ElementId("command_getregistername",254);
-ElementId ELEM_COMMAND_GETSTRINGDATA = ElementId("command_getstringdata",255);
-ElementId ELEM_COMMAND_GETTRACKEDREGISTERS = ElementId("command_gettrackedregisters",256);
-ElementId ELEM_COMMAND_GETUSEROPNAME = ElementId("command_getuseropname",257);
+ElementId ELEM_COMMAND_ISNAMEUSED = ElementId("command_isnameused",241);
+ElementId ELEM_COMMAND_GETBYTES = ElementId("command_getbytes",242);
+ElementId ELEM_COMMAND_GETCALLFIXUP = ElementId("command_getcallfixup",243);
+ElementId ELEM_COMMAND_GETCALLMECH = ElementId("command_getcallmech",244);
+ElementId ELEM_COMMAND_GETCALLOTHERFIXUP = ElementId("command_getcallotherfixup",245);
+ElementId ELEM_COMMAND_GETCODELABEL = ElementId("command_getcodelabel",246);
+ElementId ELEM_COMMAND_GETCOMMENTS = ElementId("command_getcomments",247);
+ElementId ELEM_COMMAND_GETCPOOLREF = ElementId("command_getcpoolref",248);
+ElementId ELEM_COMMAND_GETDATATYPE = ElementId("command_getdatatype",249);
+ElementId ELEM_COMMAND_GETEXTERNALREF = ElementId("command_getexternalref",250);
+ElementId ELEM_COMMAND_GETMAPPEDSYMBOLS = ElementId("command_getmappedsymbols",251);
+ElementId ELEM_COMMAND_GETNAMESPACEPATH = ElementId("command_getnamespacepath",252);
+ElementId ELEM_COMMAND_GETPCODE = ElementId("command_getpcode",253);
+ElementId ELEM_COMMAND_GETPCODEEXECUTABLE = ElementId("command_getpcodeexecutable",254);
+ElementId ELEM_COMMAND_GETREGISTER = ElementId("command_getregister",255);
+ElementId ELEM_COMMAND_GETREGISTERNAME = ElementId("command_getregistername",256);
+ElementId ELEM_COMMAND_GETSTRINGDATA = ElementId("command_getstringdata",257);
+ElementId ELEM_COMMAND_GETTRACKEDREGISTERS = ElementId("command_gettrackedregisters",258);
+ElementId ELEM_COMMAND_GETUSEROPNAME = ElementId("command_getuseropname",259);
 
 /// Catch the signal so the OS doesn't pop up a dialog
 /// \param sig is the OS signal (should always be SIGSEGV)
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc
index 36cab1ede..c282c25f1 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ghidra_process.cc
@@ -71,7 +71,7 @@ void connect_to_console(Funcdata *fd)
 
 #endif
 
-ElementId ELEM_DOC = ElementId("doc",229);
+ElementId ELEM_DOC = ElementId("doc",231);
 
 vector<ArchitectureGhidra *> archlist; // List of architectures currently running
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/jumptable.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/jumptable.cc
index 6a464c16d..55848aade 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/jumptable.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/jumptable.cc
@@ -23,13 +23,13 @@ namespace ghidra {
 AttributeId ATTRIB_LABEL = AttributeId("label",131);
 AttributeId ATTRIB_NUM = AttributeId("num",132);
 
-ElementId ELEM_BASICOVERRIDE = ElementId("basicoverride",211);
-ElementId ELEM_DEST = ElementId("dest",212);
-ElementId ELEM_JUMPTABLE = ElementId("jumptable",213);
-ElementId ELEM_LOADTABLE = ElementId("loadtable",214);
-ElementId ELEM_NORMADDR = ElementId("normaddr",215);
-ElementId ELEM_NORMHASH = ElementId("normhash",216);
-ElementId ELEM_STARTVAL = ElementId("startval",217);
+ElementId ELEM_BASICOVERRIDE = ElementId("basicoverride",213);
+ElementId ELEM_DEST = ElementId("dest",214);
+ElementId ELEM_JUMPTABLE = ElementId("jumptable",215);
+ElementId ELEM_LOADTABLE = ElementId("loadtable",216);
+ElementId ELEM_NORMADDR = ElementId("normaddr",217);
+ElementId ELEM_NORMHASH = ElementId("normhash",218);
+ElementId ELEM_STARTVAL = ElementId("startval",219);
 
 /// \param encoder is the stream encoder
 void LoadTable::encode(Encoder &encoder) const
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_xml.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_xml.cc
index 6847a5ebc..043d96eca 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_xml.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/loadimage_xml.cc
@@ -20,8 +20,8 @@ namespace ghidra {
 
 AttributeId ATTRIB_ARCH = AttributeId("arch",135);
 
-ElementId ELEM_BINARYIMAGE = ElementId("binaryimage",230);
-ElementId ELEM_BYTECHUNK = ElementId("bytechunk",231);
+ElementId ELEM_BINARYIMAGE = ElementId("binaryimage",232);
+ElementId ELEM_BYTECHUNK = ElementId("bytechunk",233);
 
 /// \param f is the (path to the) underlying XML file
 /// \param el is the parsed form of the file
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/options.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/options.cc
index 867fe8eb2..6eaf553e9 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/options.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/options.cc
@@ -25,39 +25,41 @@ ElementId ELEM_ALLOWCONTEXTSET = ElementId("allowcontextset",175);
 ElementId ELEM_ANALYZEFORLOOPS = ElementId("analyzeforloops",176);
 ElementId ELEM_COMMENTHEADER = ElementId("commentheader",177);
 ElementId ELEM_COMMENTINDENT = ElementId("commentindent",178);
-ElementId ELEM_COMMENTINSTRUCTION = ElementId("commentinstruction",179);
-ElementId ELEM_COMMENTSTYLE = ElementId("commentstyle",180);
-ElementId ELEM_CONVENTIONPRINTING = ElementId("conventionprinting",181);
-ElementId ELEM_CURRENTACTION = ElementId("currentaction",182);
-ElementId ELEM_DEFAULTPROTOTYPE = ElementId("defaultprototype",183);
-ElementId ELEM_ERRORREINTERPRETED = ElementId("errorreinterpreted",184);
-ElementId ELEM_ERRORTOOMANYINSTRUCTIONS = ElementId("errortoomanyinstructions",185);
-ElementId ELEM_ERRORUNIMPLEMENTED = ElementId("errorunimplemented",186);
-ElementId ELEM_EXTRAPOP = ElementId("extrapop",187);
-ElementId ELEM_IGNOREUNIMPLEMENTED = ElementId("ignoreunimplemented",188);
-ElementId ELEM_INDENTINCREMENT = ElementId("indentincrement",189);
-ElementId ELEM_INFERCONSTPTR = ElementId("inferconstptr",190);
-ElementId ELEM_INLINE = ElementId("inline",191);
-ElementId ELEM_INPLACEOPS = ElementId("inplaceops",192);
-ElementId ELEM_INTEGERFORMAT = ElementId("integerformat",193);
-ElementId ELEM_JUMPLOAD = ElementId("jumpload",194);
-ElementId ELEM_MAXINSTRUCTION = ElementId("maxinstruction",195);
-ElementId ELEM_MAXLINEWIDTH = ElementId("maxlinewidth",196);
-ElementId ELEM_NAMESPACESTRATEGY = ElementId("namespacestrategy",197);
-ElementId ELEM_NOCASTPRINTING = ElementId("nocastprinting",198);
-ElementId ELEM_NORETURN = ElementId("noreturn",199);
-ElementId ELEM_NULLPRINTING = ElementId("nullprinting",200);
-ElementId ELEM_OPTIONSLIST = ElementId("optionslist",201);
-ElementId ELEM_PARAM1 = ElementId("param1",202);
-ElementId ELEM_PARAM2 = ElementId("param2",203);
-ElementId ELEM_PARAM3 = ElementId("param3",204);
-ElementId ELEM_PROTOEVAL = ElementId("protoeval",205);
-ElementId ELEM_SETACTION = ElementId("setaction",206);
-ElementId ELEM_SETLANGUAGE = ElementId("setlanguage",207);
+ElementId ELEM_COMMENTINDENTALIGN = ElementId("commentindentalign",179);
+ElementId ELEM_COMMENTINSTRUCTION = ElementId("commentinstruction",180);
+ElementId ELEM_COMMENTSTYLE = ElementId("commentstyle",181);
+ElementId ELEM_CONVENTIONPRINTING = ElementId("conventionprinting",182);
+ElementId ELEM_CURRENTACTION = ElementId("currentaction",183);
+ElementId ELEM_DEFAULTPROTOTYPE = ElementId("defaultprototype",184);
+ElementId ELEM_ERRORREINTERPRETED = ElementId("errorreinterpreted",185);
+ElementId ELEM_ERRORTOOMANYINSTRUCTIONS = ElementId("errortoomanyinstructions",186);
+ElementId ELEM_ERRORUNIMPLEMENTED = ElementId("errorunimplemented",187);
+ElementId ELEM_EXTRAPOP = ElementId("extrapop",188);
+ElementId ELEM_IGNOREUNIMPLEMENTED = ElementId("ignoreunimplemented",189);
+ElementId ELEM_INDENTINCREMENT = ElementId("indentincrement",190);
+ElementId ELEM_INFERCONSTPTR = ElementId("inferconstptr",191);
+ElementId ELEM_INLINE = ElementId("inline",192);
+ElementId ELEM_INPLACEOPS = ElementId("inplaceops",193);
+ElementId ELEM_INTEGERFORMAT = ElementId("integerformat",194);
+ElementId ELEM_JUMPLOAD = ElementId("jumpload",195);
+ElementId ELEM_MAXINSTRUCTION = ElementId("maxinstruction",196);
+ElementId ELEM_MAXLINEWIDTH = ElementId("maxlinewidth",197);
+ElementId ELEM_NAMESPACESTRATEGY = ElementId("namespacestrategy",198);
+ElementId ELEM_NOCASTPRINTING = ElementId("nocastprinting",199);
+ElementId ELEM_NORETURN = ElementId("noreturn",200);
+ElementId ELEM_NULLPRINTING = ElementId("nullprinting",201);
+ElementId ELEM_OPTIONSLIST = ElementId("optionslist",202);
+ElementId ELEM_PARAM1 = ElementId("param1",203);
+ElementId ELEM_PARAM2 = ElementId("param2",204);
+ElementId ELEM_PARAM3 = ElementId("param3",205);
+ElementId ELEM_PROTOEVAL = ElementId("protoeval",206);
+ElementId ELEM_INDENTATIONSTYLE = ElementId("indentationstyle",207);
+ElementId ELEM_SETACTION = ElementId("setaction",208);
 ElementId ELEM_SPLITDATATYPE = ElementId("splitdatatype",270);
-ElementId ELEM_STRUCTALIGN = ElementId("structalign",208);
-ElementId ELEM_TOGGLERULE = ElementId("togglerule",209);
-ElementId ELEM_WARNING = ElementId("warning",210);
+ElementId ELEM_SETLANGUAGE = ElementId("setlanguage",209);
+ElementId ELEM_STRUCTALIGN = ElementId("structalign",210);
+ElementId ELEM_TOGGLERULE = ElementId("togglerule",211);
+ElementId ELEM_WARNING = ElementId("warning",212);
 ElementId ELEM_JUMPTABLEMAX = ElementId("jumptablemax",271);
 ElementId ELEM_NANIGNORE = ElementId("nanignore",272);
 ElementId ELEM_BRACEFORMAT = ElementId("braceformat",284);
@@ -114,6 +116,7 @@ OptionDatabase::OptionDatabase(Architecture *g)
   registerOption(new OptionMaxLineWidth());
   registerOption(new OptionIndentIncrement());
   registerOption(new OptionCommentIndent());
+  registerOption(new OptionCommentIndentAlign());
   registerOption(new OptionCommentStyle());
   registerOption(new OptionCommentHeader());
   registerOption(new OptionCommentInstruction());
@@ -515,6 +518,16 @@ string OptionCommentIndent::apply(Architecture *glb,const string &p1,const strin
   return "Comment indent set to "+p1;
 }
 
+/// \class OptionCommentIndentAlign
+/// \brief Toggle whether to align the comment with the current code rather or use a fixed indentation.
+string OptionCommentIndentAlign::apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const
+
+{
+  bool val = onOrOff(p1);
+  glb->print->setLineCommentIndentAlign(val);
+  return "Comment indent alignment turned "+p1;
+}
+
 /// \class OptionCommentStyle
 /// \brief Set the style of comment emitted by the decompiler
 ///
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/options.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/options.hh
index 7a7f713b8..af3304504 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/options.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/options.hh
@@ -211,6 +211,12 @@ public:
   virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
 };
 
+class OptionCommentIndentAlign : public ArchOption {
+public:
+  OptionCommentIndentAlign(void) { name = "commentindentalign"; }	///< Constructor
+  virtual string apply(Architecture *glb,const string &p1,const string &p2,const string &p3) const;
+};
+
 class OptionCommentStyle : public ArchOption {
 public:
   OptionCommentStyle(void) { name = "commentstyle"; }	///< Constructor
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/override.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/override.cc
index b01f7c4e4..453f5fa14 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/override.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/override.cc
@@ -18,13 +18,13 @@
 
 namespace ghidra {
 
-ElementId ELEM_DEADCODEDELAY = ElementId("deadcodedelay",218);
-ElementId ELEM_FLOW = ElementId("flow",219);
-ElementId ELEM_FORCEGOTO = ElementId("forcegoto",220);
-ElementId ELEM_INDIRECTOVERRIDE = ElementId("indirectoverride",221);
-ElementId ELEM_MULTISTAGEJUMP = ElementId("multistagejump",222);
-ElementId ELEM_OVERRIDE = ElementId("override",223);
-ElementId ELEM_PROTOOVERRIDE = ElementId("protooverride",224);
+ElementId ELEM_DEADCODEDELAY = ElementId("deadcodedelay",220);
+ElementId ELEM_FLOW = ElementId("flow",221);
+ElementId ELEM_FORCEGOTO = ElementId("forcegoto",222);
+ElementId ELEM_INDIRECTOVERRIDE = ElementId("indirectoverride",223);
+ElementId ELEM_MULTISTAGEJUMP = ElementId("multistagejump",224);
+ElementId ELEM_OVERRIDE = ElementId("override",225);
+ElementId ELEM_PROTOOVERRIDE = ElementId("protooverride",226);
 
 void Override::clear(void)
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/prefersplit.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/prefersplit.cc
index 826ff069d..5c12fa94f 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/prefersplit.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/prefersplit.cc
@@ -18,7 +18,7 @@
 
 namespace ghidra {
 
-ElementId ELEM_PREFERSPLIT = ElementId("prefersplit",225);
+ElementId ELEM_PREFERSPLIT = ElementId("prefersplit",227);
 
 bool PreferSplitRecord::operator<(const PreferSplitRecord &op2) const
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.cc
index 34210f05f..2833708a9 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.cc
@@ -88,6 +88,13 @@ void PrintLanguage::setLineCommentIndent(int4 val)
   line_commentindent = val;
 }
 
+/// \param val is whether to align comments with code or use a fixed indentation
+void PrintLanguage::setLineCommentIndentAlign(bool val)
+
+{
+  line_commentindentalign = val;
+}
+
 /// By default, comments are indicated in the high-level language by preceding
 /// them with a specific sequence of delimiter characters, and optionally
 /// by ending the comment with another set of delimiter characters.
@@ -588,6 +595,7 @@ void PrintLanguage::resetDefaultsInternal(void)
   mods = 0;
   head_comment_type = Comment::header | Comment::warningheader;
   line_commentindent = 20;
+  line_commentindentalign = false;
   namespc_strategy = MINIMAL_NAMESPACES;
   instr_comment_type = Comment::user2 | Comment::warning;
 }
@@ -602,9 +610,14 @@ void PrintLanguage::emitLineComment(int4 indent,const Comment *comm)
   const string &text( comm->getText() );
   const AddrSpace *spc = comm->getAddr().getSpace();
   uintb off = comm->getAddr().getOffset();
-  if (indent <0)
-    indent = line_commentindent; // User specified default indent
-  emit->tagLine(indent);
+  if (line_commentindentalign) {
+    emit->tagLine();
+  }
+  else {
+    if (indent <0)
+      indent = line_commentindent; // User specified default indent
+    emit->tagLine(indent);
+  }
   int4 id = emit->startComment();
   // The comment delimeters should not be printed as
   // comment tags, so that they won't get filled
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.hh
index 307ccb618..580e3632f 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/printlanguage.hh
@@ -266,6 +266,7 @@ private:
   vector<NodePending> nodepend;		///< Data-flow nodes waiting to be pushed onto the RPN stack
   int4 pending;				///< Number of data-flow nodes waiting to be pushed
   int4 line_commentindent;		///< Number of characters a comment line should be indented
+  bool line_commentindentalign;		///< Whether to align comment lines with code or use a fixed indentation
   string commentstart;			///< Delimiter characters for the start of a comment
   string commentend;			///< Delimiter characters (if any) for the end of a comment
 protected:
@@ -447,6 +448,7 @@ public:
   void setMaxLineSize(int4 mls) { emit->setMaxLineSize(mls); }		///< Set the maximum number of characters per line
   void setIndentIncrement(int4 inc) { emit->setIndentIncrement(inc); }	///< Set the number of characters to indent per level of code nesting
   void setLineCommentIndent(int4 val);					///< Set the number of characters to indent comment lines
+  void setLineCommentIndentAlign(bool val);				///< Set whether to align comment lines with code lines or not
   void setCommentDelimeter(const string &start,const string &stop,
 			   bool usecommentfill);			///< Establish comment delimiters for the language
   uint4 getInstructionComment(void) const { return instr_comment_type; }	///< Get the type of comments suitable within the body of a function
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/raw_arch.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/raw_arch.cc
index 9e4169cc1..db9f3e0cc 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/raw_arch.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/raw_arch.cc
@@ -17,7 +17,7 @@
 
 namespace ghidra {
 
-ElementId ELEM_RAW_SAVEFILE = ElementId("raw_savefile",237);
+ElementId ELEM_RAW_SAVEFILE = ElementId("raw_savefile",239);
 
 // Constructing this object registers the capability
 RawBinaryArchitectureCapability RawBinaryArchitectureCapability::rawBinaryArchitectureCapability;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh_arch.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh_arch.cc
index ab5fd936d..bbe33e48a 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh_arch.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/sleigh_arch.cc
@@ -28,10 +28,10 @@ AttributeId ATTRIB_TARGET = AttributeId("target",142);
 AttributeId ATTRIB_VARIANT = AttributeId("variant",143);
 AttributeId ATTRIB_VERSION = AttributeId("version",144);
 
-ElementId ELEM_COMPILER = ElementId("compiler",232);
-ElementId ELEM_DESCRIPTION = ElementId("description",233);
-ElementId ELEM_LANGUAGE = ElementId("language",234);
-ElementId ELEM_LANGUAGE_DEFINITIONS = ElementId("language_definitions",235);
+ElementId ELEM_COMPILER = ElementId("compiler",234);
+ElementId ELEM_DESCRIPTION = ElementId("description",235);
+ElementId ELEM_LANGUAGE = ElementId("language",236);
+ElementId ELEM_LANGUAGE_DEFINITIONS = ElementId("language_definitions",237);
 
 map<int4,Sleigh *> SleighArchitecture::translators;
 vector<LanguageDescription> SleighArchitecture::description;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.cc
index 45f29a84e..cae4e3471 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/varmap.cc
@@ -21,7 +21,7 @@ namespace ghidra {
 AttributeId ATTRIB_LOCK = AttributeId("lock",133);
 AttributeId ATTRIB_MAIN = AttributeId("main",134);
 
-ElementId ELEM_LOCALDB = ElementId("localdb",228);
+ElementId ELEM_LOCALDB = ElementId("localdb",230);
 
 /// \brief Can the given intersecting RangeHint coexist with \b this at their given offsets
 ///
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/xml_arch.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/xml_arch.cc
index ff76eac1a..8af9fa03e 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/xml_arch.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/xml_arch.cc
@@ -17,7 +17,7 @@
 
 namespace ghidra {
 
-ElementId ELEM_XML_SAVEFILE = ElementId("xml_savefile",236);
+ElementId ELEM_XML_SAVEFILE = ElementId("xml_savefile",238);
 
 // Constructing the singleton registers the capability
 XmlArchitectureCapability XmlArchitectureCapability::xmlArchitectureCapability;
diff --git a/Ghidra/Features/Decompiler/src/main/help/help/topics/DecompilePlugin/DecompilerOptions.html b/Ghidra/Features/Decompiler/src/main/help/help/topics/DecompilePlugin/DecompilerOptions.html
index a59fceb8d..35db43271 100644
--- a/Ghidra/Features/Decompiler/src/main/help/help/topics/DecompilePlugin/DecompilerOptions.html
+++ b/Ghidra/Features/Decompiler/src/main/help/help/topics/DecompilePlugin/DecompilerOptions.html
@@ -545,6 +545,15 @@
 	</p>
       </dd>
 <dt>
+<a name="DisplayCommentIndentAlign"></a><span class="term"><span class="bold"><strong>Align comments with code</strong></span></span>
+</dt>
+<dd>
+	<p>
+	  Aligns comment lines with the current indentation level of the decompiler output, instead of using a
+	  fixed amount of spaces. When checked, the comment line indent level option is ignored.
+	</p>
+      </dd>
+<dt>
 <a name="DisplayCommentStyle"></a><span class="term"><span class="bold"><strong>Comment style</strong></span></span>
 </dt>
 <dd>
diff --git a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileOptions.java b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileOptions.java
index 6b0541ce6..77c18db80 100644
--- a/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileOptions.java
+++ b/Ghidra/Features/Decompiler/src/main/java/ghidra/app/decompiler/DecompileOptions.java
@@ -284,6 +284,13 @@ public class DecompileOptions {
 	private final static int COMMENTINDENT_OPTIONDEFAULT = 20;	// Must match PrintLanguage::resetDefaultsInternal
 	private int commentindent;
 
+	private final static String COMMENTINDENTALIGN_OPTIONSTRING = "Display.Comment lines aligned with code";
+	private final static String COMMENTINDENTALIGN_OPTIONDESCRIPTION =
+		"Align each comment with the indentation of the code immediately " +
+			"following it, instead of using the comment line indent level";
+	private final static boolean COMMENTINDENTALIGN_OPTIONDEFAULT = false;	// Must match PrintLanguage::resetDefaultsInternal
+	private boolean commentindentAlign;
+
 	private final static String COMMENTSTYLE_OPTIONSTRING = "Display.Comment style";
 	private final static String COMMENTSTYLE_OPTIONDESCRIPTION =
 		"Choice between either the C style comments /* */ or C++ style // ";
@@ -507,6 +514,7 @@ public class DecompileOptions {
 		maxwidth = MAXWIDTH_OPTIONDEFAULT;
 		indentwidth = INDENTWIDTH_OPTIONDEFAULT;
 		commentindent = COMMENTINDENT_OPTIONDEFAULT;
+		commentindentAlign = COMMENTINDENTALIGN_OPTIONDEFAULT;
 		commentStyle = COMMENTSTYLE_OPTIONDEFAULT;
 		commentPREInclude = COMMENTPRE_OPTIONDEFAULT;
 		commentPLATEInclude = COMMENTPLATE_OPTIONDEFAULT;
@@ -571,6 +579,7 @@ public class DecompileOptions {
 		maxwidth = opt.getInt(MAXWIDTH_OPTIONSTRING, MAXWIDTH_OPTIONDEFAULT);
 		indentwidth = opt.getInt(INDENTWIDTH_OPTIONSTRING, INDENTWIDTH_OPTIONDEFAULT);
 		commentindent = opt.getInt(COMMENTINDENT_OPTIONSTRING, COMMENTINDENT_OPTIONDEFAULT);
+		commentindentAlign = opt.getBoolean(COMMENTINDENTALIGN_OPTIONSTRING, COMMENTINDENTALIGN_OPTIONDEFAULT);
 		commentStyle = opt.getEnum(COMMENTSTYLE_OPTIONSTRING, COMMENTSTYLE_OPTIONDEFAULT);
 		commentEOLInclude = opt.getBoolean(COMMENTEOL_OPTIONSTRING, COMMENTEOL_OPTIONDEFAULT);
 		commentPREInclude = opt.getBoolean(COMMENTPRE_OPTIONSTRING, COMMENTPRE_OPTIONDEFAULT);
@@ -718,6 +727,9 @@ public class DecompileOptions {
 		opt.registerOption(COMMENTINDENT_OPTIONSTRING, COMMENTINDENT_OPTIONDEFAULT,
 			new HelpLocation(HelpTopics.DECOMPILER, "DisplayCommentIndent"),
 			COMMENTINDENT_OPTIONDESCRIPTION);
+		opt.registerOption(COMMENTINDENTALIGN_OPTIONSTRING, COMMENTINDENTALIGN_OPTIONDEFAULT,
+			new HelpLocation(HelpTopics.DECOMPILER, "DisplayCommentIndentAlign"),
+			COMMENTINDENTALIGN_OPTIONDESCRIPTION);
 		opt.registerOption(COMMENTSTYLE_OPTIONSTRING, COMMENTSTYLE_OPTIONDEFAULT,
 			new HelpLocation(HelpTopics.DECOMPILER, "DisplayCommentStyle"),
 			COMMENTSTYLE_OPTIONDESCRIPTION);
@@ -916,6 +928,9 @@ public class DecompileOptions {
 		if (commentindent != COMMENTINDENT_OPTIONDEFAULT) {
 			appendOption(encoder, ELEM_COMMENTINDENT, Integer.toString(commentindent), "", "");
 		}
+		if (commentindentAlign != COMMENTINDENTALIGN_OPTIONDEFAULT) {
+			appendOption(encoder, ELEM_COMMENTINDENTALIGN, commentindentAlign ? "on" : "off", "", "");
+		}
 		if (commentStyle != COMMENTSTYLE_OPTIONDEFAULT) {
 			String curstyle = CommentStyleEnum.CPPStyle.equals(commentStyle) ? "cplusplus" : "c";
 			appendOption(encoder, ELEM_COMMENTSTYLE, curstyle, "", "");
@@ -1428,6 +1443,22 @@ public class DecompileOptions {
 		maxIntructionsPer = num;
 	}
 
+	public int getCommentIndent() {
+		return commentindent;
+	}
+
+	public void setCommentIndent(int indent) {
+		commentindent = indent;
+	}
+
+	public boolean isCommentIndentAlign() {
+		return commentindentAlign;
+	}
+
+	public void setCommentIndentAlign(boolean align) {
+		commentindentAlign = align;
+	}
+
 	/**
 	 * If the number of entries in a single jumptable exceeds this value, the decompiler will
 	 * not recover the table and control flow from the indirect jump corresponding to the table
diff --git a/Ghidra/Features/Decompiler/src/test.slow/java/ghidra/app/plugin/core/decompile/DecompilerTest.java b/Ghidra/Features/Decompiler/src/test.slow/java/ghidra/app/plugin/core/decompile/DecompilerTest.java
index 1044a1a4e..cb1668d84 100644
--- a/Ghidra/Features/Decompiler/src/test.slow/java/ghidra/app/plugin/core/decompile/DecompilerTest.java
+++ b/Ghidra/Features/Decompiler/src/test.slow/java/ghidra/app/plugin/core/decompile/DecompilerTest.java
@@ -15,10 +15,14 @@
  */
 package ghidra.app.plugin.core.decompile;
 
+import java.util.Optional;
+
 import org.junit.*;
 
 import ghidra.app.decompiler.*;
 import ghidra.program.model.address.Address;
+import ghidra.program.model.address.AddressSpace;
+import ghidra.program.model.listing.CodeUnit;
 import ghidra.program.model.listing.Function;
 import ghidra.program.model.listing.Program;
 import ghidra.test.AbstractGhidraHeadedIntegrationTest;
@@ -28,13 +32,14 @@ import ghidra.util.task.TaskMonitor;
 public class DecompilerTest extends AbstractGhidraHeadedIntegrationTest {
 	private Program prog;
 	private DecompInterface decompiler;
+	private long returnBytesOffset = 0x0;
 
 	@Before
 	public void setUp() throws Exception {
 
 		ToyProgramBuilder builder = new ToyProgramBuilder("notepad_decompiler", true);
 		builder.createMemory("test", "0x0", 2);
-		builder.addBytesReturn(0x0);
+		builder.addBytesReturn(returnBytesOffset);
 		builder.createFunction("0x0");
 		prog = builder.getProgram();
 
@@ -58,4 +63,74 @@ public class DecompilerTest extends AbstractGhidraHeadedIntegrationTest {
 		String decompilation = decompResults.getDecompiledFunction().getC();
 		Assert.assertNotNull(decompilation);
 	}
+
+	@Test
+	public void testAlignedCommentIndentation() throws Exception {
+		int indent = 20;
+		DecompileOptions options = new DecompileOptions();
+		options.setCommentIndent(indent);
+		options.setCommentIndentAlign(true);
+		options.setPRECommentIncluded(true);
+		decompiler.setOptions(options);
+
+		AddressSpace space = prog.getAddressFactory().getDefaultAddressSpace();
+
+		// add a comment to the program listing
+		Address returnBytesAddr = space.getAddress(returnBytesOffset);
+		int transaction = prog.startTransaction("add comment for indentation test");
+		String comment = "aligned-comment-indentation-test";
+		prog.getListing().getCodeUnitAt(returnBytesAddr).setComment(CodeUnit.PRE_COMMENT, comment);
+		prog.endTransaction(transaction, true);
+
+		Address addr = space.getAddress(0x0);
+		Function func = prog.getListing().getFunctionAt(addr);
+		DecompileResults decompResults = decompiler.decompileFunction(func,
+			DecompileOptions.SUGGESTED_DECOMPILE_TIMEOUT_SECS, TaskMonitor.DUMMY);
+		String decompilation = decompResults.getDecompiledFunction().getC();
+		Assert.assertNotNull(decompilation);
+
+		Optional<String> commentLineCheck = decompilation.lines().filter(line -> line.contains(comment)).findFirst();
+		Optional<String> returnLineCheck = decompilation.lines().filter(line -> line.endsWith("return;")).findFirst();
+		Assert.assertTrue(commentLineCheck.isPresent());
+		Assert.assertTrue(returnLineCheck.isPresent());
+
+		String commentLine = commentLineCheck.get();
+		String returnLine = returnLineCheck.get();
+
+		Assert.assertFalse(commentLine.startsWith(" ".repeat(indent)));
+
+		int commentIndentation = commentLine.indexOf(commentLine.stripLeading());
+		int returnIndentation = returnLine.indexOf(returnLine.stripLeading());
+		Assert.assertEquals(commentIndentation, returnIndentation);
+	}
+
+	@Test
+	public void testFixedCommentIndentation() throws Exception {
+		int indent = 20;
+		DecompileOptions options = new DecompileOptions();
+		options.setCommentIndent(indent);
+		options.setCommentIndentAlign(false);
+		options.setPRECommentIncluded(true);
+		decompiler.setOptions(options);
+
+		AddressSpace space = prog.getAddressFactory().getDefaultAddressSpace();
+
+		// add a comment to the program listing
+		Address returnBytesAddr = space.getAddress(returnBytesOffset);
+		int transaction = prog.startTransaction("add comment for indentation test");
+		String comment = "fixed-comment-indentation-test";
+		prog.getListing().getCodeUnitAt(returnBytesAddr).setComment(CodeUnit.PRE_COMMENT, comment);
+		prog.endTransaction(transaction, true);
+
+		Address addr = space.getAddress(0x0);
+		Function func = prog.getListing().getFunctionAt(addr);
+		DecompileResults decompResults = decompiler.decompileFunction(func,
+			DecompileOptions.SUGGESTED_DECOMPILE_TIMEOUT_SECS, TaskMonitor.DUMMY);
+		String decompilation = decompResults.getDecompiledFunction().getC();
+		Assert.assertNotNull(decompilation);
+
+		Optional<String> commentLine = decompilation.lines().filter(line -> line.contains(comment)).findFirst();
+		Assert.assertTrue(commentLine.isPresent());
+		Assert.assertTrue(commentLine.get().startsWith(" ".repeat(indent)));
+	}
 }
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/ElementId.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/ElementId.java
index 6575d1007..5299d4d93 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/ElementId.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/ElementId.java
@@ -275,151 +275,149 @@ public record ElementId(String name, int id) {
 	public static final ElementId ELEM_ANALYZEFORLOOPS = new ElementId("analyzeforloops", 176);
 	public static final ElementId ELEM_COMMENTHEADER = new ElementId("commentheader", 177);
 	public static final ElementId ELEM_COMMENTINDENT = new ElementId("commentindent", 178);
-	public static final ElementId ELEM_COMMENTINSTRUCTION =
-		new ElementId("commentinstruction", 179);
-	public static final ElementId ELEM_COMMENTSTYLE = new ElementId("commentstyle", 180);
-	public static final ElementId ELEM_CONVENTIONPRINTING =
-		new ElementId("conventionprinting", 181);
-	public static final ElementId ELEM_CURRENTACTION = new ElementId("currentaction", 182);
-	public static final ElementId ELEM_DEFAULTPROTOTYPE = new ElementId("defaultprototype", 183);
-	public static final ElementId ELEM_ERRORREINTERPRETED =
-		new ElementId("errorreinterpreted", 184);
-	public static final ElementId ELEM_ERRORTOOMANYINSTRUCTIONS =
-		new ElementId("errortoomanyinstructions", 185);
-	public static final ElementId ELEM_ERRORUNIMPLEMENTED =
-		new ElementId("errorunimplemented", 186);
-	public static final ElementId ELEM_EXTRAPOP = new ElementId("extrapop", 187);
-	public static final ElementId ELEM_IGNOREUNIMPLEMENTED =
-		new ElementId("ignoreunimplemented", 188);
-	public static final ElementId ELEM_INDENTINCREMENT = new ElementId("indentincrement", 189);
-	public static final ElementId ELEM_INFERCONSTPTR = new ElementId("inferconstptr", 190);
-	public static final ElementId ELEM_INLINE = new ElementId("inline", 191);
-	public static final ElementId ELEM_INPLACEOPS = new ElementId("inplaceops", 192);
-	public static final ElementId ELEM_INTEGERFORMAT = new ElementId("integerformat", 193);
-	public static final ElementId ELEM_JUMPLOAD = new ElementId("jumpload", 194);
-	public static final ElementId ELEM_MAXINSTRUCTION = new ElementId("maxinstruction", 195);
-	public static final ElementId ELEM_MAXLINEWIDTH = new ElementId("maxlinewidth", 196);
-	public static final ElementId ELEM_NAMESPACESTRATEGY = new ElementId("namespacestrategy", 197);
-	public static final ElementId ELEM_NOCASTPRINTING = new ElementId("nocastprinting", 198);
-	public static final ElementId ELEM_NORETURN = new ElementId("noreturn", 199);
-	public static final ElementId ELEM_NULLPRINTING = new ElementId("nullprinting", 200);
-	public static final ElementId ELEM_OPTIONSLIST = new ElementId("optionslist", 201);
-	public static final ElementId ELEM_PARAM1 = new ElementId("param1", 202);
-	public static final ElementId ELEM_PARAM2 = new ElementId("param2", 203);
-	public static final ElementId ELEM_PARAM3 = new ElementId("param3", 204);
-	public static final ElementId ELEM_PROTOEVAL = new ElementId("protoeval", 205);
-	public static final ElementId ELEM_SETACTION = new ElementId("setaction", 206);
-	public static final ElementId ELEM_SETLANGUAGE = new ElementId("setlanguage", 207);
-	public static final ElementId ELEM_STRUCTALIGN = new ElementId("structalign", 208);
-	public static final ElementId ELEM_TOGGLERULE = new ElementId("togglerule", 209);
-	public static final ElementId ELEM_WARNING = new ElementId("warning", 210);
+	public static final ElementId ELEM_COMMENTINDENTALIGN = new ElementId("commentindentalign", 179);
+	public static final ElementId ELEM_COMMENTINSTRUCTION = new ElementId("commentinstruction", 180);
+	public static final ElementId ELEM_COMMENTSTYLE = new ElementId("commentstyle", 181);
+	public static final ElementId ELEM_CONVENTIONPRINTING = new ElementId("conventionprinting", 182);
+	public static final ElementId ELEM_CURRENTACTION = new ElementId("currentaction", 183);
+	public static final ElementId ELEM_DEFAULTPROTOTYPE = new ElementId("defaultprototype", 184);
+	public static final ElementId ELEM_ERRORREINTERPRETED = new ElementId("errorreinterpreted", 185);
+	public static final ElementId ELEM_ERRORTOOMANYINSTRUCTIONS = new ElementId("errortoomanyinstructions", 186);
+	public static final ElementId ELEM_ERRORUNIMPLEMENTED = new ElementId("errorunimplemented", 187);
+	public static final ElementId ELEM_EXTRAPOP = new ElementId("extrapop", 188);
+	public static final ElementId ELEM_IGNOREUNIMPLEMENTED = new ElementId("ignoreunimplemented", 189);
+	public static final ElementId ELEM_INDENTINCREMENT = new ElementId("indentincrement", 190);
+	public static final ElementId ELEM_INFERCONSTPTR = new ElementId("inferconstptr", 191);
+	public static final ElementId ELEM_INLINE = new ElementId("inline", 192);
+	public static final ElementId ELEM_INPLACEOPS = new ElementId("inplaceops", 193);
+	public static final ElementId ELEM_INTEGERFORMAT = new ElementId("integerformat", 194);
+	public static final ElementId ELEM_JUMPLOAD = new ElementId("jumpload", 195);
+	public static final ElementId ELEM_MAXINSTRUCTION = new ElementId("maxinstruction", 196);
+	public static final ElementId ELEM_MAXLINEWIDTH = new ElementId("maxlinewidth", 197);
+	public static final ElementId ELEM_NAMESPACESTRATEGY = new ElementId("namespacestrategy", 198);
+	public static final ElementId ELEM_NOCASTPRINTING = new ElementId("nocastprinting", 199);
+	public static final ElementId ELEM_NORETURN = new ElementId("noreturn", 200);
+	public static final ElementId ELEM_NULLPRINTING = new ElementId("nullprinting", 201);
+	public static final ElementId ELEM_OPTIONSLIST = new ElementId("optionslist", 202);
+	public static final ElementId ELEM_PARAM1 = new ElementId("param1", 203);
+	public static final ElementId ELEM_PARAM2 = new ElementId("param2", 204);
+	public static final ElementId ELEM_PARAM3 = new ElementId("param3", 205);
+	public static final ElementId ELEM_PROTOEVAL = new ElementId("protoeval", 206);
+	public static final ElementId ELEM_INDENTATIONSTYLE = new ElementId("indentationstyle", 207);
+	public static final ElementId ELEM_SETACTION = new ElementId("setaction", 208);
+	public static final ElementId ELEM_SETLANGUAGE = new ElementId("setlanguage", 209);
+	public static final ElementId ELEM_STRUCTALIGN = new ElementId("structalign", 210);
+	public static final ElementId ELEM_TOGGLERULE = new ElementId("togglerule", 211);
+	public static final ElementId ELEM_WARNING = new ElementId("warning", 212);
 
 	public static final ElementId ELEM_BRACEFORMAT = new ElementId("braceformat", 284);
 
 	// jumptable
-	public static final ElementId ELEM_BASICOVERRIDE = new ElementId("basicoverride", 211);
-	public static final ElementId ELEM_DEST = new ElementId("dest", 212);
-	public static final ElementId ELEM_JUMPTABLE = new ElementId("jumptable", 213);
-	public static final ElementId ELEM_LOADTABLE = new ElementId("loadtable", 214);
-	public static final ElementId ELEM_NORMADDR = new ElementId("normaddr", 215);
-	public static final ElementId ELEM_NORMHASH = new ElementId("normhash", 216);
-	public static final ElementId ELEM_STARTVAL = new ElementId("startval", 217);
+	public static final ElementId ELEM_BASICOVERRIDE = new ElementId("basicoverride", 213);
+	public static final ElementId ELEM_DEST = new ElementId("dest", 214);
+	public static final ElementId ELEM_JUMPTABLE = new ElementId("jumptable", 215);
+	public static final ElementId ELEM_LOADTABLE = new ElementId("loadtable", 216);
+	public static final ElementId ELEM_NORMADDR = new ElementId("normaddr", 217);
+	public static final ElementId ELEM_NORMHASH = new ElementId("normhash", 218);
+	public static final ElementId ELEM_STARTVAL = new ElementId("startval", 219);
 
 	// override
-	public static final ElementId ELEM_DEADCODEDELAY = new ElementId("deadcodedelay", 218);
-	public static final ElementId ELEM_FLOW = new ElementId("flow", 219);
-	public static final ElementId ELEM_FORCEGOTO = new ElementId("forcegoto", 220);
-	public static final ElementId ELEM_INDIRECTOVERRIDE = new ElementId("indirectoverride", 221);
-	public static final ElementId ELEM_MULTISTAGEJUMP = new ElementId("multistagejump", 222);
-	public static final ElementId ELEM_OVERRIDE = new ElementId("override", 223);
-	public static final ElementId ELEM_PROTOOVERRIDE = new ElementId("protooverride", 224);
+	public static final ElementId ELEM_DEADCODEDELAY = new ElementId("deadcodedelay", 220);
+	public static final ElementId ELEM_FLOW = new ElementId("flow", 221);
+	public static final ElementId ELEM_FORCEGOTO = new ElementId("forcegoto", 222);
+	public static final ElementId ELEM_INDIRECTOVERRIDE = new ElementId("indirectoverride", 223);
+	public static final ElementId ELEM_MULTISTAGEJUMP = new ElementId("multistagejump", 224);
+	public static final ElementId ELEM_OVERRIDE = new ElementId("override", 225);
+	public static final ElementId ELEM_PROTOOVERRIDE = new ElementId("protooverride", 226);
 
 	// prefersplit
-	public static final ElementId ELEM_PREFERSPLIT = new ElementId("prefersplit", 225);
+	public static final ElementId ELEM_PREFERSPLIT = new ElementId("prefersplit", 227);
 
 	// callgraph
-	public static final ElementId ELEM_CALLGRAPH = new ElementId("callgraph", 226);
-	public static final ElementId ELEM_NODE = new ElementId("node", 227);
+	public static final ElementId ELEM_CALLGRAPH = new ElementId("callgraph", 228);
+	public static final ElementId ELEM_NODE = new ElementId("node", 229);
 
 	// varmap
-	public static final ElementId ELEM_LOCALDB = new ElementId("localdb", 228);
+	public static final ElementId ELEM_LOCALDB = new ElementId("localdb", 230);
 
 	// ghidra_process
-	public static final ElementId ELEM_DOC = new ElementId("doc", 229);
+	public static final ElementId ELEM_DOC = new ElementId("doc", 231);
 
 	// loadimage_xml
-//	public static final ElementId ELEM_BINARYIMAGE = new ElementId("binaryimage", 230);
-//	public static final ElementId ELEM_BYTECHUNK = new ElementId("bytechunk", 231);
+//	public static final ElementId ELEM_BINARYIMAGE = new ElementId("binaryimage", 232);
+//	public static final ElementId ELEM_BYTECHUNK = new ElementId("bytechunk", 233);
 
 	// sleigh_arch
-//	public static final ElementId ELEM_COMPILER = new ElementId("compiler", 232);
-//	public static final ElementId ELEM_DESCRIPTION = new ElementId("description", 233);
-//	public static final ElementId ELEM_LANGUAGE = new ElementId("language", 234);
-//	public static final ElementId ELEM_LANGUAGE_DEFINITIONS =
-//		new ElementId("language_definitions", 235);
+//	public static final ElementId ELEM_COMPILER = new ElementId("compiler", 234);
+//	public static final ElementId ELEM_DESCRIPTION = new ElementId("description", 235);
+//	public static final ElementId ELEM_LANGUAGE = new ElementId("language", 236);
+//	public static final ElementId ELEM_LANGUAGE_DEFINITIONS = new ElementId("language_definitions", 237);
 
 	// xml_arch
-//	public static final ElementId ELEM_XML_SAVEFILE = new ElementId("xml_savefile", 236);
+//	public static final ElementId ELEM_XML_SAVEFILE = new ElementId("xml_savefile", 238);
 
 	// raw_arch
-//	public static final ElementId ELEM_RAW_SAVEFILE = new ElementId("raw_savefile", 237);
+//	public static final ElementId ELEM_RAW_SAVEFILE = new ElementId("raw_savefile", 239);
+
+	// bfd_arch
+//	public static final ElemendId ELEM_BFD_SAVEFILE = new ElementId("bfd_savefile", 240);
 
 	// ghidra_arch
-	public static final int COMMAND_ISNAMEUSED = 239;
+	public static final int COMMAND_ISNAMEUSED = 241;
 	public static final ElementId ELEM_COMMAND_ISNAMEUSED =
 		new ElementId("command_isnameused", COMMAND_ISNAMEUSED);
-	public static final int COMMAND_GETBYTES = 240;
+	public static final int COMMAND_GETBYTES = 242;
 	public static final ElementId ELEM_COMMAND_GETBYTES =
 		new ElementId("command_getbytes", COMMAND_GETBYTES);
-	public static final int COMMAND_GETCALLFIXUP = 241;
+	public static final int COMMAND_GETCALLFIXUP = 243;
 	public static final ElementId ELEM_COMMAND_GETCALLFIXUP =
 		new ElementId("command_getcallfixup", COMMAND_GETCALLFIXUP);
-	public static final int COMMAND_GETCALLMECH = 242;
+	public static final int COMMAND_GETCALLMECH = 244;
 	public static final ElementId ELEM_COMMAND_GETCALLMECH =
 		new ElementId("command_getcallmech", COMMAND_GETCALLMECH);
-	public static final int COMMAND_GETCALLOTHERFIXUP = 243;
+	public static final int COMMAND_GETCALLOTHERFIXUP = 245;
 	public static final ElementId ELEM_COMMAND_GETCALLOTHERFIXUP =
 		new ElementId("command_getcallotherfixup", COMMAND_GETCALLOTHERFIXUP);
-	public static final int COMMAND_GETCODELABEL = 244;
+	public static final int COMMAND_GETCODELABEL = 246;
 	public static final ElementId ELEM_COMMAND_GETCODELABEL =
 		new ElementId("command_getcodelabel", COMMAND_GETCODELABEL);
-	public static final int COMMAND_GETCOMMENTS = 245;
+	public static final int COMMAND_GETCOMMENTS = 247;
 	public static final ElementId ELEM_COMMAND_GETCOMMENTS =
 		new ElementId("command_getcomments", COMMAND_GETCOMMENTS);
-	public static final int COMMAND_GETCPOOLREF = 246;
+	public static final int COMMAND_GETCPOOLREF = 248;
 	public static final ElementId ELEM_COMMAND_GETCPOOLREF =
 		new ElementId("command_getcpoolref", COMMAND_GETCPOOLREF);
-	public static final int COMMAND_GETDATATYPE = 247;
+	public static final int COMMAND_GETDATATYPE = 249;
 	public static final ElementId ELEM_COMMAND_GETDATATYPE =
 		new ElementId("command_getdatatype", COMMAND_GETDATATYPE);
-	public static final int COMMAND_GETEXTERNALREF = 248;
+	public static final int COMMAND_GETEXTERNALREF = 250;
 	public static final ElementId ELEM_COMMAND_GETEXTERNALREF =
 		new ElementId("command_getexternalref", COMMAND_GETEXTERNALREF);
-	public static final int COMMAND_GETMAPPEDSYMBOLS = 249;
+	public static final int COMMAND_GETMAPPEDSYMBOLS = 251;
 	public static final ElementId ELEM_COMMAND_GETMAPPEDSYMBOLS =
 		new ElementId("command_getmappedsymbols", COMMAND_GETMAPPEDSYMBOLS);
-	public static final int COMMAND_GETNAMESPACEPATH = 250;
+	public static final int COMMAND_GETNAMESPACEPATH = 252;
 	public static final ElementId ELEM_COMMAND_GETNAMESPACEPATH =
 		new ElementId("command_getnamespacepath", COMMAND_GETNAMESPACEPATH);
-	public static final int COMMAND_GETPCODE = 251;
+	public static final int COMMAND_GETPCODE = 253;
 	public static final ElementId ELEM_COMMAND_GETPCODE =
 		new ElementId("command_getpcode", COMMAND_GETPCODE);
-	public static final int COMMAND_GETPCODEEXECUTABLE = 252;
+	public static final int COMMAND_GETPCODEEXECUTABLE = 254;
 	public static final ElementId ELEM_COMMAND_GETPCODEEXECUTABLE =
 		new ElementId("command_getpcodeexecutable", COMMAND_GETPCODEEXECUTABLE);
-	public static final int COMMAND_GETREGISTER = 253;
+	public static final int COMMAND_GETREGISTER = 255;
 	public static final ElementId ELEM_COMMAND_GETREGISTER =
 		new ElementId("command_getregister", COMMAND_GETREGISTER);
-	public static final int COMMAND_GETREGISTERNAME = 254;
+	public static final int COMMAND_GETREGISTERNAME = 256;
 	public static final ElementId ELEM_COMMAND_GETREGISTERNAME =
 		new ElementId("command_getregistername", COMMAND_GETREGISTERNAME);
-	public static final int COMMAND_GETSTRINGDATA = 255;
+	public static final int COMMAND_GETSTRINGDATA = 257;
 	public static final ElementId ELEM_COMMAND_GETSTRINGDATA =
 		new ElementId("command_getstring", COMMAND_GETSTRINGDATA);
-	public static final int COMMAND_GETTRACKEDREGISTERS = 256;
+	public static final int COMMAND_GETTRACKEDREGISTERS = 258;
 	public static final ElementId ELEM_COMMAND_GETTRACKEDREGISTERS =
 		new ElementId("command_gettrackedregisters", COMMAND_GETTRACKEDREGISTERS);
-	public static final int COMMAND_GETUSEROPNAME = 257;
+	public static final int COMMAND_GETUSEROPNAME = 259;
 	public static final ElementId ELEM_COMMAND_GETUSEROPNAME =
 		new ElementId("command_getuseropname", COMMAND_GETUSEROPNAME);
 
-- 
2.43.0

