From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: pr0me <lukas@binarly.io>
Date: Sat, 21 Jun 2025 13:53:12 +0200
Subject: [PATCH] 8277: Fix Infinite Loops in PtrSubUndo Rule

allow PTRSUB with zero offset and no extra (e.g., for
 casts) to fix oscillating

fix incorrectly adjusting offset in PtrSubUndo to avoid inf loop

Revert "fix incorrectly adjusting offset in PtrSubUndo to avoid inf loop"

This reverts commit 33ec9993f8f0acea81141414e2e10c84408d433b.

bail on getExtraOffset processing unknown ops repeatedly
---
 .../Features/Decompiler/src/decompile/cpp/ruleaction.cc   | 8 ++++++--
 1 file changed, 6 insertions(+), 2 deletions(-)

diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/ruleaction.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/ruleaction.cc
index fba67eeedf..4b41af1954 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/ruleaction.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/ruleaction.cc
@@ -7402,7 +7402,8 @@ int8 RulePtrsubUndo::getExtraOffset(PcodeOp *op,int8 &multiplier)
 	multiplier = ptraddmult;
     }
     else {
-      break;
+      multiplier = 0;
+      return extra;
     }
     outvn = op->getOut();
     op = outvn->loneDescend();
@@ -7518,10 +7519,13 @@ int4 RulePtrsubUndo::applyOp(PcodeOp *op,Funcdata &data)
   if (basevn->getTypeReadFacing(op)->isPtrsubMatching(val,extra,multiplier))
     return 0;
 
+  // Don't undo PTRSUB with zero offset and no extra - these can be valid pointer operations (e.g., casts)
+  if (val == 0 && extra == 0)
+    return 0;
   data.opSetOpcode(op,CPUI_INT_ADD);
   op->clearStopTypePropagation();
   extra = removeLocalAdds(op->getOut(),data);
-  if (extra != 0) {
+  if (extra != 0 && multiplier != 0) {
     val = val + extra;		// Lump extra into additive offset
     data.opSetInput(op,data.newConstant(cvn->getSize(), val & calc_mask(cvn->getSize())),1);
   }
-- 
2.45.1

