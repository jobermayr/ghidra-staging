From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Matthew White <mehw.is.me@inventati.org>
Date: Mon, 2 Feb 2026 05:42:20 +0000
Subject: [PATCH] 8957: proof of concept: reorganize windows spaces by tabs
 drag-N-drop, and allow to cancel a drag operation anytime

allow to reorganize tabs by drag-N-drop

Components can be moved around dragging headers over tabs, tabs over
headers, headers over headers, and tabs over tabs.

While moving tabs in the same node, components shift is based on the
dragging direction.  Moving a tab from left to right will place that
tab after the component on which it is dropped over.  When moving in
the opposite direction, going from right to left will place that tab
before the component on which it is dropped over.

Dropping a component over headers or tabs in a different node, shall
add a new tab before the component on which it is dropped over.

Dropping a component over a placeholder's window surface, will still
append a tab as last item.

new logic and cursors for headers and tabs drag-N-drop actions

Title bars (headers) and tabs can be dragged over other headers and
tabs, and in different window spaces.

Dragging a component into another window space, will append it as a
last tab.  While dragging it over a header of another window space,
will prepend that component as a first tab.

A new set of cursors, could highlight these different actions, and
also when a tab will be put after or before the one dragged over.

use shortcuts to drag-N-drop at the beginning or end of a stack

Dropping a component over any header, will prepend it at the beginning
of the windows space that the mouse cursor is over.

Dropping a component over any content space, will append it at the end
of the windows space that the mouse cursor is over.

new transient window popup as drag-N-drop visual feedback

Visual feedback, to inform the user about a component drag-N-drop
event in progress.  This is for when a header, or tab, is dragged
around to drop a component in another space, create a split, or a
new window.

add help for title bars (headers) and tabs drag-N-drop

Describe how a drag-N-drop action is performed, while dragging by
header or tab, over a window space, or over another header or tab.

allow drag-N-drop interruptions without unexpected results

Pressing the ESC key is expected to cancel the current drag operation.

By design, a drag-N-drop operation might silence some events, with the
exception of ALT, CTRL, and SHIFT key modifiers.

This patch implements a WORKAROUND to guess ESC key events, and others
disrupting the drag operation, which had been silenced.  It's range of
effectiveness is within the region of drop zones.

To allow graceful interruptions, outside of any drop zone, without any
unexpected result, a drop action is marked as invalid by default.  Key
modifiers are used to temporarily toggle a different behavior.

CTRL directs a drag to move a component in a new window, and the SHIFT
key is to temporarily invalidate the drop.  Releasing a modifier would
revert to the normal drag-N-drop processing.

fix drag-N-drop null header condition

This fixes the possibility of an exception when a drag-N-drop to an
empty main window, without any components, could try to get the key
modifiers ALT, CTRL, and SHIFT, state via a null header variable.

The state of key modifiers should be read by header static methods.

implement drag-N-drop multiple selection of components

After starting to drag a component, holding ALT would extend the
selection to all the components to its right.  Holding ALT+SHIFT
would extend the selection to all the components to its left.

A multiple selection of components can be dragged around, acting
as a group when a drop is executed.

A whole group of components can be moved in a new window, create
a new split containing all the components in the group, or moved
in the same way as a single one, so that this group could become
part of a different stack, shift position as a whole in the same
window space, or being pushed between tabs in another one.

A multiple selection can dynamically change while moving a group
in the same window space.  The selection would be cut at the tab
hovered by the mouse cursor, so that the group could shift after
the hovered tab, if on its right, or before, if on its left.

Effectively, a stack section can be detached from its own space,
and be relocated elsewhere, by a single gesture which extends to
all the components part of this selection.

After a drop, the sort order of a stack section is maintained as
the focus is given to the component from which the drag begun.

highlight the selected component tabs of a drag-N-drop operation

Each selected component, taking part of a drag-N-drop operation, will
have its own tab highlighted.

This could give a feecback to the user about what would be relocated,
a single component or a multiple selection.

add help about drag-N-drop modifier keys and tabs highlights

Describe to the user how to use the modifier keys ALT, CTRL, and SHIFT
to direct a drag-N-drop operation, and illustrate how to do a multiple
selection of components to be moved.

Also, mention the visual feedbacks available, to inform about the drop
result that is expected after executing a drag-N-drop operation.
---
 Ghidra/Features/Base/certification.manifest   |   4 +
 .../topics/DockingWindows/Docking_Windows.htm |  83 +++--
 .../DockingWindows/images/header.stack.png    | Bin 0 -> 897 bytes
 .../DockingWindows/images/hover.stack.png     | Bin 947 -> 900 bytes
 .../topics/DockingWindows/images/push.png     | Bin 0 -> 910 bytes
 .../DockingWindows/images/shift.left.png      | Bin 0 -> 887 bytes
 .../DockingWindows/images/shift.right.png     | Bin 0 -> 885 bytes
 .../src/main/java/docking/ComponentNode.java  |  64 +++-
 .../main/java/docking/DockableComponent.java  | 183 ++++++++---
 .../src/main/java/docking/DockableHeader.java | 292 +++++++++++++++++-
 .../java/docking/DockingWindowManager.java    | 129 +++++++-
 .../src/main/java/docking/DropCode.java       |  24 +-
 .../src/main/java/docking/HeaderCursor.java   | 134 ++++++++
 .../main/java/docking/TransientWindow.java    | 136 ++++++++
 .../src/main/java/docking/WindowPosition.java |  44 ++-
 .../tabbedpane/DockingTabRenderer.java        |  73 ++++-
 16 files changed, 1087 insertions(+), 79 deletions(-)
 mode change 100644 => 100755 Ghidra/Features/Base/certification.manifest
 mode change 100644 => 100755 Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/Docking_Windows.htm
 create mode 100644 Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/images/header.stack.png
 create mode 100644 Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/images/push.png
 create mode 100644 Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/images/shift.left.png
 create mode 100644 Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/images/shift.right.png
 mode change 100644 => 100755 Ghidra/Framework/Docking/src/main/java/docking/ComponentNode.java
 create mode 100755 Ghidra/Framework/Docking/src/main/java/docking/TransientWindow.java

diff --git a/Ghidra/Features/Base/certification.manifest b/Ghidra/Features/Base/certification.manifest
old mode 100644
new mode 100755
index a25227089a..5c62be230e
--- a/Ghidra/Features/Base/certification.manifest
+++ b/Ghidra/Features/Base/certification.manifest
@@ -383,10 +383,14 @@ src/main/help/help/topics/DockingWindows/Docking_Windows.htm||GHIDRA||||END|
 src/main/help/help/topics/DockingWindows/images/Tool.png||GHIDRA||||END|
 src/main/help/help/topics/DockingWindows/images/Window_Menu.png||GHIDRA||||END|
 src/main/help/help/topics/DockingWindows/images/hover.stack.png||GHIDRA||||END|
+src/main/help/help/topics/DockingWindows/images/header.stack.png||GHIDRA||||END|
 src/main/help/help/topics/DockingWindows/images/invalid.png||GHIDRA||||END|
 src/main/help/help/topics/DockingWindows/images/leftArrow.png||GHIDRA||||END|
+src/main/help/help/topics/DockingWindows/images/push.png||GHIDRA||||END|
 src/main/help/help/topics/DockingWindows/images/resize.png||GHIDRA||||END|
 src/main/help/help/topics/DockingWindows/images/rightArrow.png||GHIDRA||||END|
+src/main/help/help/topics/DockingWindows/images/shift.left.png||GHIDRA||||END|
+src/main/help/help/topics/DockingWindows/images/shift.right.png||GHIDRA||||END|
 src/main/help/help/topics/DockingWindows/images/upArrow.png||GHIDRA||||END|
 src/main/help/help/topics/EclipseIntegration/EclipseIntegration.htm||GHIDRA||||END|
 src/main/help/help/topics/EquatePlugin/Equates.htm||GHIDRA||||END|
diff --git a/Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/Docking_Windows.htm b/Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/Docking_Windows.htm
old mode 100644
new mode 100755
index 8584063697..318a5b3aca
--- a/Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/Docking_Windows.htm
+++ b/Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/Docking_Windows.htm
@@ -96,8 +96,8 @@
         <LI><I><B>Docked with other components</B></I>: components are side-by-side (or top to
         bottom) with another component.</LI>
 
-        <LI><I><B>Stacked with other components</B></I>: components share the same space and tabs
-        are used to display them one at a time.</LI>
+        <LI><I><B>Stacked with other components</B></I>: components share the same window space,
+        and tabs are used to display them one at a time.</LI>
 
         <LI><I><B>In their own window</B></I>: a component can be placed in its own window.</LI>
       </OL>
@@ -108,31 +108,64 @@
       <BLOCKQUOTE>
 
 	      <P>Components can be rearranged by dragging them in various ways. &nbsp;To drag a component,
-	      press and hold the left mouse button on the title bar of the component to be moved and begin
-	      moving the mouse. &nbsp;The mouse cursor will change to indicate what will happen if the
-	      mouse button is released at that location.<BR>
+	      press and hold the left mouse button on the title bar (header) or tab of the component to be
+	      moved, then begin moving the mouse to drag it around. &nbsp;Press ALT to include in the drag
+	      all the components at the right of the first one selected, or ALT+SHIT for all components at
+	      the left. &nbsp;The dragged components tabs will be highlighted and a transient window popup
+	      lists their names. &nbsp;The mouse cursor changes to indicate what would happen if the mouse
+	      button is released at that location. &nbsp;While in the same window space, ALT and ALT+SHIFT
+	      drive a dynamic multiple selection, which is cut at the tab where the mouse cursor is over.<BR>
 	      &nbsp;&nbsp;&nbsp;<BR>
-	      &nbsp;&nbsp;&nbsp; <IMG src="images/invalid.png" alt=""> &nbsp; &nbsp;Invalid Location -
-	      releasing here will cancel the drag operation.<BR>
-	      &nbsp;&nbsp;&nbsp; <IMG src="images/leftArrow.png" alt=""> &nbsp; Will move the component to the
-	      left of the component that the mouse cursor is over.<BR>
-	      &nbsp;&nbsp;&nbsp; <IMG src="images/rightArrow.png" alt=""> &nbsp; &nbsp;Will move the component
-	      to the right of the component that the mouse cursor is over.<BR>
-	      &nbsp;&nbsp;&nbsp; <IMG src="images/upArrow.png" alt=""> &nbsp; Will move the component above the
-	      component that the mouse cursor is over.<BR>
-	      &nbsp;&nbsp;&nbsp; <IMG src="images/downArrow.png" alt=""> &nbsp; Will move the component below
-	      the component that the mouse cursor is over.<BR>
-	      &nbsp;&nbsp;&nbsp; <IMG src="images/hover.stack.png" alt=""> &nbsp; Will stack the component with
-	      the component that the mouse is over, creating a tabbed pane effect.<BR>
-	      &nbsp;&nbsp;&nbsp; <IMG src="images/window.png" alt=""> &nbsp; &nbsp;Will place the component
-	      in a new window.<BR>
+	      &nbsp;&nbsp;&nbsp; <IMG src="images/invalid.png" alt=""> &nbsp; Invalid Location - releasing
+	      here will cancel the drag operation. &nbsp;This is the same as holding SHIFT, to temporarily
+	      invalidate a drag. &nbsp;Then, release the left mouse button to cancel and conclude the drag
+	      or release the SHIFT key to resume to drag normally.<BR>
+	      &nbsp;&nbsp;&nbsp; <IMG src="images/leftArrow.png" alt=""> &nbsp; Move the group of selected
+	      components to the left of the window space that the mouse cursor is over.<BR>
+	      &nbsp;&nbsp;&nbsp; <IMG src="images/rightArrow.png" alt=""> &nbsp; Move the group of selected
+	      components to the right of the window space that the mouse cursor is over.<BR>
+	      &nbsp;&nbsp;&nbsp; <IMG src="images/upArrow.png" alt=""> &nbsp; Move the group of selected
+	      components above the window space that the mouse cursor is over.<BR>
+	      &nbsp;&nbsp;&nbsp; <IMG src="images/downArrow.png" alt=""> &nbsp; Move the group of selected
+	      components below the window space that the mouse cursor is over.<BR>
+	      &nbsp;&nbsp;&nbsp; <IMG src="images/hover.stack.png" alt=""> &nbsp; Stack the group of selected
+	      components in the window space that the mouse cursor is over, creating a tabbed pane effect,
+	      appending the selected components. &nbsp;This is what would happen when dropping over a content
+	      space.<BR>
+	      &nbsp;&nbsp;&nbsp; <IMG src="images/header.stack.png" alt=""> &nbsp; Stack the group of selected
+	      components in the window space that the mouse cursor is over, creating a tabbed pane effect,
+	      prepending the selected components. &nbsp;This is what would happen when dropping over a
+	      title bar (header).<BR>
+	      &nbsp;&nbsp;&nbsp; <IMG src="images/push.png" alt=""> &nbsp; Push the group of selected
+	      components between other tabs, moving the hovered tab to the right of that group. &nbsp;This is
+	      what would happen when dropping over a tab in another window space.<BR>
+	      &nbsp;&nbsp;&nbsp; <IMG src="images/shift.left.png" alt=""> &nbsp; Shift the group of selected
+	      components, moving the group before the hovered tab. &nbsp;This is what would happen when
+	      dropping over a tab, in the same window space, located at the left of that group.<BR>
+	      &nbsp;&nbsp;&nbsp; <IMG src="images/shift.right.png" alt=""> &nbsp; Shift the group of selected
+	      components, moving the group after the hovered tab. &nbsp;This is what would append when
+	      dropping over a tab, in the same window space, located at the right of that group.<BR>
+	      &nbsp;&nbsp;&nbsp; <IMG src="images/window.png" alt=""> &nbsp; Place the group of selected
+	      components in a new window. &nbsp;This mode is temporarily activated while holding CTRL.
+	      Then, release the left mouse to confirm the drop or release the CTRL key to resume to drag
+	      normally.<BR>
 	      </P>
-	
-	      <P><IMG src="help/shared/tip.png" border="0"> To get the arrow cursors to appear, move the
-	      mouse near the inside edge of another component. &nbsp;To get the stack cursor, move the
-	      mouse over the middle area of another component. &nbsp;To get the new window cursor, move the
-	      mouse over the desktop. &nbsp;The Invalid location cursor will appear when the mouse is over
-	      the component being moved.</P>
+
+	      <P><IMG src="help/shared/tip.png" border="0"> To get the arrow cursors to appear, move near
+	      the inside edge of a window space. &nbsp;To get the stack cursor, move over a content space
+	      (to append components), or over a title bar (to prepend components). &nbsp;To get the shift,
+	      or push cursors, respectively, move over a tab in the same window space, or in another one.
+	      To get the new window cursor, hold CTRL after starting to drag. &nbsp;While CTRL isn't hold
+	      down, the Invalid Location cursor appears if the mouse is outside of any drop zone, or over
+	      the desktop, or over the tab of the component first selected in the group or over its title
+	      bar if not part of stacked components. &nbsp;To cancel a drag operation, hit ESC, click a
+	      different button, or hold just SHIFT and then release the left mouse button. &nbsp;CTRL+ALT
+	      and CTRL+ALT+SHIFT can move a group of selected components in a new window. &nbsp;To dock a
+	      group of components, hold just ALT or ALT+SHIFT. &nbsp;Hold ALT to extend a selection from a
+	      component first selected to all at its right, or ALT+SHIT to those on its left. &nbsp;While
+	      in the same window space, this kind of multiple selection is cut at the tab hovered by the
+	      mouse cursor, so that a group of components can shift after that tab, if at the right side
+	      of that group, or before that tab, if at the left side of that group.</P>
 	</BLOCKQUOTE>
 
       <H3>Resizing components</H3>
diff --git a/Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/images/header.stack.png b/Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/images/header.stack.png
new file mode 100644
index 0000000000000000000000000000000000000000..c097b0f50da594c606f1740927f630254dbc7446
GIT binary patch
literal 897
zcmW+!y=qob5S$PKAtd-igdhqF;w#u_G0OL$0gXZO01F}(66`E&9JDc5TiGlkA}N%-
z!P<(QASf1#Sl9?D1(oZb9Ju#zmOV2&GiPsm>+0Id=@kHLo7ZNydOy|Q$>qiVKlym)
z46ump>pSy4>gdzaranp8>s!A5a7cq2WC%kV$^gO$5>AK+B8ej4Fb5s(kRu%FC`aR&
zK*80(2qA@Pu7Cv?@PGml$Up^<umlsHP$CkUs00dDV8IJ2L?H`R0BB<z`XFJ9t1Pgm
zG$V~}lrfBHEMxa}xtEh7gG{m-z-d0J?vyi}=`3f9G>ujlC5D({iLKmX-1ne@5zJr(
z+YZYC>PaOdnaN7FM^<bmFRB>DELIW2-G-A7dlW;o3ToHP2Dh7J3R9ZOgrQ~(<YSy>
zZj#1R`)fX?beCM=N>_P9_U&%$+E^i_R8l8lq1NMF3PmVG73z2_)grz7QjyA3r8+Y!
zwQ}#vr6^^oN*M2=<#pQK)ERbMoy<tlY<S@|5W_Mp%Q~FSVHo5bG%@UHCq~}p!!`H8
z9iHh~-e$D!me^{>K%q=E^LQB+!(WdvWkhCVMUyvAL-y@%>{?EL4kKPkn)<O!n2xsH
z-QE5D{b`ymzFV-aU)r2q-r0D5`}eV>)n)w1`E>5!aPQ^4yZkic`m+beA7XLm`251z
r8^0cXpS}Nj@aEr5u7A1zbK&VK{%)K&zjW~8bK_uhzBPM$#UK9%yg6z>

literal 0
HcmV?d00001

diff --git a/Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/images/hover.stack.png b/Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/images/hover.stack.png
index 3f39ad89d1b925b2959165dabf4bbc87d1ad1681..9daf01d161439d088783cbd813b5205069acafb4 100644
GIT binary patch
delta 108
zcmV-y0F(c-2ZRT(AOmD=ZEdQms{jB0JFfvC0000#Nkl<Z7?orA4+RVe0OY_$AHV<s
zQ6%liqHwhYL{YWFMd4~G6h-qJ!Y?Rp!YPWZ9a$R6`A<L;O*^tQ3IG71-2ax5tXxz8
O0000<MNUMnLSTaLg(*z{

delta 156
zcmZo+-^{*2fw}%a0}z5h#3d6K1_lO|k|4ieumFC7Awq|j7pUIO)5S5Q;#TsH|ME-{
z0t_d9@(cg%KXORDYu#K%Utz{Tom&$x)^oXToYnWLu4d7RTNj&{R09e+7G=6~I;1c#
Zi1goK=eV56{1a#tgQu&X%Q~loCICOpQQ80i

diff --git a/Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/images/push.png b/Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/images/push.png
new file mode 100644
index 0000000000000000000000000000000000000000..9e2fa925797af2cbeb5c0567ac78f7ef8bd37ec7
GIT binary patch
literal 910
zcmW+!J!_Uh5S$Q%5Qw56#E)VH3kwNiYconh3`p=Jh2;iGKqUwvpyd!7txTc)62u}!
z6o0{DCBf28!Tkv-1&i0c9Ncr<KD#?RGxzrX>hj#|#aRGzD|Z(k_IbYdxtZzyzW%Xs
z8JNcXduvO5)ydY$p}tAk>vw)SI;O!5GK3)wWdLCW2`5AZkwg)2n1c>?$Ptcol%xBZ
zK*80G5kd;pSOE(#-~k09kbw#yVF@NYp+qDyQ3({Rz=9W4h(Z>s0MN!b^Z~*cr7W<g
zG$V~}lrfBHEMw<(xR;Y6gG{ozfzy0M-6>}{(^<|YX&R|6N(?c@5}UcjsP~|P5zJr(
zTMo<7)RRg^GLw~TjjY&6UQ{uPS*#+4y4_Ab<WUULDyUU68`y4=DNJc969$_xkdJX1
zxk0+0T3_=qrMu(`SGvl(Wmk7%$HodNrIOkS3pF3_P$)tfs!-cwsV3>2mx@%TD%GA@
zshN8hm!g!VDq*~frq^zFQhV5TwKKy-v!R9C=opr1S=Q#X4?`g5fQcbbD>3{wAF8<z
z?C?y_@)o0cH^pW%1`1`Wk;luh82WmQDI+o?D;m6Ux@A{)V#jjw?>OS4q)9)P2_`4U
z*4Ea+!NFuQx%GL<I(}wn>G95^7n?gT*S9yYyuH5p>SpXede*-dRu*rs&3}0E_ubr$
zz3WH9_x&@js}H_hdHnPA`)gnS%<p}hI%|t>_Al(70@j`{%sjnx_^T_ivb4H*c*l4D
E1E9KVF8}}l

literal 0
HcmV?d00001

diff --git a/Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/images/shift.left.png b/Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/images/shift.left.png
new file mode 100644
index 0000000000000000000000000000000000000000..8d4697108bb68769267aa3bffff70c8333de82cd
GIT binary patch
literal 887
zcmW+!v1(OO5FF7$gfyZcVzF3?h1dpUlovFhQ6wL*Ac9T6!oo@hwNNZfBUmm$B)mfX
zge@hAm8Hd&R$?irJa=>9-ossXXLe@J%R5`w*G`;00bp(O#^P?Dr~5s5{AholeYt-Q
zIEp(rw>SD%hp!F~^`Dgee9!j>zi4oS3}Hw^89*38!U+*UBvAw$=AgqJa)cut<!C$;
zD7YFJA*4{v6|evU9#9|x8K?jfmSDmYN<<<Pl|aD?EO<eMC}g1u0BzQx4+&#NSzvEz
zMjG8HV;Iv|#_sKMKTe7aGRbNHr}<RfDQ7s-S<V(|npPJjhL~cBt=wYfJ*Z#=Gg!g4
z!*W19sbnNGS;_Xuip}Ij6{DENDq`GiIQiJ47||-IT{9bQH^~&HG?fXXW)|{Ur<t3i
z@znmB&zA0zD_rR+Z^)kR#;(m1Qc5Lt5*BJb-lb54GE||C$5JiQyDt@~OjW8gvr;Sf
z9xg>GOI5<$i<Z}EcT;EBadk42qS<)iHi%)FmSr7I=P(92hbG3Jc4G22AJ^Q6J3P~~
zyv=CcEwR<iLZM7G^V|%J@z-OvjL3|vX!7Q1$e!-TuI1{_uZVY&R()AkSREcaJ3Gte
za<y8me>`Gczr4A)x_#!&z2C3bF6~}C5I*nySU!BY_u%@AE03|TOP}`MK6!TG`ToD#
eJaudR>+Uh^|2)6{=+(EsJ&nzct;L6H{`5cYNoZ>T

literal 0
HcmV?d00001

diff --git a/Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/images/shift.right.png b/Ghidra/Features/Base/src/main/help/help/topics/DockingWindows/images/shift.right.png
new file mode 100644
index 0000000000000000000000000000000000000000..4c02d8d03487d87ed73972c17bc942bd46c70d5c
GIT binary patch
literal 885
zcmW+!v1(OO5F81J1R^R3K`a()i&$GYh8OgKgdmm{3t}Urv=oL2f>>x{zXTCUp}(+L
zNsxSj#g;Zg3JXExxtk039`3R`vomvE@9o~(SiiOoU}JfI@vzUU{a(4S*58-kpI!&n
zu=n86PXFrc)!Cu`ld_*5`SJLa1~<qMhBTA`gb^g15D`QYMZjSWI@}>gIMPv$#xsF}
ztAP<h3e{Wz3ozgT1tO4v3Ls$#COn};Br;J66s*947gUHs7ODWyW*z#FFlLkm_LgR(
z(Ty^OF^y&H-Y)m!q{twXtOjtJPt~1rhBKYzY>}pEbx~r7DVEsEEoR<>3Pv!46>K{!
z2h@{FMlzF?Y>%wiOkPwmidn28#@&XKk3EVJt%BM$v*C7=Okqk>nJ{W*A)j@cxk(yN
z?XUT4=`Oj#m9FxJ?CEao+B_kpR8l8lq1NMF3PmVG73z2_)grz7QjyA3r8+Y!wQ}#_
zQk1e(CCt5Od7XAQb%q^RCo?IUjTdf%7?x>S*5PyxV~}%bV(e)rCU5g`&3(ATGd;`O
zjMm)}Tg@yK%2YGY&9E4MJ!Z>@%*cu+Z=Qzi>2B;=uKu1ze2}#2%d*1i?AYJmKRP;E
ztyZ_coU^WPEf;qmZN7i<=k3PUyPL<tx5J-Dr*9574=%mHc|ME9Wh{T+dHiebaB=J3
ZtBd%$bK}#=_VbgT#d2qN@p;=1{sZt?WzYZs

literal 0
HcmV?d00001

diff --git a/Ghidra/Framework/Docking/src/main/java/docking/ComponentNode.java b/Ghidra/Framework/Docking/src/main/java/docking/ComponentNode.java
old mode 100644
new mode 100755
index 896be59193..97c7038adb
--- a/Ghidra/Framework/Docking/src/main/java/docking/ComponentNode.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/ComponentNode.java
@@ -185,6 +185,43 @@ class ComponentNode extends Node {
 		topLevelNode.componentAdded(placeholder);
 	}
 
+	/**
+	 * Push a component to this node, before or after the selected one.
+	 * Stack the component at the beginning, if the selected one is null.
+	 * @param placeholder the placeholder to push.
+	 * @param selected the selected component of a target window space.
+	 */
+	void push(ComponentPlaceholder placeholder, ComponentPlaceholder selected) {
+		ComponentNode sourceNode = placeholder.getNode();
+		if (selected == null) {
+			sourceNode.remove(placeholder);
+			// Stack the placeholder at the beginning, if the selected
+			// one is null.
+			windowPlaceholders.add(0, placeholder);
+		} else {
+			// Taking the selected component index before removing the
+			// placeholder from its own node, is to properly shift the
+			// position of items when both are in the same space.
+			//
+			// In the same node, shift a component after the selected,
+			// if on its right, otherwise before, if on its left.
+			//
+			// Pushing the component in a new node, will always put it
+			// before the selected one.
+			int index = windowPlaceholders.indexOf(selected);
+			sourceNode.remove(placeholder);
+			windowPlaceholders.add(index, placeholder);
+		}
+		placeholder.setNode(this);
+
+		if (placeholder.isActive()) {
+			top = placeholder;
+			invalidate();
+		}
+		WindowNode topLevelNode = getTopLevelNode();
+		topLevelNode.componentAdded(placeholder);
+	}
+
 	/**
 	 * Removes the component from this node, but not from the manager. Used when
 	 * the component is moved.  If component is active, it will remain active.
@@ -326,7 +363,16 @@ class ComponentNode extends Node {
 
 			DockingTabRenderer tabRenderer =
 				createTabRenderer(tabbedPane, placeholder, fullTitle, tabText, component);
-			c.installDragDropTarget(tabbedPane);
+
+			// This is to register tabs as drag-N-drop targets.
+			// c.installDragDropTarget(tabbedPane) is for group
+			// of tabs, and won't allow to track single tabs as
+			// substitutes of a DockableComponent placeholder's
+			// window surface.
+			c.installDragDropTarget(tabRenderer);
+
+			tabRenderer.installDragSource(c.getHeader());
+
 			tabRenderer.installPopupMenu(createTabPopupMenu(activeComponents, placeholder));
 
 			tabbedPane.setTabComponentAt(i, tabRenderer);
@@ -632,6 +678,22 @@ class ComponentNode extends Node {
 		return null;
 	}
 
+	/*
+	 * Returns the list of placeholders in this node.
+	 */
+	List<ComponentPlaceholder> getPlaceholders() {
+		return new ArrayList<>(windowPlaceholders);
+	}
+
+	/*
+	 * Returns the list of active placeholders in this node.
+	 */
+	List<ComponentPlaceholder> getActivePlaceholders() {
+		List<ComponentPlaceholder> activeComponents = new ArrayList<>();
+		populateActiveComponents(activeComponents);
+		return activeComponents;
+	}
+
 	@Override
 	WindowNode getTopLevelNode() {
 		if (parent != null) {
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/DockableComponent.java b/Ghidra/Framework/Docking/src/main/java/docking/DockableComponent.java
index 3a93106c2d..dd17af3d04 100644
--- a/Ghidra/Framework/Docking/src/main/java/docking/DockableComponent.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/DockableComponent.java
@@ -18,12 +18,14 @@ package docking;
 import java.awt.*;
 import java.awt.dnd.*;
 import java.awt.event.*;
+import java.util.List;
 
 import javax.swing.*;
 
 import org.apache.commons.lang3.ArrayUtils;
 
 import docking.action.DockingActionIf;
+import docking.widgets.tabbedpane.DockingTabRenderer;
 import ghidra.util.*;
 import help.HelpService;
 
@@ -55,8 +57,24 @@ public class DockableComponent extends JPanel implements ContainerListener {
 	public static ComponentPlaceholder TARGET_INFO;
 	public static ComponentPlaceholder DRAGGED_OVER_INFO;
 	public static ComponentPlaceholder SOURCE_INFO;
+	public static List<ComponentPlaceholder> SOURCE_SECTION_INFO;
 	public static boolean DROP_CODE_SET;
 
+	// FIXME: This is a WORKAROUND to guess if a drag-N-drop operation was
+	// interrupted, by either a key press (ESC) or by another mouse button
+	// clicked.  The caveat is its limit.  A voluntary interruption, while
+	// the cursor is over a drop zone, would generate an uncommon dragExit
+	// triggered by DropTargetEvent alone.  The catch is to confirm that a
+	// DragSourceEvent did not trigger any dragExit counterpart, as it has
+	// to happen when the cursor is moved outside of any drop zone.
+	//
+	// The motive of this workaround is that while a drag-N-drop operation
+	// is in progress, its implementation might silence listening to other
+	// events, except pressing the modifiers ALT, CTRL, and SHIFT, so that
+	// pressing ESC isn't registered, and has to be determined indirectly,
+	// to gracefully cancel the action in progress.
+	public static boolean triggeredDragExit = false;
+
 	private DockableHeader header;
 	private MouseListener popupListener;
 	private ComponentPlaceholder placeholder;
@@ -105,6 +123,11 @@ public class DockableComponent extends JPanel implements ContainerListener {
 				add(header, BorderLayout.NORTH);
 			}
 
+			// This is to register headers as drag-N-drop targets.
+			// So that a DockableComponent could be dropped over a
+			// header, in place of a placeholder's window surface.
+			installDragDropTarget(header);
+
 			providerComp = initializeComponentPlaceholder(placeholder);
 
 			JPanel contentPanel = new JPanel(new BorderLayout());
@@ -259,16 +282,6 @@ public class DockableComponent extends JPanel implements ContainerListener {
 		return placeholder.getFullTitle();
 	}
 
-	/**
-	 * Translates the given point so that it is relative to the given component
-	 */
-	private void translate(Point p, Component c) {
-		Point cLoc = c.getLocationOnScreen();
-		Point myLoc = getLocationOnScreen();
-		p.x = p.x + cLoc.x - myLoc.x;
-		p.y = p.y + cLoc.y - myLoc.y;
-	}
-
 	private class DockableComponentDropTarget extends DropTarget {
 
 		DockableComponentDropTarget(Component comp) {
@@ -278,69 +291,79 @@ public class DockableComponent extends JPanel implements ContainerListener {
 		@Override
 		public synchronized void drop(DropTargetDropEvent dtde) {
 			clearAutoscroll();
-			if (dtde.isDataFlavorSupported(ComponentTransferable.localComponentProviderFlavor)) {
-				Point p = dtde.getLocation();
-				translate(p, ((DropTarget) dtde.getSource()).getComponent());
-				setDropCode(p);
+
+			if (!dtde.isDataFlavorSupported(ComponentTransferable.localComponentProviderFlavor)) {
+				dtde.rejectDrop();
+				return;
+			}
+
+			Component dropTarget = ((DropTarget) dtde.getSource()).getComponent();
+			setDropCode(dtde.getLocation(), dropTarget);
+
+			if (DROP_CODE_SET) {
 				TARGET_INFO = placeholder;
 				dtde.acceptDrop(dtde.getDropAction());
 				dtde.dropComplete(true);
+				return;
 			}
-			else {
-				dtde.rejectDrop();
-			}
+
+			dtde.rejectDrop();
 		}
 
 		@Override
 		public synchronized void dragEnter(DropTargetDragEvent dtde) {
 			super.dragEnter(dtde);
 
-			// On Mac, sometimes this component is not showing,
-			// which causes exception in the translate method.
-			if (!isShowing()) {
+			triggeredDragExit = false;
+
+			if (!dtde.isDataFlavorSupported(ComponentTransferable.localComponentProviderFlavor)) {
 				dtde.rejectDrag();
 				return;
 			}
 
-			if (dtde.isDataFlavorSupported(ComponentTransferable.localComponentProviderFlavor)) {
-				Point p = dtde.getLocation();
-				translate(p, ((DropTarget) dtde.getSource()).getComponent());
-				setDropCode(p);
+			Component dropTarget = ((DropTarget) dtde.getSource()).getComponent();
+			setDropCode(dtde.getLocation(), dropTarget);
+
+			if (DROP_CODE_SET) {
 				DRAGGED_OVER_INFO = placeholder;
 				dtde.acceptDrag(dtde.getDropAction());
+				return;
 			}
-			else {
-				dtde.rejectDrag();
-			}
+
+			dtde.rejectDrag();
 		}
 
 		@Override
 		public synchronized void dragOver(DropTargetDragEvent dtde) {
 			super.dragOver(dtde);
 
-			// On Mac, sometimes this component is not showing,
-			// which causes exception in the translate method.
-			if (!isShowing()) {
+			triggeredDragExit = false;
+
+			if (!dtde.isDataFlavorSupported(ComponentTransferable.localComponentProviderFlavor)) {
 				dtde.rejectDrag();
 				return;
 			}
 
-			if (dtde.isDataFlavorSupported(ComponentTransferable.localComponentProviderFlavor)) {
-				Point p = dtde.getLocation();
-				translate(p, ((DropTarget) dtde.getSource()).getComponent());
-				setDropCode(p);
+			Component dropTarget = ((DropTarget) dtde.getSource()).getComponent();
+			setDropCode(dtde.getLocation(), dropTarget);
+
+			if (DROP_CODE_SET) {
 				DRAGGED_OVER_INFO = placeholder;
 				dtde.acceptDrag(dtde.getDropAction());
+				return;
 			}
-			else {
-				dtde.rejectDrag();
-			}
+
+			dtde.rejectDrag();
 		}
 
 		@Override
 		public synchronized void dragExit(DropTargetEvent dte) {
 			super.dragExit(dte);
-			DROP_CODE = DropCode.WINDOW;
+			triggeredDragExit = true;
+			// FIXME: This is a WORKAROUND to allow the interruption of a drag-N-drop
+			// operation while outside of a drop zone.  The drop should be considered
+			// invalid, unless the CTRL key modifier is kept pressed.
+			DROP_CODE = DockableHeader.isCtrlModifierDown() ? DropCode.WINDOW : DropCode.INVALID;
 			DROP_CODE_SET = true;
 			DRAGGED_OVER_INFO = null;
 		}
@@ -426,13 +449,78 @@ public class DockableComponent extends JPanel implements ContainerListener {
 		}
 	}
 
+	/**
+	 * Translates the given point so that it is relative to the given component
+	 */
+	private void translate(Point p, Component c) {
+		Point cLoc = c.getLocationOnScreen();
+		Point myLoc = getLocationOnScreen();
+		p.x = p.x + cLoc.x - myLoc.x;
+		p.y = p.y + cLoc.y - myLoc.y;
+	}
+
 	/**
 	 * Sets the drop code base on the cursor location.
 	 * @param p the cursor location.
+	 * @param c the drop target.
 	 */
-	private void setDropCode(Point p) {
+	private void setDropCode(Point p, Component c) {
 		DROP_CODE_SET = true;
 
+		// Pressing the CTRL key modifier takes precedence.  It is an override
+		// to enable moving a dragged component in a new window.  This mode is
+		// togglable and disabled by default as a prevention to an involuntary
+		// action when a drag-N-drop operation is interrupted, by either a key
+		// press (ESC), or by another mouse button clicked.
+		if (DockableHeader.isCtrlModifierDown()) {
+			DROP_CODE = DropCode.WINDOW;
+			return;
+		}
+
+		// Pressing the SHIFT key modifier, temporarily invalidates the action
+		// expected by a drag-N-drop operation in progress, unless the ALT key
+		// is pressed.  Releasing the key should resume the normal processing.
+		if (DockableHeader.isShiftModifierDown() && !DockableHeader.isAltModifierDown()) {
+			DROP_CODE = DropCode.INVALID;
+			return;
+		}
+
+		// Tabs of components that aren't currently showing, are valid targets
+		// to drop a component on another which isn't showing its own content.
+		if (c instanceof DockingTabRenderer) {
+			if (SOURCE_INFO == placeholder) {
+				// the cursor is over the same tab, just ignore this action
+				DROP_CODE = DropCode.INVALID;
+			}
+			else if (SOURCE_INFO.getNode() != placeholder.getNode()	) {
+				// push the component between others, in another window space
+				DROP_CODE = DropCode.PUSH;
+			}
+			else {
+				// FIXME: assume that there is a tabbed pane
+				JTabbedPane tabbedPane = (JTabbedPane) getParent();
+				int target_index = tabbedPane.indexOfTabComponent(c);
+				int source_index = tabbedPane.indexOfComponent(SOURCE_INFO.getComponent());
+				if (target_index < source_index) {
+					// shift the component to the left, in the same window space
+					DROP_CODE = DropCode.SHIFT_LEFT;
+				}
+				else {
+					// shift the component to the right, in the same window space
+					DROP_CODE = DropCode.SHIFT_RIGHT;
+				}
+			}
+			return;
+		}
+
+		// On Mac, sometimes this component is not showing,
+		// which causes exception in the translate method.
+		if (!isShowing()) {
+			DROP_CODE_SET = false;
+			return;
+		}
+		translate(p, c);
+
 		if (placeholder == null) {
 			DROP_CODE = DropCode.ROOT;
 			return;
@@ -442,7 +530,7 @@ public class DockableComponent extends JPanel implements ContainerListener {
 			return;
 		}
 		if (SOURCE_INFO.getNode().winMgr != placeholder.getNode().winMgr) {
-			DROP_CODE = DropCode.WINDOW;
+			DROP_CODE = DropCode.INVALID;
 			return;
 		}
 		if (SOURCE_INFO == placeholder && !placeholder.isStacked()) {
@@ -455,14 +543,25 @@ public class DockableComponent extends JPanel implements ContainerListener {
 		else if (p.x > getWidth() - DROP_EDGE_OFFSET) {
 			DROP_CODE = DropCode.RIGHT;
 		}
-		else if (p.y < DROP_EDGE_OFFSET) {
+		// Leave some space to drop over a header.  The TOP drop zone should be
+		// just below the title bar (header).
+		else if (p.y > DROP_EDGE_OFFSET && p.y < DROP_EDGE_OFFSET * 2) {
 			DROP_CODE = DropCode.TOP;
 		}
 		else if (p.y > getHeight() - DROP_EDGE_OFFSET) {
 			DROP_CODE = DropCode.BOTTOM;
 		}
+		// Dragging a component over a header, is a shortcut to prepend it as a
+		// fist tab in the windows space that the mouse cursor is over.
+		else if (c instanceof DockableHeader) {
+			// place the component at the beginning of the target stack
+			DROP_CODE = DropCode.PREPEND;
+		}
+		// Dragging a component over its own content space, in the same window,
+		// is a shortcut to append it as a last tab.
 		else if (SOURCE_INFO == placeholder) {
-			DROP_CODE = DropCode.INVALID;
+			// place the component at the end of the target stack
+			DROP_CODE = DropCode.STACK;
 		}
 		else {
 			DROP_CODE = DropCode.STACK;
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/DockableHeader.java b/Ghidra/Framework/Docking/src/main/java/docking/DockableHeader.java
index 0a59093f52..dbb539c86f 100644
--- a/Ghidra/Framework/Docking/src/main/java/docking/DockableHeader.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/DockableHeader.java
@@ -24,6 +24,7 @@ import java.util.List;
 import java.util.stream.Collectors;
 
 import javax.swing.JFrame;
+import javax.swing.JTabbedPane;
 import javax.swing.SwingUtilities;
 
 import org.jdesktop.animation.timing.Animator;
@@ -50,7 +51,7 @@ import help.HelpService;
  * source functionality.
  */
 public class DockableHeader extends GenericHeader
-		implements DragGestureListener, DragSourceListener {
+		implements DragGestureListener, DragSourceListener, DragSourceMotionListener {
 
 	private DockableComponent dockComp;
 
@@ -60,6 +61,16 @@ public class DockableHeader extends GenericHeader
 
 	private Animator focusAnimator;
 
+	// drag-N-drop key modifiers flags
+	private static boolean ALT_DOWN = false;
+	private static boolean CTRL_DOWN = false;
+	private static boolean SHIFT_DOWN = false;
+
+	// FIXME: This is a WORKAROUND to guess if a drag-N-drop operation was
+	// interrupted, by either a key press (ESC) or by another mouse button
+	// clicked.  It will work only while over a drop zone.
+	private static boolean confirmedDragExit = false;
+
 	/**
 	 * Constructs a new DockableHeader for the given dockableComponent.
 	 * 
@@ -82,9 +93,25 @@ public class DockableHeader extends GenericHeader
 		toolBarMgr.dispose(); // reset the default manager before we create our own
 		toolBarMgr = new DockableToolBarManager(dockableComp, this);
 
+		// A drag-N-drop operation can be directed with key modifiers.
+		//
+		// ACTION_MOVE: pressing CTRL triggers dragExit while over a drop zone,
+		// but not pressing SHIFT (CTRL means "copy").
+		//
+		// ACTION_COPY: pressing SHIFT triggers dragExit while over a drop zone,
+		// but not pressing CTRL (SHIFT means "move").
+		//
+		// ACTION_LINK: either CTRL or SHIFT trigger dragExit while over a drop
+		// zone, but not pressing them together.  This helps to detect a toggle
+		// switch kept pressed, while over a drop zone.
+		//
+		// With any of the above, pressing ALT shouldn't trigger dragExit while
+		// over a drop zone.
 		dragSource.createDefaultDragGestureRecognizer(titlePanel.getDragComponent(),
 			DnDConstants.ACTION_MOVE, DockableHeader.this);
 
+		dragSource.addDragSourceMotionListener(DockableHeader.this);
+
 		resetComponents();
 	}
 
@@ -269,10 +296,26 @@ public class DockableHeader extends GenericHeader
 			(modifiers & InputEvent.BUTTON3_DOWN_MASK) != 0) {
 			return;
 		}
-		DockableComponent.DROP_CODE = DropCode.WINDOW;
+
+		confirmedDragExit = false;
+		DockableComponent.triggeredDragExit = false;
+
+		ALT_DOWN = SHIFT_DOWN = CTRL_DOWN = false;
+
+		// NOTE: This is a remainder to assume an invalid drop action,
+		// to prevent unexpected effects when voluntarily interrupting
+		// a drag-N-drop operation while outside of a drop zone.
+		DockableComponent.DROP_CODE = DropCode.INVALID;
 		DockableComponent.DROP_CODE_SET = true;
+		DockableComponent.DRAGGED_OVER_INFO = null;
+		DockableComponent.SOURCE_SECTION_INFO = null;
 		DockableComponent.SOURCE_INFO = dockComp.getComponentWindowingPlaceholder();
 
+		// NOTE: Get the title from the source placeholder, and not of
+		// the header.  This is to be consistent with tool tip updates
+		// which use titles of placeholders.
+		TransientWindow.showTransientWindow(DockableComponent.SOURCE_INFO.getTitle());
+
 		dragCursorManager.dragStarted();
 
 		dragSource.startDrag(event, DragSource.DefaultMoveNoDrop,
@@ -284,9 +327,21 @@ public class DockableHeader extends GenericHeader
 		dragCursorManager.restoreCursorOnPreviousDraggedOverComponent();
 		dragCursorManager.dragEnded();
 
+		TransientWindow.hideTransientWindow();
+
+		// NOTE: This guesses a drag-N-drop voluntary interruption, by
+		// either a key press (ESC) or by another mouse button clicked
+		// while over a drop zone.  Only dragExit from DropTargetEvent
+		// should had been triggered in this context.
+		if (DockableComponent.triggeredDragExit != confirmedDragExit) {
+			resetStackSection();
+			return;
+		}
+
 		ComponentPlaceholder info = dockComp.getComponentWindowingPlaceholder();
 		DockingWindowManager winMgr = info.getNode().winMgr;
 		if (DockableComponent.DROP_CODE == DropCode.INVALID) {
+			resetStackSection();
 			return;
 		}
 
@@ -297,27 +352,61 @@ public class DockableHeader extends GenericHeader
 //		}
 //		else
 		if (DockableComponent.DROP_CODE == DropCode.WINDOW) {
-			winMgr.movePlaceholder(info, event.getLocation());
+			if (ALT_DOWN) {
+				winMgr.moveStackSection(DockableComponent.SOURCE_SECTION_INFO,
+					info, event.getLocation());
+			}
+			else {
+				winMgr.movePlaceholder(info, event.getLocation());
+			}
 		}
 		else {
-			winMgr.movePlaceholder(info, DockableComponent.TARGET_INFO,
-				DockableComponent.DROP_CODE.getWindowPosition());
+			if (ALT_DOWN) {
+				winMgr.moveStackSection(DockableComponent.SOURCE_SECTION_INFO,
+					info, DockableComponent.TARGET_INFO,
+					DockableComponent.DROP_CODE.getWindowPosition());
+			}
+			else {
+				winMgr.movePlaceholder(info, DockableComponent.TARGET_INFO,
+					DockableComponent.DROP_CODE.getWindowPosition());
+			}
 		}
+
+		resetStackSection();
 	}
 
 	@Override
 	public void dragEnter(DragSourceDragEvent event) {
 		setCursor(event);
+		confirmedDragExit = false;
 	}
 
 	@Override
 	public void dragExit(DragSourceEvent event) {
 		setCursor(event);
+		confirmedDragExit = true;
+		if (ALT_DOWN) {
+			setStackSection(DockableComponent.SOURCE_INFO,
+				DockableComponent.DRAGGED_OVER_INFO, SHIFT_DOWN);
+		}
+		else {
+			setStackSection(DockableComponent.SOURCE_INFO);
+		}
+		highlightStackSection();
 	}
 
 	@Override
 	public void dragOver(DragSourceDragEvent event) {
 		setCursor(event);
+		confirmedDragExit = false;
+		if (ALT_DOWN) {
+			setStackSection(DockableComponent.SOURCE_INFO,
+				DockableComponent.DRAGGED_OVER_INFO, SHIFT_DOWN);
+		}
+		else {
+			setStackSection(DockableComponent.SOURCE_INFO);
+		}
+		highlightStackSection();
 	}
 
 	/**
@@ -336,9 +425,200 @@ public class DockableHeader extends GenericHeader
 		dragCursorManager.setCursor(event, c);
 	}
 
+	/**
+	 * drag-n-drop ALT key modifier flag.
+	 *
+	 * @return TRUE is the key modifier is pressed, otherwise FALSE
+	 */
+	public static boolean isAltModifierDown() {
+		return ALT_DOWN;
+	}
+
+	/**
+	 * drag-n-drop CTRL key modifier flag.
+	 *
+	 * @return TRUE is the key modifier is pressed, otherwise FALSE
+	 */
+	public static boolean isCtrlModifierDown() {
+		return CTRL_DOWN;
+	}
+
+	/**
+	 * drag-n-drop SHIFT key modifier flag.
+	 *
+	 * @return TRUE is the key modifier is pressed, otherwise FALSE
+	 */
+	public static boolean isShiftModifierDown() {
+		return SHIFT_DOWN;
+	}
+
+	/**
+	 * Resets the current state of the stack section which was dragged
+	 * around, removing the highlights from tabs.
+	 */
+	private static void resetStackSection() {
+		DockableComponent.SOURCE_SECTION_INFO = null;
+		highlightStackSection();
+	}
+
+	/**
+	 * Repaints each tab to apply/remove highlights depending upon the
+	 * current state of the stack section dragged around.
+	 */
+	private static void highlightStackSection() {
+
+		// Get the source component.
+		DockableComponent comp = DockableComponent.SOURCE_INFO.getComponent();
+
+		// Loop over each tab of the tabbed pane associated
+		// with the source component to process highlights.
+		if (comp.getParent() instanceof JTabbedPane) {
+			JTabbedPane tabbedPane = (JTabbedPane) comp.getParent();
+			synchronized(tabbedPane.getTreeLock()) {
+				for (Component c : tabbedPane.getComponents()) {
+					if (c instanceof DockableComponent) {
+						int tabIndex = tabbedPane.indexOfComponent(c);
+						if (tabIndex != -1) {
+							tabbedPane.getTabComponentAt(tabIndex).repaint();
+						}
+					}
+				}
+			}
+		}
+	}
+
+	/**
+	 * Updates the information about a multiple component selection as
+	 * a stack section is dragged around.
+	 *
+	 * The selection starts from a source placeholder, and ends either
+	 * with the first or last placeholder in the same window space, or
+	 * before the destination placeholder if it's in the same stack of
+	 * the source.
+	 *
+	 * @param source the placeholder from where the selection starts
+	 * @param destination the placeholder with the mouse cursor over
+	 * @param selectLeftSide if TRUE, select from the left of source
+	 */
+	private static void setStackSection(ComponentPlaceholder source,
+			ComponentPlaceholder destination, boolean selectLeftSide) {
+
+		// Collect the active placeholders found in
+		// the source's stack.
+		List<ComponentPlaceholder> placeholders = source.getNode().getActivePlaceholders();
+
+		// Pre-process the stack's selection range.
+		int infoIndex = placeholders.indexOf(source);
+
+		// The hovered placeholder has index -1, if
+		// in another window space than the source.
+		int overIndex = placeholders.indexOf(destination);
+
+		if (selectLeftSide) {
+			// If the hovered placeholder is on the
+			// same window space of the source, and
+			// and it's before it, the selection is
+			// started after it.
+			overIndex = overIndex < infoIndex ? overIndex + 1 : 0;
+
+			// Section of placeholders found on the
+			// left of the source placeholder.
+			DockableComponent.SOURCE_SECTION_INFO = placeholders.subList(overIndex, infoIndex + 1);
+		}
+		else {
+			// If the hovered placeholder is on the
+			// same window space of the source, and
+			// and it is after it, the selection is
+			// ended before it.
+			overIndex = overIndex > infoIndex ? overIndex : placeholders.size();
+
+			// Section of placeholders found on the
+			// right of the source placeholder.
+			DockableComponent.SOURCE_SECTION_INFO = placeholders.subList(infoIndex, overIndex);
+		}
+
+		// Put each selected placeholder title on a
+		// separate line while joining in the text.
+		String infoText = DockableComponent.SOURCE_SECTION_INFO.stream()
+				.map(p -> p.getTitle())
+				.collect(Collectors.joining("\n"));
+
+		// Update the transient tool tip text.
+		TransientWindow.updateTransientWindow(infoText);
+	}
+
+	/**
+	 * Updates the information about a multiple component selection as
+	 * a single placeholder, part of a stack, is dragged around.
+	 *
+	 * @param source the placeholder dragged around, part of a stack
+	 */
+	private static void setStackSection(ComponentPlaceholder source) {
+		DockableComponent.SOURCE_SECTION_INFO = new ArrayList<>(Arrays.asList(source));
+		TransientWindow.updateTransientWindow(source.getTitle());
+	}
+
+	/**
+	 * This is executed after a modifier is pressed or released.
+	 */
 	@Override
 	public void dropActionChanged(DragSourceDragEvent event) {
-		// don't care
+
+		// Before determining the current state, reset all
+		// key modifiers, and the default drop action too.
+		ALT_DOWN = SHIFT_DOWN = CTRL_DOWN = false;
+		DockableComponent.DROP_CODE = DropCode.INVALID;
+
+		// Clear the stack section dragged around, and
+		// reset all tabs highlights, while outside of
+		// any drop zone.
+		if (confirmedDragExit) {
+			setStackSection(DockableComponent.SOURCE_INFO);
+			highlightStackSection();
+		}
+
+		// Check if any key modifier is being pressed.
+		int modifiers = event.getGestureModifiersEx();
+
+		ALT_DOWN = ((modifiers & InputEvent.ALT_DOWN_MASK) != 0);
+		CTRL_DOWN = ((modifiers & InputEvent.CTRL_DOWN_MASK) != 0);
+		SHIFT_DOWN = ((modifiers & InputEvent.SHIFT_DOWN_MASK) != 0);
+
+		if (ALT_DOWN && confirmedDragExit) {
+			// Temporarily mark a stack section, of which a
+			// placeholder is part of, as to be moved.
+			setStackSection(DockableComponent.SOURCE_INFO,
+				DockableComponent.DRAGGED_OVER_INFO, SHIFT_DOWN);
+
+			// Highlight all tabs part of the stack section
+			// and turn off the unselected.
+			highlightStackSection();
+		}
+		// NOTE: While the ALT key is pressed, SHIFT should
+		// indicate a right-to-left stack selection, from a
+		// source placeholder.  In this context, it's not a
+		// toggle to mark the drag-N-drop as invalid.
+		else if (SHIFT_DOWN) {
+			// Temporarily mark the drag-N-drop as invalid,
+			// as an alternative to a sudden interruption.
+			DockableComponent.DROP_CODE = DropCode.INVALID;
+		}
+		if (CTRL_DOWN) {
+			// Temporarily mark the dragged component as to
+			// be moved in a new window.  Releasing the key
+			// press should revert to the default state.
+			DockableComponent.DROP_CODE = DropCode.WINDOW;
+		}
+
+		// Force a mouse cursor update, needed while outside of
+		// any drop zone, since no dragExit, Enter, Over should
+		// take place.
+		setCursor(event);
+	}
+
+	@Override
+	public void dragMouseMoved(DragSourceDragEvent event) {
+		TransientWindow.positionTransientWindow();
 	}
 
 	private DragCursorManager createDragCursorManager() {
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java b/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java
index 72105f78c4..1243d30634 100644
--- a/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/DockingWindowManager.java
@@ -1184,6 +1184,116 @@ public class DockingWindowManager implements PropertyChangeListener, Placeholder
 		}
 	}
 
+	/**
+	 * Moves a stack section of placeholders in a new window, that will
+	 * be anchored at the given point.
+	 *
+	 * @param stackSection the stack section of placeholders to be moved
+	 * @param selected the placeholder that will be focused in the stack
+	 * @param p the location at which a new stack window will be created
+	 */
+	void moveStackSection(List<ComponentPlaceholder> stackSection, ComponentPlaceholder selected,
+			Point p) {
+
+		// Work over a copy of the stack section argument.
+		List<ComponentPlaceholder> stack = new ArrayList<>(stackSection);
+
+		// Get the first placeholder of the stack section.
+		ComponentPlaceholder source = stack.getFirst();
+		ComponentNode sourceNode = source.getNode();
+
+		// Move the first placeholder got in a new window.
+		stack.removeFirst();
+		sourceNode.remove(source);
+		root.addToNewWindow(source, p);
+		ComponentNode destinationNode = source.getNode();
+
+		// Add the rest of placeholders to the new window.
+		for (ComponentPlaceholder placeholder : stack) {
+			sourceNode.remove(placeholder);
+			destinationNode.add(placeholder);
+		}
+
+		// Force the focus over the selected placeholder.
+		setNextFocusPlaceholder(selected);
+		scheduleUpdate();
+	}
+
+	/**
+	 * Moves a stack section of placeholders to a new docked location,
+	 * in the space specified by the given destination.
+	 *
+	 * @param stackSection the stack section of placeholders to be moved
+	 * @param selected the placeholder that will be focused in the stack
+	 * @param destination the placeholder indicating the docked location
+	 * @param windowPosition a code specifying the docking relationships
+	 */
+	void moveStackSection(List<ComponentPlaceholder> stackSection, ComponentPlaceholder selected,
+			ComponentPlaceholder destination, WindowPosition windowPosition) {
+		List<ComponentPlaceholder> stack = new ArrayList<>(stackSection);
+		ComponentPlaceholder source = stack.getFirst();
+		ComponentNode sourceNode = source.getNode();
+		if (destination != null) {
+			ComponentNode destinationNode = destination.getNode();
+			if (windowPosition == WindowPosition.STACK) {
+				for (ComponentPlaceholder placeholder : stack) {
+					sourceNode.remove(placeholder);
+					destinationNode.add(placeholder);
+				}
+			}
+			else if (windowPosition == WindowPosition.PUSH ||
+					windowPosition == WindowPosition.SHIFT_LEFT) {
+				for (ComponentPlaceholder placeholder : stack) {
+					// Don't remove the source placeholder from its own node
+					// outside of push(), since that will change the indexes
+					// of components, preventing push() to properly shift an
+					// item position when both source and destination are in
+					// the same node.  push() itself will handle the removal
+					// of the source placeholder from its own node.
+					destinationNode.push(placeholder, destination);
+				}
+			}
+			else if (windowPosition == WindowPosition.SHIFT_RIGHT) {
+				for (ComponentPlaceholder placeholder : stack.reversed()) {
+					// Reversing the remaining placeholders order before the
+					// push, is to respect the original stack positioning in
+					// the context of the docking relationships specified.
+					destinationNode.push(placeholder, destination);
+				}
+			}
+			else if (windowPosition == WindowPosition.PREPEND) {
+				for (ComponentPlaceholder placeholder : stack.reversed()) {
+					// Effectively, move the source placeholder at the start
+					// of the destination node.
+					destinationNode.push(placeholder, null);
+				}
+			}
+			else {
+				stack.removeFirst();
+				sourceNode.remove(source);
+				destinationNode.split(source, windowPosition);
+				ComponentNode newNode = source.getNode();
+				for (ComponentPlaceholder placeholder : stack) {
+					sourceNode.remove(placeholder);
+					newNode.add(placeholder);
+				}
+			}
+		}
+		else {
+			stack.removeFirst();
+			sourceNode.remove(source);
+			root.add(source, WindowPosition.RIGHT);
+			ComponentNode newNode = source.getNode();
+			for (ComponentPlaceholder placeholder : stack) {
+				sourceNode.remove(placeholder);
+				newNode.add(placeholder);
+			}
+		}
+
+		setNextFocusPlaceholder(selected);
+		scheduleUpdate();
+	}
+
 	/**
 	 * Moves the component associated with the given source placeholder object from its current
 	 * docked location to its own window that will be anchored at the given point.
@@ -1211,11 +1321,28 @@ public class DockingWindowManager implements PropertyChangeListener, Placeholder
 		ComponentNode sourceNode = source.getNode();
 		if (destination != null) {
 			ComponentNode destinationNode = destination.getNode();
-			sourceNode.remove(source);
 			if (windowPosition == WindowPosition.STACK) {
+				sourceNode.remove(source);
 				destinationNode.add(source);
 			}
+			else if (windowPosition == WindowPosition.PUSH ||
+					windowPosition == WindowPosition.SHIFT_LEFT ||
+					windowPosition == WindowPosition.SHIFT_RIGHT) {
+				// Don't remove the source placeholder from its own node
+				// outside of push(), since that will change the indexes
+				// of components, preventing push() to properly shift an
+				// item position when both source and destination are in
+				// the same node.  push() itself will handle the removal
+				// of the source placeholder from its own node.
+				destinationNode.push(source, destination);
+			}
+			else if (windowPosition == WindowPosition.PREPEND) {
+				// Effectively, move the source placeholder at the start
+				// of the destination node.
+				destinationNode.push(source, null);
+			}
 			else {
+				sourceNode.remove(source);
 				destinationNode.split(source, windowPosition);
 			}
 		}
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/DropCode.java b/Ghidra/Framework/Docking/src/main/java/docking/DropCode.java
index 6de555096e..ba28554366 100644
--- a/Ghidra/Framework/Docking/src/main/java/docking/DropCode.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/DropCode.java
@@ -22,7 +22,7 @@ import java.awt.Cursor;
  * convenience methods for translating this drop code into a cursor and window position.
  */
 enum DropCode {
-	INVALID, STACK, LEFT, RIGHT, TOP, BOTTOM, ROOT, WINDOW;
+	INVALID, STACK, PREPEND, PUSH, SHIFT_LEFT, SHIFT_RIGHT, LEFT, RIGHT, TOP, BOTTOM, ROOT, WINDOW;
 
 	public Cursor getCursor() {
 		Cursor c = HeaderCursor.NO_DROP;
@@ -42,6 +42,18 @@ enum DropCode {
 			case STACK:
 				c = HeaderCursor.STACK;
 				break;
+			case PREPEND:
+				c = HeaderCursor.PREPEND;
+				break;
+			case PUSH:
+				c = HeaderCursor.PUSH;
+				break;
+			case SHIFT_LEFT:
+				c = HeaderCursor.SHIFT_LEFT;
+				break;
+			case SHIFT_RIGHT:
+				c = HeaderCursor.SHIFT_RIGHT;
+				break;
 			case ROOT:
 				c = HeaderCursor.STACK;
 				break;
@@ -57,6 +69,8 @@ enum DropCode {
 
 	public WindowPosition getWindowPosition() {
 		switch (this) {
+			case WINDOW:
+				return WindowPosition.WINDOW;
 			case BOTTOM:
 				return WindowPosition.BOTTOM;
 			case LEFT:
@@ -65,6 +79,14 @@ enum DropCode {
 				return WindowPosition.RIGHT;
 			case STACK:
 				return WindowPosition.STACK;
+			case PREPEND:
+				return WindowPosition.PREPEND;
+			case PUSH:
+				return WindowPosition.PUSH;
+			case SHIFT_LEFT:
+				return WindowPosition.SHIFT_LEFT;
+			case SHIFT_RIGHT:
+				return WindowPosition.SHIFT_RIGHT;
 			case TOP:
 				return WindowPosition.TOP;
 			default:
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/HeaderCursor.java b/Ghidra/Framework/Docking/src/main/java/docking/HeaderCursor.java
index cf88ecc39c..e03b4d039d 100644
--- a/Ghidra/Framework/Docking/src/main/java/docking/HeaderCursor.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/HeaderCursor.java
@@ -38,6 +38,10 @@ public class HeaderCursor {
 	static Cursor TOP;
 	static Cursor BOTTOM;
 	static Cursor STACK;
+	static Cursor PREPEND;
+	static Cursor PUSH;
+	static Cursor SHIFT_LEFT;
+	static Cursor SHIFT_RIGHT;
 	static Cursor NEW_WINDOW;
 	static Cursor NO_DROP = DragSource.DefaultMoveNoDrop;
 
@@ -65,6 +69,18 @@ public class HeaderCursor {
 		image = drawStack();
 		STACK = tk.createCustomCursor(image, new Point(8, 8), "STACK");
 
+		image = drawPrepend();
+		PREPEND = tk.createCustomCursor(image, new Point(8, 8), "PREPEND");
+
+		image = drawPush();
+		PUSH = tk.createCustomCursor(image, new Point(6, 6), "PUSH");
+
+		image = drawShiftLeft();
+		SHIFT_LEFT = tk.createCustomCursor(image, new Point(6, 6), "SHIFT_LEFT");
+
+		image = drawShiftRight();
+		SHIFT_RIGHT = tk.createCustomCursor(image, new Point(6, 6), "SHIFT_RIGHT");
+
 		image = drawNewWindow();
 		NEW_WINDOW = tk.createCustomCursor(image, new Point(0, 0), "NEW_WINDOW");
 	}
@@ -145,6 +161,32 @@ public class HeaderCursor {
 
 	private static Image drawStack() {
 
+		BufferedImage image = new BufferedImage(32, 32, BufferedImage.TYPE_INT_ARGB);
+		// highlight the target position in the stack
+		int headerColor = new GColor("color.bg.header.active").getRGB();
+		int offset = 6;
+		for (int x = 1; x < 10; x++) {
+			for (int y = 1; y < 10; y++) {
+				image.setRGB(x + offset, y, headerColor);
+			}
+		}
+		int v = CURSOR_COLOR.getRGB();
+		for (int i = 0; i < 3; i++) {
+			int x = i * 3;
+			int y = 6 - i * 3;
+			for (int j = 0; j < 10; j++) {
+				image.setRGB(x, y + j, v);
+				image.setRGB(x + 10, y + j, v);
+				image.setRGB(x + j, y, v);
+				image.setRGB(x + j, y + 10, v);
+			}
+		}
+
+		return image;
+	}
+
+	private static Image drawPrepend() {
+
 		BufferedImage image = new BufferedImage(32, 32, BufferedImage.TYPE_INT_ARGB);
 		int v = CURSOR_COLOR.getRGB();
 		for (int i = 0; i < 3; i++) {
@@ -157,6 +199,98 @@ public class HeaderCursor {
 				image.setRGB(x + j, y + 10, v);
 			}
 		}
+		// highlight the target position in the stack
+		int headerColor = new GColor("color.bg.header.active").getRGB();
+		int offset = 6;
+		for (int x = 1; x < 10; x++) {
+			for (int y = 1; y < 10; y++) {
+				image.setRGB(x, y + offset, headerColor);
+			}
+		}
+
+		return image;
+	}
+
+	private static Image drawPush() {
+
+		BufferedImage image = new BufferedImage(32, 32, BufferedImage.TYPE_INT_ARGB);
+		// draw adjacent overlapping boxes
+		int v = CURSOR_COLOR.getRGB();
+		for (int i = 0; i < 2; i++) {
+			int x = i * 3;
+			int y = i%2 != 0 ? 3 : 0;
+			for (int j = 0; j < 10; j++) {
+				image.setRGB(x, y + j, v);
+				image.setRGB(x + 10, y + j, v);
+				image.setRGB(x + j, y, v);
+				image.setRGB(x + j, y + 10, v);
+			}
+		}
+		// highlight the target position in the stack
+		int headerColor = new GColor("color.bg.header.active").getRGB();
+		int x_offset = 0;
+		int y_offset = 0;
+		for (int x = 1; x < 10; x++) {
+			for (int y = 1; y < 10; y++) {
+				image.setRGB(x + x_offset, y + y_offset, headerColor);
+			}
+		}
+
+		return image;
+	}
+
+	private static Image drawShiftLeft() {
+
+		BufferedImage image = new BufferedImage(32, 32, BufferedImage.TYPE_INT_ARGB);
+		// highlight the target position in the stack
+		int headerColor = new GColor("color.bg.header.active").getRGB();
+		int x_offset = 0;
+		int y_offset = 3;
+		for (int x = 1; x < 10; x++) {
+			for (int y = 1; y < 10; y++) {
+				image.setRGB(x + x_offset, y + y_offset, headerColor);
+			}
+		}
+		// draw adjacent overlapping boxes
+		int v = CURSOR_COLOR.getRGB();
+		for (int i = 0; i < 2; i++) {
+			int x = i * 3;
+			int y = i%2 == 0 ? 3 : 0;
+			for (int j = 0; j < 10; j++) {
+				image.setRGB(x, y + j, v);
+				image.setRGB(x + 10, y + j, v);
+				image.setRGB(x + j, y, v);
+				image.setRGB(x + j, y + 10, v);
+			}
+		}
+
+		return image;
+	}
+
+	private static Image drawShiftRight() {
+
+		BufferedImage image = new BufferedImage(32, 32, BufferedImage.TYPE_INT_ARGB);
+		// highlight the target position in the stack
+		int headerColor = new GColor("color.bg.header.active").getRGB();
+		int x_offset = 3;
+		int y_offset = 3;
+		for (int x = 1; x < 10; x++) {
+			for (int y = 1; y < 10; y++) {
+				image.setRGB(x + x_offset, y + y_offset, headerColor); // horizontal line
+			}
+		}
+		// draw adjacent overlapping boxes
+		int v = CURSOR_COLOR.getRGB();
+		for (int i = 0; i < 2; i++) {
+			int x = i * 3;                      // concatenate moving by x offset
+			int y = i%2 != 0 ? 3 : 0;           // alternate y higher and lower
+			for (int j = 0; j < 10; j++) {
+				image.setRGB(x, y + j, v);      // left vertical line
+				image.setRGB(x + 10, y + j, v); // right vertical line
+				image.setRGB(x + j, y, v);      // top horizontal line
+				image.setRGB(x + j, y + 10, v); // bottom horizontal line
+			}
+		}
 
 		return image;
 	}
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/TransientWindow.java b/Ghidra/Framework/Docking/src/main/java/docking/TransientWindow.java
new file mode 100755
index 0000000000..77e59494ee
--- /dev/null
+++ b/Ghidra/Framework/Docking/src/main/java/docking/TransientWindow.java
@@ -0,0 +1,136 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package docking;
+
+import java.awt.Color;
+import java.awt.MouseInfo;
+import java.awt.Point;
+import java.awt.Window;
+
+import javax.swing.BorderFactory;
+import javax.swing.JToolTip;
+import javax.swing.JWindow;
+
+/**
+ * Drag feedback indicator class.
+ *
+ * Once activated, a tool tip will follow the mouse cursor across all the screen.
+ *
+ * To automatically update its location at a specific polling rate:
+ *
+ * TransientWindow.activateTransientWindow("Title", pollingRate);
+ * TransientWindow.deactivateTransientWindow();
+ *
+ * To change parameters:
+ *
+ * TransientWindow.updateTransientWindow("Title");
+ * TransientWindow.updateTransientWindow(pollingRate);
+ *
+ * To manually control the tool tip:
+ *
+ * TransientWindow.showTransientWindow("Title");
+ * TransientWindow.positionTransientWindow();
+ * TransientWindow.hideTransientWindow();
+ */
+public class TransientWindow {
+
+	private static JToolTip transientTip;
+	private static JWindow transientWindow;
+
+	private static int defaultPollingRate = 20;
+
+	private static void createTransientWindow(String title) {
+		if (transientWindow != null) {
+			return;
+		}
+
+		transientTip = new JToolTip();
+		transientTip.setBorder(BorderFactory.createLineBorder(Color.YELLOW));
+		transientTip.setTipText(title);
+		transientTip.setVisible(true);
+		transientTip.setOpaque(false);
+
+		transientWindow = new JWindow();
+		transientWindow.setOpacity(0.7f);
+		transientWindow.setAlwaysOnTop(true);
+		transientWindow.setType(Window.Type.POPUP);
+		transientWindow.setFocusableWindowState(false);
+		transientWindow.getContentPane().add(transientTip);
+
+		transientWindow.pack();
+	}
+
+	private static void transientWindowListener() {
+		while (transientWindow != null) {
+			try {
+				Thread.sleep(defaultPollingRate);
+				positionTransientWindow();
+			} catch (InterruptedException e) {
+				e.printStackTrace();
+			}
+		}
+	}
+
+	public static synchronized void positionTransientWindow() {
+		if (transientWindow == null) {
+			return;
+		}
+		Point p = MouseInfo.getPointerInfo().getLocation();
+		transientWindow.setLocation(p.x + 16, p.y + 16);
+	}
+
+	public synchronized static void updateTransientWindow(String title) {
+		if (transientWindow == null || transientTip == null) {
+			return;
+		}
+		transientTip.setTipText(title);
+		transientWindow.pack();
+	}
+
+	public synchronized static void updateTransientWindow(int pollingRate) {
+		defaultPollingRate = pollingRate;
+	}
+
+	public static void showTransientWindow(String title) {
+		createTransientWindow(title);
+		positionTransientWindow();
+		transientWindow.setVisible(true);
+	}
+
+	public static synchronized void hideTransientWindow() {
+		if (transientWindow == null) {
+			return;
+		}
+		transientWindow.setVisible(false);
+		transientWindow = null;
+		transientTip = null;
+	}
+
+	public static synchronized void activateTransientWindow(String title, int pollingRate) {
+		if (transientWindow != null) {
+			return;
+		}
+		Runnable task = () -> transientWindowListener();
+		Thread thread = new Thread(task);
+		defaultPollingRate = pollingRate;
+		showTransientWindow(title);
+		thread.start();
+	}
+
+	public static void deactivateTransientWindow() {
+		hideTransientWindow();
+	}
+}
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/WindowPosition.java b/Ghidra/Framework/Docking/src/main/java/docking/WindowPosition.java
index 938b258d0c..b974cb1d44 100644
--- a/Ghidra/Framework/Docking/src/main/java/docking/WindowPosition.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/WindowPosition.java
@@ -33,7 +33,47 @@ public enum WindowPosition {
 
 	/** 
 	 * Signals that windows should be stacked with other windows within  
-	 * the same group.
+	 * the same group, appending them at the end of the stack.
 	 */
-	STACK
+	STACK,
+
+	/**
+	 * Signals that windows should be stacked with other windows within
+	 * the same group, prepending them at the beginning of the stack.
+	 *
+	 * NOTE: This should not be used for setDefaultWindowPosition() and
+	 * setIntraGroupPosition(), it's just an action code.  Use STACK to
+	 * mark the real window position, instead.
+	 */
+	PREPEND,
+
+	/**
+	 * Signals that windows should be pushed between other windows, for
+	 * taking a selected window position in the stack.
+	 *
+	 * NOTE: This should not be used for setDefaultWindowPosition() and
+	 * setIntraGroupPosition(), it's just an action code.  Use STACK to
+	 * mark the real window position, instead.
+	 */
+	PUSH,
+
+	/**
+	 * Signals that windows are shifting position within the same group
+	 * of stacked windows, moving over windows preceding them.
+	 *
+	 * NOTE: This should not be used for setDefaultWindowPosition() and
+	 * setIntraGroupPosition(), it's just an action code.  Use STACK to
+	 * mark the real window position, instead.
+	 */
+	SHIFT_LEFT,
+
+	/**
+	 * Signals that windows are shifting position within the same group
+	 * of stacked windows, moving over windows following them.
+	 *
+	 * NOTE: This should not be used for setDefaultWindowPosition() and
+	 * setIntraGroupPosition(), it's just an action code.  Use STACK to
+	 * mark the real window position, instead.
+	 */
+	SHIFT_RIGHT
 }
diff --git a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tabbedpane/DockingTabRenderer.java b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tabbedpane/DockingTabRenderer.java
index bd7cf212c5..3cbd2d9223 100644
--- a/Ghidra/Framework/Docking/src/main/java/docking/widgets/tabbedpane/DockingTabRenderer.java
+++ b/Ghidra/Framework/Docking/src/main/java/docking/widgets/tabbedpane/DockingTabRenderer.java
@@ -16,10 +16,17 @@
 package docking.widgets.tabbedpane;
 
 import java.awt.*;
+import java.awt.dnd.DnDConstants;
+import java.awt.dnd.DragGestureListener;
+import java.awt.dnd.DragSource;
+import java.awt.dnd.DragSourceMotionListener;
 import java.awt.event.*;
+import java.awt.geom.Area;
 
 import javax.swing.*;
 
+import docking.ComponentPlaceholder;
+import docking.DockableComponent;
 import docking.widgets.EmptyBorderButton;
 import docking.widgets.label.GDLabel;
 import generic.theme.CloseIcon;
@@ -33,20 +40,34 @@ public class DockingTabRenderer extends JPanel {
 	private static final int MAX_TITLE_LENGTH = 25;
 	private Icon CLOSE_ICON = new CloseIcon(true);
 
+	// This is for easy access to the tabbed pane.
+	private final JTabbedPane tabbedPane;
+
 	private JLabel titleLabel;
 	private JLabel iconLabel;
 	private JButton closeButton;
 
+	private DragSource dragSource;
+
 	private HierarchyListener hierarchyListener;
 	private TabContainerForwardingMouseListener forwardingListener;
 	private JPopupMenu popupMenu;
 
+	// Semi-transparent yellow color to highlight selected tabs.
+	private static final Color highlightColor = new Color(
+			Color.YELLOW.getRed(),
+			Color.YELLOW.getGreen(),
+			Color.YELLOW.getBlue(),
+			50);
+
 	public DockingTabRenderer(final JTabbedPane tabbedPane, String fullTitle, String tabText,
 			ActionListener closeListener) {
 
 		final ForwardingMouseListener eventForwardingListener =
 			new ForwardingMouseListener(tabbedPane);
 
+		this.tabbedPane = tabbedPane;
+
 		titleLabel = new GDLabel();
 		iconLabel = new GDLabel();
 		closeButton = new EmptyBorderButton();
@@ -84,6 +105,44 @@ public class DockingTabRenderer extends JPanel {
 		installMouseForwardingListenerWorkaround(tabbedPane);
 	}
 
+	@Override
+	protected void paintComponent(Graphics g) {
+		super.paintComponent(g);
+
+		// Highlight the tab.
+		if (isHighlighted()) {
+			Rectangle r = getVisibleRect();
+			g.setColor(highlightColor);
+			g.fillRect(r.x, r.y, r.width, r.height);
+		}
+	}
+
+	/**
+	 * Returns the current state of the tab highlight.
+	 *
+	 * @return TRUE is highlighted, otherwise FALSE
+	 */
+	public boolean isHighlighted() {
+		return isComponentDragged();
+	}
+
+	/**
+	 * Specifies if the associated component is being dragged around.
+	 *
+	 * @return TRUE is the associated component is being dragged around
+	 */
+	private boolean isComponentDragged() {
+		if (DockableComponent.SOURCE_SECTION_INFO != null) {
+			int index = tabbedPane.indexOfTabComponent(this);
+			Component comp = tabbedPane.getComponentAt(index);
+			if (comp instanceof DockableComponent) {
+				ComponentPlaceholder placeholder = ((DockableComponent) comp).getComponentWindowingPlaceholder();
+				return DockableComponent.SOURCE_SECTION_INFO.contains(placeholder);
+			}
+		}
+		return false;
+	}
+
 	private void installMouseForwardingListenerWorkaround(final JTabbedPane tabbedPane) {
 
 		forwardingListener = new TabContainerForwardingMouseListener(tabbedPane);
@@ -130,6 +189,12 @@ public class DockingTabRenderer extends JPanel {
 		this.popupMenu = popupMenu;
 	}
 
+	public void installDragSource(DragGestureListener dgl) {
+		dragSource = new DragSource();
+		dragSource.createDefaultDragGestureRecognizer(titleLabel, DnDConstants.ACTION_MOVE, dgl);
+		dragSource.addDragSourceMotionListener((DragSourceMotionListener) dgl);
+	}
+
 	public void setIcon(Icon icon) {
 		iconLabel.setIcon(icon);
 	}
@@ -238,7 +303,13 @@ public class DockingTabRenderer extends JPanel {
 				return false;
 			}
 
-			popupMenu.show(e.getComponent(), e.getX(), e.getY());
+			// Verify that the cursor was over the component at the moment of the
+			// event.  Suppress cases in which the right mouse button was clicked
+			// outside of the region of the component.  This could happen while a
+			// tab drag-N-drop operation is in progress, misplacing the popup.
+			if (new Area(getVisibleRect()).contains(e.getX(), e.getY())) {
+				popupMenu.show(e.getComponent(), e.getX(), e.getY());
+			}
 
 			return true;
 		}
-- 
2.45.1

