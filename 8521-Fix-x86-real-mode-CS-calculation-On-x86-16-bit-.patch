From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Luke=20Sern=C3=A9?= <luke.serne@solconmail.nl>
Date: Tue, 23 Sep 2025 20:57:35 +0200
Subject: [PATCH] 8521: Fix x86 real mode CS calculation On x86 16-bit real
 mode, the CS varnode was re-calculated on every jump. However, due to the
 nature of how real mode works, it is impossible to reconstruct the value of
 CS at those points. Luckily, the correct value of CS seems to be set at the
 beginning of the function by auto-analysis in real mode, so if we don't
 change it, it should be correct throughout the function. Also change the
 definition of some of the "CALLF" instructions to ensure the correct value of
 CS is restored after the call.

---
 Ghidra/Processors/x86/data/languages/ia.sinc | 10 +++++-----
 1 file changed, 5 insertions(+), 5 deletions(-)

diff --git a/Ghidra/Processors/x86/data/languages/ia.sinc b/Ghidra/Processors/x86/data/languages/ia.sinc
index 380726d212..1f38b61dc5 100644
--- a/Ghidra/Processors/x86/data/languages/ia.sinc
+++ b/Ghidra/Processors/x86/data/languages/ia.sinc
@@ -1103,7 +1103,7 @@ addr64: [Base64 + Index64*ss + simm32_64] is mod=2 & r_m=4; Index64 & Base64 & s
 addr64: [Base64 + Index64*ss]			is mod=2 & r_m=4; Index64 & Base64 & ss; imm32=0   { local tmp=Base64+Index64*ss; export tmp; }
 @endif
 
-currentCS: CS is protectedMode=0 & CS { tmp:4 = (inst_next >> 4) & 0xf000; CS = tmp:2; export CS; }
+currentCS: CS is protectedMode=0 & CS { export CS; }
 currentCS: CS is protectedMode=1 & CS { tmp:4 = (inst_next >> 16) & 0xffff; CS = tmp:2; export CS; }
  
 segWide: is segover=0		        { export 0:$(SIZE); }
@@ -3027,10 +3027,10 @@ with : lockprefx=0 {
 @endif
 
 # direct far calls generate an opcode undefined exception in x86-64
-:CALLF ptr1616      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0x9a; ptr1616           { push22(CS); build ptr1616; push22(&:2 inst_next); call ptr1616; }
-:CALLF ptr1616      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0x9a; ptr1616           { push42(CS); build ptr1616; push42(&:2 inst_next); call ptr1616; }
-:CALLF ptr1632      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0x9a; ptr1632           { push22(CS); build ptr1632; push24(&:4 inst_next); call ptr1632; }
-:CALLF ptr1632      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0x9a; ptr1632           { pushseg44(CS); build ptr1632; push44(&:4 inst_next); call ptr1632; }
+:CALLF ptr1616      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=0 & byte=0x9a; ptr1616           { tmp:2 = CS; push22(CS); build ptr1616; push22(&:2 inst_next); call ptr1616; CS = tmp; }
+:CALLF ptr1616      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=0 & byte=0x9a; ptr1616           { tmp:2 = CS; push42(CS); build ptr1616; push42(&:2 inst_next); call ptr1616; CS = tmp; }
+:CALLF ptr1632      is $(LONGMODE_OFF) & vexMode=0 & addrsize=0 & opsize=1 & byte=0x9a; ptr1632           { tmp:2 = CS; push22(CS); build ptr1632; push24(&:4 inst_next); call ptr1632; CS = tmp; }
+:CALLF ptr1632      is $(LONGMODE_OFF) & vexMode=0 & addrsize=1 & opsize=1 & byte=0x9a; ptr1632           { tmp:2 = CS; pushseg44(CS); build ptr1632; push44(&:4 inst_next); call ptr1632; CS = tmp; }
 :CALLF m1616        is vexMode=0 & addrsize=0 & opsize=0 & byte=0xff; m1616 & reg_opcode=3 ... { push22(CS); build m1616; push22(&:2 inst_next); call [m1616]; }
 :CALLF m1616        is vexMode=0 & addrsize=1 & opsize=0 & byte=0xff; m1616 & reg_opcode=3 ... { push42(CS); build m1616; push42(&:2 inst_next); call [m1616]; }
 @ifdef IA64
-- 
2.45.1

