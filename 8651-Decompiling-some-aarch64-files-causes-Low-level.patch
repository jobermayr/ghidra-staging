From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Johannes Obermayr <johannesobermayr@gmx.de>
Date: Wed, 19 Nov 2025 17:57:33 +0100
Subject: [PATCH] 8651: Decompiling some aarch64 files causes Low-level Error:
 Forced merge caused intersection

---
 .../src/decompile/cpp/include/ghidra/merge.hh |  2 +-
 .../Decompiler/src/decompile/cpp/merge.cc     | 37 +++++++++++++------
 2 files changed, 26 insertions(+), 13 deletions(-)

diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/include/ghidra/merge.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/include/ghidra/merge.hh
index 54228bcf44..90a3ff104f 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/include/ghidra/merge.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/include/ghidra/merge.hh
@@ -108,7 +108,7 @@ class Merge {
   void mergeOp(PcodeOp *op);
   void mergeIndirect(PcodeOp *indop);
   void mergeLinear(vector<HighVariable *> &highvec);
-  bool merge(HighVariable *high1,HighVariable *high2,bool isspeculative);
+  bool merge(HighVariable *high1,HighVariable *high2,bool isspeculative,bool printWarning);
   bool checkCopyPair(HighVariable *high,PcodeOp *domOp,PcodeOp *subOp);
   void buildDominantCopy(HighVariable *high,vector<PcodeOp *> &copy,int4 pos,int4 size);
   void markRedundantCopies(HighVariable *high,vector<PcodeOp *> &copy,int4 pos,int4 size);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/merge.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/merge.cc
index 295354594d..8d2e9106e9 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/merge.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/merge.cc
@@ -284,7 +284,7 @@ void Merge::mergeLinear(vector<HighVariable *> &highvec)
     high = *initer;
     for(outiter=highstack.begin();outiter!=highstack.end();++outiter) {
       if (mergeTestSpeculative(*outiter,high))
-	if (merge(*outiter,high,true)) break;
+	if (merge(*outiter,high,true,false)) break;
     }
     if (outiter==highstack.end())
       highstack.push_back(high);
@@ -311,8 +311,7 @@ void Merge::mergeRangeMust(VarnodeLocSet::const_iterator startiter,VarnodeLocSet
     vn = *startiter;
     if (vn->getHigh() == high) continue;
     mergeTestMust(vn);
-    if (!merge(high,vn->getHigh(),false))
-      throw LowlevelError("Forced merge caused intersection");
+    merge(high,vn->getHigh(),false,true);
   }
 }
 
@@ -343,7 +342,7 @@ void Merge::mergeOpcode(OpCode opc)
 	vn2 = op->getIn(j);
 	if (!mergeTestBasic(vn2)) continue;
 	if (mergeTestRequired(vn1->getHigh(),vn2->getHigh()))
-	  merge(vn1->getHigh(),vn2->getHigh(),false);	// This is a required merge
+	  merge(vn1->getHigh(),vn2->getHigh(),false,false);	// This is a required merge
       }
     }
   }
@@ -763,7 +762,7 @@ void Merge::mergeOp(PcodeOp *op)
   for(i=0;i<max;++i) {		// Try to merge everything for real now
     if (!mergeTestRequired(op->getOut()->getHigh(),op->getIn(i)->getHigh()))
       throw LowlevelError("Non-cover related merge restriction violated, despite trims");
-    if (!merge(op->getOut()->getHigh(),op->getIn(i)->getHigh(),false)) {
+    if (!merge(op->getOut()->getHigh(),op->getIn(i)->getHigh(),false,true)) {
       ostringstream errstr;
       errstr << "Unable to force merge of op at " << op->getSeqNum();
       throw LowlevelError(errstr.str());
@@ -854,7 +853,7 @@ void Merge::mergeIndirect(PcodeOp *indop)
 
   Varnode *invn0 = indop->getIn(0);
   if (mergeTestRequired(outvn->getHigh(),invn0->getHigh())) {
-    if (merge(invn0->getHigh(),outvn->getHigh(),false))
+    if (merge(invn0->getHigh(),outvn->getHigh(),false,false))
       return;
   }
   // If we cannot merge, the only thing that can go wrong with an input trim, is if the output of
@@ -862,7 +861,7 @@ void Merge::mergeIndirect(PcodeOp *indop)
   if (snipOutputInterference(indop)) {
     // If we found (and snipped) something related to the output, try merging again before snipping the INDIRECT
     if (mergeTestRequired(outvn->getHigh(), invn0->getHigh())) {
-      if (merge(invn0->getHigh(),outvn->getHigh(),false))
+      if (merge(invn0->getHigh(),outvn->getHigh(),false,false))
 	return;
     }
   }
@@ -876,7 +875,7 @@ void Merge::mergeIndirect(PcodeOp *indop)
   data.opSetInput(indop,newop->getOut(),0);
   data.opInsertBefore(newop,indop);
   if (!mergeTestRequired(outvn->getHigh(),indop->getIn(0)->getHigh()) ||
-      (!merge(indop->getIn(0)->getHigh(),outvn->getHigh(),false))) // Try merge again
+      (!merge(indop->getIn(0)->getHigh(),outvn->getHigh(),false,true))) // Try merge again
     //  if (!merge(indop->Input(0)->High(),outvn->High()))
     throw LowlevelError("Unable to merge address forced indirect");
 }
@@ -939,7 +938,7 @@ void Merge::mergeMultiEntry(void)
 	conflictCount += 1;
 	continue;
       }
-      if (!merge(high,newHigh,false)) {		// Attempt the merge
+      if (!merge(high,newHigh,false,true)) {	// Attempt the merge
 	symbol->setMergeProblems();
 	newHigh->setUnmerged();
 	conflictCount += 1;
@@ -1007,7 +1006,7 @@ void Merge::mergeAdjacent(void)
       if (!mergeTestAdjacent(high_out,high_in)) continue;
 
       if (!testCache.intersection(high_in,high_out)) // If no interval intersection
-	merge(high_out,high_in,true);
+	merge(high_out,high_in,true,false);
     }
   }
 }
@@ -1561,12 +1560,26 @@ void Merge::registerProtoPartialRoot(Varnode *vn)
 /// \param high1 is the first HighVariable being merged
 /// \param high2 is the second
 /// \param isspeculative is \b true if the desired merge is speculative
+/// \param printWarning is \b true if decompiler should inform about issues while merging
 /// \return \b true if the merge was successful
-bool Merge::merge(HighVariable *high1,HighVariable *high2,bool isspeculative)
+bool Merge::merge(HighVariable *high1,HighVariable *high2,bool isspeculative,bool printWarning)
 
 {
   if (high1 == high2) return true; // Already merged
-  if (testCache.intersection(high1,high2)) return false;
+  if (testCache.intersection(high1,high2)) {
+    if (printWarning) {
+      data.warningHeader("Skipped merge: testCache.intersection(high1,high2)");
+    }
+    return false;
+  }
+
+  // If their coverage ranges intersect, they are not compatible
+  if (!high1->getCover().intersect(high2->getCover())) {
+    if (printWarning) {
+      data.warningHeader("Skipped merge: !high1->getCover().intersect(high2->getCover())");
+    }
+    return false;
+  }
 
   high1->merge(high2,&testCache,isspeculative);	// Do the actual merge
   high1->updateCover();				// Update cover now so that updateHigh won't purge cached tests
-- 
2.45.1

