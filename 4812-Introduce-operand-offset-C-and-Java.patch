From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Klaus=20K=C3=A4mpf?= <kkaempf@gmail.com>
Date: Sun, 30 Oct 2022 20:01:10 +0100
Subject: [PATCH] 4812: Introduce operand offset (C++ and Java)
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Introduce operand_offset

Signed-off-by: Klaus Kämpf <kkaempf@gmail.com>

Add operand_offset to sleigh Java

Signed-off-by: Klaus Kämpf <kkaempf@gmail.com>
---
 .../src/decompile/cpp/pcodeparse.cc           |   1 +
 .../Decompiler/src/decompile/cpp/pcodeparse.y |   1 +
 .../Decompiler/src/decompile/cpp/semantics.cc |   8 ++
 .../Decompiler/src/decompile/cpp/semantics.hh |   2 +-
 .../Decompiler/src/decompile/cpp/slaformat.cc |   5 +
 .../Decompiler/src/decompile/cpp/slaformat.hh |   5 +
 .../src/decompile/cpp/slgh_compile.cc         |   2 +
 .../src/decompile/cpp/slghpatexpress.cc       |  16 +++
 .../src/decompile/cpp/slghpatexpress.hh       |  14 +++
 .../Decompiler/src/decompile/cpp/slghscan.cc  |   1 +
 .../Decompiler/src/decompile/cpp/slghscan.l   |   1 +
 .../src/decompile/cpp/slghsymbol.cc           |  67 ++++++++++++
 .../src/decompile/cpp/slghsymbol.hh           |  21 +++-
 .../ghidra/sleigh/grammar/SleighCompiler.g    |   6 +
 .../AbstractSleighAssemblerBuilder.java       |   3 +
 .../expression/OffsetInstructionValue.java    |  75 +++++++++++++
 .../sleigh/expression/PatternExpression.java  |   3 +
 .../sleigh/symbol/OffsetSymbol.java           |  72 ++++++++++++
 .../processors/sleigh/symbol/SymbolTable.java |   3 +
 .../processors/sleigh/template/ConstTpl.java  |   4 +
 .../java/ghidra/pcode/utils/SlaFormat.java    |   5 +
 .../ghidra/pcodeCPort/semantics/ConstTpl.java |   7 +-
 .../slgh_compile/SleighCompile.java           |   2 +
 .../pcodeCPort/slgh_compile/Yylval.java       |   1 +
 .../OffsetInstructionValue.java               |  65 +++++++++++
 .../pcodeCPort/slghsymbol/OffsetSymbol.java   | 103 ++++++++++++++++++
 .../pcodeCPort/slghsymbol/symbol_type.java    |   1 +
 .../program/model/lang/PcodeParser.java       |   1 +
 28 files changed, 491 insertions(+), 4 deletions(-)
 create mode 100644 Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/expression/OffsetInstructionValue.java
 create mode 100644 Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/symbol/OffsetSymbol.java
 create mode 100644 Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slghpatexpress/OffsetInstructionValue.java
 create mode 100644 Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slghsymbol/OffsetSymbol.java

diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.cc
index 2d28821dd5..8ae701ef29 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.cc
@@ -3074,6 +3074,7 @@ int4 PcodeSnippet::lex(void)
 	yylval.operandsym = (OperandSymbol *)sym;
 	return OPERANDSYM;
       case SleighSymbol::start_symbol:
+      case SleighSymbol::offset_symbol:
       case SleighSymbol::end_symbol:
       case SleighSymbol::next2_symbol:
       case SleighSymbol::flowdest_symbol:
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.y b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.y
index 66a1acd8ca..e98a8bff54 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.y
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/pcodeparse.y
@@ -744,6 +744,7 @@ int4 PcodeSnippet::lex(void)
 	yylval.operandsym = (OperandSymbol *)sym;
 	return OPERANDSYM;
       case SleighSymbol::start_symbol:
+      case SleighSymbol::offset_symbol:
       case SleighSymbol::end_symbol:
       case SleighSymbol::next2_symbol:
       case SleighSymbol::flowdest_symbol:
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc
index b59368b5d1..3ef9fb612c 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.cc
@@ -122,6 +122,7 @@ uintb ConstTpl::fix(const ParserWalker &walker) const
   // of the temporary storage
   switch(type) {
   case j_start:
+  case j_offset:
     return walker.getAddr().getOffset(); // Fill in starting address placeholder with real address
   case j_next:
     return walker.getNaddr().getOffset(); // Fill in next address placeholder with real address
@@ -320,6 +321,10 @@ void ConstTpl::encode(Encoder &encoder) const
     encoder.openElement(sla::ELEM_CONST_START);
     encoder.closeElement(sla::ELEM_CONST_START);
     break;
+  case j_offset:
+    encoder.openElement(sla::ELEM_OPERAND_OFFSET);
+    encoder.closeElement(sla::ELEM_OPERAND_OFFSET);
+    break;
   case j_next:
     encoder.openElement(sla::ELEM_CONST_NEXT);
     encoder.closeElement(sla::ELEM_CONST_NEXT);
@@ -387,6 +392,9 @@ void ConstTpl::decode(Decoder &decoder)
   else if (el == sla::ELEM_CONST_START) {
     type = j_start;
   }
+  else if (el == sla::ELEM_OPERAND_OFFSET) {
+    type = j_offset;
+  }
   else if (el == sla::ELEM_CONST_NEXT) {
     type = j_next;
   }
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.hh
index 9117a45c75..808329fea6 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/semantics.hh
@@ -35,7 +35,7 @@ class ConstTpl {
 public:
   enum const_type { real=0, handle=1, j_start=2, j_next=3, j_next2=4, j_curspace=5, 
 		    j_curspace_size=6, spaceid=7, j_relative=8,
-		    j_flowref=9, j_flowref_size=10, j_flowdest=11, j_flowdest_size=12 };
+		    j_flowref=9, j_flowref_size=10, j_flowdest=11, j_flowdest_size=12, j_offset=13 };
   enum v_field { v_space=0, v_offset=1, v_size=2, v_offset_plus=3 };
 private:
   const_type type;
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slaformat.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slaformat.cc
index f8b3bcfa73..19d5d0b829 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slaformat.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slaformat.cc
@@ -166,6 +166,11 @@ ElementId ELEM_CONST_FLOWREF = ElementId("const_flowref", 85, FORMAT_SCOPE);
 ElementId ELEM_CONST_FLOWREF_SIZE = ElementId("const_flowref_size", 86, FORMAT_SCOPE);
 ElementId ELEM_CONST_FLOWDEST = ElementId("const_flowdest", 87, FORMAT_SCOPE);
 ElementId ELEM_CONST_FLOWDEST_SIZE = ElementId("const_flowdest_size", 88, FORMAT_SCOPE);
+ElementId ELEM_OFFSET = ElementId("offset", 89, FORMAT_SCOPE);
+ElementId ELEM_OFFSET_EXP = ElementId("offset_exp", 90, FORMAT_SCOPE);
+ElementId ELEM_OFFSET_SYM = ElementId("offset_sym", 91, FORMAT_SCOPE);
+ElementId ELEM_OFFSET_SYM_HEAD = ElementId("offset_sym_head", 92, FORMAT_SCOPE);
+ElementId ELEM_OPERAND_OFFSET = ElementId("operand_offset", 93, FORMAT_SCOPE);
 
 /// The bytes of the header are read from the stream and verified against the required form and current version.
 /// If the form matches, \b true is returned.  No additional bytes are read.
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slaformat.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/slaformat.hh
index a8eb11b63c..3b5a459bd0 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slaformat.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slaformat.hh
@@ -97,6 +97,7 @@ extern ElementId ELEM_NULL;		///< SLA format element "null"
 extern ElementId ELEM_OPERAND_EXP;	///< SLA format element "operand_exp"
 extern ElementId ELEM_OPERAND_SYM;	///< SLA format element "operand_sym"
 extern ElementId ELEM_OPERAND_SYM_HEAD;	///< SLA format element "operand_sym_head"
+extern ElementId ELEM_OPERAND_OFFSET;	///< SLA format element "operand_offset"
 extern ElementId ELEM_OPER;		///< SLA format element "oper"
 extern ElementId ELEM_DECISION;		///< SLA format element "decision"
 extern ElementId ELEM_OPPRINT;		///< SLA format element "opprint"
@@ -154,6 +155,10 @@ extern ElementId ELEM_NEXT2_SYM;	///< SLA format element "next2_sym"
 extern ElementId ELEM_NEXT2_SYM_HEAD;	///< SLA format element "next2_sym_head"
 extern ElementId ELEM_START_SYM;	///< SLA format element "start_sym"
 extern ElementId ELEM_START_SYM_HEAD;	///< SLA format element "start_sym_head"
+extern ElementId ELEM_OFFSET;		///< SLA format element "offset"
+extern ElementId ELEM_OFFSET_SYM;	///< SLA format element "offset_sym"
+extern ElementId ELEM_OFFSET_SYM_HEAD;	///< SLA format element "offset_sym_head"
+extern ElementId ELEM_OFFSET_EXP;	///< SLA format element "offset_exp"
 extern ElementId ELEM_SUBTABLE_SYM;	///< SLA format element "subtable_sym"
 extern ElementId ELEM_SUBTABLE_SYM_HEAD;	///< SLA format element "subtable_sym_head"
 extern ElementId ELEM_VALUEMAP_SYM;	///< SLA format element "valuemap_sym"
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
index 71cfddefd6..0eb12f882d 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slgh_compile.cc
@@ -1818,6 +1818,8 @@ void SleighCompile::predefinedSymbols(void)
   symtab.addSymbol(spacesym);
   StartSymbol *startsym = new StartSymbol("inst_start",getConstantSpace());
   symtab.addSymbol(startsym);
+  OffsetSymbol *offsetsym = new OffsetSymbol("operand_offset",getConstantSpace());
+  symtab.addSymbol(offsetsym);
   EndSymbol *endsym = new EndSymbol("inst_next",getConstantSpace());
   symtab.addSymbol(endsym);
   Next2Symbol *next2sym = new Next2Symbol("inst_next2",getConstantSpace());
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghpatexpress.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slghpatexpress.cc
index b571181a65..7d8e1a290c 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghpatexpress.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghpatexpress.cc
@@ -478,6 +478,8 @@ PatternExpression *PatternExpression::decodeExpression(Decoder &decoder,Translat
     res = new OperandValue();
   else if (el == sla::ELEM_START_EXP)
     res = new StartInstructionValue();
+  else if (el == sla::ELEM_OFFSET_EXP)
+    res = new OperandOffsetValue();
   else if (el == sla::ELEM_END_EXP)
     res = new EndInstructionValue();
   else if (el == sla::ELEM_PLUS_EXP)
@@ -735,6 +737,20 @@ void StartInstructionValue::decode(Decoder &decoder,Translate *trans)
   decoder.closeElement(el);
 }
 
+void OperandOffsetValue::encode(Encoder &encoder) const
+
+{
+  encoder.openElement(sla::ELEM_OFFSET_EXP);
+  encoder.closeElement(sla::ELEM_OFFSET_EXP);
+}
+
+void OperandOffsetValue::decode(Decoder &decoder,Translate *trans)
+
+{
+  uint4 el = decoder.openElement(sla::ELEM_OFFSET_EXP);
+  decoder.closeElement(el);
+}
+
 void EndInstructionValue::encode(Encoder &encoder) const
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghpatexpress.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/slghpatexpress.hh
index 3f596c41eb..701bf3f973 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghpatexpress.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghpatexpress.hh
@@ -156,6 +156,20 @@ public:
   virtual void encode(Encoder &encoder) const;
   virtual void decode(Decoder &decoder,Translate *trans);
 };
+
+class OperandOffsetValue : public PatternValue {
+public:
+  OperandOffsetValue(void) {}
+  virtual intb getValue(ParserWalker &walker) const {
+    return (intb)walker.getOffset(-1);
+  }
+  virtual TokenPattern genMinPattern(const vector<TokenPattern> &ops) const { return TokenPattern(); }
+  virtual TokenPattern genPattern(intb val) const { return TokenPattern(); }
+  virtual intb minValue(void) const { return (intb)0; }
+  virtual intb maxValue(void) const { return (intb)0; }
+  virtual void encode(Encoder &encoder) const;
+  virtual void decode(Decoder &decoder,Translate *trans);
+};
                                                                                         
 class EndInstructionValue : public PatternValue {
 public:
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.cc
index a9ecc612df..b2b343bca7 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.cc
@@ -1572,6 +1572,7 @@ int4 find_symbol(void) {
     sleighlval.operandsym = (OperandSymbol *)sym;
     return OPERANDSYM;
   case SleighSymbol::start_symbol:
+  case SleighSymbol::offset_symbol:
   case SleighSymbol::end_symbol:
   case SleighSymbol::next2_symbol:
   case SleighSymbol::flowdest_symbol:
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.l b/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.l
index f5097abe1d..e394f6971f 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.l
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghscan.l
@@ -429,6 +429,7 @@ int4 find_symbol(void) {
     sleighlval.operandsym = (OperandSymbol *)sym;
     return OPERANDSYM;
   case SleighSymbol::start_symbol:
+  case SleighSymbol::offset_symbol:
   case SleighSymbol::end_symbol:
   case SleighSymbol::next2_symbol:
   case SleighSymbol::flowdest_symbol:
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.cc
index 0608f6a638..6cf4842d12 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.cc
@@ -222,6 +222,8 @@ void SymbolTable::decodeSymbolHeader(Decoder &decoder)
     sym = new OperandSymbol();
   else if (el == sla::ELEM_START_SYM_HEAD)
     sym = new StartSymbol();
+  else if (el == sla::ELEM_OFFSET_SYM_HEAD)
+    sym = new OffsetSymbol();
   else if (el == sla::ELEM_END_SYM_HEAD)
     sym = new EndSymbol();
   else if (el == sla::ELEM_NEXT2_SYM_HEAD)
@@ -1135,6 +1137,71 @@ void StartSymbol::decode(Decoder &decoder,SleighBase *trans)
   decoder.closeElement(sla::ELEM_START_SYM.getId());
 }
 
+OffsetSymbol::OffsetSymbol(const string &nm,AddrSpace *cspc) : SpecificSymbol(nm)
+
+{
+  const_space = cspc;
+  patexp = new OperandOffsetValue();
+  patexp->layClaim();
+}
+
+OffsetSymbol::~OffsetSymbol(void)
+
+{
+  if (patexp != (PatternExpression *)0)
+    PatternExpression::release(patexp);
+}
+
+VarnodeTpl *OffsetSymbol::getVarnode(void) const
+
+{ // Returns current operand offset as a constant
+  ConstTpl spc(const_space);
+  ConstTpl off(ConstTpl::j_offset);
+  ConstTpl sz_zero;
+  return new VarnodeTpl(spc,off,sz_zero);
+}
+
+void OffsetSymbol::getFixedHandle(FixedHandle &hand,ParserWalker &walker) const
+
+{
+  hand.space = walker.getCurSpace();
+  hand.offset_space = (AddrSpace *)0;
+  hand.offset_offset = walker.getAddr().getOffset(); // Get starting address of instruction
+  hand.size = hand.space->getAddrSize();
+}
+
+void OffsetSymbol::print(ostream &s,ParserWalker &walker) const
+
+{
+  intb val = (intb) walker.getAddr().getOffset();
+    s << "0x" << std::hex << val << std::dec;
+}
+
+void OffsetSymbol::encode(Encoder &encoder) const
+
+{
+  encoder.openElement(sla::ELEM_OFFSET);
+  encoder.writeUnsignedInteger(sla::ATTRIB_ID, getId());
+  encoder.closeElement(sla::ELEM_OFFSET);
+}
+
+void OffsetSymbol::encodeHeader(Encoder &encoder) const
+
+{
+  encoder.openElement(sla::ELEM_OFFSET_SYM_HEAD);
+  SleighSymbol::encodeHeader(encoder);
+  encoder.closeElement(sla::ELEM_OFFSET_SYM_HEAD);
+}
+
+void OffsetSymbol::decode(Decoder &decoder,SleighBase *trans)
+
+{
+  const_space = trans->getConstantSpace();
+  patexp = new OperandOffsetValue();
+  patexp->layClaim();
+  decoder.closeElement(sla::ELEM_OFFSET_SYM.getId());
+}
+
 EndSymbol::EndSymbol(const string &nm,AddrSpace *cspc) : SpecificSymbol(nm)
 
 {
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.hh
index ad34dada60..97d4dddfac 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/slghsymbol.hh
@@ -26,8 +26,8 @@ class SleighSymbol {
   friend class SymbolTable;
 public:
   enum symbol_type { space_symbol, token_symbol, userop_symbol, value_symbol, valuemap_symbol,
-		     name_symbol, varnode_symbol, varnodelist_symbol, operand_symbol,
-		     start_symbol, end_symbol, next2_symbol, subtable_symbol, macro_symbol, section_symbol,
+		     name_symbol, varnode_symbol, varnodelist_symbol, operand_symbol, start_symbol,
+		     offset_symbol, end_symbol, next2_symbol, subtable_symbol, macro_symbol, section_symbol,
                      bitrange_symbol, context_symbol, epsilon_symbol, label_symbol, flowdest_symbol, flowref_symbol,
 		     dummy_symbol };
 private:
@@ -373,6 +373,23 @@ public:
   virtual void decode(Decoder &decoder,SleighBase *trans);
 };
 
+class OffsetSymbol : public SpecificSymbol {
+  AddrSpace *const_space;
+  PatternExpression *patexp;
+public:
+  OffsetSymbol(void) { patexp = (PatternExpression *)0; } // For use with restoreXml
+  OffsetSymbol(const string &nm,AddrSpace *cspc);
+  virtual ~OffsetSymbol(void);
+  virtual VarnodeTpl *getVarnode(void) const;
+  virtual PatternExpression *getPatternExpression(void) const { return patexp; }
+  virtual void getFixedHandle(FixedHandle &hand,ParserWalker &walker) const;
+  virtual void print(ostream &s,ParserWalker &walker) const;
+  virtual symbol_type getType(void) const { return offset_symbol; }
+  virtual void encode(Encoder &encoder) const;
+  virtual void encodeHeader(Encoder &encoder) const;
+  virtual void decode(Decoder &decoder,SleighBase *trans);
+};
+
 class EndSymbol : public SpecificSymbol {
   AddrSpace *const_space;
   PatternExpression *patexp;
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/antlr/ghidra/sleigh/grammar/SleighCompiler.g b/Ghidra/Framework/SoftwareModeling/src/main/antlr/ghidra/sleigh/grammar/SleighCompiler.g
index 2ea32de90d..986c55f994 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/antlr/ghidra/sleigh/grammar/SleighCompiler.g
+++ b/Ghidra/Framework/SoftwareModeling/src/main/antlr/ghidra/sleigh/grammar/SleighCompiler.g
@@ -344,6 +344,7 @@ specific_symbol[String purpose] returns [SpecificSymbol symbol]
 			if (sym == null) {
 				unknownSymbolError($s.getText(), find($s), "start, end, next2, operand, epsilon, or varnode", purpose);
 			} else if(sym.getType() != symbol_type.start_symbol
+					&& sym.getType() != symbol_type.offset_symbol
 					&& sym.getType() != symbol_type.end_symbol
 					&& sym.getType() != symbol_type.next2_symbol
 					&& sym.getType() != symbol_type.flowdest_symbol
@@ -854,6 +855,7 @@ pattern_symbol[String purpose] returns [PatternExpression expr]
                 }
                 $expr = os.getPatternExpression();
 			} else if(sym.getType() == symbol_type.start_symbol
+					|| sym.getType() == symbol_type.offset_symbol
 					|| sym.getType() == symbol_type.end_symbol
 					|| sym.getType() == symbol_type.next2_symbol
 					|| sym.getType() == symbol_type.flowdest_symbol
@@ -889,6 +891,7 @@ pattern_symbol2[String purpose] returns [PatternExpression expr]
 			if (sym == null) {
 				unknownSymbolError($s.getText(), find($s), "start, end, next2, operand, epsilon, or varnode", purpose);
 			} else if(sym.getType() == symbol_type.start_symbol
+					|| sym.getType() == symbol_type.offset_symbol
 					|| sym.getType() == symbol_type.end_symbol
 					|| sym.getType() == symbol_type.next2_symbol
 					|| sym.getType() == symbol_type.flowdest_symbol
@@ -962,6 +965,7 @@ cstatement[VectorSTL<ContextChange> r]
 							|| sym.getType() == symbol_type.name_symbol
 							|| sym.getType() == symbol_type.varnodelist_symbol
 							|| sym.getType() == symbol_type.start_symbol
+							|| sym.getType() == symbol_type.offset_symbol
 							|| sym.getType() == symbol_type.end_symbol
 							|| sym.getType() == symbol_type.next2_symbol
 							|| sym.getType() == symbol_type.flowdest_symbol
@@ -1197,6 +1201,7 @@ assignment returns [VectorSTL<OpTpl> value]
                                               bitSym.getBitOffset(),
                                               bitSym.numBits(),e);
 			} else if(sym.getType() != symbol_type.start_symbol
+					&& sym.getType() != symbol_type.offset_symbol
 					&& sym.getType() != symbol_type.end_symbol
 					&& sym.getType() != symbol_type.next2_symbol
 					&& sym.getType() != symbol_type.flowdest_symbol
@@ -1541,6 +1546,7 @@ expr_apply returns [Object value]
 						pcode.reportError(find($t), "macro invocation not allowed as expression");
 					}
 				} else if(sym.getType() == symbol_type.start_symbol
+					|| sym.getType() == symbol_type.offset_symbol
 					|| sym.getType() == symbol_type.end_symbol
 					|| sym.getType() == symbol_type.next2_symbol
 					|| sym.getType() == symbol_type.flowdest_symbol
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/AbstractSleighAssemblerBuilder.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/AbstractSleighAssemblerBuilder.java
index 9f25ddbfeb..5e66e76c91 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/AbstractSleighAssemblerBuilder.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/assembler/sleigh/AbstractSleighAssemblerBuilder.java
@@ -328,6 +328,9 @@ public abstract class AbstractSleighAssemblerBuilder< //
 				else if (sym instanceof StartSymbol) {
 					// Ignore. We handle inst_start in semantic processing
 				}
+				else if (sym instanceof OffsetSymbol) {
+					// Ignore. We handle inst_start in semantic processing
+				}
 				else if (sym instanceof EndSymbol) {
 					// Ignore. We handle inst_next in semantic processing
 				}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/expression/OffsetInstructionValue.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/expression/OffsetInstructionValue.java
new file mode 100644
index 0000000000..cdf75ab662
--- /dev/null
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/expression/OffsetInstructionValue.java
@@ -0,0 +1,75 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/*
+ * Created on Feb 8, 2005
+ *
+ */
+package ghidra.app.plugin.processors.sleigh.expression;
+
+import static ghidra.pcode.utils.SlaFormat.*;
+
+import ghidra.app.plugin.processors.sleigh.ParserWalker;
+import ghidra.app.plugin.processors.sleigh.SleighLanguage;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.mem.MemoryAccessException;
+import ghidra.program.model.pcode.Decoder;
+import ghidra.program.model.pcode.DecoderException;
+
+/**
+ *
+ *
+ * The offset value of the current instructions address
+ */
+public class OffsetInstructionValue extends PatternValue {
+	private static final int HASH = "[operand_offset]".hashCode();
+
+	@Override
+	public int hashCode() {
+		return HASH;
+	}
+
+	@Override
+	public boolean equals(Object obj) {
+		return obj instanceof OffsetInstructionValue;
+	}
+
+	@Override
+	public long minValue() {
+		return 0;
+	}
+
+	@Override
+	public long maxValue() {
+		return 0;
+	}
+
+	@Override
+	public long getValue(ParserWalker walker) throws MemoryAccessException {
+		return walker.getOffset(-1);
+	}
+
+	@Override
+	public void decode(Decoder decoder, SleighLanguage lang) throws DecoderException {
+		int el = decoder.openElement(ELEM_OFFSET_EXP);
+		decoder.closeElement(el);
+		// Nothing to do
+	}
+
+	@Override
+	public String toString() {
+		return "[operand_offset]";
+	}
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/expression/PatternExpression.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/expression/PatternExpression.java
index 3818f96ee1..9ed790d3f0 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/expression/PatternExpression.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/expression/PatternExpression.java
@@ -54,6 +54,9 @@ public abstract class PatternExpression {
 		else if (el == ELEM_START_EXP.id()) {
 			res = new StartInstructionValue();
 		}
+		else if (el == ELEM_OFFSET_EXP.id()) {
+			res = new OffsetInstructionValue();
+		}
 		else if (el == ELEM_END_EXP.id()) {
 			res = new EndInstructionValue();
 		}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/symbol/OffsetSymbol.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/symbol/OffsetSymbol.java
new file mode 100644
index 0000000000..44fa9bff8d
--- /dev/null
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/symbol/OffsetSymbol.java
@@ -0,0 +1,72 @@
+/* ###
+ * IP: GHIDRA
+ * REVIEWED: YES
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/*
+ * Created on Feb 8, 2005
+ *
+ */
+package ghidra.app.plugin.processors.sleigh.symbol;
+
+import static ghidra.pcode.utils.SlaFormat.*;
+
+import java.util.ArrayList;
+
+import ghidra.app.plugin.processors.sleigh.*;
+import ghidra.app.plugin.processors.sleigh.expression.OffsetInstructionValue;
+import ghidra.app.plugin.processors.sleigh.expression.PatternExpression;
+import ghidra.program.model.mem.MemoryAccessException;
+import ghidra.program.model.pcode.Decoder;
+import ghidra.program.model.pcode.DecoderException;
+
+/**
+ * TripleSymbol with semantic value equal to offset of instruction's
+ * current address
+ */
+public class OffsetSymbol extends SpecificSymbol {
+
+	private PatternExpression patexp;
+
+	@Override
+	public PatternExpression getPatternExpression() {
+		return patexp;
+	}
+
+	@Override
+	public void getFixedHandle(FixedHandle hand, ParserWalker walker) {
+		hand.space = walker.getCurSpace();
+		hand.offset_space = null;
+		hand.offset_offset = walker.getAddr().getOffset();
+		hand.size = hand.space.getPointerSize();
+	}
+
+	@Override
+	public String print(ParserWalker walker) throws MemoryAccessException {
+		long val = walker.getAddr().getOffset();
+		return "0x" + Long.toHexString(val);
+	}
+
+	@Override
+	public void printList(ParserWalker walker, ArrayList<Object> list) {
+		list.add(walker.getParentHandle());
+	}
+
+	@Override
+	public void decode(Decoder decoder, SleighLanguage sleigh) throws DecoderException {
+		patexp = new OffsetInstructionValue();
+		decoder.closeElement(ELEM_END_SYM.id());
+	}
+
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/symbol/SymbolTable.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/symbol/SymbolTable.java
index 1b3f1ae1be..d77f1b5021 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/symbol/SymbolTable.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/symbol/SymbolTable.java
@@ -174,6 +174,9 @@ public class SymbolTable {
 		else if (el == ELEM_START_SYM_HEAD.id()) {
 			sym = new StartSymbol();
 		}
+		else if (el == ELEM_OFFSET_SYM_HEAD.id()) {
+			sym = new OffsetSymbol();
+		}
 		else if (el == ELEM_END_SYM_HEAD.id()) {
 			sym = new EndSymbol();
 		}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/template/ConstTpl.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/template/ConstTpl.java
index 75cc37f1e2..abe8c9ac81 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/template/ConstTpl.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/app/plugin/processors/sleigh/template/ConstTpl.java
@@ -46,6 +46,7 @@ public class ConstTpl {
 	public static final int J_FLOWREF_SIZE = 10;
 	public static final int J_FLOWDEST = 11;
 	public static final int J_FLOWDEST_SIZE = 12;
+	public static final int J_OFFSET = 13;
 
 	public static final int V_SPACE = 0;
 	public static final int V_OFFSET = 1;
@@ -302,6 +303,9 @@ public class ConstTpl {
 		else if (el == ELEM_CONST_START.id()) {
 			type = J_START;
 		}
+		else if (el == ELEM_OFFSET.id()) {
+			type = J_OFFSET;
+		}
 		else if (el == ELEM_CONST_NEXT.id()) {
 			type = J_NEXT;
 		}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcode/utils/SlaFormat.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcode/utils/SlaFormat.java
index 742341daa6..2201f32ac1 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcode/utils/SlaFormat.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcode/utils/SlaFormat.java
@@ -191,6 +191,11 @@ public class SlaFormat {
 	public static final ElementId ELEM_CONST_FLOWDEST = new ElementId("const_flowdest", 87);
 	public static final ElementId ELEM_CONST_FLOWDEST_SIZE =
 		new ElementId("const_flowdest_size", 88);
+	public static final ElementId ELEM_OFFSET = new ElementId("offset", 89);
+	public static final ElementId ELEM_OFFSET_EXP = new ElementId("offset_exp", 90);
+	public static final ElementId ELEM_OFFSET_SYM = new ElementId("offset_sym", 91);
+	public static final ElementId ELEM_OFFSET_SYM_HEAD = new ElementId("offset_sym_head", 92);
+	public static final ElementId ELEM_OPERAND_OFFSET = new ElementId("operand_offset", 93);
 
 	/**
 	 * Try to read the header bytes of the .sla format from the given stream. If the header bytes
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/semantics/ConstTpl.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/semantics/ConstTpl.java
index 4c84b4d94e..c991c86c4a 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/semantics/ConstTpl.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/semantics/ConstTpl.java
@@ -45,7 +45,8 @@ public class ConstTpl {
 		j_flowref,
 		j_flowref_size,
 		j_flowdest,
-		j_flowdest_size
+		j_flowdest_size,
+		j_offset
 	}
 
 	public enum v_field {
@@ -263,6 +264,10 @@ public class ConstTpl {
 				encoder.openElement(ELEM_CONST_START);
 				encoder.closeElement(ELEM_CONST_START);
 				break;
+			case j_offset:
+				encoder.openElement(ELEM_OFFSET);
+				encoder.closeElement(ELEM_OFFSET);
+				break;
 			case j_next:
 				encoder.openElement(ELEM_CONST_NEXT);
 				encoder.closeElement(ELEM_CONST_NEXT);
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java
index c016ddbe20..04021829d2 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/SleighCompile.java
@@ -290,6 +290,8 @@ public class SleighCompile extends SleighBase {
 		symtab.addSymbol(spacesym);
 		StartSymbol startsym = new StartSymbol(location, "inst_start", getConstantSpace());
 		symtab.addSymbol(startsym);
+		OffsetSymbol offsetsym = new OffsetSymbol(location, "operand_offset", getConstantSpace());
+		symtab.addSymbol(offsetsym);
 		EndSymbol endsym = new EndSymbol(location, "inst_next", getConstantSpace());
 		symtab.addSymbol(endsym);
 		Next2Symbol next2sym = new Next2Symbol(location, "inst_next2", getConstantSpace());
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/Yylval.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/Yylval.java
index f165ca6b8b..dc57400015 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/Yylval.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slgh_compile/Yylval.java
@@ -30,6 +30,7 @@ class Yylval {
     VarnodeListSymbol varlistsym;
     OperandSymbol operandsym;
     StartSymbol startsym;
+    OffsetSymbol offsetsym;
     EndSymbol endsym;
 	Next2Symbol next2sym;
     SubtableSymbol subtablesym;
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slghpatexpress/OffsetInstructionValue.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slghpatexpress/OffsetInstructionValue.java
new file mode 100644
index 0000000000..1167a3dde6
--- /dev/null
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slghpatexpress/OffsetInstructionValue.java
@@ -0,0 +1,65 @@
+/* ###
+ * IP: GHIDRA
+ * REVIEWED: YES
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.pcodeCPort.slghpatexpress;
+
+import static ghidra.pcode.utils.SlaFormat.*;
+
+import generic.stl.VectorSTL;
+import ghidra.app.plugin.processors.sleigh.ParserWalker;
+import ghidra.program.model.pcode.Encoder;
+import ghidra.sleigh.grammar.Location;
+
+import java.io.IOException;
+
+
+public class OffsetInstructionValue extends PatternValue {
+
+	public OffsetInstructionValue(Location location) {
+		super(location);
+	}
+
+	public long getValue(ParserWalker pos) {
+		return pos.getOffset(-1);
+	}
+
+	@Override
+	public TokenPattern genMinPattern(VectorSTL<TokenPattern> ops) {
+		return new TokenPattern(location);
+	}
+
+	@Override
+	public TokenPattern genPattern(long val) {
+		return new TokenPattern(location);
+	}
+
+	@Override
+	public long minValue() {
+		return 0;
+	}
+
+	@Override
+	public long maxValue() {
+		return 0;
+	}
+
+	@Override
+	public void encode(Encoder encoder) throws IOException {
+		encoder.openElement(ELEM_INTB);
+		encoder.closeElement(ELEM_INTB);
+	}
+
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slghsymbol/OffsetSymbol.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slghsymbol/OffsetSymbol.java
new file mode 100644
index 0000000000..967e6b9605
--- /dev/null
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slghsymbol/OffsetSymbol.java
@@ -0,0 +1,103 @@
+/* ###
+ * IP: GHIDRA
+ * REVIEWED: YES
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.pcodeCPort.slghsymbol;
+
+import static ghidra.pcode.utils.SlaFormat.*;
+
+import ghidra.app.plugin.processors.sleigh.ParserWalker;
+import ghidra.app.plugin.processors.sleigh.FixedHandle;
+import ghidra.pcodeCPort.semantics.ConstTpl;
+import ghidra.pcodeCPort.semantics.VarnodeTpl;
+import ghidra.pcodeCPort.slghpatexpress.PatternExpression;
+import ghidra.pcodeCPort.slghpatexpress.OffsetInstructionValue;
+import ghidra.pcodeCPort.space.AddrSpace;
+import ghidra.program.model.pcode.Encoder;
+import ghidra.sleigh.grammar.Location;
+
+import java.io.IOException;
+import java.io.PrintStream;
+
+public class OffsetSymbol extends SpecificSymbol {
+	private AddrSpace const_space;
+	private PatternExpression patexp;
+
+	OffsetSymbol(Location location) {
+		super(location);
+		patexp = null;
+	}
+
+	@Override
+	public PatternExpression getPatternExpression() {
+		return patexp;
+	}
+
+	@Override
+	public symbol_type getType() {
+		return symbol_type.offset_symbol;
+	}
+
+	public OffsetSymbol(Location location, String nm, AddrSpace cspc) {
+		super(location, nm);
+		const_space = cspc;
+		patexp = new OffsetInstructionValue(location);
+		patexp.layClaim();
+	}
+
+	@Override
+	public void dispose() {
+		if (patexp != null) {
+			PatternExpression.release(patexp);
+		}
+	}
+
+	// Returns current instruction offset as a constant
+	@Override
+	public VarnodeTpl getVarnode() {
+		ConstTpl spc = new ConstTpl(const_space);
+		ConstTpl off = new ConstTpl(ConstTpl.const_type.j_offset);
+		ConstTpl sz_zero = new ConstTpl();
+		return new VarnodeTpl(location, spc, off, sz_zero);
+	}
+
+	public void getFixedHandle(FixedHandle hand, ParserWalker pos) {
+		hand.space = pos.getCurSpace();
+		hand.offset_space = null;
+		hand.offset_offset = pos.getAddr().getOffset(); // Get starting address of instruction
+		hand.size = hand.space.getPointerSize();
+	}
+
+	public void print(PrintStream s, ParserWalker pos) {
+		long val = pos.getAddr().getOffset();
+		s.append("0x");
+		s.print(Long.toHexString(val));
+	}
+
+	@Override
+	public void encode(Encoder encoder) throws IOException {
+		encoder.openElement(ELEM_START_SYM);
+		encoder.writeUnsignedInteger(ATTRIB_ID, id);
+		encoder.closeElement(ELEM_START_SYM);
+	}
+
+	@Override
+	public void encodeHeader(Encoder encoder) throws IOException {
+		encoder.openElement(ELEM_START_SYM_HEAD);
+		encodeSleighSymbolHeader(encoder);
+		encoder.closeElement(ELEM_START_SYM_HEAD);
+	}
+
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slghsymbol/symbol_type.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slghsymbol/symbol_type.java
index b29cc3f238..e026e32a23 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slghsymbol/symbol_type.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/pcodeCPort/slghsymbol/symbol_type.java
@@ -26,6 +26,7 @@ public enum symbol_type {
 	varnodelist_symbol,
 	operand_symbol,
 	start_symbol,  // inst_start, inst_ref, inst_def
+	offset_symbol,
 	end_symbol,    // inst_next
 	next2_symbol,    // inst_next2
 	subtable_symbol,
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/PcodeParser.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/PcodeParser.java
index 8166b87ef8..eee777c613 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/PcodeParser.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/PcodeParser.java
@@ -84,6 +84,7 @@ public class PcodeParser extends PcodeCompile {
 
 		Location internalLoc = Location.INTERNALLY_DEFINED;
 		symbolMap.put("inst_start", new StartSymbol(internalLoc, "inst_start", getConstantSpace()));
+		symbolMap.put("operand_offset", new OffsetSymbol(internalLoc, "operand_offset", getConstantSpace()));
 		symbolMap.put("inst_next", new EndSymbol(internalLoc, "inst_next", getConstantSpace()));
 		symbolMap.put("inst_next2", new Next2Symbol(internalLoc, "inst_next2", getConstantSpace()));
 		symbolMap.put("inst_ref", new FlowRefSymbol(internalLoc, "inst_ref", getConstantSpace()));
-- 
2.44.0

