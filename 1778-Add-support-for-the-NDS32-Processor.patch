From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Timoth=C3=A9e=20COCAULT?= <timothee.cocault@gmail.com>
Date: Thu, 16 Apr 2020 18:58:10 +0200
Subject: [PATCH] 1778: Add support for the NDS32 Processor

Add pbsad* instructions

Add clip* instructions

Ignore llw/scw atomicity

Implement tlbop

Fix dpref*

Fix clip signed comparison

Fix typo in XOR instruction

Implement basic ELF relocation

Add DWARF register mapping

Add gp recovery from ELF symbol

Add pcodeTest for little-endian variant

Fix divr and divsr instructions

Add baseline v3
---
 Ghidra/Processors/NDS32/Module.manifest       |    0
 Ghidra/Processors/NDS32/build.gradle          |   15 +
 .../Processors/NDS32/certification.manifest   |   17 +
 .../Processors/NDS32/data/buildLanguage.xml   |   50 +
 .../Processors/NDS32/data/languages/lsmw.sinc |  576 +++++++++
 .../NDS32/data/languages/nds32.cspec          |  104 ++
 .../NDS32/data/languages/nds32.dwarf          |   14 +
 .../NDS32/data/languages/nds32.ldefs          |   30 +
 .../NDS32/data/languages/nds32.opinion        |    5 +
 .../NDS32/data/languages/nds32.pspec          |    5 +
 .../NDS32/data/languages/nds32.sinc           | 1079 +++++++++++++++++
 .../NDS32/data/languages/nds32be.slaspec      |    7 +
 .../NDS32/data/languages/nds32le.slaspec      |    7 +
 .../NDS32/data/patterns/nds32_patterns.xml    |   13 +
 .../data/patterns/patternconstraints.xml      |    5 +
 Ghidra/Processors/NDS32/data/sleighArgs.txt   |    6 +
 .../plugin/core/analysis/NDS32Analyzer.java   |  187 +++
 .../NDS32_ElfRelocationConstants.java         |   74 ++
 .../NDS32_ElfRelocationHandler.java           |  116 ++
 .../processors/NDS32_LE_O0_EmulatorTest.java  |   41 +
 .../processors/NDS32_LE_O3_EmulatorTest.java  |   41 +
 21 files changed, 2392 insertions(+)
 create mode 100644 Ghidra/Processors/NDS32/Module.manifest
 create mode 100644 Ghidra/Processors/NDS32/build.gradle
 create mode 100644 Ghidra/Processors/NDS32/certification.manifest
 create mode 100644 Ghidra/Processors/NDS32/data/buildLanguage.xml
 create mode 100644 Ghidra/Processors/NDS32/data/languages/lsmw.sinc
 create mode 100644 Ghidra/Processors/NDS32/data/languages/nds32.cspec
 create mode 100644 Ghidra/Processors/NDS32/data/languages/nds32.dwarf
 create mode 100644 Ghidra/Processors/NDS32/data/languages/nds32.ldefs
 create mode 100644 Ghidra/Processors/NDS32/data/languages/nds32.opinion
 create mode 100644 Ghidra/Processors/NDS32/data/languages/nds32.pspec
 create mode 100644 Ghidra/Processors/NDS32/data/languages/nds32.sinc
 create mode 100644 Ghidra/Processors/NDS32/data/languages/nds32be.slaspec
 create mode 100644 Ghidra/Processors/NDS32/data/languages/nds32le.slaspec
 create mode 100644 Ghidra/Processors/NDS32/data/patterns/nds32_patterns.xml
 create mode 100644 Ghidra/Processors/NDS32/data/patterns/patternconstraints.xml
 create mode 100644 Ghidra/Processors/NDS32/data/sleighArgs.txt
 create mode 100644 Ghidra/Processors/NDS32/src/main/java/ghidra/app/plugin/core/analysis/NDS32Analyzer.java
 create mode 100644 Ghidra/Processors/NDS32/src/main/java/ghidra/app/util/bin/format/elf/relocation/NDS32_ElfRelocationConstants.java
 create mode 100644 Ghidra/Processors/NDS32/src/main/java/ghidra/app/util/bin/format/elf/relocation/NDS32_ElfRelocationHandler.java
 create mode 100644 Ghidra/Processors/NDS32/src/test.processors/java/ghidra/test/processors/NDS32_LE_O0_EmulatorTest.java
 create mode 100644 Ghidra/Processors/NDS32/src/test.processors/java/ghidra/test/processors/NDS32_LE_O3_EmulatorTest.java

diff --git a/Ghidra/Processors/NDS32/Module.manifest b/Ghidra/Processors/NDS32/Module.manifest
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/Ghidra/Processors/NDS32/build.gradle b/Ghidra/Processors/NDS32/build.gradle
new file mode 100644
index 0000000000..4df69b4630
--- /dev/null
+++ b/Ghidra/Processors/NDS32/build.gradle
@@ -0,0 +1,15 @@
+apply from: "$rootProject.projectDir/gradle/distributableGhidraModule.gradle"
+apply from: "$rootProject.projectDir/gradle/javaProject.gradle"
+apply from: "$rootProject.projectDir/gradle/jacocoProject.gradle"
+apply from: "$rootProject.projectDir/gradle/javaTestProject.gradle"
+apply from: "$rootProject.projectDir/gradle/processorProject.gradle"
+apply plugin: 'eclipse'
+eclipse.project.name = 'Processors NDS32'
+
+
+dependencies {
+	api project(':Base')
+	//compile project(':Base')
+	// Temporary dependency so that pcodeTests can use the Decompiler switch recovery
+	//compile project(':Decompiler')
+}
diff --git a/Ghidra/Processors/NDS32/certification.manifest b/Ghidra/Processors/NDS32/certification.manifest
new file mode 100644
index 0000000000..ceadc1d06d
--- /dev/null
+++ b/Ghidra/Processors/NDS32/certification.manifest
@@ -0,0 +1,17 @@
+##VERSION: 2.0
+Module.manifest||GHIDRA||||END|
+build.gradle||GHIDRA||||END|
+data/buildLanguage.xml||GHIDRA||||END|
+data/languages/lsmw.sinc||GHIDRA||||END|
+data/languages/nds32.cspec||GHIDRA||||END|
+data/languages/nds32.dwarf||GHIDRA||||END|
+data/languages/nds32.ldefs||GHIDRA||||END|
+data/languages/nds32.opinion||GHIDRA||||END|
+data/languages/nds32.pspec||GHIDRA||||END|
+data/languages/nds32.sinc||GHIDRA||||END|
+data/languages/nds32be.slaspec||GHIDRA||||END|
+data/languages/nds32le.slaspec||GHIDRA||||END|
+data/patterns/nds32_patterns.xml||GHIDRA||||END|
+data/patterns/patternconstraints.xml||GHIDRA||||END|
+data/sleighArgs.txt||GHIDRA||||END|
+src/main/java/ghidra/app/plugin/core/analysis/NDS32Analyzer.java||GHIDRA||||END|
diff --git a/Ghidra/Processors/NDS32/data/buildLanguage.xml b/Ghidra/Processors/NDS32/data/buildLanguage.xml
new file mode 100644
index 0000000000..74a29faf79
--- /dev/null
+++ b/Ghidra/Processors/NDS32/data/buildLanguage.xml
@@ -0,0 +1,50 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<!--
+  + Compile sleigh languages within this module.
+  + Sleigh compiler options are read from the sleighArgs.txt file.
+  + Eclipse: right-click on this file and choose menu item "Run As->Ant Build"
+  -->
+
+<project name="privateBuildDeveloper" default="sleighCompile">
+
+	<property name="sleigh.compile.class" value="ghidra.pcodeCPort.slgh_compile.SleighCompile"/>
+
+	<!--Import optional ant properties.  GhidraDev Eclipse plugin produces this so this file can find the Ghidra installation-->
+	<import file="../.antProperties.xml" optional="false" />
+
+	<target name="sleighCompile">
+
+		<!-- If language module is detached from installation, get Ghidra installation directory path from imported properties -->
+		<property name="framework.path" value="${ghidra.install.dir}/Ghidra/Framework"/>
+
+		<path id="sleigh.class.path">
+			<fileset dir="${framework.path}/SoftwareModeling/lib">
+				<include name="*.jar"/>
+			</fileset>
+			<fileset dir="${framework.path}/Generic/lib">
+				<include name="*.jar"/>
+			</fileset>
+			<fileset dir="${framework.path}/Utility/lib">
+				<include name="*.jar"/>
+			</fileset>
+		</path>
+
+		<available classname="${sleigh.compile.class}" classpathref="sleigh.class.path" property="sleigh.compile.exists"/>
+
+		<fail unless="sleigh.compile.exists" />
+
+		<java classname="${sleigh.compile.class}"
+			classpathref="sleigh.class.path"
+			fork="true"
+			failonerror="true">
+			<jvmarg value="-Xmx2048M"/>
+			<arg value="-i"/>
+			<arg value="sleighArgs.txt"/>
+			<arg value="-a"/>
+			<arg value="./languages"/>
+		</java>
+
+	</target>
+
+</project>
diff --git a/Ghidra/Processors/NDS32/data/languages/lsmw.sinc b/Ghidra/Processors/NDS32/data/languages/lsmw.sinc
new file mode 100644
index 0000000000..2953e445d1
--- /dev/null
+++ b/Ghidra/Processors/NDS32/data/languages/lsmw.sinc
@@ -0,0 +1,576 @@
+macro Lmwbi(reg) {
+    reg = *mult_addr;
+    mult_addr = mult_addr + 4;
+}
+
+macro Lmwbd(reg) {
+    reg = *mult_addr;
+    mult_addr = mult_addr - 4;
+}
+
+macro Lmwai(reg) {
+    mult_addr = mult_addr + 4;
+    reg = *mult_addr;
+}
+
+macro Lmwad(reg) {
+    mult_addr = mult_addr - 4;
+    reg = *mult_addr;
+}
+
+macro Smwbi(reg) {
+    *mult_addr = reg;
+    mult_addr = mult_addr + 4;
+}
+
+macro Smwbd(reg) {
+    *mult_addr = reg;
+    mult_addr = mult_addr - 4;
+}
+
+macro Smwai(reg) {
+    mult_addr = mult_addr + 4;
+    *mult_addr = reg;
+}
+
+macro Smwad(reg) {
+    mult_addr = mult_addr - 4;
+    *mult_addr = reg;
+}
+
+Lmwbi.a0: a0 is LsmwRb_<=0 & LsmwRe_>=0 & a0 { Lmwbi(a0); }
+Lmwbi.a0: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.a1: a1 is LsmwRb_<=1 & LsmwRe_>=1 & a1 { Lmwbi(a1); }
+Lmwbi.a1: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.a2: a2 is LsmwRb_<=2 & LsmwRe_>=2 & a2 { Lmwbi(a2); }
+Lmwbi.a2: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.a3: a3 is LsmwRb_<=3 & LsmwRe_>=3 & a3 { Lmwbi(a3); }
+Lmwbi.a3: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.a4: a4 is LsmwRb_<=4 & LsmwRe_>=4 & a4 { Lmwbi(a4); }
+Lmwbi.a4: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.a5: a5 is LsmwRb_<=5 & LsmwRe_>=5 & a5 { Lmwbi(a5); }
+Lmwbi.a5: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.s0: s0 is LsmwRb_<=6 & LsmwRe_>=6 & s0 { Lmwbi(s0); }
+Lmwbi.s0: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.s1: s1 is LsmwRb_<=7 & LsmwRe_>=7 & s1 { Lmwbi(s1); }
+Lmwbi.s1: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.s2: s2 is LsmwRb_<=8 & LsmwRe_>=8 & s2 { Lmwbi(s2); }
+Lmwbi.s2: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.s3: s3 is LsmwRb_<=9 & LsmwRe_>=9 & s3 { Lmwbi(s3); }
+Lmwbi.s3: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.s4: s4 is LsmwRb_<=10 & LsmwRe_>=10 & s4 { Lmwbi(s4); }
+Lmwbi.s4: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.s5: s5 is LsmwRb_<=11 & LsmwRe_>=11 & s5 { Lmwbi(s5); }
+Lmwbi.s5: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.s6: s6 is LsmwRb_<=12 & LsmwRe_>=12 & s6 { Lmwbi(s6); }
+Lmwbi.s6: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.s7: s7 is LsmwRb_<=13 & LsmwRe_>=13 & s7 { Lmwbi(s7); }
+Lmwbi.s7: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.s8: s8 is LsmwRb_<=14 & LsmwRe_>=14 & s8 { Lmwbi(s8); }
+Lmwbi.s8: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.ta: ta is LsmwRb_<=15 & LsmwRe_>=15 & ta { Lmwbi(ta); }
+Lmwbi.ta: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.t0: t0 is LsmwRb_<=16 & LsmwRe_>=16 & t0 { Lmwbi(t0); }
+Lmwbi.t0: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.t1: t1 is LsmwRb_<=17 & LsmwRe_>=17 & t1 { Lmwbi(t1); }
+Lmwbi.t1: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.t2: t2 is LsmwRb_<=18 & LsmwRe_>=18 & t2 { Lmwbi(t2); }
+Lmwbi.t2: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.t3: t3 is LsmwRb_<=19 & LsmwRe_>=19 & t3 { Lmwbi(t3); }
+Lmwbi.t3: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.t4: t4 is LsmwRb_<=20 & LsmwRe_>=20 & t4 { Lmwbi(t4); }
+Lmwbi.t4: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.t5: t5 is LsmwRb_<=21 & LsmwRe_>=21 & t5 { Lmwbi(t5); }
+Lmwbi.t5: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.t6: t6 is LsmwRb_<=22 & LsmwRe_>=22 & t6 { Lmwbi(t6); }
+Lmwbi.t6: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.t7: t7 is LsmwRb_<=23 & LsmwRe_>=23 & t7 { Lmwbi(t7); }
+Lmwbi.t7: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.t8: t8 is LsmwRb_<=24 & LsmwRe_>=24 & t8 { Lmwbi(t8); }
+Lmwbi.t8: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.t9: t9 is LsmwRb_<=25 & LsmwRe_>=25 & t9 { Lmwbi(t9); }
+Lmwbi.t9: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.p0: p0 is LsmwRb_<=26 & LsmwRe_>=26 & p0 { Lmwbi(p0); }
+Lmwbi.p0: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.p1: p1 is LsmwRb_<=27 & LsmwRe_>=27 & p1 { Lmwbi(p1); }
+Lmwbi.p1: is LsmwRb_ & LsmwRe_ { }
+Lmwbi.fp: fp is Enable4_fp=1 & fp { Lmwbi(fp); }
+Lmwbi.fp: is Enable4_fp=0 { }
+Lmwbi.gp: gp is Enable4_gp=1 & gp { Lmwbi(gp); }
+Lmwbi.gp: is Enable4_gp=0 { }
+Lmwbi.lp: lp is Enable4_lp=1 & lp { Lmwbi(lp); }
+Lmwbi.lp: is Enable4_lp=0 { }
+Lmwbi.sp: sp is Enable4_sp=1 & sp { Lmwbi(sp); }
+Lmwbi.sp: is Enable4_sp=0 { }
+
+Lmwbd.a0: a0 is LsmwRb_<=0 & LsmwRe_>=0 & a0 { Lmwbd(a0); }
+Lmwbd.a0: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.a1: a1 is LsmwRb_<=1 & LsmwRe_>=1 & a1 { Lmwbd(a1); }
+Lmwbd.a1: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.a2: a2 is LsmwRb_<=2 & LsmwRe_>=2 & a2 { Lmwbd(a2); }
+Lmwbd.a2: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.a3: a3 is LsmwRb_<=3 & LsmwRe_>=3 & a3 { Lmwbd(a3); }
+Lmwbd.a3: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.a4: a4 is LsmwRb_<=4 & LsmwRe_>=4 & a4 { Lmwbd(a4); }
+Lmwbd.a4: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.a5: a5 is LsmwRb_<=5 & LsmwRe_>=5 & a5 { Lmwbd(a5); }
+Lmwbd.a5: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.s0: s0 is LsmwRb_<=6 & LsmwRe_>=6 & s0 { Lmwbd(s0); }
+Lmwbd.s0: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.s1: s1 is LsmwRb_<=7 & LsmwRe_>=7 & s1 { Lmwbd(s1); }
+Lmwbd.s1: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.s2: s2 is LsmwRb_<=8 & LsmwRe_>=8 & s2 { Lmwbd(s2); }
+Lmwbd.s2: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.s3: s3 is LsmwRb_<=9 & LsmwRe_>=9 & s3 { Lmwbd(s3); }
+Lmwbd.s3: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.s4: s4 is LsmwRb_<=10 & LsmwRe_>=10 & s4 { Lmwbd(s4); }
+Lmwbd.s4: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.s5: s5 is LsmwRb_<=11 & LsmwRe_>=11 & s5 { Lmwbd(s5); }
+Lmwbd.s5: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.s6: s6 is LsmwRb_<=12 & LsmwRe_>=12 & s6 { Lmwbd(s6); }
+Lmwbd.s6: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.s7: s7 is LsmwRb_<=13 & LsmwRe_>=13 & s7 { Lmwbd(s7); }
+Lmwbd.s7: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.s8: s8 is LsmwRb_<=14 & LsmwRe_>=14 & s8 { Lmwbd(s8); }
+Lmwbd.s8: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.ta: ta is LsmwRb_<=15 & LsmwRe_>=15 & ta { Lmwbd(ta); }
+Lmwbd.ta: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.t0: t0 is LsmwRb_<=16 & LsmwRe_>=16 & t0 { Lmwbd(t0); }
+Lmwbd.t0: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.t1: t1 is LsmwRb_<=17 & LsmwRe_>=17 & t1 { Lmwbd(t1); }
+Lmwbd.t1: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.t2: t2 is LsmwRb_<=18 & LsmwRe_>=18 & t2 { Lmwbd(t2); }
+Lmwbd.t2: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.t3: t3 is LsmwRb_<=19 & LsmwRe_>=19 & t3 { Lmwbd(t3); }
+Lmwbd.t3: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.t4: t4 is LsmwRb_<=20 & LsmwRe_>=20 & t4 { Lmwbd(t4); }
+Lmwbd.t4: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.t5: t5 is LsmwRb_<=21 & LsmwRe_>=21 & t5 { Lmwbd(t5); }
+Lmwbd.t5: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.t6: t6 is LsmwRb_<=22 & LsmwRe_>=22 & t6 { Lmwbd(t6); }
+Lmwbd.t6: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.t7: t7 is LsmwRb_<=23 & LsmwRe_>=23 & t7 { Lmwbd(t7); }
+Lmwbd.t7: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.t8: t8 is LsmwRb_<=24 & LsmwRe_>=24 & t8 { Lmwbd(t8); }
+Lmwbd.t8: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.t9: t9 is LsmwRb_<=25 & LsmwRe_>=25 & t9 { Lmwbd(t9); }
+Lmwbd.t9: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.p0: p0 is LsmwRb_<=26 & LsmwRe_>=26 & p0 { Lmwbd(p0); }
+Lmwbd.p0: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.p1: p1 is LsmwRb_<=27 & LsmwRe_>=27 & p1 { Lmwbd(p1); }
+Lmwbd.p1: is LsmwRb_ & LsmwRe_ { }
+Lmwbd.fp: fp is Enable4_fp=1 & fp { Lmwbd(fp); }
+Lmwbd.fp: is Enable4_fp=0 { }
+Lmwbd.gp: gp is Enable4_gp=1 & gp { Lmwbd(gp); }
+Lmwbd.gp: is Enable4_gp=0 { }
+Lmwbd.lp: lp is Enable4_lp=1 & lp { Lmwbd(lp); }
+Lmwbd.lp: is Enable4_lp=0 { }
+Lmwbd.sp: sp is Enable4_sp=1 & sp { Lmwbd(sp); }
+Lmwbd.sp: is Enable4_sp=0 { }
+
+Lmwai.a0: a0 is LsmwRb_<=0 & LsmwRe_>=0 & a0 { Lmwai(a0); }
+Lmwai.a0: is LsmwRb_ & LsmwRe_ { }
+Lmwai.a1: a1 is LsmwRb_<=1 & LsmwRe_>=1 & a1 { Lmwai(a1); }
+Lmwai.a1: is LsmwRb_ & LsmwRe_ { }
+Lmwai.a2: a2 is LsmwRb_<=2 & LsmwRe_>=2 & a2 { Lmwai(a2); }
+Lmwai.a2: is LsmwRb_ & LsmwRe_ { }
+Lmwai.a3: a3 is LsmwRb_<=3 & LsmwRe_>=3 & a3 { Lmwai(a3); }
+Lmwai.a3: is LsmwRb_ & LsmwRe_ { }
+Lmwai.a4: a4 is LsmwRb_<=4 & LsmwRe_>=4 & a4 { Lmwai(a4); }
+Lmwai.a4: is LsmwRb_ & LsmwRe_ { }
+Lmwai.a5: a5 is LsmwRb_<=5 & LsmwRe_>=5 & a5 { Lmwai(a5); }
+Lmwai.a5: is LsmwRb_ & LsmwRe_ { }
+Lmwai.s0: s0 is LsmwRb_<=6 & LsmwRe_>=6 & s0 { Lmwai(s0); }
+Lmwai.s0: is LsmwRb_ & LsmwRe_ { }
+Lmwai.s1: s1 is LsmwRb_<=7 & LsmwRe_>=7 & s1 { Lmwai(s1); }
+Lmwai.s1: is LsmwRb_ & LsmwRe_ { }
+Lmwai.s2: s2 is LsmwRb_<=8 & LsmwRe_>=8 & s2 { Lmwai(s2); }
+Lmwai.s2: is LsmwRb_ & LsmwRe_ { }
+Lmwai.s3: s3 is LsmwRb_<=9 & LsmwRe_>=9 & s3 { Lmwai(s3); }
+Lmwai.s3: is LsmwRb_ & LsmwRe_ { }
+Lmwai.s4: s4 is LsmwRb_<=10 & LsmwRe_>=10 & s4 { Lmwai(s4); }
+Lmwai.s4: is LsmwRb_ & LsmwRe_ { }
+Lmwai.s5: s5 is LsmwRb_<=11 & LsmwRe_>=11 & s5 { Lmwai(s5); }
+Lmwai.s5: is LsmwRb_ & LsmwRe_ { }
+Lmwai.s6: s6 is LsmwRb_<=12 & LsmwRe_>=12 & s6 { Lmwai(s6); }
+Lmwai.s6: is LsmwRb_ & LsmwRe_ { }
+Lmwai.s7: s7 is LsmwRb_<=13 & LsmwRe_>=13 & s7 { Lmwai(s7); }
+Lmwai.s7: is LsmwRb_ & LsmwRe_ { }
+Lmwai.s8: s8 is LsmwRb_<=14 & LsmwRe_>=14 & s8 { Lmwai(s8); }
+Lmwai.s8: is LsmwRb_ & LsmwRe_ { }
+Lmwai.ta: ta is LsmwRb_<=15 & LsmwRe_>=15 & ta { Lmwai(ta); }
+Lmwai.ta: is LsmwRb_ & LsmwRe_ { }
+Lmwai.t0: t0 is LsmwRb_<=16 & LsmwRe_>=16 & t0 { Lmwai(t0); }
+Lmwai.t0: is LsmwRb_ & LsmwRe_ { }
+Lmwai.t1: t1 is LsmwRb_<=17 & LsmwRe_>=17 & t1 { Lmwai(t1); }
+Lmwai.t1: is LsmwRb_ & LsmwRe_ { }
+Lmwai.t2: t2 is LsmwRb_<=18 & LsmwRe_>=18 & t2 { Lmwai(t2); }
+Lmwai.t2: is LsmwRb_ & LsmwRe_ { }
+Lmwai.t3: t3 is LsmwRb_<=19 & LsmwRe_>=19 & t3 { Lmwai(t3); }
+Lmwai.t3: is LsmwRb_ & LsmwRe_ { }
+Lmwai.t4: t4 is LsmwRb_<=20 & LsmwRe_>=20 & t4 { Lmwai(t4); }
+Lmwai.t4: is LsmwRb_ & LsmwRe_ { }
+Lmwai.t5: t5 is LsmwRb_<=21 & LsmwRe_>=21 & t5 { Lmwai(t5); }
+Lmwai.t5: is LsmwRb_ & LsmwRe_ { }
+Lmwai.t6: t6 is LsmwRb_<=22 & LsmwRe_>=22 & t6 { Lmwai(t6); }
+Lmwai.t6: is LsmwRb_ & LsmwRe_ { }
+Lmwai.t7: t7 is LsmwRb_<=23 & LsmwRe_>=23 & t7 { Lmwai(t7); }
+Lmwai.t7: is LsmwRb_ & LsmwRe_ { }
+Lmwai.t8: t8 is LsmwRb_<=24 & LsmwRe_>=24 & t8 { Lmwai(t8); }
+Lmwai.t8: is LsmwRb_ & LsmwRe_ { }
+Lmwai.t9: t9 is LsmwRb_<=25 & LsmwRe_>=25 & t9 { Lmwai(t9); }
+Lmwai.t9: is LsmwRb_ & LsmwRe_ { }
+Lmwai.p0: p0 is LsmwRb_<=26 & LsmwRe_>=26 & p0 { Lmwai(p0); }
+Lmwai.p0: is LsmwRb_ & LsmwRe_ { }
+Lmwai.p1: p1 is LsmwRb_<=27 & LsmwRe_>=27 & p1 { Lmwai(p1); }
+Lmwai.p1: is LsmwRb_ & LsmwRe_ { }
+Lmwai.fp: fp is Enable4_fp=1 & fp { Lmwai(fp); }
+Lmwai.fp: is Enable4_fp=0 { }
+Lmwai.gp: gp is Enable4_gp=1 & gp { Lmwai(gp); }
+Lmwai.gp: is Enable4_gp=0 { }
+Lmwai.lp: lp is Enable4_lp=1 & lp { Lmwai(lp); }
+Lmwai.lp: is Enable4_lp=0 { }
+Lmwai.sp: sp is Enable4_sp=1 & sp { Lmwai(sp); }
+Lmwai.sp: is Enable4_sp=0 { }
+
+Lmwad.a0: a0 is LsmwRb_<=0 & LsmwRe_>=0 & a0 { Lmwad(a0); }
+Lmwad.a0: is LsmwRb_ & LsmwRe_ { }
+Lmwad.a1: a1 is LsmwRb_<=1 & LsmwRe_>=1 & a1 { Lmwad(a1); }
+Lmwad.a1: is LsmwRb_ & LsmwRe_ { }
+Lmwad.a2: a2 is LsmwRb_<=2 & LsmwRe_>=2 & a2 { Lmwad(a2); }
+Lmwad.a2: is LsmwRb_ & LsmwRe_ { }
+Lmwad.a3: a3 is LsmwRb_<=3 & LsmwRe_>=3 & a3 { Lmwad(a3); }
+Lmwad.a3: is LsmwRb_ & LsmwRe_ { }
+Lmwad.a4: a4 is LsmwRb_<=4 & LsmwRe_>=4 & a4 { Lmwad(a4); }
+Lmwad.a4: is LsmwRb_ & LsmwRe_ { }
+Lmwad.a5: a5 is LsmwRb_<=5 & LsmwRe_>=5 & a5 { Lmwad(a5); }
+Lmwad.a5: is LsmwRb_ & LsmwRe_ { }
+Lmwad.s0: s0 is LsmwRb_<=6 & LsmwRe_>=6 & s0 { Lmwad(s0); }
+Lmwad.s0: is LsmwRb_ & LsmwRe_ { }
+Lmwad.s1: s1 is LsmwRb_<=7 & LsmwRe_>=7 & s1 { Lmwad(s1); }
+Lmwad.s1: is LsmwRb_ & LsmwRe_ { }
+Lmwad.s2: s2 is LsmwRb_<=8 & LsmwRe_>=8 & s2 { Lmwad(s2); }
+Lmwad.s2: is LsmwRb_ & LsmwRe_ { }
+Lmwad.s3: s3 is LsmwRb_<=9 & LsmwRe_>=9 & s3 { Lmwad(s3); }
+Lmwad.s3: is LsmwRb_ & LsmwRe_ { }
+Lmwad.s4: s4 is LsmwRb_<=10 & LsmwRe_>=10 & s4 { Lmwad(s4); }
+Lmwad.s4: is LsmwRb_ & LsmwRe_ { }
+Lmwad.s5: s5 is LsmwRb_<=11 & LsmwRe_>=11 & s5 { Lmwad(s5); }
+Lmwad.s5: is LsmwRb_ & LsmwRe_ { }
+Lmwad.s6: s6 is LsmwRb_<=12 & LsmwRe_>=12 & s6 { Lmwad(s6); }
+Lmwad.s6: is LsmwRb_ & LsmwRe_ { }
+Lmwad.s7: s7 is LsmwRb_<=13 & LsmwRe_>=13 & s7 { Lmwad(s7); }
+Lmwad.s7: is LsmwRb_ & LsmwRe_ { }
+Lmwad.s8: s8 is LsmwRb_<=14 & LsmwRe_>=14 & s8 { Lmwad(s8); }
+Lmwad.s8: is LsmwRb_ & LsmwRe_ { }
+Lmwad.ta: ta is LsmwRb_<=15 & LsmwRe_>=15 & ta { Lmwad(ta); }
+Lmwad.ta: is LsmwRb_ & LsmwRe_ { }
+Lmwad.t0: t0 is LsmwRb_<=16 & LsmwRe_>=16 & t0 { Lmwad(t0); }
+Lmwad.t0: is LsmwRb_ & LsmwRe_ { }
+Lmwad.t1: t1 is LsmwRb_<=17 & LsmwRe_>=17 & t1 { Lmwad(t1); }
+Lmwad.t1: is LsmwRb_ & LsmwRe_ { }
+Lmwad.t2: t2 is LsmwRb_<=18 & LsmwRe_>=18 & t2 { Lmwad(t2); }
+Lmwad.t2: is LsmwRb_ & LsmwRe_ { }
+Lmwad.t3: t3 is LsmwRb_<=19 & LsmwRe_>=19 & t3 { Lmwad(t3); }
+Lmwad.t3: is LsmwRb_ & LsmwRe_ { }
+Lmwad.t4: t4 is LsmwRb_<=20 & LsmwRe_>=20 & t4 { Lmwad(t4); }
+Lmwad.t4: is LsmwRb_ & LsmwRe_ { }
+Lmwad.t5: t5 is LsmwRb_<=21 & LsmwRe_>=21 & t5 { Lmwad(t5); }
+Lmwad.t5: is LsmwRb_ & LsmwRe_ { }
+Lmwad.t6: t6 is LsmwRb_<=22 & LsmwRe_>=22 & t6 { Lmwad(t6); }
+Lmwad.t6: is LsmwRb_ & LsmwRe_ { }
+Lmwad.t7: t7 is LsmwRb_<=23 & LsmwRe_>=23 & t7 { Lmwad(t7); }
+Lmwad.t7: is LsmwRb_ & LsmwRe_ { }
+Lmwad.t8: t8 is LsmwRb_<=24 & LsmwRe_>=24 & t8 { Lmwad(t8); }
+Lmwad.t8: is LsmwRb_ & LsmwRe_ { }
+Lmwad.t9: t9 is LsmwRb_<=25 & LsmwRe_>=25 & t9 { Lmwad(t9); }
+Lmwad.t9: is LsmwRb_ & LsmwRe_ { }
+Lmwad.p0: p0 is LsmwRb_<=26 & LsmwRe_>=26 & p0 { Lmwad(p0); }
+Lmwad.p0: is LsmwRb_ & LsmwRe_ { }
+Lmwad.p1: p1 is LsmwRb_<=27 & LsmwRe_>=27 & p1 { Lmwad(p1); }
+Lmwad.p1: is LsmwRb_ & LsmwRe_ { }
+Lmwad.fp: fp is Enable4_fp=1 & fp { Lmwad(fp); }
+Lmwad.fp: is Enable4_fp=0 { }
+Lmwad.gp: gp is Enable4_gp=1 & gp { Lmwad(gp); }
+Lmwad.gp: is Enable4_gp=0 { }
+Lmwad.lp: lp is Enable4_lp=1 & lp { Lmwad(lp); }
+Lmwad.lp: is Enable4_lp=0 { }
+Lmwad.sp: sp is Enable4_sp=1 & sp { Lmwad(sp); }
+Lmwad.sp: is Enable4_sp=0 { }
+
+Smwbi.a0: a0 is LsmwRb_<=0 & LsmwRe_>=0 & a0 { Smwbi(a0); }
+Smwbi.a0: is LsmwRb_ & LsmwRe_ { }
+Smwbi.a1: a1 is LsmwRb_<=1 & LsmwRe_>=1 & a1 { Smwbi(a1); }
+Smwbi.a1: is LsmwRb_ & LsmwRe_ { }
+Smwbi.a2: a2 is LsmwRb_<=2 & LsmwRe_>=2 & a2 { Smwbi(a2); }
+Smwbi.a2: is LsmwRb_ & LsmwRe_ { }
+Smwbi.a3: a3 is LsmwRb_<=3 & LsmwRe_>=3 & a3 { Smwbi(a3); }
+Smwbi.a3: is LsmwRb_ & LsmwRe_ { }
+Smwbi.a4: a4 is LsmwRb_<=4 & LsmwRe_>=4 & a4 { Smwbi(a4); }
+Smwbi.a4: is LsmwRb_ & LsmwRe_ { }
+Smwbi.a5: a5 is LsmwRb_<=5 & LsmwRe_>=5 & a5 { Smwbi(a5); }
+Smwbi.a5: is LsmwRb_ & LsmwRe_ { }
+Smwbi.s0: s0 is LsmwRb_<=6 & LsmwRe_>=6 & s0 { Smwbi(s0); }
+Smwbi.s0: is LsmwRb_ & LsmwRe_ { }
+Smwbi.s1: s1 is LsmwRb_<=7 & LsmwRe_>=7 & s1 { Smwbi(s1); }
+Smwbi.s1: is LsmwRb_ & LsmwRe_ { }
+Smwbi.s2: s2 is LsmwRb_<=8 & LsmwRe_>=8 & s2 { Smwbi(s2); }
+Smwbi.s2: is LsmwRb_ & LsmwRe_ { }
+Smwbi.s3: s3 is LsmwRb_<=9 & LsmwRe_>=9 & s3 { Smwbi(s3); }
+Smwbi.s3: is LsmwRb_ & LsmwRe_ { }
+Smwbi.s4: s4 is LsmwRb_<=10 & LsmwRe_>=10 & s4 { Smwbi(s4); }
+Smwbi.s4: is LsmwRb_ & LsmwRe_ { }
+Smwbi.s5: s5 is LsmwRb_<=11 & LsmwRe_>=11 & s5 { Smwbi(s5); }
+Smwbi.s5: is LsmwRb_ & LsmwRe_ { }
+Smwbi.s6: s6 is LsmwRb_<=12 & LsmwRe_>=12 & s6 { Smwbi(s6); }
+Smwbi.s6: is LsmwRb_ & LsmwRe_ { }
+Smwbi.s7: s7 is LsmwRb_<=13 & LsmwRe_>=13 & s7 { Smwbi(s7); }
+Smwbi.s7: is LsmwRb_ & LsmwRe_ { }
+Smwbi.s8: s8 is LsmwRb_<=14 & LsmwRe_>=14 & s8 { Smwbi(s8); }
+Smwbi.s8: is LsmwRb_ & LsmwRe_ { }
+Smwbi.ta: ta is LsmwRb_<=15 & LsmwRe_>=15 & ta { Smwbi(ta); }
+Smwbi.ta: is LsmwRb_ & LsmwRe_ { }
+Smwbi.t0: t0 is LsmwRb_<=16 & LsmwRe_>=16 & t0 { Smwbi(t0); }
+Smwbi.t0: is LsmwRb_ & LsmwRe_ { }
+Smwbi.t1: t1 is LsmwRb_<=17 & LsmwRe_>=17 & t1 { Smwbi(t1); }
+Smwbi.t1: is LsmwRb_ & LsmwRe_ { }
+Smwbi.t2: t2 is LsmwRb_<=18 & LsmwRe_>=18 & t2 { Smwbi(t2); }
+Smwbi.t2: is LsmwRb_ & LsmwRe_ { }
+Smwbi.t3: t3 is LsmwRb_<=19 & LsmwRe_>=19 & t3 { Smwbi(t3); }
+Smwbi.t3: is LsmwRb_ & LsmwRe_ { }
+Smwbi.t4: t4 is LsmwRb_<=20 & LsmwRe_>=20 & t4 { Smwbi(t4); }
+Smwbi.t4: is LsmwRb_ & LsmwRe_ { }
+Smwbi.t5: t5 is LsmwRb_<=21 & LsmwRe_>=21 & t5 { Smwbi(t5); }
+Smwbi.t5: is LsmwRb_ & LsmwRe_ { }
+Smwbi.t6: t6 is LsmwRb_<=22 & LsmwRe_>=22 & t6 { Smwbi(t6); }
+Smwbi.t6: is LsmwRb_ & LsmwRe_ { }
+Smwbi.t7: t7 is LsmwRb_<=23 & LsmwRe_>=23 & t7 { Smwbi(t7); }
+Smwbi.t7: is LsmwRb_ & LsmwRe_ { }
+Smwbi.t8: t8 is LsmwRb_<=24 & LsmwRe_>=24 & t8 { Smwbi(t8); }
+Smwbi.t8: is LsmwRb_ & LsmwRe_ { }
+Smwbi.t9: t9 is LsmwRb_<=25 & LsmwRe_>=25 & t9 { Smwbi(t9); }
+Smwbi.t9: is LsmwRb_ & LsmwRe_ { }
+Smwbi.p0: p0 is LsmwRb_<=26 & LsmwRe_>=26 & p0 { Smwbi(p0); }
+Smwbi.p0: is LsmwRb_ & LsmwRe_ { }
+Smwbi.p1: p1 is LsmwRb_<=27 & LsmwRe_>=27 & p1 { Smwbi(p1); }
+Smwbi.p1: is LsmwRb_ & LsmwRe_ { }
+Smwbi.fp: fp is Enable4_fp=1 & fp { Smwbi(fp); }
+Smwbi.fp: is Enable4_fp=0 { }
+Smwbi.gp: gp is Enable4_gp=1 & gp { Smwbi(gp); }
+Smwbi.gp: is Enable4_gp=0 { }
+Smwbi.lp: lp is Enable4_lp=1 & lp { Smwbi(lp); }
+Smwbi.lp: is Enable4_lp=0 { }
+Smwbi.sp: sp is Enable4_sp=1 & sp { Smwbi(sp); }
+Smwbi.sp: is Enable4_sp=0 { }
+
+Smwbd.a0: a0 is LsmwRb_<=0 & LsmwRe_>=0 & a0 { Smwbd(a0); }
+Smwbd.a0: is LsmwRb_ & LsmwRe_ { }
+Smwbd.a1: a1 is LsmwRb_<=1 & LsmwRe_>=1 & a1 { Smwbd(a1); }
+Smwbd.a1: is LsmwRb_ & LsmwRe_ { }
+Smwbd.a2: a2 is LsmwRb_<=2 & LsmwRe_>=2 & a2 { Smwbd(a2); }
+Smwbd.a2: is LsmwRb_ & LsmwRe_ { }
+Smwbd.a3: a3 is LsmwRb_<=3 & LsmwRe_>=3 & a3 { Smwbd(a3); }
+Smwbd.a3: is LsmwRb_ & LsmwRe_ { }
+Smwbd.a4: a4 is LsmwRb_<=4 & LsmwRe_>=4 & a4 { Smwbd(a4); }
+Smwbd.a4: is LsmwRb_ & LsmwRe_ { }
+Smwbd.a5: a5 is LsmwRb_<=5 & LsmwRe_>=5 & a5 { Smwbd(a5); }
+Smwbd.a5: is LsmwRb_ & LsmwRe_ { }
+Smwbd.s0: s0 is LsmwRb_<=6 & LsmwRe_>=6 & s0 { Smwbd(s0); }
+Smwbd.s0: is LsmwRb_ & LsmwRe_ { }
+Smwbd.s1: s1 is LsmwRb_<=7 & LsmwRe_>=7 & s1 { Smwbd(s1); }
+Smwbd.s1: is LsmwRb_ & LsmwRe_ { }
+Smwbd.s2: s2 is LsmwRb_<=8 & LsmwRe_>=8 & s2 { Smwbd(s2); }
+Smwbd.s2: is LsmwRb_ & LsmwRe_ { }
+Smwbd.s3: s3 is LsmwRb_<=9 & LsmwRe_>=9 & s3 { Smwbd(s3); }
+Smwbd.s3: is LsmwRb_ & LsmwRe_ { }
+Smwbd.s4: s4 is LsmwRb_<=10 & LsmwRe_>=10 & s4 { Smwbd(s4); }
+Smwbd.s4: is LsmwRb_ & LsmwRe_ { }
+Smwbd.s5: s5 is LsmwRb_<=11 & LsmwRe_>=11 & s5 { Smwbd(s5); }
+Smwbd.s5: is LsmwRb_ & LsmwRe_ { }
+Smwbd.s6: s6 is LsmwRb_<=12 & LsmwRe_>=12 & s6 { Smwbd(s6); }
+Smwbd.s6: is LsmwRb_ & LsmwRe_ { }
+Smwbd.s7: s7 is LsmwRb_<=13 & LsmwRe_>=13 & s7 { Smwbd(s7); }
+Smwbd.s7: is LsmwRb_ & LsmwRe_ { }
+Smwbd.s8: s8 is LsmwRb_<=14 & LsmwRe_>=14 & s8 { Smwbd(s8); }
+Smwbd.s8: is LsmwRb_ & LsmwRe_ { }
+Smwbd.ta: ta is LsmwRb_<=15 & LsmwRe_>=15 & ta { Smwbd(ta); }
+Smwbd.ta: is LsmwRb_ & LsmwRe_ { }
+Smwbd.t0: t0 is LsmwRb_<=16 & LsmwRe_>=16 & t0 { Smwbd(t0); }
+Smwbd.t0: is LsmwRb_ & LsmwRe_ { }
+Smwbd.t1: t1 is LsmwRb_<=17 & LsmwRe_>=17 & t1 { Smwbd(t1); }
+Smwbd.t1: is LsmwRb_ & LsmwRe_ { }
+Smwbd.t2: t2 is LsmwRb_<=18 & LsmwRe_>=18 & t2 { Smwbd(t2); }
+Smwbd.t2: is LsmwRb_ & LsmwRe_ { }
+Smwbd.t3: t3 is LsmwRb_<=19 & LsmwRe_>=19 & t3 { Smwbd(t3); }
+Smwbd.t3: is LsmwRb_ & LsmwRe_ { }
+Smwbd.t4: t4 is LsmwRb_<=20 & LsmwRe_>=20 & t4 { Smwbd(t4); }
+Smwbd.t4: is LsmwRb_ & LsmwRe_ { }
+Smwbd.t5: t5 is LsmwRb_<=21 & LsmwRe_>=21 & t5 { Smwbd(t5); }
+Smwbd.t5: is LsmwRb_ & LsmwRe_ { }
+Smwbd.t6: t6 is LsmwRb_<=22 & LsmwRe_>=22 & t6 { Smwbd(t6); }
+Smwbd.t6: is LsmwRb_ & LsmwRe_ { }
+Smwbd.t7: t7 is LsmwRb_<=23 & LsmwRe_>=23 & t7 { Smwbd(t7); }
+Smwbd.t7: is LsmwRb_ & LsmwRe_ { }
+Smwbd.t8: t8 is LsmwRb_<=24 & LsmwRe_>=24 & t8 { Smwbd(t8); }
+Smwbd.t8: is LsmwRb_ & LsmwRe_ { }
+Smwbd.t9: t9 is LsmwRb_<=25 & LsmwRe_>=25 & t9 { Smwbd(t9); }
+Smwbd.t9: is LsmwRb_ & LsmwRe_ { }
+Smwbd.p0: p0 is LsmwRb_<=26 & LsmwRe_>=26 & p0 { Smwbd(p0); }
+Smwbd.p0: is LsmwRb_ & LsmwRe_ { }
+Smwbd.p1: p1 is LsmwRb_<=27 & LsmwRe_>=27 & p1 { Smwbd(p1); }
+Smwbd.p1: is LsmwRb_ & LsmwRe_ { }
+Smwbd.fp: fp is Enable4_fp=1 & fp { Smwbd(fp); }
+Smwbd.fp: is Enable4_fp=0 { }
+Smwbd.gp: gp is Enable4_gp=1 & gp { Smwbd(gp); }
+Smwbd.gp: is Enable4_gp=0 { }
+Smwbd.lp: lp is Enable4_lp=1 & lp { Smwbd(lp); }
+Smwbd.lp: is Enable4_lp=0 { }
+Smwbd.sp: sp is Enable4_sp=1 & sp { Smwbd(sp); }
+Smwbd.sp: is Enable4_sp=0 { }
+
+Smwai.a0: a0 is LsmwRb_<=0 & LsmwRe_>=0 & a0 { Smwai(a0); }
+Smwai.a0: is LsmwRb_ & LsmwRe_ { }
+Smwai.a1: a1 is LsmwRb_<=1 & LsmwRe_>=1 & a1 { Smwai(a1); }
+Smwai.a1: is LsmwRb_ & LsmwRe_ { }
+Smwai.a2: a2 is LsmwRb_<=2 & LsmwRe_>=2 & a2 { Smwai(a2); }
+Smwai.a2: is LsmwRb_ & LsmwRe_ { }
+Smwai.a3: a3 is LsmwRb_<=3 & LsmwRe_>=3 & a3 { Smwai(a3); }
+Smwai.a3: is LsmwRb_ & LsmwRe_ { }
+Smwai.a4: a4 is LsmwRb_<=4 & LsmwRe_>=4 & a4 { Smwai(a4); }
+Smwai.a4: is LsmwRb_ & LsmwRe_ { }
+Smwai.a5: a5 is LsmwRb_<=5 & LsmwRe_>=5 & a5 { Smwai(a5); }
+Smwai.a5: is LsmwRb_ & LsmwRe_ { }
+Smwai.s0: s0 is LsmwRb_<=6 & LsmwRe_>=6 & s0 { Smwai(s0); }
+Smwai.s0: is LsmwRb_ & LsmwRe_ { }
+Smwai.s1: s1 is LsmwRb_<=7 & LsmwRe_>=7 & s1 { Smwai(s1); }
+Smwai.s1: is LsmwRb_ & LsmwRe_ { }
+Smwai.s2: s2 is LsmwRb_<=8 & LsmwRe_>=8 & s2 { Smwai(s2); }
+Smwai.s2: is LsmwRb_ & LsmwRe_ { }
+Smwai.s3: s3 is LsmwRb_<=9 & LsmwRe_>=9 & s3 { Smwai(s3); }
+Smwai.s3: is LsmwRb_ & LsmwRe_ { }
+Smwai.s4: s4 is LsmwRb_<=10 & LsmwRe_>=10 & s4 { Smwai(s4); }
+Smwai.s4: is LsmwRb_ & LsmwRe_ { }
+Smwai.s5: s5 is LsmwRb_<=11 & LsmwRe_>=11 & s5 { Smwai(s5); }
+Smwai.s5: is LsmwRb_ & LsmwRe_ { }
+Smwai.s6: s6 is LsmwRb_<=12 & LsmwRe_>=12 & s6 { Smwai(s6); }
+Smwai.s6: is LsmwRb_ & LsmwRe_ { }
+Smwai.s7: s7 is LsmwRb_<=13 & LsmwRe_>=13 & s7 { Smwai(s7); }
+Smwai.s7: is LsmwRb_ & LsmwRe_ { }
+Smwai.s8: s8 is LsmwRb_<=14 & LsmwRe_>=14 & s8 { Smwai(s8); }
+Smwai.s8: is LsmwRb_ & LsmwRe_ { }
+Smwai.ta: ta is LsmwRb_<=15 & LsmwRe_>=15 & ta { Smwai(ta); }
+Smwai.ta: is LsmwRb_ & LsmwRe_ { }
+Smwai.t0: t0 is LsmwRb_<=16 & LsmwRe_>=16 & t0 { Smwai(t0); }
+Smwai.t0: is LsmwRb_ & LsmwRe_ { }
+Smwai.t1: t1 is LsmwRb_<=17 & LsmwRe_>=17 & t1 { Smwai(t1); }
+Smwai.t1: is LsmwRb_ & LsmwRe_ { }
+Smwai.t2: t2 is LsmwRb_<=18 & LsmwRe_>=18 & t2 { Smwai(t2); }
+Smwai.t2: is LsmwRb_ & LsmwRe_ { }
+Smwai.t3: t3 is LsmwRb_<=19 & LsmwRe_>=19 & t3 { Smwai(t3); }
+Smwai.t3: is LsmwRb_ & LsmwRe_ { }
+Smwai.t4: t4 is LsmwRb_<=20 & LsmwRe_>=20 & t4 { Smwai(t4); }
+Smwai.t4: is LsmwRb_ & LsmwRe_ { }
+Smwai.t5: t5 is LsmwRb_<=21 & LsmwRe_>=21 & t5 { Smwai(t5); }
+Smwai.t5: is LsmwRb_ & LsmwRe_ { }
+Smwai.t6: t6 is LsmwRb_<=22 & LsmwRe_>=22 & t6 { Smwai(t6); }
+Smwai.t6: is LsmwRb_ & LsmwRe_ { }
+Smwai.t7: t7 is LsmwRb_<=23 & LsmwRe_>=23 & t7 { Smwai(t7); }
+Smwai.t7: is LsmwRb_ & LsmwRe_ { }
+Smwai.t8: t8 is LsmwRb_<=24 & LsmwRe_>=24 & t8 { Smwai(t8); }
+Smwai.t8: is LsmwRb_ & LsmwRe_ { }
+Smwai.t9: t9 is LsmwRb_<=25 & LsmwRe_>=25 & t9 { Smwai(t9); }
+Smwai.t9: is LsmwRb_ & LsmwRe_ { }
+Smwai.p0: p0 is LsmwRb_<=26 & LsmwRe_>=26 & p0 { Smwai(p0); }
+Smwai.p0: is LsmwRb_ & LsmwRe_ { }
+Smwai.p1: p1 is LsmwRb_<=27 & LsmwRe_>=27 & p1 { Smwai(p1); }
+Smwai.p1: is LsmwRb_ & LsmwRe_ { }
+Smwai.fp: fp is Enable4_fp=1 & fp { Smwai(fp); }
+Smwai.fp: is Enable4_fp=0 { }
+Smwai.gp: gp is Enable4_gp=1 & gp { Smwai(gp); }
+Smwai.gp: is Enable4_gp=0 { }
+Smwai.lp: lp is Enable4_lp=1 & lp { Smwai(lp); }
+Smwai.lp: is Enable4_lp=0 { }
+Smwai.sp: sp is Enable4_sp=1 & sp { Smwai(sp); }
+Smwai.sp: is Enable4_sp=0 { }
+
+Smwad.a0: a0 is LsmwRb_<=0 & LsmwRe_>=0 & a0 { Smwad(a0); }
+Smwad.a0: is LsmwRb_ & LsmwRe_ { }
+Smwad.a1: a1 is LsmwRb_<=1 & LsmwRe_>=1 & a1 { Smwad(a1); }
+Smwad.a1: is LsmwRb_ & LsmwRe_ { }
+Smwad.a2: a2 is LsmwRb_<=2 & LsmwRe_>=2 & a2 { Smwad(a2); }
+Smwad.a2: is LsmwRb_ & LsmwRe_ { }
+Smwad.a3: a3 is LsmwRb_<=3 & LsmwRe_>=3 & a3 { Smwad(a3); }
+Smwad.a3: is LsmwRb_ & LsmwRe_ { }
+Smwad.a4: a4 is LsmwRb_<=4 & LsmwRe_>=4 & a4 { Smwad(a4); }
+Smwad.a4: is LsmwRb_ & LsmwRe_ { }
+Smwad.a5: a5 is LsmwRb_<=5 & LsmwRe_>=5 & a5 { Smwad(a5); }
+Smwad.a5: is LsmwRb_ & LsmwRe_ { }
+Smwad.s0: s0 is LsmwRb_<=6 & LsmwRe_>=6 & s0 { Smwad(s0); }
+Smwad.s0: is LsmwRb_ & LsmwRe_ { }
+Smwad.s1: s1 is LsmwRb_<=7 & LsmwRe_>=7 & s1 { Smwad(s1); }
+Smwad.s1: is LsmwRb_ & LsmwRe_ { }
+Smwad.s2: s2 is LsmwRb_<=8 & LsmwRe_>=8 & s2 { Smwad(s2); }
+Smwad.s2: is LsmwRb_ & LsmwRe_ { }
+Smwad.s3: s3 is LsmwRb_<=9 & LsmwRe_>=9 & s3 { Smwad(s3); }
+Smwad.s3: is LsmwRb_ & LsmwRe_ { }
+Smwad.s4: s4 is LsmwRb_<=10 & LsmwRe_>=10 & s4 { Smwad(s4); }
+Smwad.s4: is LsmwRb_ & LsmwRe_ { }
+Smwad.s5: s5 is LsmwRb_<=11 & LsmwRe_>=11 & s5 { Smwad(s5); }
+Smwad.s5: is LsmwRb_ & LsmwRe_ { }
+Smwad.s6: s6 is LsmwRb_<=12 & LsmwRe_>=12 & s6 { Smwad(s6); }
+Smwad.s6: is LsmwRb_ & LsmwRe_ { }
+Smwad.s7: s7 is LsmwRb_<=13 & LsmwRe_>=13 & s7 { Smwad(s7); }
+Smwad.s7: is LsmwRb_ & LsmwRe_ { }
+Smwad.s8: s8 is LsmwRb_<=14 & LsmwRe_>=14 & s8 { Smwad(s8); }
+Smwad.s8: is LsmwRb_ & LsmwRe_ { }
+Smwad.ta: ta is LsmwRb_<=15 & LsmwRe_>=15 & ta { Smwad(ta); }
+Smwad.ta: is LsmwRb_ & LsmwRe_ { }
+Smwad.t0: t0 is LsmwRb_<=16 & LsmwRe_>=16 & t0 { Smwad(t0); }
+Smwad.t0: is LsmwRb_ & LsmwRe_ { }
+Smwad.t1: t1 is LsmwRb_<=17 & LsmwRe_>=17 & t1 { Smwad(t1); }
+Smwad.t1: is LsmwRb_ & LsmwRe_ { }
+Smwad.t2: t2 is LsmwRb_<=18 & LsmwRe_>=18 & t2 { Smwad(t2); }
+Smwad.t2: is LsmwRb_ & LsmwRe_ { }
+Smwad.t3: t3 is LsmwRb_<=19 & LsmwRe_>=19 & t3 { Smwad(t3); }
+Smwad.t3: is LsmwRb_ & LsmwRe_ { }
+Smwad.t4: t4 is LsmwRb_<=20 & LsmwRe_>=20 & t4 { Smwad(t4); }
+Smwad.t4: is LsmwRb_ & LsmwRe_ { }
+Smwad.t5: t5 is LsmwRb_<=21 & LsmwRe_>=21 & t5 { Smwad(t5); }
+Smwad.t5: is LsmwRb_ & LsmwRe_ { }
+Smwad.t6: t6 is LsmwRb_<=22 & LsmwRe_>=22 & t6 { Smwad(t6); }
+Smwad.t6: is LsmwRb_ & LsmwRe_ { }
+Smwad.t7: t7 is LsmwRb_<=23 & LsmwRe_>=23 & t7 { Smwad(t7); }
+Smwad.t7: is LsmwRb_ & LsmwRe_ { }
+Smwad.t8: t8 is LsmwRb_<=24 & LsmwRe_>=24 & t8 { Smwad(t8); }
+Smwad.t8: is LsmwRb_ & LsmwRe_ { }
+Smwad.t9: t9 is LsmwRb_<=25 & LsmwRe_>=25 & t9 { Smwad(t9); }
+Smwad.t9: is LsmwRb_ & LsmwRe_ { }
+Smwad.p0: p0 is LsmwRb_<=26 & LsmwRe_>=26 & p0 { Smwad(p0); }
+Smwad.p0: is LsmwRb_ & LsmwRe_ { }
+Smwad.p1: p1 is LsmwRb_<=27 & LsmwRe_>=27 & p1 { Smwad(p1); }
+Smwad.p1: is LsmwRb_ & LsmwRe_ { }
+Smwad.fp: fp is Enable4_fp=1 & fp { Smwad(fp); }
+Smwad.fp: is Enable4_fp=0 { }
+Smwad.gp: gp is Enable4_gp=1 & gp { Smwad(gp); }
+Smwad.gp: is Enable4_gp=0 { }
+Smwad.lp: lp is Enable4_lp=1 & lp { Smwad(lp); }
+Smwad.lp: is Enable4_lp=0 { }
+Smwad.sp: sp is Enable4_sp=1 & sp { Smwad(sp); }
+Smwad.sp: is Enable4_sp=0 { }
+
+Lmw.regs: is LsmwBa=0 & LsmwId=0 & Lmwbi.sp & Lmwbi.lp & Lmwbi.gp & Lmwbi.fp & Lmwbi.p1 & Lmwbi.p0 & Lmwbi.t9 & Lmwbi.t8 & Lmwbi.t7 & Lmwbi.t6 & Lmwbi.t5 & Lmwbi.t4 & Lmwbi.t3 & Lmwbi.t2 & Lmwbi.t1 & Lmwbi.t0 & Lmwbi.ta & Lmwbi.s8 & Lmwbi.s7 & Lmwbi.s6 & Lmwbi.s5 & Lmwbi.s4 & Lmwbi.s3 & Lmwbi.s2 & Lmwbi.s1 & Lmwbi.s0 & Lmwbi.a5 & Lmwbi.a4 & Lmwbi.a3 & Lmwbi.a2 & Lmwbi.a1 & Lmwbi.a0 { }
+Lmw.regs: is LsmwBa=0 & LsmwId=1 & Lmwbd.a0 & Lmwbd.a1 & Lmwbd.a2 & Lmwbd.a3 & Lmwbd.a4 & Lmwbd.a5 & Lmwbd.s0 & Lmwbd.s1 & Lmwbd.s2 & Lmwbd.s3 & Lmwbd.s4 & Lmwbd.s5 & Lmwbd.s6 & Lmwbd.s7 & Lmwbd.s8 & Lmwbd.ta & Lmwbd.t0 & Lmwbd.t1 & Lmwbd.t2 & Lmwbd.t3 & Lmwbd.t4 & Lmwbd.t5 & Lmwbd.t6 & Lmwbd.t7 & Lmwbd.t8 & Lmwbd.t9 & Lmwbd.p0 & Lmwbd.p1 & Lmwbd.fp & Lmwbd.gp & Lmwbd.lp & Lmwbd.sp { }
+Lmw.regs: is LsmwBa=1 & LsmwId=0 & Lmwai.sp & Lmwai.lp & Lmwai.gp & Lmwai.fp & Lmwai.p1 & Lmwai.p0 & Lmwai.t9 & Lmwai.t8 & Lmwai.t7 & Lmwai.t6 & Lmwai.t5 & Lmwai.t4 & Lmwai.t3 & Lmwai.t2 & Lmwai.t1 & Lmwai.t0 & Lmwai.ta & Lmwai.s8 & Lmwai.s7 & Lmwai.s6 & Lmwai.s5 & Lmwai.s4 & Lmwai.s3 & Lmwai.s2 & Lmwai.s1 & Lmwai.s0 & Lmwai.a5 & Lmwai.a4 & Lmwai.a3 & Lmwai.a2 & Lmwai.a1 & Lmwai.a0 { }
+Lmw.regs: is LsmwBa=1 & LsmwId=1 & Lmwad.a0 & Lmwad.a1 & Lmwad.a2 & Lmwad.a3 & Lmwad.a4 & Lmwad.a5 & Lmwad.s0 & Lmwad.s1 & Lmwad.s2 & Lmwad.s3 & Lmwad.s4 & Lmwad.s5 & Lmwad.s6 & Lmwad.s7 & Lmwad.s8 & Lmwad.ta & Lmwad.t0 & Lmwad.t1 & Lmwad.t2 & Lmwad.t3 & Lmwad.t4 & Lmwad.t5 & Lmwad.t6 & Lmwad.t7 & Lmwad.t8 & Lmwad.t9 & Lmwad.p0 & Lmwad.p1 & Lmwad.fp & Lmwad.gp & Lmwad.lp & Lmwad.sp { }
+Smw.regs: is LsmwBa=0 & LsmwId=0 & Smwbi.sp & Smwbi.lp & Smwbi.gp & Smwbi.fp & Smwbi.p1 & Smwbi.p0 & Smwbi.t9 & Smwbi.t8 & Smwbi.t7 & Smwbi.t6 & Smwbi.t5 & Smwbi.t4 & Smwbi.t3 & Smwbi.t2 & Smwbi.t1 & Smwbi.t0 & Smwbi.ta & Smwbi.s8 & Smwbi.s7 & Smwbi.s6 & Smwbi.s5 & Smwbi.s4 & Smwbi.s3 & Smwbi.s2 & Smwbi.s1 & Smwbi.s0 & Smwbi.a5 & Smwbi.a4 & Smwbi.a3 & Smwbi.a2 & Smwbi.a1 & Smwbi.a0 { }
+Smw.regs: is LsmwBa=0 & LsmwId=1 & Smwbd.a0 & Smwbd.a1 & Smwbd.a2 & Smwbd.a3 & Smwbd.a4 & Smwbd.a5 & Smwbd.s0 & Smwbd.s1 & Smwbd.s2 & Smwbd.s3 & Smwbd.s4 & Smwbd.s5 & Smwbd.s6 & Smwbd.s7 & Smwbd.s8 & Smwbd.ta & Smwbd.t0 & Smwbd.t1 & Smwbd.t2 & Smwbd.t3 & Smwbd.t4 & Smwbd.t5 & Smwbd.t6 & Smwbd.t7 & Smwbd.t8 & Smwbd.t9 & Smwbd.p0 & Smwbd.p1 & Smwbd.fp & Smwbd.gp & Smwbd.lp & Smwbd.sp { }
+Smw.regs: is LsmwBa=1 & LsmwId=0 & Smwai.sp & Smwai.lp & Smwai.gp & Smwai.fp & Smwai.p1 & Smwai.p0 & Smwai.t9 & Smwai.t8 & Smwai.t7 & Smwai.t6 & Smwai.t5 & Smwai.t4 & Smwai.t3 & Smwai.t2 & Smwai.t1 & Smwai.t0 & Smwai.ta & Smwai.s8 & Smwai.s7 & Smwai.s6 & Smwai.s5 & Smwai.s4 & Smwai.s3 & Smwai.s2 & Smwai.s1 & Smwai.s0 & Smwai.a5 & Smwai.a4 & Smwai.a3 & Smwai.a2 & Smwai.a1 & Smwai.a0 { }
+Smw.regs: is LsmwBa=1 & LsmwId=1 & Smwad.a0 & Smwad.a1 & Smwad.a2 & Smwad.a3 & Smwad.a4 & Smwad.a5 & Smwad.s0 & Smwad.s1 & Smwad.s2 & Smwad.s3 & Smwad.s4 & Smwad.s5 & Smwad.s6 & Smwad.s7 & Smwad.s8 & Smwad.ta & Smwad.t0 & Smwad.t1 & Smwad.t2 & Smwad.t3 & Smwad.t4 & Smwad.t5 & Smwad.t6 & Smwad.t7 & Smwad.t8 & Smwad.t9 & Smwad.p0 & Smwad.p1 & Smwad.fp & Smwad.gp & Smwad.lp & Smwad.sp { }
+Lmwa.regs: is LsmwBa=0 & LsmwId=0 & Lmwbi.sp & Lmwbi.lp & Lmwbi.gp & Lmwbi.fp & Lmwbi.p1 & Lmwbi.p0 & Lmwbi.t9 & Lmwbi.t8 & Lmwbi.t7 & Lmwbi.t6 & Lmwbi.t5 & Lmwbi.t4 & Lmwbi.t3 & Lmwbi.t2 & Lmwbi.t1 & Lmwbi.t0 & Lmwbi.ta & Lmwbi.s8 & Lmwbi.s7 & Lmwbi.s6 & Lmwbi.s5 & Lmwbi.s4 & Lmwbi.s3 & Lmwbi.s2 & Lmwbi.s1 & Lmwbi.s0 & Lmwbi.a5 & Lmwbi.a4 & Lmwbi.a3 & Lmwbi.a2 & Lmwbi.a1 & Lmwbi.a0 { }
+Lmwa.regs: is LsmwBa=0 & LsmwId=1 & Lmwbd.a0 & Lmwbd.a1 & Lmwbd.a2 & Lmwbd.a3 & Lmwbd.a4 & Lmwbd.a5 & Lmwbd.s0 & Lmwbd.s1 & Lmwbd.s2 & Lmwbd.s3 & Lmwbd.s4 & Lmwbd.s5 & Lmwbd.s6 & Lmwbd.s7 & Lmwbd.s8 & Lmwbd.ta & Lmwbd.t0 & Lmwbd.t1 & Lmwbd.t2 & Lmwbd.t3 & Lmwbd.t4 & Lmwbd.t5 & Lmwbd.t6 & Lmwbd.t7 & Lmwbd.t8 & Lmwbd.t9 & Lmwbd.p0 & Lmwbd.p1 & Lmwbd.fp & Lmwbd.gp & Lmwbd.lp & Lmwbd.sp { }
+Lmwa.regs: is LsmwBa=1 & LsmwId=0 & Lmwai.sp & Lmwai.lp & Lmwai.gp & Lmwai.fp & Lmwai.p1 & Lmwai.p0 & Lmwai.t9 & Lmwai.t8 & Lmwai.t7 & Lmwai.t6 & Lmwai.t5 & Lmwai.t4 & Lmwai.t3 & Lmwai.t2 & Lmwai.t1 & Lmwai.t0 & Lmwai.ta & Lmwai.s8 & Lmwai.s7 & Lmwai.s6 & Lmwai.s5 & Lmwai.s4 & Lmwai.s3 & Lmwai.s2 & Lmwai.s1 & Lmwai.s0 & Lmwai.a5 & Lmwai.a4 & Lmwai.a3 & Lmwai.a2 & Lmwai.a1 & Lmwai.a0 { }
+Lmwa.regs: is LsmwBa=1 & LsmwId=1 & Lmwad.a0 & Lmwad.a1 & Lmwad.a2 & Lmwad.a3 & Lmwad.a4 & Lmwad.a5 & Lmwad.s0 & Lmwad.s1 & Lmwad.s2 & Lmwad.s3 & Lmwad.s4 & Lmwad.s5 & Lmwad.s6 & Lmwad.s7 & Lmwad.s8 & Lmwad.ta & Lmwad.t0 & Lmwad.t1 & Lmwad.t2 & Lmwad.t3 & Lmwad.t4 & Lmwad.t5 & Lmwad.t6 & Lmwad.t7 & Lmwad.t8 & Lmwad.t9 & Lmwad.p0 & Lmwad.p1 & Lmwad.fp & Lmwad.gp & Lmwad.lp & Lmwad.sp { }
+Smwa.regs: is LsmwBa=0 & LsmwId=0 & Smwbi.sp & Smwbi.lp & Smwbi.gp & Smwbi.fp & Smwbi.p1 & Smwbi.p0 & Smwbi.t9 & Smwbi.t8 & Smwbi.t7 & Smwbi.t6 & Smwbi.t5 & Smwbi.t4 & Smwbi.t3 & Smwbi.t2 & Smwbi.t1 & Smwbi.t0 & Smwbi.ta & Smwbi.s8 & Smwbi.s7 & Smwbi.s6 & Smwbi.s5 & Smwbi.s4 & Smwbi.s3 & Smwbi.s2 & Smwbi.s1 & Smwbi.s0 & Smwbi.a5 & Smwbi.a4 & Smwbi.a3 & Smwbi.a2 & Smwbi.a1 & Smwbi.a0 { }
+Smwa.regs: is LsmwBa=0 & LsmwId=1 & Smwbd.a0 & Smwbd.a1 & Smwbd.a2 & Smwbd.a3 & Smwbd.a4 & Smwbd.a5 & Smwbd.s0 & Smwbd.s1 & Smwbd.s2 & Smwbd.s3 & Smwbd.s4 & Smwbd.s5 & Smwbd.s6 & Smwbd.s7 & Smwbd.s8 & Smwbd.ta & Smwbd.t0 & Smwbd.t1 & Smwbd.t2 & Smwbd.t3 & Smwbd.t4 & Smwbd.t5 & Smwbd.t6 & Smwbd.t7 & Smwbd.t8 & Smwbd.t9 & Smwbd.p0 & Smwbd.p1 & Smwbd.fp & Smwbd.gp & Smwbd.lp & Smwbd.sp { }
+Smwa.regs: is LsmwBa=1 & LsmwId=0 & Smwai.sp & Smwai.lp & Smwai.gp & Smwai.fp & Smwai.p1 & Smwai.p0 & Smwai.t9 & Smwai.t8 & Smwai.t7 & Smwai.t6 & Smwai.t5 & Smwai.t4 & Smwai.t3 & Smwai.t2 & Smwai.t1 & Smwai.t0 & Smwai.ta & Smwai.s8 & Smwai.s7 & Smwai.s6 & Smwai.s5 & Smwai.s4 & Smwai.s3 & Smwai.s2 & Smwai.s1 & Smwai.s0 & Smwai.a5 & Smwai.a4 & Smwai.a3 & Smwai.a2 & Smwai.a1 & Smwai.a0 { }
+Smwa.regs: is LsmwBa=1 & LsmwId=1 & Smwad.a0 & Smwad.a1 & Smwad.a2 & Smwad.a3 & Smwad.a4 & Smwad.a5 & Smwad.s0 & Smwad.s1 & Smwad.s2 & Smwad.s3 & Smwad.s4 & Smwad.s5 & Smwad.s6 & Smwad.s7 & Smwad.s8 & Smwad.ta & Smwad.t0 & Smwad.t1 & Smwad.t2 & Smwad.t3 & Smwad.t4 & Smwad.t5 & Smwad.t6 & Smwad.t7 & Smwad.t8 & Smwad.t9 & Smwad.p0 & Smwad.p1 & Smwad.fp & Smwad.gp & Smwad.lp & Smwad.sp { }
diff --git a/Ghidra/Processors/NDS32/data/languages/nds32.cspec b/Ghidra/Processors/NDS32/data/languages/nds32.cspec
new file mode 100644
index 0000000000..f6608d63ce
--- /dev/null
+++ b/Ghidra/Processors/NDS32/data/languages/nds32.cspec
@@ -0,0 +1,104 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<compiler_spec>
+    <data_organization>
+        <absolute_max_alignment value="0" />
+        <machine_alignment value="2" />
+        <default_alignment value="1" />
+        <default_pointer_alignment value="4" />
+        <pointer_size value="4" />
+        <wchar_size value="2" />
+        <short_size value="2" />
+        <integer_size value="4" />
+        <long_size value="4" />
+        <long_long_size value="8" />
+        <float_size value="4" />
+        <double_size value="8" />
+        <long_double_size value="8" />
+        <size_alignment_map>
+            <entry size="1" alignment="1" />
+            <entry size="2" alignment="2" />
+            <entry size="4" alignment="4" />
+            <entry size="8" alignment="4" />
+        </size_alignment_map>
+    </data_organization>
+    <global>
+        <range space="ram"/>
+    </global>
+    <stackpointer register="sp" space="ram"/>
+    <returnaddress>
+        <register name="lp"/>
+    </returnaddress>
+    <default_proto>
+        <prototype name="__stdcall" extrapop="0" stackshift="0">
+            <input>
+                <pentry minsize="1" maxsize="4" extension="inttype">
+                    <register name="a0"/>
+                </pentry>
+                <pentry minsize="1" maxsize="4" extension="inttype">
+                    <register name="a1"/>
+                </pentry>
+                <pentry minsize="1" maxsize="4" extension="inttype">
+                    <register name="a2"/>
+                </pentry>
+                <pentry minsize="1" maxsize="4" extension="inttype">
+                    <register name="a3"/>
+                </pentry>
+                <pentry minsize="1" maxsize="4" extension="inttype">
+                    <register name="a4"/>
+                </pentry>
+                <pentry minsize="1" maxsize="4" extension="inttype">
+                    <register name="a5"/>
+                </pentry>
+                <pentry minsize="1" maxsize="500" align="4">
+                    <addr offset="24" space="stack"/>
+                </pentry>
+            </input>
+            <output killedbycall="true">
+                <pentry minsize="1" maxsize="4" extension="inttype">
+                    <register name="a0"/>
+                </pentry>
+                <pentry minsize="5" maxsize="8">
+                    <addr space="join" piece1="a1" piece2="a0"/>
+                </pentry>
+            </output>
+            <unaffected>
+                <register name="s0"/>
+                <register name="s1"/>
+                <register name="s2"/>
+                <register name="s3"/>
+                <register name="s4"/>
+                <register name="s5"/>
+                <register name="s6"/>
+                <register name="s7"/>
+                <register name="s8"/>
+
+                <register name="p0"/>
+                <register name="p1"/>
+                <register name="fp"/>
+                <register name="gp"/>
+                <register name="lp"/>
+                <register name="sp"/>
+            </unaffected>
+            <killedbycall>
+                <register name="a0"/>
+                <register name="a1"/>
+                <register name="a2"/>
+                <register name="a3"/>
+                <register name="a4"/>
+                <register name="a5"/>
+                <register name="ta"/>
+                <register name="t0"/>
+                <register name="t1"/>
+                <register name="t2"/>
+                <register name="t3"/>
+                <register name="t4"/>
+                <register name="t5"/>
+                <register name="t6"/>
+                <register name="t7"/>
+                <register name="t8"/>
+                <register name="t9"/>
+            </killedbycall>
+        </prototype>
+    </default_proto>
+</compiler_spec>
diff --git a/Ghidra/Processors/NDS32/data/languages/nds32.dwarf b/Ghidra/Processors/NDS32/data/languages/nds32.dwarf
new file mode 100644
index 0000000000..b254e363fd
--- /dev/null
+++ b/Ghidra/Processors/NDS32/data/languages/nds32.dwarf
@@ -0,0 +1,14 @@
+<dwarf>
+    <register_mappings>
+        <register_mapping dwarf="0" ghidra="a0" auto_count="6"/> <!-- a0..a5 -->
+        <register_mapping dwarf="6" ghidra="s0" auto_count="9"/> <!-- s0..s8 -->
+        <register_mapping dwarf="15" ghidra="ta"/>
+        <register_mapping dwarf="16" ghidra="t0" auto_count="10"/> <!-- t0..t9 -->
+        <register_mapping dwarf="26" ghidra="p0" auto_count="2"/> <!-- p0..p1 -->
+        <register_mapping dwarf="28" ghidra="fp"/>
+        <register_mapping dwarf="29" ghidra="gp"/>
+        <register_mapping dwarf="30" ghidra="lp"/>
+        <register_mapping dwarf="31" ghidra="sp" stackpointer="true"/>
+    </register_mappings>
+    <call_frame_cfa value="0"/>
+</dwarf>
diff --git a/Ghidra/Processors/NDS32/data/languages/nds32.ldefs b/Ghidra/Processors/NDS32/data/languages/nds32.ldefs
new file mode 100644
index 0000000000..0e89de40db
--- /dev/null
+++ b/Ghidra/Processors/NDS32/data/languages/nds32.ldefs
@@ -0,0 +1,30 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<language_definitions>
+  <language processor="NDS32"
+            endian="big"
+            instructionEndian="big"
+            size="32"
+            variant="default"
+            version="1.0"
+            slafile="nds32be.sla"
+            processorspec="nds32.pspec"
+            id="NDS32:BE:32:default">
+    <description>NDS32 default processor 32-bit big-endian</description>
+    <compiler name="default" spec="nds32.cspec" id="default"/>
+    <external_name tool="DWARF.register.mapping.file" name="nds32.dwarf"/>
+  </language>
+  <language processor="NDS32"
+            endian="little"
+            instructionEndian="big"
+            size="32"
+            variant="default"
+            version="1.0"
+            slafile="nds32le.sla"
+            processorspec="nds32.pspec"
+            id="NDS32:LE:32:default">
+    <description>NDS32 default processor 32-bit little-endian</description>
+    <compiler name="default" spec="nds32.cspec" id="default"/>
+    <external_name tool="DWARF.register.mapping.file" name="nds32.dwarf"/>
+  </language>
+</language_definitions>
diff --git a/Ghidra/Processors/NDS32/data/languages/nds32.opinion b/Ghidra/Processors/NDS32/data/languages/nds32.opinion
new file mode 100644
index 0000000000..bf744db132
--- /dev/null
+++ b/Ghidra/Processors/NDS32/data/languages/nds32.opinion
@@ -0,0 +1,5 @@
+<opinions>
+    <constraint loader="Executable and Linking Format (ELF)" compilerSpecID="default">
+        <constraint primary="167" processor="NDS32"  size="32" />
+    </constraint>
+</opinions>
diff --git a/Ghidra/Processors/NDS32/data/languages/nds32.pspec b/Ghidra/Processors/NDS32/data/languages/nds32.pspec
new file mode 100644
index 0000000000..0210d9209a
--- /dev/null
+++ b/Ghidra/Processors/NDS32/data/languages/nds32.pspec
@@ -0,0 +1,5 @@
+<?xml version="1.0" encoding="UTF-8"?>
+
+<processor_spec>
+    <programcounter register="pc"/>
+</processor_spec>
diff --git a/Ghidra/Processors/NDS32/data/languages/nds32.sinc b/Ghidra/Processors/NDS32/data/languages/nds32.sinc
new file mode 100644
index 0000000000..39aa3cd5e1
--- /dev/null
+++ b/Ghidra/Processors/NDS32/data/languages/nds32.sinc
@@ -0,0 +1,1079 @@
+### General ###
+
+define endian=big;
+define alignment=2;
+define space ram type=ram_space size=4 wordsize=1 default;
+define space register type=register_space size=4;
+
+define register offset=0 size=4
+[a0 a1 a2 a3 a4 a5 s0 s1 s2 s3 s4 s5 s6 s7 s8 ta t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 p0 p1 fp gp lp sp];
+
+define register offset=0x90 size=4
+[pc ipc mult_addr mult_inc];
+
+define register offset=0x100 size=8
+[d0 d1];
+
+define register offset=0x100 size=4
+[d0.hi d0.lo d1.hi d1.lo];
+
+
+
+define token instr32(32)
+    OpSz        = (31, 31)
+    Opc         = (25, 30)
+    Rt          = (20, 24)
+    Rth         = (21, 24)
+    Rtl         = (21, 24)
+    Ra          = (15, 19)
+    Rb          = (10, 14)
+    Rd          = (5, 9)
+    Rs          = (5, 9)
+    Sub5        = (0, 4)
+    Sub6        = (0, 5)
+    Sub8        = (0, 7)
+    Imm5u       = (10, 14)
+    Imm5s       = (10, 14) signed
+    Br1t        = (14, 14)
+    Br2t        = (16, 19)
+    Alu2Mod     = (6, 9)
+    Dtl         = (22, 24)
+    Dt          = (21, 21)
+    Dtlow       = (21, 21)
+    Dthigh      = (21, 21)
+    Dtr         = (20, 20)
+    JIt         = (24, 24)
+    Imm19s      = (0, 18) signed
+    Imm18s      = (0, 17) signed
+    Imm17s      = (0, 16) signed
+    Imm16s      = (0, 15) signed
+    Imm14s      = (0, 13) signed
+    Imm15u      = (0, 14)
+    Imm15s      = (0, 14) signed
+    Imm20u      = (0, 19)
+    Imm20s      = (0, 19) signed
+    Imm24s      = (0, 23) signed
+    Imm11s		= (8, 18) signed
+    Imm8s		= (0, 7) signed
+    sv          = (8, 9)
+    SrIdx       = (10, 19)
+    Swid        = (5, 19)
+
+    CctlZ       = (11, 14)
+    CctlLevel   = (10, 10)
+    CctlSub     = (5, 9)
+
+    MsyncZ      = (8, 19)
+    MsyncSub    = (5, 7)
+
+    DtIt        = (8, 9)
+    Jz          = (6, 7)
+    JrHint      = (5, 5)
+
+    ToggleL     = (21, 24)
+    Toggle      = (20, 20)
+
+    Usr         = (15, 19)
+    Group       = (10, 14)
+
+    DprefD      = (24, 24)
+    DprefSub    = (20, 23)
+
+    TlbopSub    = (5, 9)
+
+    StandbyZ    = (7, 9)
+    StandbySub  = (5, 6)
+
+    GpSub1      = (19, 19)
+    GpSub2      = (18, 19)
+    GpSub3      = (17, 19)
+
+    sh          = (5, 9)
+
+    Bxxc		= (19, 19)
+
+    LsmwRa = (15, 19)
+    LsmwRb = (20, 24)
+    LsmwRb_ = (20, 24)
+    LsmwRe = (10, 14)
+    LsmwRe_ = (10, 14)
+    Enable4 = (6, 9)
+    Enable4_fp = (9, 9)
+    Enable4_gp = (8, 8)
+    Enable4_lp = (7, 7)
+    Enable4_sp = (6, 6)
+    LsmwLs = (5, 5)
+    LsmwBa = (4, 4)
+    LsmwId = (3, 3)
+    LsmwM = (2, 2)
+    LsmwSub = (0, 1)
+;
+
+attach variables [Rt Rs Ra Rb Rd LsmwRa LsmwRb LsmwRe] [
+    a0 a1 a2 a3 a4 a5 s0 s1 s2 s3 s4 s5 s6 s7 s8 ta t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 p0 p1 fp gp lp sp
+];
+
+attach variables [Rtl] [
+    a0 a2 a4 s0 s2 s4 s6 s8 t0 t2 t4 t6 t8 p0 fp lp
+];
+
+attach variables [Rth] [
+    a1 a3 a5 s1 s3 s5 s7 ta t1 t3 t5 t7 t9 p1 gp sp
+];
+
+attach variables [Dt] [
+    d0 d1
+];
+
+attach variables [Dtlow] [
+    d0.lo d1.lo
+];
+
+attach variables [Dthigh] [
+    d0.hi d1.hi
+];
+
+
+@define I32     "(OpSz=0)"
+@define ALU_1   "(Opc=0b100000)"
+@define ALU_2   "(Opc=0b100001)"
+@define ALU2Z   "(Alu2Mod=0b0000)"
+@define GPR     "(Alu2Mod=0b0001)"
+@define BR1     "(Opc=0b100110)"
+@define BR2     "(Opc=0b100111)"
+@define BR3     "(Opc=0b101101)"
+@define LSMW    "(Opc=0b011101)"
+@define JI      "(Opc=0b100100)"
+@define MEM     "(Opc=0b011100)"
+@define MISC    "(Opc=0b110010)"
+@define JREG    "(Opc=0b100101)"
+@define SBGP    "(Opc=0b011111)"
+@define LBGP    "(Opc=0b010111)"
+@define HWGP    "(Opc=0b011110)"
+@define SIMD    "(Opc=0b111000)"
+
+
+
+### ALU Instruction with Immediate ###
+
+:addi  Rt, Ra, Imm15s is $(I32) & Opc=0b101000 & Rt & Ra & Imm15s { Rt = Ra + Imm15s; }
+:subri Rt, Ra, Imm15s is $(I32) & Opc=0b101001 & Rt & Ra & Imm15s { Rt = Imm15s - Ra; }
+:andi  Rt, Ra, Imm15u is $(I32) & Opc=0b101010 & Rt & Ra & Imm15u { Rt = Ra & Imm15u; }
+:ori   Rt, Ra, Imm15u is $(I32) & Opc=0b101100 & Rt & Ra & Imm15u { Rt = Ra | Imm15u; }
+:xori  Rt, Ra, Imm15u is $(I32) & Opc=0b101011 & Rt & Ra & Imm15u { Rt = Ra ^ Imm15u; }
+:slti  Rt, Ra, Imm15s is $(I32) & Opc=0b101110 & Rt & Ra & Imm15s { Rt = zext(Ra < Imm15s); }
+:sltsi Rt, Ra, Imm15s is $(I32) & Opc=0b101111 & Rt & Ra & Imm15s { Rt = zext(Ra s< Imm15s); }
+:movi  Rt,     Imm20s is $(I32) & Opc=0b100010 & Rt & Imm20s      { Rt = Imm20s; }
+:sethi Rt,     Imm20u is $(I32) & Opc=0b100011 & Rt & Imm20u      { Rt = Imm20u << 12;}
+
+
+### ALU Instruction ###
+
+:add  Rt, Ra, Rb is $(I32) & $(ALU_1) & Rt & Ra & Rb & Rd=0 & Sub5=0b00000 { Rt = Ra + Rb; }
+:sub  Rt, Ra, Rb is $(I32) & $(ALU_1) & Rt & Ra & Rb & Rd=0 & Sub5=0b00001 { Rt = Ra - Rb; }
+:and  Rt, Ra, Rb is $(I32) & $(ALU_1) & Rt & Ra & Rb & Rd=0 & Sub5=0b00010 { Rt = Ra & Rb; }
+:xor  Rt, Ra, Rb is $(I32) & $(ALU_1) & Rt & Ra & Rb & Rd=0 & Sub5=0b00011 { Rt = Ra ^ Rb; }
+:or   Rt, Ra, Rb is $(I32) & $(ALU_1) & Rt & Ra & Rb & Rd=0 & Sub5=0b00100 { Rt = Ra | Rb; }
+:nor  Rt, Ra, Rb is $(I32) & $(ALU_1) & Rt & Ra & Rb & Rd=0 & Sub5=0b00101 { Rt = ~(Ra | Rb); }
+:slt  Rt, Ra, Rb is $(I32) & $(ALU_1) & Rt & Ra & Rb & Rd=0 & Sub5=0b00110 { Rt = zext(Ra < Rb); }
+:slts Rt, Ra, Rb is $(I32) & $(ALU_1) & Rt & Ra & Rb & Rd=0 & Sub5=0b00111 { Rt = zext(Ra s< Rb); }
+:sva  Rt, Ra, Rb is $(I32) & $(ALU_1) & Rt & Ra & Rb & Rd=0 & Sub5=0b11000 { Rt = zext(scarry(Ra, Rb)); }
+:svs  Rt, Ra, Rb is $(I32) & $(ALU_1) & Rt & Ra & Rb & Rd=0 & Sub5=0b11001 { Rt = zext(sborrow(Ra, Rb)); }
+:seb  Rt, Ra     is $(I32) & $(ALU_1) & Rt & Ra & Rb=0b00000 & Rd=0 & Sub5=0b10000 { local tmp = Ra; Rt = sext(tmp:1); }
+:seh  Rt, Ra     is $(I32) & $(ALU_1) & Rt & Ra & Rb=0b00000 & Rd=0 & Sub5=0b10001 { local tmp = Ra; Rt = sext(tmp:2); }
+:zeb  Rt, Ra     is $(I32) & Opc=0b101010 & Rt & Ra & Imm15u=0xff                  { local tmp = Ra; Rt = zext(tmp:1); }
+:zeh  Rt, Ra     is $(I32) & $(ALU_1) & Rt & Ra & Rb=0b00000 & Rd=0 & Sub5=0b10011 { local tmp = Ra; Rt = zext(tmp:2); }
+:wsbh Rt, Ra     is $(I32) & $(ALU_1) & Rt & Ra & Rb=0b00000 & Rd=0 & Sub5=0b10100
+{
+    Rt = ((Ra & 0x000000ff) << 8)
+       | ((Ra & 0x0000ff00) >> 8)
+       | ((Ra & 0x00ff0000) << 8)
+       | ((Ra & 0xff000000) >> 8);
+}
+
+
+### Shifter Instruction ###
+
+:slli  Rt, Ra, Imm5u is $(I32) & $(ALU_1) & Rt & Ra & Imm5u & Rd=0 & Sub5=0b01000 { Rt = Ra  << Imm5u; }
+:srli  Rt, Ra, Imm5u is $(I32) & $(ALU_1) & Rt & Ra & Imm5u & Rd=0 & Sub5=0b01001 { Rt = Ra  >> Imm5u; }
+:srai  Rt, Ra, Imm5u is $(I32) & $(ALU_1) & Rt & Ra & Imm5u & Rd=0 & Sub5=0b01010 { Rt = Ra s>> Imm5u; }
+:rotri Rt, Ra, Imm5u is $(I32) & $(ALU_1) & Rt & Ra & Imm5u & Rd=0 & Sub5=0b01011 { Rt = (Ra >> Imm5u) | (Ra << (32 - Imm5u)); }
+:sll   Rt, Ra, Rb    is $(I32) & $(ALU_1) & Rt & Ra & Rb    & Rd=0 & Sub5=0b01100 { tmp:4 = Rb & 0b11111; Rt = Ra  << tmp; }
+:srl   Rt, Ra, Rb    is $(I32) & $(ALU_1) & Rt & Ra & Rb    & Rd=0 & Sub5=0b01101 { tmp:4 = Rb & 0b11111; Rt = Ra  >> tmp; }
+:sra   Rt, Ra, Rb    is $(I32) & $(ALU_1) & Rt & Ra & Rb    & Rd=0 & Sub5=0b01110 { tmp:4 = Rb & 0b11111; Rt = Ra s>> tmp; }
+:rotr  Rt, Ra, Rb    is $(I32) & $(ALU_1) & Rt & Ra & Rb    & Rd=0 & Sub5=0b01111 { tmp:4 = Rb & 0b11111; Rt = (Ra >> tmp) | (Ra << (32 - tmp)); }
+
+
+### Multiply Instruction ###
+
+:mul     Rt,    Ra, Rb is $(I32) & $(ALU_2) & Rt                    & Ra & Rb & $(ALU2Z) & Sub6=0b100100 { Rt = Ra * Rb; }
+:mults64 Dt,    Ra, Rb is $(I32) & $(ALU_2) & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & $(ALU2Z) & Sub6=0b101000 { Dt = sext(Ra) * sext(Rb); }
+:mult64  Dt,    Ra, Rb is $(I32) & $(ALU_2) & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & $(ALU2Z) & Sub6=0b101001 { Dt = zext(Ra) * zext(Rb); }
+:madds64 Dt,    Ra, Rb is $(I32) & $(ALU_2) & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & $(ALU2Z) & Sub6=0b101010 { Dt = Dt + (sext(Ra) * sext(Rb)); }
+:madd64  Dt,    Ra, Rb is $(I32) & $(ALU_2) & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & $(ALU2Z) & Sub6=0b101011 { Dt = Dt + (zext(Ra) * zext(Rb)); }
+:msubs64 Dt,    Ra, Rb is $(I32) & $(ALU_2) & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & $(ALU2Z) & Sub6=0b101100 { Dt = Dt - (sext(Ra) * sext(Rb)); }
+:msub64  Dt,    Ra, Rb is $(I32) & $(ALU_2) & Dtl=0 & Dt    & Dtr=0 & Ra & Rb & $(ALU2Z) & Sub6=0b101101 { Dt = Dt - (zext(Ra) * zext(Rb)); }
+:mult32  Dtlow, Ra, Rb is $(I32) & $(ALU_2) & Dtl=0 & Dtlow & Dtr=0 & Ra & Rb & $(ALU2Z) & Sub6=0b110001 { Dtlow = Ra * Rb; }
+:madd32  Dtlow, Ra, Rb is $(I32) & $(ALU_2) & Dtl=0 & Dtlow & Dtr=0 & Ra & Rb & $(ALU2Z) & Sub6=0b110011 { Dtlow = Dtlow + (Ra * Rb); }
+:msub32  Dtlow, Ra, Rb is $(I32) & $(ALU_2) & Dtl=0 & Dtlow & Dtr=0 & Ra & Rb & $(ALU2Z) & Sub6=0b110101 { Dtlow = Dtlow - (Ra * Rb); }
+
+
+# TODO : special instruction, but used get the division results
+# There are more special registers
+UsrName: d0.lo is Group=0 & Usr=0 & d0.lo { export d0.lo; }
+UsrName: d0.hi is Group=0 & Usr=1 & d0.hi { export d0.hi; }
+UsrName: d1.lo is Group=0 & Usr=2 & d1.lo { export d1.lo; }
+UsrName: d1.hi is Group=0 & Usr=3 & d1.hi { export d1.hi; }
+
+:mfusr Rt, UsrName is $(I32) & $(ALU_2) & Rt & UsrName & $(ALU2Z) & Sub6=0b100000 { UsrName = Rt; }
+:mtusr Rt, UsrName is $(I32) & $(ALU_2) & Rt & UsrName & $(ALU2Z) & Sub6=0b100001 { Rt = UsrName; }
+
+
+### Divide Instructions ###
+
+:div  Dt, Ra, Rb is $(I32) & $(ALU_2) & Dtl=0 & Dt & Dtlow & Dthigh & Dtr=0 & Ra & Rb & $(ALU2Z) & Sub6=0b101111 { Dtlow = Ra  / Rb; Dthigh = Ra  % Rb; }
+:divs Dt, Ra, Rb is $(I32) & $(ALU_2) & Dtl=0 & Dt & Dtlow & Dthigh & Dtr=0 & Ra & Rb & $(ALU2Z) & Sub6=0b101110 { Dtlow = Ra s/ Rb; Dthigh = Ra s% Rb; }
+
+
+### Load / Store Instruction (immediate) ###
+
+ByteOffset: off is Imm15s [ off = Imm15s << 0; ] { export *[const]:4 off; }
+HalfOffset: off is Imm15s [ off = Imm15s << 1; ] { export *[const]:4 off; }
+WordOffset: off is Imm15s [ off = Imm15s << 2; ] { export *[const]:4 off; }
+
+AddrByteRaImm15s: [Ra + ByteOffset] is Ra & ByteOffset { addr:4 = Ra + ByteOffset; export addr; }
+AddrHalfRaImm15s: [Ra + HalfOffset] is Ra & HalfOffset { addr:4 = Ra + HalfOffset; export addr; }
+AddrWordRaImm15s: [Ra + WordOffset] is Ra & WordOffset { addr:4 = Ra + WordOffset; export addr; }
+
+:lwi  Rt, AddrWordRaImm15s is $(I32) & Opc=0b000010 & Rt & AddrWordRaImm15s { Rt = *AddrWordRaImm15s; }
+:lhi  Rt, AddrHalfRaImm15s is $(I32) & Opc=0b000001 & Rt & AddrHalfRaImm15s { local tmp:2 = *AddrHalfRaImm15s; Rt = zext(tmp); }
+:lhsi Rt, AddrHalfRaImm15s is $(I32) & Opc=0b010001 & Rt & AddrHalfRaImm15s { local tmp:2 = *AddrHalfRaImm15s; Rt = sext(tmp); }
+:lbi  Rt, AddrByteRaImm15s is $(I32) & Opc=0b000000 & Rt & AddrByteRaImm15s { local tmp:1 = *AddrByteRaImm15s; Rt = zext(tmp); }
+:lbsi Rt, AddrByteRaImm15s is $(I32) & Opc=0b010000 & Rt & AddrByteRaImm15s { local tmp:1 = *AddrByteRaImm15s; Rt = sext(tmp); }
+:swi  Rt, AddrWordRaImm15s is $(I32) & Opc=0b001010 & Rt & AddrWordRaImm15s { *AddrWordRaImm15s = Rt; }
+:shi  Rt, AddrHalfRaImm15s is $(I32) & Opc=0b001001 & Rt & AddrHalfRaImm15s { local tmp = Rt; *AddrHalfRaImm15s = tmp:2; }
+:sbi  Rt, AddrByteRaImm15s is $(I32) & Opc=0b001000 & Rt & AddrByteRaImm15s { local tmp = Rt; *AddrByteRaImm15s = tmp:1; }
+
+### Load / Store Instruction (immediate, postincr) ###
+
+:lwi.bi  Rt, [Ra], WordOffset is $(I32) & Opc=0b000110 & Rt & Ra & WordOffset { Rt = *Ra; Ra = Ra + WordOffset; }
+:lhi.bi  Rt, [Ra], HalfOffset is $(I32) & Opc=0b000101 & Rt & Ra & HalfOffset { local tmp:2 = *Ra; Rt = zext(tmp); Ra = Ra + HalfOffset; }
+:lhsi.bi Rt, [Ra], HalfOffset is $(I32) & Opc=0b010101 & Rt & Ra & HalfOffset { local tmp:2 = *Ra; Rt = sext(tmp); Ra = Ra + HalfOffset; }
+:lbi.bi  Rt, [Ra], ByteOffset is $(I32) & Opc=0b000100 & Rt & Ra & ByteOffset { local tmp:1 = *Ra; Rt = zext(tmp); Ra = Ra + ByteOffset; }
+:lbsi.bi Rt, [Ra], ByteOffset is $(I32) & Opc=0b010100 & Rt & Ra & ByteOffset { local tmp:1 = *Ra; Rt = sext(tmp); Ra = Ra + ByteOffset; }
+:swi.bi  Rt, [Ra], WordOffset is $(I32) & Opc=0b001110 & Rt & Ra & WordOffset { *Ra = Rt; Ra = Ra + WordOffset; }
+:shi.bi  Rt, [Ra], HalfOffset is $(I32) & Opc=0b001101 & Rt & Ra & HalfOffset { local tmp = Rt; *Ra = tmp:2; Ra = Ra + HalfOffset; }
+:sbi.bi  Rt, [Ra], ByteOffset is $(I32) & Opc=0b001100 & Rt & Ra & ByteOffset { local tmp = Rt; *Ra = tmp:1; Ra = Ra + ByteOffset; }
+
+
+### Load / Store Instruction (register) ###
+
+OffsetRbsv: (Rb "<<" sv) is Rb & sv { off:4 = Rb << sv; export off; }
+AddrRaRbsv: [Ra + OffsetRbsv] is Ra & OffsetRbsv { addr:4 = Ra + OffsetRbsv; export addr; }
+
+:lw  Rt, AddrRaRbsv is $(I32) & $(MEM) & Rt & AddrRaRbsv & Sub8=0b00000010 { Rt = *AddrRaRbsv; }
+:lh  Rt, AddrRaRbsv is $(I32) & $(MEM) & Rt & AddrRaRbsv & Sub8=0b00000001 { local tmp:2 = *AddrRaRbsv; Rt = zext(tmp); }
+:lhs Rt, AddrRaRbsv is $(I32) & $(MEM) & Rt & AddrRaRbsv & Sub8=0b00010001 { local tmp:2 = *AddrRaRbsv; Rt = sext(tmp); }
+:lb  Rt, AddrRaRbsv is $(I32) & $(MEM) & Rt & AddrRaRbsv & Sub8=0b00000000 { local tmp:1 = *AddrRaRbsv; Rt = zext(tmp); }
+:lbs Rt, AddrRaRbsv is $(I32) & $(MEM) & Rt & AddrRaRbsv & Sub8=0b00010000 { local tmp:1 = *AddrRaRbsv; Rt = sext(tmp); }
+:sw  Rt, AddrRaRbsv is $(I32) & $(MEM) & Rt & AddrRaRbsv & Sub8=0b00001010 { *AddrRaRbsv = Rt; }
+:sh  Rt, AddrRaRbsv is $(I32) & $(MEM) & Rt & AddrRaRbsv & Sub8=0b00001001 { local tmp = Rt; *AddrRaRbsv = tmp:2; }
+:sb  Rt, AddrRaRbsv is $(I32) & $(MEM) & Rt & AddrRaRbsv & Sub8=0b00001000 { local tmp = Rt; *AddrRaRbsv = tmp:1; }
+
+
+### Load / Store Instruction (register, postincr) ###
+
+:lw.bi  Rt, [Ra], OffsetRbsv is $(I32) & $(MEM) & Rt & Ra & OffsetRbsv & Sub8=0b00000110 { Rt = *Ra; Ra = Ra + OffsetRbsv; }
+:lh.bi  Rt, [Ra], OffsetRbsv is $(I32) & $(MEM) & Rt & Ra & OffsetRbsv & Sub8=0b00000101 { local tmp:2 = *Ra; Rt = zext(tmp); Ra = Ra + OffsetRbsv; }
+:lhs.bi Rt, [Ra], OffsetRbsv is $(I32) & $(MEM) & Rt & Ra & OffsetRbsv & Sub8=0b00010101 { local tmp:2 = *Ra; Rt = sext(tmp); Ra = Ra + OffsetRbsv; }
+:lb.bi  Rt, [Ra], OffsetRbsv is $(I32) & $(MEM) & Rt & Ra & OffsetRbsv & Sub8=0b00000100 { local tmp:1 = *Ra; Rt = zext(tmp); Ra = Ra + OffsetRbsv; }
+:lbs.bi Rt, [Ra], OffsetRbsv is $(I32) & $(MEM) & Rt & Ra & OffsetRbsv & Sub8=0b00010100 { local tmp:1 = *Ra; Rt = sext(tmp); Ra = Ra + OffsetRbsv; }
+:sw.bi  Rt, [Ra], OffsetRbsv is $(I32) & $(MEM) & Rt & Ra & OffsetRbsv & Sub8=0b00001110 { *Ra = Rt; Ra = Ra + OffsetRbsv; }
+:sh.bi  Rt, [Ra], OffsetRbsv is $(I32) & $(MEM) & Rt & Ra & OffsetRbsv & Sub8=0b00001101 { local tmp = Rt; *Ra = tmp:2; Ra = Ra + OffsetRbsv; }
+:sb.bi  Rt, [Ra], OffsetRbsv is $(I32) & $(MEM) & Rt & Ra & OffsetRbsv & Sub8=0b00001100 { local tmp = Rt; *Ra = tmp:1; Ra = Ra + OffsetRbsv; }
+
+
+### Load / Store Multiple Word Instruction ###
+
+# TODO : this is ugly
+@include "lsmw.sinc"
+
+LsmwBa_: "b" is LsmwBa=0 { }
+LsmwBa_: "a" is LsmwBa=1 { }
+
+LsmwId_: "i" is LsmwId=0 { }
+LsmwId_: "d" is LsmwId=1 { }
+
+LsmwM_: ""  is LsmwRa & LsmwM=0 { }
+LsmwM_: "m" is LsmwRa & LsmwM=1 { LsmwRa = mult_addr; }
+
+
+:lmw.^LsmwBa_^LsmwId_^LsmwM_ LsmwRb, [LsmwRa], LsmwRe, Enable4 is $(I32) & $(LSMW) & LsmwRb & LsmwRa & LsmwRe & Enable4 & LsmwLs=0 & LsmwBa_ & LsmwId_ & LsmwM_ & LsmwSub=0b00 & Lmw.regs
+{
+    mult_addr = LsmwRa;
+    build Lmw.regs;
+    build LsmwM_;
+}
+
+:smw.^LsmwBa_^LsmwId_^LsmwM_ LsmwRb, [LsmwRa], LsmwRe, Enable4 is $(I32) & $(LSMW) & LsmwRb & LsmwRa & LsmwRe & Enable4 & LsmwLs=1 & LsmwBa_ & LsmwId_ & LsmwM_ & LsmwSub=0b00 & Smw.regs
+{
+    mult_addr = LsmwRa;
+    build Smw.regs;
+    build LsmwM_;
+}
+
+
+### Load / Store Instruction for Atomic Updates ###
+
+:llw Rt, AddrRaRbsv is $(I32) & $(MEM) & Rt & AddrRaRbsv & Sub8=0b00011000 { Rt = *AddrRaRbsv; }
+:scw Rt, AddrRaRbsv is $(I32) & $(MEM) & Rt & AddrRaRbsv & Sub8=0b00011001 { *AddrRaRbsv = Rt; }
+
+
+### Load / Store Instructions with User-mode Privilege ###
+
+# TODO : special constraint (user-mode address translation)
+
+:lwup Rt, AddrRaRbsv is $(I32) & $(MEM) & Rt & AddrRaRbsv & Sub8=0b00100010 { Rt = *AddrRaRbsv; }
+:swup Rt, AddrRaRbsv is $(I32) & $(MEM) & Rt & AddrRaRbsv & Sub8=0b00101010 { *AddrRaRbsv = Rt; }
+
+
+### Jump Instruction ###
+
+Rel24: addr is Imm24s [ addr = inst_start + (Imm24s << 1); ] { export *:4 addr; }
+
+:j    Rel24 is $(I32) & $(JI)   & JIt=0 & Rel24 { goto Rel24; }
+:jal  Rel24 is $(I32) & $(JI)   & JIt=1 & Rel24 { lp = inst_next; call Rel24; }
+:jr   Rb    is $(I32) & $(JREG) & Rt=0 & Ra=0 & Rb & DtIt=0b00 & Jz=0 & JrHint=0 & Sub5=0b00000 { goto [Rb]; }
+:ret  Rb    is $(I32) & $(JREG) & Rt=0 & Ra=0 & Rb & DtIt=0b00 & Jz=0 & JrHint=1 & Sub5=0b00000 { return [Rb]; }
+:jral Rt,Rb is $(I32) & $(JREG) & Rt & Ra=0 & Rb & DtIt=0b00 & Jz=0 & JrHint=0 & Sub5=0b00001 { Rt = inst_next; call [Rb]; }
+
+
+### Branch Instruction ###
+Rel14: addr is Imm14s [ addr = inst_start + (Imm14s << 1); ] { export *:4 addr; }
+Rel16: addr is Imm16s [ addr = inst_start + (Imm16s << 1); ] { export *:4 addr; }
+
+:beq  Rt, Ra, Rel14 is $(I32) & $(BR1) & Rt & Ra & Br1t=0 & Rel14 { if(Rt == Ra) goto Rel14; }
+:bne  Rt, Ra, Rel14 is $(I32) & $(BR1) & Rt & Ra & Br1t=1 & Rel14 { if(Rt != Ra) goto Rel14; }
+:beqz Rt,     Rel16 is $(I32) & $(BR2) & Rt & Br2t=0b0010 & Rel16 { if(Rt == 0)  goto Rel16; }
+:bnez Rt,     Rel16 is $(I32) & $(BR2) & Rt & Br2t=0b0011 & Rel16 { if(Rt != 0)  goto Rel16; }
+:bgez Rt,     Rel16 is $(I32) & $(BR2) & Rt & Br2t=0b0100 & Rel16 { if(Rt s>= 0) goto Rel16; }
+:bltz Rt,     Rel16 is $(I32) & $(BR2) & Rt & Br2t=0b0101 & Rel16 { if(Rt s< 0)  goto Rel16; }
+:bgtz Rt,     Rel16 is $(I32) & $(BR2) & Rt & Br2t=0b0110 & Rel16 { if(Rt s> 0)  goto Rel16; }
+:blez Rt,     Rel16 is $(I32) & $(BR2) & Rt & Br2t=0b0111 & Rel16 { if(Rt s<= 0) goto Rel16; }
+
+
+### Branch with link Instruction ###
+
+:bgezal Rt, Rel16 is $(I32) & $(BR2) & Rt & Br2t=0b1100 & Rel16
+{
+    lp = inst_next;
+    if(Rt s>= 0) goto <end>;
+        call Rel16;
+    <end>
+}
+
+:bltzal Rt, Rel16 is $(I32) & $(BR2) & Rt & Br2t=0b1101 & Rel16
+{
+    lp = inst_next;
+    if(Rt s< 0) goto <end>;
+        call Rel16;
+    <end>
+}
+
+
+### Read / Write System Registers ###
+
+# TODO : special instruction, do we create the system registers ?
+define pcodeop mfsr;
+define pcodeop mtsr;
+
+:mfsr Rt, SrIdx is $(I32) & $(MISC) & Rt & SrIdx & Rd=0 & Sub5=0b00010 { Rt = mfsr(SrIdx:4); }
+:mtsr Rt, SrIdx is $(I32) & $(MISC) & Rt & SrIdx & Rd=0 & Sub5=0b00011 { mtsr(SrIdx:4, Rt:4); }
+
+
+### Jump Register with System Register Update ###
+
+# TODO : special constraint (address translation off)
+
+:jr.itoff  Rb    is $(I32) & $(JREG) & Rt=0 & Ra=0 & Rb & DtIt=0b01 & Jz=0 & JrHint=0 & Sub5=0b00000 { goto [Rb]; }
+:jr.toff   Rb    is $(I32) & $(JREG) & Rt=0 & Ra=0 & Rb & DtIt=0b11 & Jz=0 & JrHint=0 & Sub5=0b00000 { goto [Rb]; }
+:jral.iton Rt,Rb is $(I32) & $(JREG) & Rt   & Ra=0 & Rb & DtIt=0b01 & Jz=0 & JrHint=0 & Sub5=0b00001 { Rt = inst_next; call [Rb]; }
+:jral.ton  Rt,Rb is $(I32) & $(JREG) & Rt   & Ra=0 & Rb & DtIt=0b11 & Jz=0 & JrHint=0 & Sub5=0b00001 { Rt = inst_next; call [Rb]; }
+
+
+### MMU Instruction ###
+
+define pcodeop TLB_TargetRead;
+define pcodeop TLB_TargetWrite;
+define pcodeop TLB_RWrite;
+define pcodeop TLB_RWriteLock;
+define pcodeop TLB_Unlock;
+define pcodeop TLB_Probe;
+define pcodeop TLB_Invalidate;
+define pcodeop TLB_FlushAll;
+
+:tlbop Ra,"TargetRead"  is $(I32) & $(MISC) & Rt & Ra & Rb=0 & TlbopSub=0 & Sub5=0b01110 { TLB_TargetRead(Ra:4); }
+:tlbop Ra,"TargetWrite" is $(I32) & $(MISC) & Rt & Ra & Rb=0 & TlbopSub=1 & Sub5=0b01110 { TLB_TargetWrite(Ra:4); }
+:tlbop Ra,"RWrite"      is $(I32) & $(MISC) & Rt & Ra & Rb=0 & TlbopSub=2 & Sub5=0b01110 { TLB_RWrite(Ra:4); }
+:tlbop Ra,"RWriteLock"  is $(I32) & $(MISC) & Rt & Ra & Rb=0 & TlbopSub=3 & Sub5=0b01110 { TLB_RWriteLock(Ra:4); }
+:tlbop Ra,"Unlock"      is $(I32) & $(MISC) & Rt & Ra & Rb=0 & TlbopSub=4 & Sub5=0b01110 { TLB_Unlock(Ra:4); }
+:tlbop Rt,Ra,"Probe"    is $(I32) & $(MISC) & Rt & Ra & Rb=0 & TlbopSub=5 & Sub5=0b01110 { TLB_Probe(Rt:4, Ra:4); }
+:tlbop Ra,"Invalidate"  is $(I32) & $(MISC) & Rt & Ra & Rb=0 & TlbopSub=6 & Sub5=0b01110 { TLB_Invalidate(Ra:4); }
+:tlbop "FlushAll"       is $(I32) & $(MISC) & Rt & Ra & Rb=0 & TlbopSub=7 & Sub5=0b01110 { TLB_FlushAll(); }
+
+
+### Conditional Move ###
+
+:cmovz Rt, Ra, Rb is $(I32) & $(ALU_1) & Rt & Ra & Rb & Rd=0 & Sub5=0b11010
+{
+    if(Rb != 0) goto <end>;
+        Rt = Ra;
+    <end>
+}
+
+:cmovn Rt, Ra, Rb is $(I32) & $(ALU_1) & Rt & Ra & Rb & Rd=0 & Sub5=0b11011
+{
+    if(Rb == 0) goto <end>;
+        Rt = Ra;
+    <end>
+}
+
+
+### Synchronization Instruction ###
+
+# TODO : special function, and subfunctions
+
+define pcodeop msync;
+define pcodeop isync;
+
+:msync MsyncSub is $(I32) & $(MISC) & Rt=0 & MsyncZ=0 & MsyncSub & Sub5=0b01100 { msync(MsyncSub:1); }
+:isync Rt       is $(I32) & $(MISC) & Rt & Ra=0 & Rb=0 & Rd=0    & Sub5=0b01101 { isync(Rt:4); }
+
+### Prefetch Instruction ###
+
+define pcodeop dpref;
+
+OffsetRbsv2: (Rb "<<" sv) is Rb & sv { off:4 = Rb << (sv + 1); export off; }
+AddrRaRbsv2: [Ra + OffsetRbsv2] is Ra & OffsetRbsv2 { addr:4 = Ra + OffsetRbsv2; export addr; }
+
+:dpref DprefSub, AddrRaRbsv2 is $(I32) & $(MEM) & DprefD=0 & DprefSub & AddrRaRbsv2 & Sub8=0b00010011 {
+    dpref(DprefSub:1, AddrRaRbsv2:4);
+}
+
+DprefD_: "w" is DprefD=0 { }
+DprefD_: "d" is DprefD=1 { }
+
+DprefiAddr: [Ra + Offset] is DprefD=0 & Ra & Imm15s [ Offset = Imm15s << 2; ] { export *[const]:4 Offset; }
+DprefiAddr: [Ra + Offset] is DprefD=1 & Ra & Imm15s [ Offset = Imm15s << 3; ] { export *[const]:4 Offset; }
+
+:dprefi.^DprefD_ DprefSub, DprefiAddr is $(I32) & Opc=0b010011 & DprefD_ & DprefSub & DprefiAddr {
+    dpref(DprefSub:1, DprefiAddr:4);
+}
+
+
+### NOP Instruction ###
+
+:nop is $(I32) & $(ALU_1) & Rt=0 & Ra=0 & Imm5u=0 & Rd=0 & Sub5=0b01001 { }
+
+
+### Serialization Instruction ###
+
+define pcodeop dsb;
+define pcodeop isb;
+
+:dsb is $(I32) & $(MISC) & Rt=0 & Ra=0 & Rb=0 & Rd=0 & Sub5=0b01000 { dsb(); }
+:isb is $(I32) & $(MISC) & Rt=0 & Ra=0 & Rb=0 & Rd=0 & Sub5=0b01001 { isb(); }
+
+
+### Exception Generation Instruction ###
+
+define pcodeop break;
+define pcodeop syscall;
+define pcodeop trap;
+
+:break   Swid is $(I32) & $(MISC) & Rt=0 & Swid & Sub5=0b01010 { break(Swid:4); }
+:syscall Swid is $(I32) & $(MISC) & Rt=0 & Swid & Sub5=0b01011 { syscall(Swid:4); }
+:trap    Swid is $(I32) & $(MISC) & Rt=0 & Swid & Sub5=0b00101 { trap(Swid:4); }
+
+:teqz Rt, Swid is $(I32) & $(MISC) & Rt & Swid & Sub5=0b00110
+{
+    if(Rt != 0) goto <end>;
+        trap(Swid:4);
+    <end>
+}
+
+:tnez Rt, Swid is $(I32) & $(MISC) & Rt & Swid & Sub5=0b00111
+{
+    if(Rt == 0) goto <end>;
+        trap(Swid:4);
+    <end>
+}
+
+
+### Special Return Instruction ###
+
+:iret is $(I32) & $(MISC) & Rt=0 & Ra=0 & Rb=0 & Rd=0 & Sub5=0b00100 { return [ipc]; }
+
+# TODO : special constraint (address translation off)
+:ret.itoff Rb is $(I32) & $(JREG) & Rt=0 & Ra=0 & Rb & DtIt=0b01 & Jz=0 & JrHint=1 & Sub5=0b00000 { return [Rb]; }
+:ret.toff  Rb is $(I32) & $(JREG) & Rt=0 & Ra=0 & Rb & DtIt=0b11 & Jz=0 & JrHint=1 & Sub5=0b00000 { return [Rb]; }
+
+
+### Cache Control Instruction ###
+
+# TODO : special function, with subfunctions
+define pcodeop cctl;
+
+:cctl Rt, Ra, CctlLevel, CctlSub is $(I32) & $(MISC) & Rt & Ra & CctlZ=0 & CctlLevel & CctlSub & Sub5=0b00001 { cctl(Rt:4, Ra:4, CctlLevel:1, CctlSub:1); }
+
+
+# Miscellaneous Instructions (Baseline)
+
+# TODO : special function. Not sure if we use context or registers for this.
+
+define pcodeop setgie;
+
+SetgieEN: "d" is Toggle=0 { setgie(0:1); }
+SetgieEN: "e" is Toggle=1 { setgie(1:1); }
+
+:setgie.^SetgieEN is $(I32) & $(MISC) & ToggleL=0 & SetgieEN & SrIdx=0b0010000000 & Rd=0b00010 & Sub5=0b00011 { }
+
+define pcodeop setend;
+
+SetendBE: "l" is Toggle=0 { setend(0:1); }
+SetendBE: "b" is Toggle=1 { setend(1:1); }
+
+:setend.^SetendBE is $(I32) & $(MISC) & ToggleL=0 & SetendBE & SrIdx=0b0010000000 & Rd=0b00001 & Sub5=0b00011 { }
+
+:standby StandbySub is $(I32) & $(MISC) & Rt=0 & Ra=0 & Rb=0 & StandbyZ=0 & StandbySub & Sub5=0b00000 { goto inst_start; }
+
+
+
+### 32-bit Baseline V2 instructions ###
+
+@if defined(BASELINE_V2)
+
+### ALU Instructions ###
+
+:addi.gp is $(I32) & $(SBGP) & Rt & GpSub1=0b1 & Imm19s { Rt = gp + Imm19s; }
+
+
+### Multiply and Divide Instructions (V2) ###
+
+:mulr64 Rt, Ra, Rb is $(I32) & $(ALU_2) & Rt & Ra & Rb & $(GPR) & Sub6=0b101001 & Rtl & Rth
+{
+    res:8 = zext(Ra) * zext(Rb);
+@if ENDIAN == "big"
+    Rtl = res(4);
+    Rth = res:4;
+@else
+    Rtl = res:4;
+    Rth = res(4);
+@endif
+}
+
+:mulsr64 Rt, Ra, Rb is $(I32) & $(ALU_2) & Rt & Ra & Rb & $(GPR) & Sub6=0b101000 & Rtl & Rth
+{
+    res:8 = sext(Ra) * sext(Rb);
+@if ENDIAN == "big"
+    Rtl = res(4);
+    Rth = res:4;
+@else
+    Rtl = res:4;
+    Rth = res(4);
+@endif
+}
+
+:maddr32 Rt, Ra, Rb is $(I32) & $(ALU_2) & Rt & Ra & Rb & $(GPR) & Sub6=0b110011 { Rt = Rt + (Ra * Rb); }
+:msubr32 Rt, Ra, Rb is $(I32) & $(ALU_2) & Rt & Ra & Rb & $(GPR) & Sub6=0b110101 { Rt = Rt - (Ra * Rb); }
+:divr    Rt, Rs, Ra, Rb is $(I32) & $(ALU_1) & Rt & Ra & Rb & Rs & Sub5=0b10111 { local div = Ra / Rb; local mod = Ra % Rb; Rs = mod; Rt = div; }
+:divsr   Rt, Rs, Ra, Rb is $(I32) & $(ALU_1) & Rt & Ra & Rb & Rs & Sub5=0b10110 { local div = Ra s/ Rb; local mod = Ra s% Rb; Rs = mod; Rt = div; }
+
+
+### Load/Store Instructions ###
+
+GpByteAddress: [+ off] is Imm19s [ off = Imm19s << 0; ] { addr:4 = gp + off; export addr; }
+GpHalfAddress: [+ off] is Imm18s [ off = Imm18s << 1; ] { addr:4 = gp + off; export addr; }
+GpWordAddress: [+ off] is Imm17s [ off = Imm17s << 2; ] { addr:4 = gp + off; export addr; }
+
+:lbi.gp Rt,  GpByteAddress is $(I32) & $(LBGP) & Rt & GpSub1=0b0   & GpByteAddress { local tmp:1 = *GpByteAddress; Rt = zext(tmp); }
+:lbsi.gp Rt, GpByteAddress is $(I32) & $(LBGP) & Rt & GpSub1=0b1   & GpByteAddress { local tmp:1 = *GpByteAddress; Rt = sext(tmp); }
+:lhi.gp Rt,  GpHalfAddress is $(I32) & $(HWGP) & Rt & GpSub2=0b00  & GpHalfAddress { local tmp:2 = *GpHalfAddress; Rt = zext(tmp); }
+:lhsi.gp Rt, GpHalfAddress is $(I32) & $(HWGP) & Rt & GpSub2=0b01  & GpHalfAddress { local tmp:2 = *GpHalfAddress; Rt = sext(tmp); }
+:lwi.gp Rt,  GpWordAddress is $(I32) & $(HWGP) & Rt & GpSub3=0b110 & GpWordAddress { Rt = *GpWordAddress; }
+:sbi.gp Rt,  GpByteAddress is $(I32) & $(SBGP) & Rt & GpSub1=0b0   & GpByteAddress { local tmp = Rt; *GpByteAddress = tmp:1; }
+:shi.gp Rt,  GpHalfAddress is $(I32) & $(HWGP) & Rt & GpSub2=0b10  & GpHalfAddress { local tmp = Rt; *GpHalfAddress = tmp:2; }
+:swi.gp Rt,  GpWordAddress is $(I32) & $(HWGP) & Rt & GpSub3=0b111 & GpWordAddress { *GpWordAddress = Rt; }
+
+# TODO : same as lmw/smw, this is horrible
+
+:lmwa.^LsmwBa_^LsmwId_^LsmwM_ LsmwRb, [LsmwRa], LsmwRe, Enable4 is $(I32) & $(LSMW) & LsmwRb & LsmwRa & LsmwRe & Enable4 & LsmwLs=0 & LsmwBa_ & LsmwId_ & LsmwM_ & LsmwSub=0b01 & Lmwa.regs
+{
+    mult_addr = LsmwRa;
+    build Lmwa.regs;
+    build LsmwM_;
+}
+
+:smwa.^LsmwBa_^LsmwId_^LsmwM_ LsmwRb, [LsmwRa], LsmwRe, Enable4 is $(I32) & $(LSMW) & LsmwRb & LsmwRa & LsmwRe & Enable4 & LsmwLs=1 & LsmwBa_ & LsmwId_ & LsmwM_ & LsmwSub=0b01 & Smwa.regs
+{
+    mult_addr = LsmwRa;
+    build Smwa.regs;
+    build LsmwM_;
+}
+
+:lbup Rt, AddrRaRbsv is $(I32) & $(MEM) & Rt & AddrRaRbsv & Sub8=0b00100000 { local tmp:1 = *AddrRaRbsv; Rt = zext(tmp); }
+:sbup Rt, AddrRaRbsv is $(I32) & $(MEM) & Rt & AddrRaRbsv & Sub8=0b00101000 { local tmp = Rt; *AddrRaRbsv = tmp:1; }
+
+@endif
+
+
+
+### 32-bit Baseline V3 instructions ###
+
+@if defined(BASELINE_V3)
+
+### ALU Instructions with Shift Operation (v3) ###
+
+:add_slli Rt, Ra, Rb, sh is $(I32) & $(ALU_1) & Rt & Ra & Rb & sh & Sub5=0b00000 { Rt = Ra + (Rb << sh); }
+:and_slli Rt, Ra, Rb, sh is $(I32) & $(ALU_1) & Rt & Ra & Rb & sh & Sub5=0b00010 { Rt = Ra & (Rb << sh); }
+:or_slli  Rt, Ra, Rb, sh is $(I32) & $(ALU_1) & Rt & Ra & Rb & sh & Sub5=0b00100 { Rt = Ra | (Rb << sh); }
+:sub_slli Rt, Ra, Rb, sh is $(I32) & $(ALU_1) & Rt & Ra & Rb & sh & Sub5=0b00001 { Rt = Ra - (Rb << sh); }
+:xor_slli Rt, Ra, Rb, sh is $(I32) & $(ALU_1) & Rt & Ra & Rb & sh & Sub5=0b00011 { Rt = Ra ^ (Rb << sh); }
+
+:add_srli Rt, Ra, Rb, sh is $(I32) & $(ALU_1) & Rt & Ra & Rb & sh & Sub5=0b11100 { Rt = Ra + (Rb << sh); }
+:and_srli Rt, Ra, Rb, sh is $(I32) & $(ALU_1) & Rt & Ra & Rb & sh & Sub5=0b11110 { Rt = Ra & (Rb << sh); }
+:or_srli  Rt, Ra, Rb, sh is $(I32) & $(ALU_1) & Rt & Ra & Rb & sh & Sub5=0b10101 { Rt = Ra | (Rb << sh); }
+:sub_srli Rt, Ra, Rb, sh is $(I32) & $(ALU_1) & Rt & Ra & Rb & sh & Sub5=0b11101 { Rt = Ra - (Rb << sh); }
+:xor_srli Rt, Ra, Rb, sh is $(I32) & $(ALU_1) & Rt & Ra & Rb & sh & Sub5=0b11111 { Rt = Ra ^ (Rb << sh); }
+
+### Conditional Branch and Jump Instructions (V3) ###
+
+Rel8: addr is Imm8s [ addr = inst_start + (Imm8s << 1); ] { export *:4 addr; }
+:beqc  Rt, Imm11s, Rel8 is $(I32) & $(BR3) & Rt & Bxxc=0 & Imm11s & Rel8 { if(Rt == Imm11s) goto Rel8; }
+:bnec  Rt, Imm11s, Rel8 is $(I32) & $(BR3) & Rt & Bxxc=1 & Imm11s & Rel8 { if(Rt != Imm11s) goto Rel8; }
+
+:jralnez Rt,Rb is $(I32) & $(JREG) & Rt & Ra=0 & Rb & DtIt=0b00 & Jz=0 & JrHint=0 & Sub5=0b00011 { if(Rb == 0) goto <end>; Rt = inst_next; call [Rb]; <end> }
+:jrnez   Rb    is $(I32) & $(JREG) & Rt=0 & Ra=0 & Rb & DtIt=0b00 & Jz=0 & JrHint=0 & Sub5=0b00010 { if(Rb == 0) goto <end>; goto [Rb]; <end> }
+
+### Bit Manipulation Instructions (V3) ###
+
+:bitc  Rt, Ra, Rb     is $(I32) & $(ALU_1) & Rt & Ra & Rb & Rd=0 & Sub5=0b10010 { Rt = Ra & (~Rb); }
+:bitci Rt, Ra, Imm15u is $(I32) & Opc=0b110011 & Rt & Ra & Imm15u { Rt = Ra & (~Imm15u); }
+
+### Cache Control Instruction (V3) ###
+
+# TODO: Add CCTL L1D_WBALL, level
+
+@endif
+
+
+
+### 32-bit ISA extension ###
+
+### ALU Instruction (Performance) ###
+
+@if defined(PERFORMANCE_V1)
+
+:abs Rt, Ra is $(I32) & $(ALU_2) & Rt & Ra & Rb=0 & $(ALU2Z) & Sub6=0b000011
+{
+    gez:4 = zext(Ra s>= 0);
+    ltz:4 = zext(Ra s< 0);
+    Rt = (Ra * gez) | ((-Ra) * ltz);
+}
+
+:ave Rt, Ra, Rb is $(I32) & $(ALU_2) & Rt & Ra & Rb & $(ALU2Z) & Sub6=0b000010
+{
+    Rt = (Ra + Rb + 1) s>> 2;
+}
+
+:max Rt, Ra, Rb is $(I32) & $(ALU_2) & Rt & Ra & Rb & $(ALU2Z) & Sub6=0b000000
+{
+    altb:4 = zext(Ra s< Rb);
+    ageb:4 = zext(Ra s>= Rb);
+    Rt = (Ra * ageb) | (Rb * altb);
+}
+
+:min Rt, Ra, Rb is $(I32) & $(ALU_2) & Rt & Ra & Rb & $(ALU2Z) & Sub6=0b000001
+{
+    altb:4 = zext(Ra s< Rb);
+    ageb:4 = zext(Ra s>= Rb);
+    Rt = (Ra * altb) | (Rb * ageb);
+}
+
+:bset Rt, Ra, Imm5u is $(I32) & $(ALU_2) & Rt & Ra & Imm5u & $(ALU2Z) & Sub6=0b001000 { Rt = Ra | (1 << Imm5u); }
+:bclr Rt, Ra, Imm5u is $(I32) & $(ALU_2) & Rt & Ra & Imm5u & $(ALU2Z) & Sub6=0b001001 { Rt = Ra & ~(1 << Imm5u); }
+:btgl Rt, Ra, Imm5u is $(I32) & $(ALU_2) & Rt & Ra & Imm5u & $(ALU2Z) & Sub6=0b001010 { Rt = Ra ^ (1 << Imm5u); }
+:btst Rt, Ra, Imm5u is $(I32) & $(ALU_2) & Rt & Ra & Imm5u & $(ALU2Z) & Sub6=0b001011 { Rt = (Ra >> Imm5u) & 1; }
+
+:clips Rt, Ra, Imm5u is $(I32) & $(ALU_2) & Rt & Ra & Imm5u & $(ALU2Z) & Sub6=0b000100
+{
+    local upper:4 = (1 << Imm5u) - 1;
+    local lower:4 = -(1 << Imm5u);
+    if(Ra s<= upper) goto <elif>;
+        Rt = upper;
+        goto <end>;
+    <elif>
+    if(Ra s>= lower) goto <else>;
+        Rt = lower;
+        goto <end>;
+    <else>
+        Rt = Ra;
+    <end>
+}
+:clip Rt, Ra, Imm5u is $(I32) & $(ALU_2) & Rt & Ra & Imm5u & $(ALU2Z) & Sub6=0b000101
+{
+    local upper:4 = (1 << Imm5u) - 1;
+    if(Ra s<= upper) goto <elif>;
+        Rt = upper;
+        goto <end>;
+    <elif>
+    if(Ra s>= 0) goto <else>;
+        Rt = 0;
+        goto <end>;
+    <else>
+        Rt = Ra;
+    <end>
+}
+
+:clz Rt, Ra is $(I32) & $(ALU_2) & Rt & Ra & Imm5u=0 & $(ALU2Z) & Sub6=0b000111
+{
+  countTmp:4 = 0;
+  inputTmp:4 = Ra;
+
+ <loopbegin>
+  if ((inputTmp & 0x80000000) != 0) goto <loopend>;
+
+  countTmp = countTmp + 1;
+  inputTmp = (inputTmp << 1) | 1;
+  goto <loopbegin>;
+
+ <loopend>
+  Rt = countTmp;
+}
+
+:clo Rt, Ra is $(I32) & $(ALU_2) & Rt & Ra & Imm5u=0 & $(ALU2Z) & Sub6=0b000110
+{
+  countTmp:4 = 0;
+  inputTmp:4 = Ra;
+
+ <loopbegin>
+  if ((inputTmp & 0x80000000) == 0) goto <loopend>;
+
+  countTmp = countTmp + 1;
+  inputTmp = (inputTmp << 1) | 1;
+  goto <loopbegin>;
+
+ <loopend>
+  Rt = countTmp;
+}
+
+@endif
+
+
+### Performance Extension V2 ###
+
+@if defined(PERFORMANCE_V2)
+
+# TODO : arithmetic functions: bs*
+:bse is $(I32) & $(ALU_2) & Rt & Ra & Rb & $(ALU2Z) & Sub6=0b001100 unimpl
+:bsp is $(I32) & $(ALU_2) & Rt & Ra & Rb & $(ALU2Z) & Sub6=0b001101 unimpl
+
+macro add_abs_diff(dst, src1, src2, shift)
+{
+    local src1_ = src1 >> shift;
+    local src2_ = src2 >> shift;
+    local src1__ = src1_:1;
+    local src2__ = src2_:1;
+    local a:1 = src1__ - src2__;
+    local agez:1 = zext(a s>= 0);
+    local altz:1 = zext(a s< 0);
+    local aabs:1 = (a * agez) | ((-a) * altz);
+    dst = dst + zext(aabs);
+}
+:pbsad Rt, Ra, Rb is $(I32) & $(SIMD) & Rt & Ra & Rb & Rd=0 & Sub5=0b0000
+{
+    Rt = 0;
+    add_abs_diff(Rt, Ra, Rb, 0);
+    add_abs_diff(Rt, Ra, Rb, 8);
+    add_abs_diff(Rt, Ra, Rb, 16);
+    add_abs_diff(Rt, Ra, Rb, 24);
+}
+:pbsada Rt, Ra, Rb is $(I32) & $(SIMD) & Rt & Ra & Rb & Rd=0 & Sub5=0b0001
+{
+    add_abs_diff(Rt, Ra, Rb, 0);
+    add_abs_diff(Rt, Ra, Rb, 8);
+    add_abs_diff(Rt, Ra, Rb, 16);
+    add_abs_diff(Rt, Ra, Rb, 24);
+}
+
+@endif
+
+
+
+
+########### 16b ############
+
+define token instr16(16)
+    opsz        = (15, 15)
+    opc4        = (11, 14)
+    opc5        = (10, 14)
+    opc6        = (9, 14)
+    opc7        = (8, 14)
+    opc8        = (7, 14)
+    opc10       = (5, 14)
+    re2         = (5, 6)
+    rt5         = (5, 9)
+    ra4         = (5, 8)
+    rt4         = (5, 8)
+    ra5         = (0, 4)
+    rb5         = (0, 4)
+    rt5b        = (0, 4)
+    rt3         = (6, 8)
+    rt3b        = (8, 10)
+    ra3         = (3, 5)
+    rb3         = (0, 2)
+    imm3u       = (0, 2)
+    imm3ub      = (3, 5)
+    imm5u       = (0, 4)
+    imm5s       = (0, 4) signed
+    imm6u       = (0, 5)
+    imm7u       = (0, 6)
+    imm8s       = (0, 7) signed
+    imm10s      = (0, 9) signed
+    xwi37_ls    = (7, 7)
+    swid9       = (0, 8)
+    rt5e1       = (4, 7)
+    rt5e2       = (4, 7)
+    ra5e1       = (0, 3)
+    ra5e2       = (0, 3)
+;
+
+attach variables [rt5 ra5 rb5 rt5b] [
+    a0 a1 a2 a3 a4 a5 s0 s1 s2 s3 s4 s5 s6 s7 s8 ta t0 t1 t2 t3 t4 t5 t6 t7 t8 t9 p0 p1 fp gp lp sp
+];
+
+attach variables [ra4 rt4] [
+    a0 a1 a2 a3 a4 a5 s0 s1 s2 s3 s4 s5 t0 t1 t2 t3
+];
+
+attach variables [rt3 ra3 rt3b rb3] [
+    a0 a1 a2 a3 a4 a5 s0 s1
+];
+
+attach variables [ra5e1 rt5e1] [
+    a0 a2 a4 s0 s2 s4 s6 s8 t0 t2 t4 t6 t8 p0 fp lp
+];
+attach variables [ra5e2 rt5e2] [
+    a1 a3 a5 s1 s3 s5 s7 ta t1 t3 t5 t7 t9 p1 gp sp
+];
+
+attach variables [re2] [
+    s0 s2 s4 s8
+];
+
+
+@define I16     "(opsz=1)"
+@define BFMI333 "(opc6=0b001011)"
+@define XWI37   "(opc4=0b0111)"
+@define XWI37SP "(opc4=0b1110)"
+@define MISC33  "(opc6=0b111111)"
+
+
+### Move Instruction ###
+
+:movi55 rt5, imm5s is $(I16) & opc5=0b00001 & rt5 & imm5s { rt5 = imm5s; }
+:mov55  rt5,   ra5 is $(I16) & opc5=0b00000 & rt5 & ra5   { rt5 = ra5; }
+
+
+### Add/Sub Instruction with Immediate ###
+
+:addi45  rt4,      imm5u is $(I16) & opc6=0b000110 & rt4       & imm5u { rt4 = rt4 + imm5u; }
+:addi333 rt3, ra3, imm3u is $(I16) & opc6=0b001110 & rt3 & ra3 & imm3u { rt3 = ra3 + imm3u; }
+:subi45  rt4,      imm5u is $(I16) & opc6=0b000111 & rt4       & imm5u { rt4 = rt4 - imm5u; }
+:subi333 rt3, ra3, imm3u is $(I16) & opc6=0b001111 & rt3 & ra3 & imm3u { rt3 = ra3 - imm3u; }
+
+
+### Add/Sub Instruction ###
+
+:add45   rt4,      rb5 is $(I16) & opc6=0b000100 & rt4       & rb5 { rt4 = rt4 + rb5; }
+:add333  rt3, ra3, rb3 is $(I16) & opc6=0b001100 & rt3 & ra3 & rb3 { rt3 = ra3 + rb3; }
+:sub45   rt4,      rb5 is $(I16) & opc6=0b000101 & rt4       & rb5 { rt4 = rt4 - rb5; }
+:sub333  rt3, ra3, rb3 is $(I16) & opc6=0b001101 & rt3 & ra3 & rb3 { rt3 = ra3 - rb3; }
+
+
+### Shift Instruction with Immediate ###
+
+:srai45  rt4,      imm5u is $(I16) & opc6=0b001000 & rt4       & imm5u { rt4 = rt4 s>> imm5u; }
+:srli45  rt4,      imm5u is $(I16) & opc6=0b001001 & rt4       & imm5u { rt4 = rt4 >> imm5u; }
+:slli333 rt3, ra3, imm3u is $(I16) & opc6=0b001010 & rt3 & ra3 & imm3u { rt3 = ra3 << imm3u; }
+
+
+### Bit Field Mask Instruction with Immediate ###
+
+:zeb33  rt3, ra3 is $(I16) & $(BFMI333) & rt3 & ra3 & imm3u=0b000 { local tmp = ra3; rt3 = zext(tmp:1); }
+:zeh33  rt3, ra3 is $(I16) & $(BFMI333) & rt3 & ra3 & imm3u=0b001 { local tmp = ra3; rt3 = zext(tmp:2); }
+:seb33  rt3, ra3 is $(I16) & $(BFMI333) & rt3 & ra3 & imm3u=0b010 { local tmp = ra3; rt3 = sext(tmp:1); }
+:seh33  rt3, ra3 is $(I16) & $(BFMI333) & rt3 & ra3 & imm3u=0b011 { local tmp = ra3; rt3 = sext(tmp:2); }
+:xlsb33 rt3, ra3 is $(I16) & $(BFMI333) & rt3 & ra3 & imm3u=0b100 { rt3 = ra3 & 1; }
+:x11b33 rt3, ra3 is $(I16) & $(BFMI333) & rt3 & ra3 & imm3u=0b101 { rt3 = ra3 & 0x7ff; }
+
+
+### Load / Store Instruction ###
+
+:lwi450 rt4,[ra5] is $(I16) & opc6=0b011010 & rt4 & ra5 { rt4 = *ra5; }
+
+rel3w: off is imm3u [ off = imm3u << 2; ] { export *[const]:4 off; }
+rel3h: off is imm3u [ off = imm3u << 1; ] { export *[const]:4 off; }
+rel3b: off is imm3u [ off = imm3u << 0 ; ] { export *[const]:4 off; }
+ra3_rel3w: [ra3 + rel3w] is ra3 & rel3w { addr:4 = ra3 + rel3w; export addr; }
+ra3_rel3h: [ra3 + rel3h] is ra3 & rel3h { addr:4 = ra3 + rel3h; export addr; }
+ra3_rel3b: [ra3 + rel3b] is ra3 & rel3b { addr:4 = ra3 + rel3b; export addr; }
+
+:lwi333    rt3, ra3_rel3w    is $(I16) & opc6=0b010000 & rt3 & ra3_rel3w   { rt3 = *ra3_rel3w; }
+:lwi333.bi rt3, [ra3], rel3w is $(I16) & opc6=0b010001 & rt3 & ra3 & rel3w { rt3 = *ra3; ra3 = ra3 + rel3w; }
+:lhi333    rt3, ra3_rel3h    is $(I16) & opc6=0b010010 & rt3 & ra3_rel3h   { local tmp:2 = *ra3_rel3h; rt3 = zext(tmp); }
+:lbi333    rt3, ra3_rel3b    is $(I16) & opc6=0b010011 & rt3 & ra3_rel3b   { local tmp:1 = *ra3_rel3b; rt3 = zext(tmp); }
+:swi450    rt4, [ra5]        is $(I16) & opc6=0b011011 & rt4 & ra5         { *ra5 = rt4; }
+:swi333    rt3, ra3_rel3w    is $(I16) & opc6=0b010100 & rt3 & ra3_rel3w   { *ra3_rel3w = rt3; }
+:swi333.bi rt3, [ra3], rel3w is $(I16) & opc6=0b010101 & rt3 & ra3 & rel3w { *ra3 = rt3; ra3 = ra3 + rel3w; }
+:shi333    rt3, ra3_rel3h    is $(I16) & opc6=0b010110 & rt3 & ra3_rel3h   { local tmp = rt3; *ra3_rel3h = tmp:2; }
+:sbi333    rt3, ra3_rel3b    is $(I16) & opc6=0b010111 & rt3 & ra3_rel3b   { local tmp = rt3; *ra3_rel3b = tmp:1; }
+
+
+### Load/Store Instruction with Implied FP ###
+
+rel7w: off is imm7u [ off = imm7u << 2; ] { export *[const]:4 off; }
+fp_rel7w: [fp + rel7w] is fp & rel7w { addr:4 = fp + rel7w; export addr; }
+
+:lwi37 rt3b, fp_rel7w is $(I16) & rt3b & $(XWI37) & xwi37_ls=0 & fp_rel7w { rt3b = *fp_rel7w; }
+:swi37 rt3b, fp_rel7w is $(I16) & rt3b & $(XWI37) & xwi37_ls=1 & fp_rel7w { *fp_rel7w = rt3b; }
+
+
+### Branch and Jump Instruction ###
+
+rel8: addr is imm8s [ addr = inst_start + (imm8s << 1); ] { export *:4 addr; }
+
+
+:beqs38 rt3b,rel8 is $(I16) & opc4=0b1010 & rt3b & rel8 { if(a5 == rt3b) goto rel8; }
+:bnes38 rt3b,rel8 is $(I16) & opc4=0b1011 & rt3b & rel8 { if(a5 != rt3b) goto rel8; }
+:beqz38 rt3b,rel8 is $(I16) & opc4=0b1000 & rt3b & rel8 { if(rt3b == 0) goto rel8; }
+:bnez38 rt3b,rel8 is $(I16) & opc4=0b1001 & rt3b & rel8 { if(rt3b != 0) goto rel8; }
+
+:j8    rel8 is $(I16) & opc7=0b1010101     & rel8 { goto rel8; }
+:jr5   rb5  is $(I16) & opc10=0b1011101000 & rb5  { goto [rb5]; }
+:ret5  rb5  is $(I16) & opc10=0b1011101100 & rb5  { return [rb5]; }
+:jral5 rb5  is $(I16) & opc10=0b1011101001 & rb5  { lp = inst_next; call [rb5]; }
+
+
+### Compare and Branch Instruction ###
+
+:slti45  ra4, imm5u is $(I16) & opc6=0b110011 & ra4 & imm5u { ta = zext(ra4 < imm5u); }
+:sltsi45 ra4, imm5u is $(I16) & opc6=0b110010 & ra4 & imm5u { ta = zext(ra4 s< imm5u); }
+:slt45   ra4, rb5   is $(I16) & opc6=0b110001 & ra4 & rb5   { ta = zext(ra4 < rb5); }
+:slts45  ra4, rb5   is $(I16) & opc6=0b110000 & ra4 & rb5   { ta = zext(ra4 s< rb5); }
+
+:beqzs8 rel8 is $(I16) & opc7=0b1101000 & rel8 { if(ta == 0) goto rel8; }
+:bnezs8 rel8 is $(I16) & opc7=0b1101001 & rel8 { if(ta != 0) goto rel8; }
+
+
+### Misc Instruction ###
+
+:break16 swid9 is $(I16) & opc6=0b110101 & swid9 { break(swid9:4); }
+:nop16 is $(I16) & opc6=0b001001 & rt4=0b0000 & imm5u=0b00000 { }
+
+
+### ALU Instructions (V2) ###
+
+@if defined(BASELINE_V2)
+
+:addi10.sp imm10s is $(I16) & opc5=0b11011 & imm10s { sp = sp + imm10s; }
+
+
+### Load/Store Instruction (V2) ###
+
+sp_rel7w: [+ rel7w] is rel7w { addr:4 = sp + rel7w; export addr; }
+
+:lwi37.sp rt3b, sp_rel7w is $(I16) & rt3b & $(XWI37SP) & xwi37_ls=0 & sp_rel7w { rt3b = *sp_rel7w; }
+:swi37.sp rt3b, sp_rel7w is $(I16) & rt3b & $(XWI37SP) & xwi37_ls=1 & sp_rel7w { *sp_rel7w = rt3b; }
+
+@endif
+
+
+
+### 16-bit Baseline V3 instructions ###
+
+@if defined(BASELINE_V3)
+
+### ALU Instructions (V3 16-bit) ###
+
+imm6u_: imm8 is imm6u [ imm8 = imm6u << 2; ] { export *[const]:4 imm8; }
+:addri36.sp rt3, imm6u_ is $(I16) & opc6=0b011000 & rt3 & imm6u_ { rt3 = sp + imm6u_; }
+:add5.pc rt5b is $(I16) & opc10=0b1011101101 & rt5b { rt5b = pc + rt5b; }
+:and33 rt3, ra3 is $(I16) & $(MISC33) & rt3 & ra3 & imm3u=0b110 { rt3 = rt3 & ra3; }
+:neg33 rt3, ra3 is $(I16) & $(MISC33) & rt3 & ra3 & imm3u=0b010 { rt3 = -ra3; }
+:not33 rt3, ra3 is $(I16) & $(MISC33) & rt3 & ra3 & imm3u=0b011 { rt3 = ~ra3; }
+:or33  rt3, ra3 is $(I16) & $(MISC33) & rt3 & ra3 & imm3u=0b111 { rt3 = rt3 | ra3; }
+:xor33 rt3, ra3 is $(I16) & $(MISC33) & rt3 & ra3 & imm3u=0b101 { rt3 = rt3 ^ ra3; }
+
+### Bit Manipulation Instructions (V3 16-bit) ###
+
+:bmski33 rt3, imm3ub is $(I16) & opc6=0b001011 & rt3 & imm3ub & imm3u=0b110 { rt3 = (rt3 >> imm3ub) & 1; }
+:fexti33 rt3, imm3ub is $(I16) & opc6=0b001011 & rt3 & imm3ub & imm3u=0b111 { rt3 = rt3 & ((1 << (imm3ub + 1)) - 1); }
+
+### Misc. Instructions (V3 16-bit) ###
+
+imm7n: off is imm5u [ off = -((32 - imm5u) << 2); ] { export *[const]:4 off; }
+:lwi45.fe rt4, [imm7n] is $(I16) & opc6=0b011001 & rt4 & imm7n { addr:4 = s2 + imm7n; rt4 = *addr; }
+
+:movd44 rt5e1, ra5e1 is $(I16) & opc7=0b1111101 & rt5e1 & rt5e2 & ra5e1 & ra5e2 { rt5e1 = ra5e1; rt5e2 = ra5e2; }
+
+imm5u_: imm6 is imm5u [ imm6 = imm5u + 16; ] { export *[const]:4 imm6; }
+:movpi45 rt4, imm5u_ is $(I16) & opc6=0b111101 & rt4 & imm5u_ { rt4 = imm5u_; }
+
+:mul33  rt3, ra3 is $(I16) & $(MISC33) & rt3 & ra3 & imm3u=0b100 { rt3 = rt3 * ra3; }
+
+# Note: POP25 and PUSH25 are highly untested ! And they just look messy :/
+imm5u__: imm8 is imm5u [ imm8 = imm5u << 3; ] { export *[const]:4 imm8; }
+
+macro push25_special() { Smwad(lp); Smwad(gp); Smwad(fp); }
+macro push25_s0() { Smwad(s0); }
+macro push25_s2() { Smwad(s2); Smwad(s1); push25_s0(); }
+macro push25_s4() { Smwad(s4); Smwad(s3); push25_s2(); }
+macro push25_s8() { Smwad(s8); Smwad(s7); Smwad(s6); Smwad(s5); push25_s4(); }
+
+push25_re: re2 is re2 & re2=0 { push25_s0(); }
+push25_re: re2 is re2 & re2=1 { push25_s2(); }
+push25_re: re2 is re2 & re2=2 { push25_s4(); }
+push25_re: re2 is re2 & re2=3 { push25_s8(); }
+
+:push25 push25_re, imm5u__ is $(I16) & opc8=0b11111000 & re2 & push25_re & imm5u__ {
+	mult_addr = sp;
+	push25_special();
+	build push25_re;
+	sp = mult_addr - imm5u__;
+	if(re2 < 1) goto <end>;
+		s2 = pc & 0xfffffffc;
+	<end>
+}
+
+macro pop25_special() { Lmwbi(fp); Lmwbi(gp); Lmwbi(lp);   }
+macro pop25_s0() { Lmwbi(s0); }
+macro pop25_s2() { pop25_s0(); Lmwbi(s1); Lmwbi(s2); }
+macro pop25_s4() { pop25_s2(); Lmwbi(s3); Lmwbi(s4); }
+macro pop25_s8() { pop25_s4(); Lmwbi(s5); Lmwbi(s6); Lmwbi(s7); Lmwbi(s8); }
+
+pop25_re: re2 is re2 & re2=0 { pop25_s0(); }
+pop25_re: re2 is re2 & re2=1 { pop25_s2(); }
+pop25_re: re2 is re2 & re2=2 { pop25_s4(); }
+pop25_re: re2 is re2 & re2=3 { pop25_s8(); }
+
+:pop25 pop25_re, imm5u__ is $(I16) & opc8=0b11111001 & re2 & pop25_re & imm5u__ {
+	mult_addr = sp;
+	build pop25_re;
+	pop25_special();
+	sp = mult_addr + imm5u__;
+	return [lp];
+}
+
+
+@endif
diff --git a/Ghidra/Processors/NDS32/data/languages/nds32be.slaspec b/Ghidra/Processors/NDS32/data/languages/nds32be.slaspec
new file mode 100644
index 0000000000..40714ad394
--- /dev/null
+++ b/Ghidra/Processors/NDS32/data/languages/nds32be.slaspec
@@ -0,0 +1,7 @@
+@define BASELINE_V2 "yes"
+@define BASELINE_V3 "yes"
+@define PERFORMANCE_V1 "yes"
+@define PERFORMANCE_V2 "yes"
+@define ENDIAN "big"
+
+@include "nds32.sinc"
diff --git a/Ghidra/Processors/NDS32/data/languages/nds32le.slaspec b/Ghidra/Processors/NDS32/data/languages/nds32le.slaspec
new file mode 100644
index 0000000000..ee6a1b9c48
--- /dev/null
+++ b/Ghidra/Processors/NDS32/data/languages/nds32le.slaspec
@@ -0,0 +1,7 @@
+@define BASELINE_V2 "yes"
+@define BASELINE_V3 "yes"
+@define PERFORMANCE_V1 "yes"
+@define PERFORMANCE_V2 "yes"
+@define ENDIAN "little"
+
+@include "nds32.sinc"
diff --git a/Ghidra/Processors/NDS32/data/patterns/nds32_patterns.xml b/Ghidra/Processors/NDS32/data/patterns/nds32_patterns.xml
new file mode 100644
index 0000000000..5cbde241f9
--- /dev/null
+++ b/Ghidra/Processors/NDS32/data/patterns/nds32_patterns.xml
@@ -0,0 +1,13 @@
+<patternlist>
+  <patternpairs totalbits="32" postbits="16">
+    <prepatterns>
+        <data>0xd5 ........</data>
+        <data>0x48 ........ ........ ........</data>
+        <data>0x92 0x00</data>
+    </prepatterns>
+    <postpatterns>
+       <data>0011101. ....1111 1......0 .0111100</data>
+       <funcstart/>
+    </postpatterns>
+  </patternpairs>
+</patternlist>
diff --git a/Ghidra/Processors/NDS32/data/patterns/patternconstraints.xml b/Ghidra/Processors/NDS32/data/patterns/patternconstraints.xml
new file mode 100644
index 0000000000..735a59bec2
--- /dev/null
+++ b/Ghidra/Processors/NDS32/data/patterns/patternconstraints.xml
@@ -0,0 +1,5 @@
+<patternconstraints>
+  <language id="NDS32:*:*:*">
+    <patternfile>nds32_patterns.xml</patternfile>
+  </language>
+</patternconstraints>
diff --git a/Ghidra/Processors/NDS32/data/sleighArgs.txt b/Ghidra/Processors/NDS32/data/sleighArgs.txt
new file mode 100644
index 0000000000..ce06926358
--- /dev/null
+++ b/Ghidra/Processors/NDS32/data/sleighArgs.txt
@@ -0,0 +1,6 @@
+# Add sleigh compiler options to this file (one per line) which will
+# be used when compiling each language within this module.
+# All options should start with a '-' character.
+#
+# IMPORTANT: The -a option should NOT be specified
+#
\ No newline at end of file
diff --git a/Ghidra/Processors/NDS32/src/main/java/ghidra/app/plugin/core/analysis/NDS32Analyzer.java b/Ghidra/Processors/NDS32/src/main/java/ghidra/app/plugin/core/analysis/NDS32Analyzer.java
new file mode 100644
index 0000000000..74c3824c25
--- /dev/null
+++ b/Ghidra/Processors/NDS32/src/main/java/ghidra/app/plugin/core/analysis/NDS32Analyzer.java
@@ -0,0 +1,187 @@
+package ghidra.app.plugin.core.analysis;
+
+import java.math.BigInteger;
+
+import ghidra.app.util.importer.MessageLog;
+import ghidra.framework.options.Options;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.address.AddressSet;
+import ghidra.program.model.address.AddressSetView;
+import ghidra.program.model.lang.Processor;
+import ghidra.program.model.lang.Register;
+import ghidra.program.model.lang.RegisterValue;
+import ghidra.program.model.listing.ContextChangeException;
+import ghidra.program.model.listing.Function;
+import ghidra.program.model.listing.Instruction;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.listing.ProgramContext;
+import ghidra.program.model.symbol.FlowType;
+import ghidra.program.model.symbol.Symbol;
+import ghidra.program.model.symbol.SymbolUtilities;
+import ghidra.program.util.ContextEvaluator;
+import ghidra.program.util.SymbolicPropogator;
+import ghidra.program.util.VarnodeContext;
+import ghidra.util.Msg;
+import ghidra.util.exception.AssertException;
+import ghidra.util.exception.CancelledException;
+import ghidra.util.task.TaskMonitor;
+
+public class NDS32Analyzer extends ConstantPropagationAnalyzer {
+	private final static String PROCESSOR_NAME = "NDS32";
+
+	private static final String SWITCH_OPTION_NAME = "Switch Table Recovery";
+	private static final String SWITCH_OPTION_DESCRIPTION = "Turn on to recover switch tables (not implemented yet !)";
+	private static final boolean SWITCH_OPTION_DEFAULT_VALUE = false;
+
+	private static final String RECOVER_GP_OPTION_NAME = "Recover global GP register writes";
+	private static final String RECOVER_GP_OPTION_DESCRIPTION = "Reads the global GP value from the symbol _SDA_BASE_";
+	private static final boolean RECOVER_GP_OPTION_DEFAULT_VALUE = true;
+
+
+	private boolean recoverSwitchTables = SWITCH_OPTION_DEFAULT_VALUE;
+	private boolean recoverGp = RECOVER_GP_OPTION_DEFAULT_VALUE;
+
+	private Address gpAssumptionValue = null;
+
+	private Register gp;
+
+	public NDS32Analyzer() {
+		super(PROCESSOR_NAME);
+	}
+
+	@Override
+	public boolean canAnalyze(Program program) {
+		boolean canAnalyze = program.getLanguage().getProcessor().equals(
+			Processor.findOrPossiblyCreateProcessor(PROCESSOR_NAME));
+
+		if (!canAnalyze) {
+			return false;
+		}
+
+		gp = program.getRegister("gp");
+
+		return true;
+	}
+
+	@Override
+	public void optionsChanged(Options options, Program program) {
+		super.optionsChanged(options, program);
+
+		options.registerOption(SWITCH_OPTION_NAME, recoverSwitchTables, null,
+				SWITCH_OPTION_DESCRIPTION);
+		recoverSwitchTables = options.getBoolean(SWITCH_OPTION_NAME, recoverSwitchTables);
+
+		options.registerOption(RECOVER_GP_OPTION_NAME, recoverGp, null,
+				RECOVER_GP_OPTION_DESCRIPTION);
+		recoverGp = options.getBoolean(RECOVER_GP_OPTION_NAME, recoverGp);
+	}
+
+	@Override
+	public boolean added(Program program, AddressSetView set, TaskMonitor monitor, MessageLog log)
+			throws CancelledException {
+		gpAssumptionValue = null;
+
+		checkForGlobalGP(program, set, monitor);
+
+		return super.added(program, set, monitor, log);
+	}
+
+	/**
+	 * Check for a global GP register symbol or discovered symbol
+	 * @param set
+	 */
+	private void checkForGlobalGP(Program program, AddressSetView set, TaskMonitor monitor) {
+		if (!recoverGp) {
+			return;
+		}
+
+		Symbol symbol = SymbolUtilities.getLabelOrFunctionSymbol(program, "_SDA_BASE_",
+			err -> Msg.error(this, err));
+		if (symbol != null) {
+			gpAssumptionValue = symbol.getAddress();
+			return;
+		}
+
+		// TODO : if the symbol doesn't exist, check manually... somewhere else
+
+		return;
+	}
+
+	@Override
+	public AddressSetView flowConstants(final Program program, Address flowStart,
+			AddressSetView flowSet, final SymbolicPropogator symEval, final TaskMonitor monitor)
+			throws CancelledException {
+
+		// get the function body
+		final Function func = program.getFunctionManager().getFunctionContaining(flowStart);
+
+		final AddressSet coveredSet = new AddressSet();
+
+		Address currentGPAssumptionValue = gpAssumptionValue;
+
+		// TODO : copypaste more code from MipsAddressAnalyzer to see if gp is written and act accordingly
+		if (func != null) {
+			flowStart = func.getEntryPoint();
+			if (currentGPAssumptionValue != null) {
+				ProgramContext programContext = program.getProgramContext();
+				RegisterValue gpVal = programContext.getRegisterValue(gp, flowStart);
+				if (gpVal == null || !gpVal.hasValue()) {
+					gpVal = new RegisterValue(gp,
+						BigInteger.valueOf(currentGPAssumptionValue.getOffset()));
+					try {
+						program.getProgramContext().setRegisterValue(func.getEntryPoint(),
+							func.getEntryPoint(), gpVal);
+					}
+					catch (ContextChangeException e) {
+						throw new AssertException("unexpected", e); // only happens for context register
+					}
+				}
+			}
+		}
+
+		ContextEvaluator eval = new ConstantPropagationContextEvaluator(monitor, trustWriteMemOption) {
+			@Override
+			public boolean evaluateDestination(VarnodeContext context, Instruction instruction) {
+				FlowType flowtype = instruction.getFlowType();
+				if (!flowtype.isJump()) {
+					return false;
+				}
+
+				if (recoverSwitchTables) {
+					String mnemonic = instruction.getMnemonicString();
+					if (mnemonic.equals("jr")) {
+						fixJumpTable(program, instruction, monitor);
+					}
+				}
+
+				return false;
+			}
+		};
+
+		AddressSet resultSet = symEval.flowConstants(flowStart, null, eval, true, monitor);
+
+		// Add in any addresses we should assume got covered
+		//   These addresses are put on because we had to stop analysis due to an unknown register value
+		resultSet.add(coveredSet);
+
+		return resultSet;
+	}
+
+	/**
+	 * @param program
+	 * @param startInstr
+	 * @param monitor
+	 */
+	private void fixJumpTable(Program program, Instruction startInstr, TaskMonitor monitor) {
+		/* TODO: implement switch recovery ?
+		 * We are looking for tables like this :
+		 *
+		 * slti45  a0,0x4						<- table size
+		 * beqzs8  LAB_005159ea					<- default jump
+		 * sethi   ta, 0x515
+		 * ori     ta, ta, 0x9a0
+		 * lw      a0, [ta + (a0 << 0x2)]		<- ref to table
+		 * jr      a0							<- table jump
+		 */
+	}
+}
diff --git a/Ghidra/Processors/NDS32/src/main/java/ghidra/app/util/bin/format/elf/relocation/NDS32_ElfRelocationConstants.java b/Ghidra/Processors/NDS32/src/main/java/ghidra/app/util/bin/format/elf/relocation/NDS32_ElfRelocationConstants.java
new file mode 100644
index 0000000000..7aaf363cfe
--- /dev/null
+++ b/Ghidra/Processors/NDS32/src/main/java/ghidra/app/util/bin/format/elf/relocation/NDS32_ElfRelocationConstants.java
@@ -0,0 +1,74 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.elf.relocation;
+
+public class NDS32_ElfRelocationConstants {
+	public static final int R_NDS32_NONE = 0;
+	public static final int R_NDS32_16_RELA = 19;
+	public static final int R_NDS32_32_RELA = 20;
+	public static final int R_NDS32_9_PCREL_RELA = 22;
+	public static final int R_NDS32_15_PCREL_RELA = 23;
+	public static final int R_NDS32_17_PCREL_RELA = 24;
+	public static final int R_NDS32_25_PCREL_RELA = 25;
+	public static final int R_NDS32_HI20_RELA = 26;
+	public static final int R_NDS32_LO12S3_RELA = 27;
+	public static final int R_NDS32_LO12S2_RELA = 28;
+	public static final int R_NDS32_LO12S1_RELA = 29;
+	public static final int R_NDS32_LO12S0_RELA = 30;
+	public static final int R_NDS32_SDA15S3_RELA = 31;
+	public static final int R_NDS32_SDA15S2_RELA = 32;
+	public static final int R_NDS32_SDA15S1_RELA = 33;
+	public static final int R_NDS32_SDA15S0_RELA = 34;
+	public static final int R_NDS32_GOT20 = 37;
+	public static final int R_NDS32_25_PLTREL = 38;
+	public static final int R_NDS32_COPY = 39;
+	public static final int R_NDS32_GLOB_DAT = 40;
+	public static final int R_NDS32_JMP_SLOT = 41;
+	public static final int R_NDS32_RELATIVE = 42;
+	public static final int R_NDS32_GOTOFF = 43;
+	public static final int R_NDS32_GOTPC20 = 44;
+	public static final int R_NDS32_GOT_HI20 = 45;
+	public static final int R_NDS32_GOT_LO12 = 46;
+	public static final int R_NDS32_GOTPC_HI20 = 47;
+	public static final int R_NDS32_GOTPC_LO12 = 48;
+	public static final int R_NDS32_GOTOFF_HI20 = 49;
+	public static final int R_NDS32_GOTOFF_LO12 = 50;
+	public static final int R_NDS32_INSN16 = 51;
+	public static final int R_NDS32_LABEL = 52;
+	public static final int R_NDS32_LONGCALL1 = 53;
+	public static final int R_NDS32_LONGCALL2 = 54;
+	public static final int R_NDS32_LONGCALL3 = 55;
+	public static final int R_NDS32_LONGJUMP1 = 56;
+	public static final int R_NDS32_LONGJUMP2 = 57;
+	public static final int R_NDS32_LONGJUMP3 = 58;
+	public static final int R_NDS32_LOADSTORE = 59;
+	public static final int R_NDS32_9_FIXED_RELA = 60;
+	public static final int R_NDS32_15_FIXED_RELA = 61;
+	public static final int R_NDS32_17_FIXED_RELA = 62;
+	public static final int R_NDS32_25_FIXED_RELA = 63;
+	public static final int R_NDS32_PLTREL_HI20 = 64;
+	public static final int R_NDS32_PLTREL_LO12 = 65;
+	public static final int R_NDS32_PLT_GOTREL_HI20 = 66;
+	public static final int R_NDS32_PLT_GOTREL_LO12 = 67;
+	public static final int R_NDS32_LO12S0_ORI_RELA = 72;
+	public static final int R_NDS32_DWARF2_OP1_RELA = 77;
+	public static final int R_NDS32_DWARF2_OP2_RELA = 78;
+	public static final int R_NDS32_DWARF2_LEB_RELA = 79;
+	public static final int R_NDS32_WORD_9_PCREL_RELA = 94;
+	public static final int R_NDS32_LONGCALL4 = 107;
+	public static final int R_NDS32_RELA_NOP_MIX = 192;
+	public static final int R_NDS32_RELA_NOP_MAX = 255;
+}
diff --git a/Ghidra/Processors/NDS32/src/main/java/ghidra/app/util/bin/format/elf/relocation/NDS32_ElfRelocationHandler.java b/Ghidra/Processors/NDS32/src/main/java/ghidra/app/util/bin/format/elf/relocation/NDS32_ElfRelocationHandler.java
new file mode 100644
index 0000000000..1dd825a845
--- /dev/null
+++ b/Ghidra/Processors/NDS32/src/main/java/ghidra/app/util/bin/format/elf/relocation/NDS32_ElfRelocationHandler.java
@@ -0,0 +1,116 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.elf.relocation;
+
+import java.util.Map;
+import ghidra.app.util.bin.format.elf.ElfConstants;
+import ghidra.app.util.bin.format.elf.ElfHeader;
+import ghidra.app.util.bin.format.elf.ElfLoadHelper;
+import ghidra.app.util.bin.format.elf.ElfRelocation;
+import ghidra.app.util.bin.format.elf.ElfRelocationTable;
+import ghidra.app.util.bin.format.elf.ElfSymbol;
+import ghidra.app.util.importer.MessageLog;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.address.AddressOutOfBoundsException;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.mem.Memory;
+import ghidra.program.model.mem.MemoryAccessException;
+import ghidra.program.model.reloc.RelocationResult;
+import ghidra.program.model.reloc.Relocation.Status;
+import ghidra.util.exception.NotFoundException;
+
+public class NDS32_ElfRelocationHandler extends ElfRelocationHandler {
+
+	@Override
+	public boolean canRelocate(ElfHeader elf) {
+		return elf.e_machine() == ElfConstants.EM_NDS32;
+	}
+
+	@Override
+	public NDS32_ElfRelocationContext createRelocationContext(ElfLoadHelper loadHelper,
+			Map<ElfSymbol, Address> symbolMap) {
+		return new NDS32_ElfRelocationContext(this, loadHelper, symbolMap);
+	}
+
+	@Override
+	public RelocationResult relocate(ElfRelocationContext elfRelocationContext, ElfRelocation relocation, Address relocationAddress)
+			throws MemoryAccessException, NotFoundException {
+		ElfHeader elf = elfRelocationContext.getElfHeader();
+
+		if (elf.e_machine() != ElfConstants.EM_NDS32) {
+			return RelocationResult.FAILURE;
+		}
+
+		if (!elf.is32Bit()) {
+			return RelocationResult.FAILURE;
+		}
+
+		NDS32_ElfRelocationContext nds32RelocationContext =
+				(NDS32_ElfRelocationContext) elfRelocationContext;
+
+		int type = relocation.getType();
+		int symbolIndex = relocation.getSymbolIndex();
+		return doRelocate(nds32RelocationContext, type, symbolIndex, relocation, relocationAddress);
+	}
+
+	private RelocationResult doRelocate(NDS32_ElfRelocationContext nds32RelocationContext, int relocType,
+			int symbolIndex, ElfRelocation relocation, Address relocationAddress)
+			throws MemoryAccessException, NotFoundException, AddressOutOfBoundsException {
+		Program program = nds32RelocationContext.getProgram();
+		Memory memory = program.getMemory();
+		MessageLog log = nds32RelocationContext.getLog();
+		ElfSymbol elfSymbol = nds32RelocationContext.getSymbol(symbolIndex);
+		long symbolValue = nds32RelocationContext.getSymbolValue(elfSymbol);
+		String symbolName = elfSymbol.getNameAsString();
+
+		// Read instruction as big endian
+		int oldValue = memory.getInt(relocationAddress, true);
+
+		long addend = 0;
+		if(relocation.hasAddend()) {
+			addend = relocation.getAddend();
+		}
+
+		int value = 0;
+		int newValue = 0;
+		int byteLength = 4; // most relocations affect 4-bytes (change if different)
+
+		switch(relocType) {
+		case NDS32_ElfRelocationConstants.R_NDS32_HI20_RELA:
+			value = (int)(symbolValue + addend);
+			newValue = (oldValue & 0xfff00000) | (value >> 12);
+			memory.setInt(relocationAddress, newValue, true);
+			break;
+		case NDS32_ElfRelocationConstants.R_NDS32_LO12S0_RELA:
+			value = (int)(symbolValue + addend);
+			newValue = (oldValue & 0xfffff000) | (value & 0xfff);
+			memory.setInt(relocationAddress, newValue, true);
+			break;
+		default:
+			markAsUnhandled(program, relocationAddress, relocType, symbolIndex, symbolName, log);
+			return RelocationResult.UNSUPPORTED;
+		}
+		return new RelocationResult(Status.APPLIED, byteLength);
+	}
+
+	private static class NDS32_ElfRelocationContext extends ElfRelocationContext {
+
+		protected NDS32_ElfRelocationContext(ElfRelocationHandler handler, ElfLoadHelper loadHelper,
+				Map<ElfSymbol, Address> symbolMap) {
+			super(handler, loadHelper, symbolMap);
+		}
+	}
+}
diff --git a/Ghidra/Processors/NDS32/src/test.processors/java/ghidra/test/processors/NDS32_LE_O0_EmulatorTest.java b/Ghidra/Processors/NDS32/src/test.processors/java/ghidra/test/processors/NDS32_LE_O0_EmulatorTest.java
new file mode 100644
index 0000000000..3799bdeeeb
--- /dev/null
+++ b/Ghidra/Processors/NDS32/src/test.processors/java/ghidra/test/processors/NDS32_LE_O0_EmulatorTest.java
@@ -0,0 +1,41 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.test.processors;
+
+import ghidra.test.processors.support.ProcessorEmulatorTestAdapter;
+
+import junit.framework.Test;
+
+public class NDS32_LE_O0_EmulatorTest extends ProcessorEmulatorTestAdapter {
+
+	private static final String LANGUAGE_ID = "NDS32:LE:32:default";
+	private static final String COMPILER_SPEC_ID = "default";
+
+	private static final String[] REG_DUMP_SET = new String[] {};
+
+	public NDS32_LE_O0_EmulatorTest(String name) throws Exception {
+		super(name, LANGUAGE_ID, COMPILER_SPEC_ID, REG_DUMP_SET);
+	}
+
+	@Override
+	protected String getProcessorDesignator() {
+		return "NDS32LE_GCC_O0";
+	}
+
+	public static Test suite() {
+		return ProcessorEmulatorTestAdapter.buildEmulatorTestSuite(NDS32_LE_O0_EmulatorTest.class);
+	}
+}
diff --git a/Ghidra/Processors/NDS32/src/test.processors/java/ghidra/test/processors/NDS32_LE_O3_EmulatorTest.java b/Ghidra/Processors/NDS32/src/test.processors/java/ghidra/test/processors/NDS32_LE_O3_EmulatorTest.java
new file mode 100644
index 0000000000..5343e5a272
--- /dev/null
+++ b/Ghidra/Processors/NDS32/src/test.processors/java/ghidra/test/processors/NDS32_LE_O3_EmulatorTest.java
@@ -0,0 +1,41 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.test.processors;
+
+import ghidra.test.processors.support.ProcessorEmulatorTestAdapter;
+
+import junit.framework.Test;
+
+public class NDS32_LE_O3_EmulatorTest extends ProcessorEmulatorTestAdapter {
+
+	private static final String LANGUAGE_ID = "NDS32:LE:32:default";
+	private static final String COMPILER_SPEC_ID = "default";
+
+	private static final String[] REG_DUMP_SET = new String[] {};
+
+	public NDS32_LE_O3_EmulatorTest(String name) throws Exception {
+		super(name, LANGUAGE_ID, COMPILER_SPEC_ID, REG_DUMP_SET);
+	}
+
+	@Override
+	protected String getProcessorDesignator() {
+		return "NDS32LE_GCC_O3";
+	}
+
+	public static Test suite() {
+		return ProcessorEmulatorTestAdapter.buildEmulatorTestSuite(NDS32_LE_O3_EmulatorTest.class);
+	}
+}
-- 
2.45.1

