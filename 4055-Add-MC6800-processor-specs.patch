From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Sigurdur Asgeirsson <siggi@undo.com>
Date: Sat, 5 Mar 2022 16:31:33 -0500
Subject: [PATCH] 4055: Add MC6800 processor specs.

Fix JSR/JMP to use EA rather than the dereferenced address.

Fix arithmetic shift right to keep MSB.

Rename OP2EA->EA2.

Revert "Fix arithmetic shift right to keep MSB.", the original implementation is just fine.

Fix spec ID.

Change to https://github.com/sigurasg/GhidraMC6800
---
 .../Processors/MC6800/certification.manifest  |  20 +
 .../MC6800/data/languages/hd6301.slaspec      |  89 ++
 .../MC6800/data/languages/mc6800.cspec        |  46 +
 .../MC6800/data/languages/mc6800.ldefs        |  58 ++
 .../MC6800/data/languages/mc6800.pspec        |  26 +
 .../MC6800/data/languages/mc6800.slaspec      | 954 ++++++++++++++++++
 .../MC6800/data/languages/mc6801.pspec        |  54 +
 .../MC6800/data/languages/mc6801.slaspec      |  89 ++
 .../Processors/MC6800/data/manuals/mc6800.idx |  73 ++
 .../Processors/MC6800/data/manuals/mc6801.idx |  88 ++
 .../is/sort/mc6800/AbstractEmulatorTest.java  | 186 ++++
 .../sort/mc6800/AbstractIntegrationTest.java  | 102 ++
 .../src/test/java/is/sort/mc6800/CC.java      |  24 +
 .../is/sort/mc6800/DisassemblyCommonTest.java | 553 ++++++++++
 .../is/sort/mc6800/DisassemblyHD6301Test.java |  93 ++
 .../is/sort/mc6800/DisassemblyMC6800Test.java | 102 ++
 .../mc6800/DisassemblyMC6801CommonTest.java   |  95 ++
 .../is/sort/mc6800/DisassemblyMC6801Test.java |  71 ++
 .../is/sort/mc6800/EmulatorHD6301Test.java    |  79 ++
 .../is/sort/mc6800/EmulatorMC6800Test.java    | 133 +++
 .../is/sort/mc6800/EmulatorMC6801Test.java    |  45 +
 21 files changed, 2980 insertions(+)
 create mode 100644 Ghidra/Processors/MC6800/data/languages/hd6301.slaspec
 create mode 100644 Ghidra/Processors/MC6800/data/languages/mc6800.cspec
 create mode 100644 Ghidra/Processors/MC6800/data/languages/mc6800.ldefs
 create mode 100644 Ghidra/Processors/MC6800/data/languages/mc6800.pspec
 create mode 100644 Ghidra/Processors/MC6800/data/languages/mc6800.slaspec
 create mode 100644 Ghidra/Processors/MC6800/data/languages/mc6801.pspec
 create mode 100644 Ghidra/Processors/MC6800/data/languages/mc6801.slaspec
 create mode 100644 Ghidra/Processors/MC6800/data/manuals/mc6800.idx
 create mode 100644 Ghidra/Processors/MC6800/data/manuals/mc6801.idx
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/AbstractEmulatorTest.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/AbstractIntegrationTest.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/CC.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyCommonTest.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyHD6301Test.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6800Test.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6801CommonTest.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6801Test.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorHD6301Test.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC6800Test.java
 create mode 100644 Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC6801Test.java

diff --git a/Ghidra/Processors/MC6800/certification.manifest b/Ghidra/Processors/MC6800/certification.manifest
index f2d77d9f3d..cea5dcebf2 100644
--- a/Ghidra/Processors/MC6800/certification.manifest
+++ b/Ghidra/Processors/MC6800/certification.manifest
@@ -21,4 +21,24 @@ data/languages/6x09_push.sinc||GHIDRA||||END|
 data/languages/H6309.slaspec||GHIDRA||||END|
 data/languages/mc146805e2.pspec||GHIDRA||||END|
 data/languages/mc146805e2.slaspec||GHIDRA||||END|
+data/languages/hd6301.slaspec||GHIDRA||||END|
+data/languages/mc6800.cspec||GHIDRA||||END|
+data/languages/mc6800.ldefs||GHIDRA||||END|
+data/languages/mc6800.pspec||GHIDRA||||END|
+data/languages/mc6800.slaspec||GHIDRA||||END|
+data/languages/mc6801.pspec||GHIDRA||||END|
+data/languages/mc6801.slaspec||GHIDRA||||END|
 data/manuals/6809.idx||GHIDRA||||END|
+data/manuals/mc6800.idx||GHIDRA||||END|
+data/manuals/mc6801.idx||GHIDRA||||END|
+src/test/java/is/sort/mc6800/AbstractEmulatorTest.java||GHIDRA||||END|
+src/test/java/is/sort/mc6800/AbstractIntegrationTest.java||GHIDRA||||END|
+src/test/java/is/sort/mc6800/CC.java||GHIDRA||||END|
+src/test/java/is/sort/mc6800/DisassemblyCommonTest.java||GHIDRA||||END|
+src/test/java/is/sort/mc6800/DisassemblyHD6301Test.java||GHIDRA||||END|
+src/test/java/is/sort/mc6800/DisassemblyMC6800Test.java||GHIDRA||||END|
+src/test/java/is/sort/mc6800/DisassemblyMC6801CommonTest.java||GHIDRA||||END|
+src/test/java/is/sort/mc6800/DisassemblyMC6801Test.java||GHIDRA||||END|
+src/test/java/is/sort/mc6800/EmulatorHD6301Test.java||GHIDRA||||END|
+src/test/java/is/sort/mc6800/EmulatorMC6800Test.java||GHIDRA||||END|
+src/test/java/is/sort/mc6800/EmulatorMC6801Test.java||GHIDRA||||END|
diff --git a/Ghidra/Processors/MC6800/data/languages/hd6301.slaspec b/Ghidra/Processors/MC6800/data/languages/hd6301.slaspec
new file mode 100644
index 0000000000..5570da5b9f
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/hd6301.slaspec
@@ -0,0 +1,89 @@
+# Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+@include "mc6801.slaspec"
+
+# 1-byte immediate operand.
+IMM1: "#"imm8 is imm8
+{
+    local tmp:1=imm8;
+    export tmp;
+}
+
+# 1-byte displacement operand.
+DISP1: imm8,X  is X; imm8
+{
+    local tmp:2 = imm8 + X;
+    export *:1 tmp;
+}
+# 1-byte memory operand.
+M1: imm8 is imm8
+{
+    export *:1 imm8;
+}
+
+:AIM IMM1, M1    is op=0x71; IMM1; M1
+{
+    logicalAnd(M1, IMM1);
+}
+
+:AIM IMM1, DISP1 is op=0x61; IMM1; DISP1
+{
+    logicalAnd(DISP1, IMM1);
+}
+
+:OIM IMM1, M1    is op=0x72; IMM1; M1
+{
+    logicalOr(M1, IMM1);
+}
+
+:OIM IMM1, DISP1 is op=0x62; IMM1; DISP1
+{
+    logicalOr(DISP1, IMM1);
+}
+
+:EIM IMM1, M1    is op=0x75; IMM1; M1
+{
+    logicalExclusiveOr(M1, IMM1);
+}
+
+:EIM IMM1, DISP1 is op=0x65; IMM1; DISP1
+{
+    logicalExclusiveOr(DISP1, IMM1);
+}
+
+:TIM IMM1, M1    is op=0x7B; IMM1; M1
+{
+    bitTest(M1, IMM1);
+}
+
+:TIM IMM1, DISP1 is op=0x6B; IMM1; DISP1
+{
+    bitTest(DISP1, IMM1);
+}
+
+:XGDX           is op=0x18
+ {
+    local tmp:2=X;
+    X=D;
+    D=tmp;
+ }
+
+:SLP            is op=0x1A
+{
+    # Sleeps the MPU, but for the purposes of analysis,
+    # execution continues after an interrupt, so this looks
+    # like a noop.
+    goto inst_next;
+}
diff --git a/Ghidra/Processors/MC6800/data/languages/mc6800.cspec b/Ghidra/Processors/MC6800/data/languages/mc6800.cspec
new file mode 100644
index 0000000000..0b48b14013
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/mc6800.cspec
@@ -0,0 +1,46 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright 2022-2024 Sigurdur Asgeirsson <siggi@sort.is>
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+
+<compiler_spec>
+  <global>
+    <range space="RAM"/>
+  </global>
+  <stackpointer register="S" space="RAM" growth="negative"/>
+  <default_proto>
+    <prototype name="__stdcall" extrapop="2" stackshift="2">
+      <input>
+        <pentry minsize="1" maxsize="1">
+          <register name="A"/>
+        </pentry>
+        <pentry minsize="1" maxsize="1">
+          <register name="B"/>
+        </pentry>
+        <pentry minsize="1" maxsize="2">
+          <register name="X"/>
+        </pentry>
+      </input>
+      <output>
+        <pentry minsize="1" maxsize="1">
+          <register name="A"/>
+        </pentry>
+      </output>
+      <unaffected>
+        <register name="S"/>
+      </unaffected>
+    </prototype>
+  </default_proto>
+</compiler_spec>
diff --git a/Ghidra/Processors/MC6800/data/languages/mc6800.ldefs b/Ghidra/Processors/MC6800/data/languages/mc6800.ldefs
new file mode 100644
index 0000000000..af9eaf8e6c
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/mc6800.ldefs
@@ -0,0 +1,58 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright 2022-2024 Sigurdur Asgeirsson <siggi@sort.is>
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+
+<language_definitions>
+  <language processor="MC6800"
+            endian="big"
+            size="16"
+            variant="default"
+            version="1.0"
+            slafile="mc6800.sla"
+            manualindexfile="../manuals/mc6800.idx"
+            processorspec="mc6800.pspec"
+            id="MC6800:BE:16:default">
+    <description>MC6800 Microprocessor</description>
+    <compiler name="default" spec="mc6800.cspec" id="default"/>
+    <external_name tool="IDA-PRO" name="MC6800"/>
+    <external_name tool="IDA-PRO" name="MC6802"/>
+    <external_name tool="IDA-PRO" name="MC6808"/>
+  </language>
+  <language processor="MC6801"
+            endian="big"
+            size="16"
+            variant="default"
+            version="1.0"
+            slafile="mc6801.sla"
+            manualindexfile="../manuals/mc6801.idx"
+            processorspec="mc6801.pspec"
+            id="MC6801:BE:16:default">
+    <description>MC6801 Microprocessor</description>
+    <compiler name="default" spec="mc6800.cspec" id="default"/>
+    <external_name tool="IDA-PRO" name="MC6801"/>
+  </language>
+  <language processor="HD6301"
+            endian="big"
+            size="16"
+            variant="default"
+            version="1.0"
+            slafile="hd6301.sla"
+            processorspec="mc6801.pspec"
+            id="HD6301:BE:16:default">
+    <description>MC6801 Microprocessor</description>
+    <compiler name="default" spec="mc6800.cspec" id="default"/>
+  </language>
+</language_definitions>
diff --git a/Ghidra/Processors/MC6800/data/languages/mc6800.pspec b/Ghidra/Processors/MC6800/data/languages/mc6800.pspec
new file mode 100644
index 0000000000..1d2a22fdf7
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/mc6800.pspec
@@ -0,0 +1,26 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright 2022-2024 Sigurdur Asgeirsson <siggi@sort.is>
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+
+<processor_spec>
+  <programcounter register="PC"/>
+  <default_symbols>
+    <symbol name="IRQ_VECTOR" address="0xFFF8" entry="true" type="code_ptr"/>
+    <symbol name="SWI_VECTOR" address="0xFFFA" entry="true" type="code_ptr"/>
+    <symbol name="NMI_VECTOR" address="0xFFFC" entry="true" type="code_ptr"/>
+    <symbol name="RST_VECTOR" address="0xFFFE" entry="true" type="code_ptr"/>
+  </default_symbols>
+</processor_spec>
diff --git a/Ghidra/Processors/MC6800/data/languages/mc6800.slaspec b/Ghidra/Processors/MC6800/data/languages/mc6800.slaspec
new file mode 100644
index 0000000000..61d380d5b8
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/mc6800.slaspec
@@ -0,0 +1,954 @@
+# Copyright 2022-2024 Sigurdur Asgeirsson <siggi@sort.is>
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+define endian=big;
+define alignment=1;
+
+@define IRQ_VECTOR  "0xFFF8"
+@define SWI_VECTOR  "0xFFFA"
+@define NMI_VECTOR  "0xFFFC"
+@define RST_VECTOR  "0xFFFE"
+
+define space RAM     type=ram_space      size=2  default;
+define space register type=register_space size=1;
+
+# 8-bit registers A, B
+define register offset=0 size=1 [ A B ];
+
+@ifdef MC6801
+define register offset=0 size=2 [ D ];
+@endif
+
+# 8-bit condition code register
+define register offset=8 size=1 [ CC ];
+# 16-bit registers:
+#    PC: Program counter
+#    S:  Stack pointer
+#    X: index register
+define register offset=16 size=2 [ PC X S ];
+
+# Status bits
+define bitrange
+    C=CC[0,1] # C: Carry (or borrow) flag
+    V=CC[1,1] # V: Overflow flag
+    Z=CC[2,1] # Z: Zero result
+    N=CC[3,1] # N: Negative result (twos complement)
+    I=CC[4,1] # I: IRQ interrupt masked
+    H=CC[5,1] # H: Half carry flag
+;
+
+define token opbyte (8)
+    op        = (0,7)
+    addrMode  = (4,5)
+    acc_4     = (4,4)
+;
+
+define token data8 (8)
+    imm8      = (0,7)
+    simm8     = (0,7) signed
+;
+
+define token data (16)
+    imm16     = (0,15)
+;
+
+attach variables acc_4 [ A B ];
+
+################################################################
+# Constructors
+################################################################
+
+REL:  addr    is simm8  [ addr = inst_next + simm8;  ]   { export *:2 addr; }
+
+# 1-byte operand, immediate/direct/indexed/extended addressing mode
+OP1: "#"imm8    is addrMode=0; imm8
+{
+    # For some reason this needs explicit sizing, or the p-code
+    # ends up picking up a zero value for all #imm8 operands.
+    local tmp:1 = imm8;
+    export tmp;
+}
+OP1: imm8    is addrMode=1; imm8
+{
+    export *:1 imm8;
+}
+OP1: imm8,X  is addrMode=2 & X; imm8
+{
+    local tmp:2 = imm8 + X;
+    export *:1 tmp;
+}
+OP1: imm16    is addrMode=3; imm16
+{
+    export *:1 imm16;
+}
+
+# 2-byte operand, direct/indexed/extended addressing mode
+OP2: "#"imm16    is addrMode=0; imm16
+{
+    local tmp:2 = imm16;
+    export tmp;
+}
+OP2: imm8    is addrMode=1; imm8
+{
+    export *:2 imm8;
+}
+OP2: imm8,X      is addrMode=2 & X; imm8
+{
+    local tmp:2 = X + imm8;
+    export *:2 tmp;
+}
+OP2: imm16      is addrMode=3; imm16
+{
+    export *:2 imm16;
+}
+
+# 2-byte EA operand for JMP/JSR
+@ifdef MC6801
+EA2: imm8      is addrMode=1; imm8
+{
+    export *:2 imm8;
+}
+@endif
+EA2: imm8,X      is addrMode=2 & X; imm8
+{
+    local tmp:2 = X + imm8;
+    export tmp;
+}
+EA2: imm16    is addrMode=3; imm16
+{
+    local tmp:2 = imm16;
+    export tmp;
+}
+
+
+################################################################
+# Macros
+################################################################
+
+macro setNZFlags(result)
+{
+    Z = (result == 0);
+    N = (result s< 0);
+}
+
+macro setHFlag(reg, op)
+{
+    local mask = 0x0F; # Low nibble mask
+
+    H = (((reg & mask) + (op & mask)) >> 4) & 1;
+}
+
+# Negate twos complement value in op.
+# P-code INT_2COMP.
+macro negate(op)
+{
+    op = -op;
+    V = (op == 0x80);
+    C = (op != 0);
+    setNZFlags(op);
+}
+
+# Logical complement of op. (0 => 1; 1 => 0)
+# P-code INT_NEGATE.
+macro complement(op)
+{
+    V = 0;
+    C = 1;
+    op = ~op;
+    setNZFlags(op);
+}
+
+macro logicalShiftRight(op)
+{
+    C = op & 1;
+    op = op >> 1;
+    Z = (op == 0);
+    N = 0;
+}
+
+macro rotateRightWithCarry(op)
+{
+    local carryOut = C << 7;
+    C = op & 1;
+    op = (op s>> 1) | carryOut;
+    setNZFlags(op);
+}
+
+macro rotateLeftWithCarry(op)
+{
+    local carryIn = C;
+    C = op >> 7;
+    op = (op << 1) | carryIn;
+    setNZFlags(op);
+}
+
+# Signed shift right.
+# P-code INT_SRIGHT.
+macro arithmeticShiftRight(op)
+{
+    C = op & 1;
+    op = (op s>> 1);
+    setNZFlags(op);
+}
+
+macro logicalShiftLeft(op)
+{
+    C = (op >> 7);
+    op = op << 1;
+    Z = (op == 0);
+    N = (op >> 7);
+}
+
+macro increment(op)
+{
+    V = (op == 0x7F);
+    op = op + 1;
+    setNZFlags(op);
+}
+
+macro decrement(op)
+{
+    V = (op == 0x80);
+    op = op - 1;
+    setNZFlags(op);
+}
+
+macro test(op)
+{
+    V = 0;
+    setNZFlags(op);
+}
+
+macro clear(op)
+{
+    V = 0;
+    op = 0;
+    Z = 1;
+    N = 0;
+}
+
+macro addition(reg, op)
+{
+    C = carry(reg, op);
+    V = scarry(reg, op);
+
+    reg = reg + op;
+
+    setNZFlags(reg);
+}
+
+macro additionWithCarry(reg, op)
+{
+    local carryIn = C;
+    local mask = 0x0F; # Low nibble mask
+    local tmpResult = reg + op;
+
+    H = (((reg & mask) + (op & mask) + carryIn) >> 4) & 1;
+    C = carry(reg, op) || carry(tmpResult, carryIn);
+    V = scarry(reg, op) ^^ scarry(tmpResult, carryIn);
+
+    reg = tmpResult + carryIn;
+
+    setNZFlags(reg);
+}
+
+macro subtraction(reg, op)
+{
+    V = sborrow(reg, op);
+    C = (reg < op);
+    reg = reg - op;
+    setNZFlags(reg);
+}
+
+macro subtractionWithCarry(reg, op)
+{
+    local carryIn = C;
+    local tmpResult = reg - op;
+
+    C = (reg < op) || (tmpResult < carryIn);
+    V = sborrow(reg, op) ^^ sborrow(tmpResult, carryIn);
+
+    reg = tmpResult - carryIn;
+
+    setNZFlags(reg);
+}
+
+macro compare(reg, op)
+{
+    V = sborrow(reg, op);
+    C = (reg < op);
+    local tmp = reg - op;
+    setNZFlags(tmp);
+}
+
+macro logicalAnd(reg, op)
+{
+    reg = reg & op;
+    setNZFlags(reg);
+    V = 0;
+}
+
+macro logicalOr(reg, op)
+{
+    reg = reg | op;
+    setNZFlags(reg);
+    V = 0;
+}
+
+macro logicalExclusiveOr(reg, op)
+{
+    reg = reg ^ op;
+    setNZFlags(reg);
+    V = 0;
+}
+
+macro bitTest(reg, op)
+{
+    local tmp = reg & op;
+    setNZFlags(tmp);
+    V = 0;
+}
+
+macro loadRegister(reg, op)
+{
+    reg = op;
+    setNZFlags(reg);
+    V = 0;
+}
+
+macro storeRegister(reg, op)
+{
+    op = reg;
+    setNZFlags(reg);
+    V = 0;
+}
+
+# Push 1 byte operand op
+macro Push1(reg, op)
+{
+    *:1 reg = op;
+    reg = reg - 1;
+}
+
+# Push 2 byte operand op
+macro Push2(reg, op)
+{
+    reg = reg - 1;
+    *:2 reg = op;
+    reg = reg - 1;
+}
+
+# Pull 1 byte operand op
+macro Pull1(reg, op)
+{
+    reg = reg + 1;
+    op = *:1 reg;
+}
+
+# Pull 2 byte operand op
+macro Pull2(reg, op)
+{
+    reg = reg + 1;
+    op = *:2 reg;
+    reg = reg + 1;
+}
+
+macro PushEntireState()
+{
+    local tmp:2 = inst_next;
+
+    Push2(S, tmp); # return PC address
+    Push2(S, X);
+    Push1(S, A);
+    Push1(S, B);
+    Push1(S, CC);
+}
+
+################################################################
+# Instructions
+################################################################
+
+################################################################
+# Opcode 0x00 - 0x0F, misc operations
+################################################################
+
+:NOP    is op=0x01
+{
+    # Intentional NOP.
+    goto inst_next;
+}
+
+:TAP    is op=0x06
+{
+    CC = A & 0x1F;
+}
+
+:TPA    is op=0x07
+{
+    A = CC;
+}
+
+:INX    is op=0x08
+{
+    X = X + 1;
+    Z = (X == 0);
+}
+
+:DEX    is op=0x09
+{
+    X = X - 1;
+    Z = (X == 0);
+}
+
+:CLV    is op=0x0A
+{
+    V = 0;
+}
+
+:SEV     is op=0x0B
+{
+    V = 1;
+}
+
+:CLC     is op=0x0C
+{
+    C = 0;
+}
+
+:SEC     is op=0x0D
+{
+    C = 1;
+}
+
+:CLI     is op=0x0E
+{
+    I = 0;
+}
+
+:SEI     is op=0x0F
+{
+    I = 1;
+}
+
+################################################################
+# Opcode 0x40 - 0x4F, register A addressing
+# Opcode 0x50 - 0x5F, register B addressing
+# Opcode 0x60 - 0x6F, indexed addressing
+# Opcode 0x70 - 0x7F, extended addressing
+################################################################
+
+:NEG^acc_4    is (op=0x40 | op=0x50) & acc_4
+{
+    negate(acc_4);
+}
+
+:NEG OP1    is (op=0x60 | op=0x70) ... & OP1
+{
+    negate(OP1);
+}
+
+:COM^acc_4  is (op=0x43 | op=0x53) & acc_4
+{
+    complement(acc_4);
+}
+
+:COM OP1    is (op=0x63 | op=0x73) ... & OP1
+{
+    complement(OP1);
+}
+
+:LSR^acc_4  is (op=0x44 | op=0x54) & acc_4
+{
+    logicalShiftRight(acc_4);
+}
+
+:LSR OP1    is (op=0x64 | op=0x74) ... & OP1
+{
+    logicalShiftRight(OP1);
+}
+
+:ROR^acc_4  is (op=0x46 | op=0x56) & acc_4
+{
+    rotateRightWithCarry(acc_4);
+}
+
+:ROR OP1    is (op=0x66 | op=0x76) ... & OP1
+{
+    rotateRightWithCarry(OP1);
+}
+
+:ASR^acc_4  is (op=0x47 | op=0x57) & acc_4
+{
+    arithmeticShiftRight(acc_4);
+}
+
+:ASR OP1    is (op=0x67 | op=0x77) ... & OP1
+{
+    arithmeticShiftRight(OP1);
+}
+
+:ASL^acc_4  is (op=0x48 | op=0x58) & acc_4
+{
+    logicalShiftLeft(acc_4);
+}
+
+:ASL OP1    is (op=0x68 | op=0x78) ... & OP1
+{
+    logicalShiftLeft(OP1);
+}
+
+:ROL^acc_4    is (op=0x49 | op=0x59) & acc_4
+{
+    rotateLeftWithCarry(acc_4);
+}
+
+:ROL OP1    is (op=0x69 | op=0x79) ... & OP1
+{
+    rotateLeftWithCarry(OP1);
+}
+
+:DEC^acc_4    is (op=0x4A | op=0x5A) & acc_4
+{
+    decrement(acc_4);
+}
+
+:DEC OP1    is (op=0x6A | op=0x7A) ... & OP1
+{
+    decrement(OP1);
+}
+
+:INC^acc_4    is (op=0x4C | op=0x5C) & acc_4
+{
+    increment(acc_4);
+}
+
+:INC OP1    is (op=0x6C | op=0x7C) ... & OP1
+{
+    increment(OP1);
+}
+
+:TST^acc_4    is (op=0x4D | op=0x5D) & acc_4
+{
+    test(acc_4);
+}
+
+:TST OP1    is (op=0x6D | op=0x7D) ... & OP1
+{
+    test(OP1);
+}
+
+:JMP EA2    is (op=0x6E | op=0x7E) ... & EA2
+{
+    local target:2 = EA2;
+    goto [target];
+}
+
+:CLR^acc_4    is (op=0x4F | op=0x5F) & acc_4
+{
+    clear(acc_4);
+}
+
+:CLR OP1    is (op=0x6F | op=0x7F) ... & OP1
+{
+    clear(OP1);
+}
+
+################################################################
+# Opcode 0x10 - 0x1F, misc. addressing
+################################################################
+
+:SBA    is op=0x10
+{
+    subtraction(A, B);
+}
+
+:CBA    is op=0x11
+{
+    compare(A, B);
+}
+
+:TAB    is op=0x16
+{
+    loadRegister(B, A);
+}
+
+:TBA    is op=0x17
+{
+    loadRegister(A, B);
+}
+
+:DAA    is op=0x19
+{
+    local highA:1 = A >> 4;
+    local lowA:1  = A & 0x0F;
+    local cc1 = (C == 1 | highA > 9 | (highA > 8) & (lowA > 9));
+    local cc2 = (H == 1 | lowA > 9);
+
+    if ( cc1 & cc2 )
+    goto <case1>;
+    if ( cc1 )
+    goto <case2>;
+    if ( cc2 )
+    goto <case3>;
+    goto <exitDAA>;
+
+    <case1>
+    C = carry(A, 0x66);
+    A = A + 0x66;
+    goto <exitDAA>;
+    <case2>
+    C = carry(A, 0x60);
+    A = A + 0x60;
+    goto <exitDAA>;
+    <case3>
+    C = carry(A, 0x06);
+    A = A + 0x06;
+    goto <exitDAA>;
+
+    <exitDAA>
+    setNZFlags(A);
+}
+
+:ABA    is op=0x1B
+{
+    addition(A, B);
+}
+
+################################################################
+# Opcode 0x20 - 0x2F, relative addressing
+################################################################
+
+:BRA REL    is op=0x20; REL
+{
+    goto REL;
+}
+
+:BHI REL    is op=0x22; REL
+{
+    if (C == 0 && Z == 0) goto REL;
+}
+
+:BLS REL    is op=0x23; REL
+{
+    if (C || Z) goto REL;
+}
+
+#:BHS REL    is op=0x24; REL # See BCC
+
+:BCC REL    is op=0x24; REL
+{
+    if (C == 0) goto REL;
+}
+
+#:BLO REL    is op=0x25; REL # see BCS
+
+:BCS REL    is op=0x25; REL
+{
+    if (C) goto REL;
+}
+
+:BNE REL     is op=0x26; REL
+{
+    if (Z == 0) goto REL;
+}
+
+:BEQ REL    is op=0x27; REL
+{
+    if (Z) goto REL;
+}
+
+:BVC REL    is op=0x28; REL
+{
+    if (V == 0) goto REL;
+}
+
+:BVS REL    is op=0x29; REL
+{
+    if (V) goto REL;
+}
+
+:BPL REL    is op=0x2A; REL
+{
+    if (N == 0) goto REL;
+}
+
+:BMI REL    is op=0x2B; REL
+{
+    if (N) goto REL;
+}
+
+:BGE REL    is op=0x2C; REL
+{
+    if (N == V) goto REL;
+}
+
+:BLT REL    is op=0x2D; REL
+{
+    if (N != V) goto REL;
+}
+
+:BGT REL    is op=0x2E; REL
+{
+    if ((Z == 0) && (N == V)) goto REL;
+}
+
+:BLE REL     is op=0x2F; REL
+{
+    if (Z || (N != V)) goto REL;
+}
+
+################################################################
+# Opcode 0x30 - 0x3F, misc. addressing
+################################################################
+
+:TSX    is op=0x30
+{
+    X = S + 1;
+}
+
+:INS    is op=0x31
+{
+    S = S + 1;
+}
+
+:PULA   is op=0x32
+{
+    Pull1(S, A);
+}
+
+:PULB   is op=0x33
+{
+    Pull1(S, B);
+}
+
+:DES    is op=0x34
+{
+    S = S - 1;
+}
+
+:TXS    is op=0x35
+{
+    S = X - 1;
+}
+
+:PSHA   is op=0x36
+{
+    Push1(S, A);
+}
+
+:PSHB   is op=0x37
+{
+    Push1(S, B);
+}
+
+:RTS    is op=0x39
+{
+    local addr:2;
+    Pull2(S, addr);
+    return [addr];
+}
+
+:RTI    is op=0x3B
+{
+    local addr:2;
+    Pull1(S, CC);
+    Pull1(S, B);
+    Pull1(S, A);
+    Pull2(S, X);
+    Pull2(S, addr);
+    return [addr];
+}
+
+:WAI    is op=0x3E
+{
+    PushEntireState();
+}
+
+:SWI    is op=0x3F
+{
+    PushEntireState();
+    I = 1;
+    tmp:2 = $(SWI_VECTOR);
+    call[tmp];
+}
+
+################################################################
+# Opcode 0x80 - 0x8F, immediate addressing
+# Opcode 0x90 - 0x9F, direct addressing
+# Opcode 0xA0 - 0xAF, indexed addressing
+# Opcode 0xB0 - 0xBF, extended addressing
+# Opcode 0xC0 - 0xCF, immediate addressing
+# Opcode 0xD0 - 0xDF, direct addressing
+# Opcode 0xE0 - 0xEF, indexed addressing
+# Opcode 0xF0 - 0xFF, extended addressing
+################################################################
+
+:SUBA OP1    is (op=0x80 | op=0x90 | op=0xA0 | op=0xB0) ... & OP1
+{
+    subtraction(A, OP1);
+}
+
+:SUBB OP1    is (op=0xC0 | op=0xD0 | op=0xE0 | op=0xF0) ... & OP1
+{
+    subtraction(B, OP1);
+}
+
+:CMPA OP1    is (op=0x81 | op=0x91 | op=0xA1 | op=0xB1) ... & OP1
+{
+    compare(A, OP1);
+}
+
+:CMPB OP1    is (op=0xC1 | op=0xD1 | op=0xE1 | op=0xF1) ... & OP1
+{
+    compare(B, OP1);
+}
+
+:SBCA OP1    is (op=0x82 | op=0x92 | op=0xA2 | op=0xB2) ... & OP1
+{
+    subtractionWithCarry(A, OP1);
+}
+
+:SBCB OP1    is (op=0xC2 | op=0xD2 | op=0xE2 | op=0xF2) ... & OP1
+{
+    subtractionWithCarry(B, OP1);
+}
+
+:ANDA OP1    is (op=0x84 | op=0x94 | op=0xA4 | op=0xB4) ... & OP1
+{
+    logicalAnd(A, OP1);
+}
+
+:ANDB OP1    is (op=0xC4 | op=0xD4 | op=0xE4 | op=0xF4) ... & OP1
+{
+    logicalAnd(B, OP1);
+}
+
+:BITA OP1    is (op=0x85 | op=0x95 | op=0xA5 | op=0xB5) ... & OP1
+{
+    bitTest(A, OP1);
+}
+
+:BITB OP1    is (op=0xC5 | op=0xD5 | op=0xE5 | op=0xF5) ... & OP1
+{
+    bitTest(B, OP1);
+}
+
+:LDAA OP1    is (op=0x86 | op=0x96 | op=0xA6 | op=0xB6) ... & OP1
+{
+    loadRegister(A, OP1);
+}
+
+:LDAB OP1    is (op=0xC6 | op=0xD6 | op=0xE6 | op=0xF6) ... & OP1
+{
+    loadRegister(B, OP1);
+}
+
+:STAA OP1    is (op=0x97 | op=0xA7 | op=0xB7) ... & OP1
+{
+    storeRegister(A, OP1);
+}
+
+:STAB OP1    is (op=0xD7 | op=0xE7 | op=0xF7) ... & OP1
+{
+    storeRegister(B, OP1);
+}
+
+:EORA OP1    is (op=0x88 | op=0x98 | op=0xA8 | op=0xB8) ... & OP1
+{
+    logicalExclusiveOr(A, OP1);
+}
+
+:EORB OP1    is (op=0xC8 | op=0xD8 | op=0xE8 | op=0xF8) ... & OP1
+{
+    logicalExclusiveOr(B, OP1);
+}
+
+:ADCA OP1    is (op=0x89 | op=0x99 | op=0xA9 | op=0xB9) ... & OP1
+{
+    additionWithCarry(A, OP1);
+}
+
+:ADCB OP1    is (op=0xC9 | op=0xD9 | op=0xE9 | op=0xF9) ... & OP1
+{
+    additionWithCarry(B, OP1);
+}
+
+:ORAA OP1    is (op=0x8A | op=0x9A | op=0xAA | op=0xBA) ... & OP1
+{
+    logicalOr(A, OP1);
+}
+
+:ORAB OP1    is (op=0xCA | op=0xDA | op=0xEA | op=0xFA) ... & OP1
+{
+    logicalOr(B, OP1);
+}
+
+:ADDA OP1    is (op=0x8B | op=0x9B | op=0xAB | op=0xBB) ... & OP1
+{
+    setHFlag(A, OP1);
+    addition(A, OP1);
+}
+
+:ADDB OP1    is (op=0xCB | op=0xDB | op=0xEB | op=0xFB) ... & OP1
+{
+    setHFlag(B, OP1);
+    addition(B, OP1);
+}
+
+:CPX OP2    is (op=0x8C | op=0x9C | op=0xAC | op=0xBC) ... & OP2
+{
+@ifdef MC6801
+    compare(X, OP2);
+@else
+    # Can't use the compare macro here because there is no carry.
+    V = sborrow(X, OP2);
+    local tmp = X - OP2;
+    setNZFlags(tmp);
+@endif
+}
+
+:BSR REL    is op=0x8D; REL
+{
+    local addr:2 = inst_next;
+    Push2(S, addr);
+    call REL;
+}
+
+:JSR EA2    is (op=0xAD | op=0xBD) ... & EA2
+{
+    local addr:2 = inst_next;
+    Push2(S, addr);
+    local target:2 = EA2;
+    call [target];
+}
+
+:LDS OP2    is (op=0x8E | op=0x9E | op=0xAE | op=0xBE) ... & OP2
+{
+    loadRegister(S, OP2);
+}
+
+:LDX OP2    is (op=0xCE | op=0xDE | op=0xEE | op=0xFE) ... & OP2
+{
+    loadRegister(X, OP2);
+}
+
+:STS OP2    is (op=0x9F | op=0xAF | op=0xBF) ... & OP2
+{
+    storeRegister(S, OP2);
+}
+
+:STX OP2    is (op=0xDF | op=0xEF | op=0xFF) ... & OP2
+{
+    storeRegister(X, OP2);
+}
diff --git a/Ghidra/Processors/MC6800/data/languages/mc6801.pspec b/Ghidra/Processors/MC6800/data/languages/mc6801.pspec
new file mode 100644
index 0000000000..e932b02c7f
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/mc6801.pspec
@@ -0,0 +1,54 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  Copyright 2022-2024 Sigurdur Asgeirsson <siggi@sort.is>
+
+  Licensed under the Apache License, Version 2.0 (the "License");
+  you may not use this file except in compliance with the License.
+  You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+  Unless required by applicable law or agreed to in writing, software
+  distributed under the License is distributed on an "AS IS" BASIS,
+  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+  See the License for the specific language governing permissions and
+  limitations under the License.
+-->
+
+<processor_spec>
+  <programcounter register="PC"/>
+
+  <default_memory_blocks>
+    <memory_block name="Internal Registers" start_address="RAM:0" length="0x20" initialized="false"/>
+  </default_memory_blocks>
+
+  <default_symbols>
+    <symbol name="P1DDR" address="0x00"/>
+    <symbol name="P2DDR" address="0x01"/>
+    <symbol name="P1DATA" address="0x02"/>
+    <symbol name="P2DATA" address="0x03"/>
+    <symbol name="P3DDR" address="0x04"/>
+    <symbol name="P4DDR" address="0x05"/>
+    <symbol name="P3DATA" address="0x06"/>
+    <symbol name="P4DATA" address="0x07"/>
+    <symbol name="TCSR" address="0x08"/>
+    <symbol name="TIMER" address="0x09"/>
+    <symbol name="OUTCMP" address="0x0B"/>
+    <symbol name="IMPCAP" address="0x0D"/>
+    <symbol name="P3SCR" address="0x0F"/>
+    <symbol name="RMCR" address="0x10"/>
+    <symbol name="TRCS" address="0x11"/>
+    <symbol name="RX" address="0x12"/>
+    <symbol name="TX" address="0x13"/>
+    <symbol name="RAMCR" address="0x14"/>
+
+    <symbol name="SCI_VECTOR" address="0xFFF0" entry="true" type="code_ptr"/>
+    <symbol name="TOF_VECTOR" address="0xFFF2" entry="true" type="code_ptr"/>
+    <symbol name="OCF_VECTOR" address="0xFFF4" entry="true" type="code_ptr"/>
+    <symbol name="ICF_VECTOR" address="0xFFF6" entry="true" type="code_ptr"/>
+    <symbol name="IRQ_VECTOR" address="0xFFF8" entry="true" type="code_ptr"/>
+    <symbol name="SWI_VECTOR" address="0xFFFA" entry="true" type="code_ptr"/>
+    <symbol name="NMI_VECTOR" address="0xFFFC" entry="true" type="code_ptr"/>
+    <symbol name="RST_VECTOR" address="0xFFFE" entry="true" type="code_ptr"/>
+  </default_symbols>
+</processor_spec>
diff --git a/Ghidra/Processors/MC6800/data/languages/mc6801.slaspec b/Ghidra/Processors/MC6800/data/languages/mc6801.slaspec
new file mode 100644
index 0000000000..6915b98edb
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/languages/mc6801.slaspec
@@ -0,0 +1,89 @@
+# Copyright 2022-2024 Sigurdur Asgeirsson <siggi@sort.is>
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#   http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+@define MC6801 ""
+
+@include "mc6800.slaspec"
+
+:ABX        is op=0x3A
+{
+    # No effect on flags.
+    X = X + zext(B);
+}
+
+:ADDD OP2   is (op=0xC3 | op=0xD3 | op=0xF3 | op=0xE3) ... & OP2
+{
+    addition(D, OP2);
+}
+
+:ASLD       is op=0x05
+{
+    C = D[15, 1];
+    D = D << 1;
+    Z = (D == 0);
+    N = D[15, 1];
+}
+
+:BRN        is op=0x21
+{
+    # Branch never is an elaborate NOP.
+    goto inst_next;
+}
+
+:JSR EA2    is op=0x9d ... & EA2
+{
+    local addr:2 = inst_next;
+    Push2(S, addr);
+    local target:2 = EA2;
+    call [target];
+}
+
+:LDD OP2    is (op=0xCC | op=0xDC | op=0xFC | op=0xEC) ... & OP2
+{
+    loadRegister(D, OP2);
+}
+
+:LSRD       is op=0x04
+{
+    C = D[0, 1];
+    D = D << 1;
+    Z = (D == 0);
+    N = D[15, 1];
+}
+
+:MUL        is op=0x3D
+{
+    D = zext(A) * zext(B);
+    C = D[15,1];
+}
+
+:PSHX       is op=0x3C
+{
+    Push2(S, X);
+}
+
+:PULX       is op=0x38
+{
+    Pull2(S, X);
+}
+
+:STD OP2    is (op=0xDD | op=0xFD | op=0xED) ... & OP2
+{
+    storeRegister(D, OP2);
+}
+
+:SUBD OP2   is (op=0x83 | op=0x93 | op=0xB3 | op=0xA3) ... & OP2
+{
+    subtraction(D, OP2);
+}
diff --git a/Ghidra/Processors/MC6800/data/manuals/mc6800.idx b/Ghidra/Processors/MC6800/data/manuals/mc6800.idx
new file mode 100644
index 0000000000..eef45a768b
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/manuals/mc6800.idx
@@ -0,0 +1,73 @@
+@mc6800.pdf [Motorola M6800 Programming Reference Manual M68PRM(D) Nov76]
+ABA, 36
+ADC, 37
+ADD, 38
+AND, 39
+ASL, 40
+ASR, 41
+BCC, 42
+BCS, 43
+BEQ, 44
+BGE, 45
+BGT, 46
+BHI, 47
+BIT, 48
+BLE, 49
+BLS, 50
+BLT, 51
+BMI, 52
+BNE, 53
+BPL, 54
+BRA, 55
+BSR, 56
+BVC, 57
+BVS, 58
+CBA, 59
+CLC, 60
+CLI, 61
+CLR, 62
+CLV, 63
+CMP, 64
+COM, 65
+CPX, 66
+DAA, 67
+DEC, 69
+DES, 70
+DEX, 71
+EOR, 72
+INC, 73
+INS, 74
+INX, 75
+JMP, 76
+JSR, 77
+LDA, 78
+LDS, 79
+LDX, 80
+LSR, 81
+NEG, 82
+NOP, 83
+ORA, 84
+PSH, 85
+PUL, 86
+ROL, 87
+ROR, 88
+RTI, 89
+RTS, 90
+SBA, 91
+SBC, 92
+SEC, 93
+SEI, 94
+SEV, 95
+STA, 96
+STS, 97
+STX, 98
+SUB, 99
+SWI, 100
+TAB, 102
+TAP, 103
+TBA, 104
+TPA, 105
+TST, 106
+TSX, 107
+TXS, 108
+WAI, 109
diff --git a/Ghidra/Processors/MC6800/data/manuals/mc6801.idx b/Ghidra/Processors/MC6800/data/manuals/mc6801.idx
new file mode 100644
index 0000000000..4acf4058e4
--- /dev/null
+++ b/Ghidra/Processors/MC6800/data/manuals/mc6801.idx
@@ -0,0 +1,88 @@
+@mc6801.pdf [MC6801RM_AD2_MC6801_Reference_Manual_May84.pdf]
+ABA, 270
+ABX, 271
+ADC, 272
+ADD, 273
+ADDD, 274
+AND, 275
+ASL, 276
+ASLD, 277
+ASR, 278
+BCC, 279
+BCS, 280
+BEQ, 281
+BGE, 282
+BGT, 283
+BHI, 284
+BHS, 285
+BIT, 286
+BLE, 287
+BLO, 288
+BLS, 289
+BLT, 290
+BMI, 291
+BNE, 292
+BPL, 293
+BRA, 294
+BRN, 295
+BSR, 296
+BVC, 297
+BVS, 298
+CBA, 299
+CLC, 300
+CLI, 301
+CLR, 302
+CLV, 303
+CMP, 304
+COM, 305
+CPX, 306
+DAA, 307
+DEC, 308
+DES, 309
+DEX, 310
+EOR, 311
+INC, 312
+INS, 313
+INX, 314
+JMP, 315
+JSR, 316
+LDA, 317
+LDD, 318
+LDS, 319
+LDX, 320
+LSL, 321
+LSLD, 322
+LSR, 323
+LSRD, 324
+MUL, 325
+NEG, 326
+NOP, 327
+ORA, 328
+PSH, 329
+PSHx, 330
+PUL, 331
+PULx, 332
+ROL, 333
+ROR, 334
+RTI, 335
+RTS, 336
+SBA, 337
+SBC, 338
+SEC, 339
+SEI, 340
+SEV, 341
+STA, 342
+STD, 343
+STS, 344
+STX, 345
+SUB, 346
+SUBD, 347
+SWI, 348
+TAB, 350
+TAP, 351
+TBA, 352
+TPA, 353
+TST, 354
+TSX, 355
+TXS, 356
+WAI, 357
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/AbstractEmulatorTest.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/AbstractEmulatorTest.java
new file mode 100644
index 0000000000..0a6efe1534
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/AbstractEmulatorTest.java
@@ -0,0 +1,186 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import static org.junit.jupiter.api.Assertions.fail;
+
+import java.io.ByteArrayOutputStream;
+
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.BeforeEach;
+
+import db.Transaction;
+import ghidra.app.emulator.EmulatorHelper;
+import ghidra.app.plugin.assembler.Assembler;
+import ghidra.app.plugin.assembler.Assemblers;
+import ghidra.pcode.memstate.MemoryFaultHandler;
+import ghidra.program.database.mem.MemoryMapDB;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.mem.MemoryBlock;
+import ghidra.util.exception.CancelledException;
+import ghidra.util.task.TaskMonitor;
+
+public abstract class AbstractEmulatorTest extends AbstractIntegrationTest {
+
+	public AbstractEmulatorTest(String lang) {
+		super(lang);
+
+		try (Transaction transaction = program.openTransaction("test")) {
+			MemoryMapDB mem = program.getMemory();
+			MemoryBlock block = mem.createUninitializedBlock("ram", address(0x0000), 0x10000, false);
+			mem.convertToInitialized(block, (byte) 0x00);
+
+			transaction.commit();
+		}
+		catch (Exception e) {
+			fail("Failed to create RAM.", e);
+		}
+	}
+
+	class FailOnMemoryFault implements MemoryFaultHandler {
+		@Override
+		public boolean uninitializedRead(Address address, int size, byte[] buf, int bufOffset) {
+			return false;
+		}
+
+		@Override
+		public boolean unknownAddress(Address address, boolean write) {
+			return false;
+		}
+	}
+
+	protected void assemble(int addr, String ... code) {
+		Transaction transaction = program.openTransaction("test");
+		Assembler asm = Assemblers.getAssembler(program);
+		try {
+			asm.assemble(address(addr), code);
+		}
+		catch (Exception e) {
+			fail("Assembly failed", e);
+			transaction.abort();
+			return;
+		}
+		transaction.commit();
+	}
+
+	protected void setA(int value) {
+		emulator.writeRegister("A", value);
+	}
+
+	protected void setB(int value) {
+		emulator.writeRegister("B", value);
+	}
+
+	protected void setD(int value) {
+		emulator.writeRegister("D", value);
+	}
+
+	protected void setCC(int value) {
+		emulator.writeRegister("CC", value);
+	}
+
+	protected void setX(int value) {
+		emulator.writeRegister("X", value);
+	}
+
+	protected void setS(int value) {
+		emulator.writeRegister("S", value);
+	}
+
+	protected void setPC(int value) {
+		emulator.writeRegister("PC", value);
+	}
+
+	protected int getA() {
+		return emulator.readRegister("A").intValue();
+	}
+
+	protected int getB() {
+		return emulator.readRegister("B").intValue();
+	}
+
+	protected int getD() {
+		return emulator.readRegister("D").intValue();
+	}
+
+	protected int getCC() {
+		return emulator.readRegister("CC").intValue();
+	}
+
+	protected int getX() {
+		return emulator.readRegister("X").intValue();
+	}
+
+	protected int getS() {
+		return emulator.readRegister("S").intValue();
+	}
+
+	protected int getPC() {
+		return emulator.readRegister("PC").intValue();
+	}
+
+	protected void write(int addr, int... bytes) {
+		ByteArrayOutputStream stream = new ByteArrayOutputStream();
+		for (int v : bytes) {
+			stream.write(v);
+		}
+		emulator.writeMemory(address(addr), stream.toByteArray());
+	}
+
+	protected byte[] read(int addr, int length) {
+		return emulator.readMemory(address(addr), length);
+	}
+
+	protected byte readByte(int addr) {
+		return read(addr, 1)[0];
+	}
+
+	protected void step(int numInstructions) {
+		try {
+			for (int i = 0; i < numInstructions; ++i)
+				emulator.step(TaskMonitor.DUMMY);
+		}
+		catch (CancelledException e) {
+			fail("Failed to step.", e);
+		}
+	}
+
+	protected void step() {
+		step(1);
+	}
+
+	protected void stepFrom(int addr, int numInstructions) {
+		setPC(addr);
+		step(numInstructions);
+	}
+
+	protected void stepFrom(int addr) {
+		stepFrom(addr, 1);
+	}
+
+	@BeforeEach
+	public void beforeEach() {
+		emulator = new EmulatorHelper(program);
+		emulator.setMemoryFaultHandler(new FailOnMemoryFault());
+	}
+
+	@AfterEach
+	public void afterEach() {
+		emulator.dispose();
+		emulator = null;
+	}
+
+	private EmulatorHelper emulator = null;
+}
\ No newline at end of file
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/AbstractIntegrationTest.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/AbstractIntegrationTest.java
new file mode 100644
index 0000000000..9a0493e039
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/AbstractIntegrationTest.java
@@ -0,0 +1,102 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+
+import db.Transaction;
+import generic.jar.ResourceFile;
+import generic.test.AbstractGTest;
+import generic.test.AbstractGenericTest;
+import ghidra.GhidraTestApplicationLayout;
+import ghidra.app.plugin.processors.sleigh.SleighLanguageProvider;
+import ghidra.framework.GModule;
+import ghidra.program.database.ProgramDB;
+import ghidra.program.disassemble.Disassembler;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.lang.Language;
+import ghidra.program.model.lang.LanguageID;
+import ghidra.program.model.listing.CodeUnit;
+import ghidra.program.model.mem.MemoryBlock;
+import ghidra.util.task.TaskMonitor;
+import utility.application.ApplicationLayout;
+
+public abstract class AbstractIntegrationTest extends AbstractGenericTest {
+
+	protected Address address(int addr) {
+		return language.getDefaultSpace().getAddress(addr);
+	}
+
+	protected CodeUnit disassemble(byte[] bytes) {
+		try (Transaction transaction = program.openTransaction("disassemble")) {
+			ByteArrayInputStream stream = new ByteArrayInputStream(bytes);
+			// Create an overlay block.
+			MemoryBlock block = program.getMemory()
+					.createInitializedBlock("test", address(0), stream, bytes.length,
+						TaskMonitor.DUMMY,
+						true);
+
+			Disassembler disassembler =
+				Disassembler.getDisassembler(program, TaskMonitor.DUMMY, null);
+			disassembler.disassemble(block.getStart(),
+				program.getMemory().getLoadedAndInitializedAddressSet());
+			CodeUnit ret = program.getCodeManager().getCodeUnitAt(block.getStart());
+			transaction.commit();
+			return ret;
+		}
+		catch (Exception e) {
+			return null;
+		}
+	}
+
+	public AbstractIntegrationTest(String lang) {
+		SleighLanguageProvider provider = SleighLanguageProvider.getSleighLanguageProvider();
+		this.language = provider.getLanguage(new LanguageID(lang));
+		ProgramDB program = null;
+		try {
+			program = new ProgramDB("test", language, language.getDefaultCompilerSpec(), this);
+		}
+		catch (IOException e) {
+		}
+		this.program = program;
+	}
+
+	@Override
+	protected ApplicationLayout createApplicationLayout() throws IOException {
+		return new TestApplicationLayout(new File(AbstractGTest.getTestDirectoryPath()));
+	}
+
+	// This is necessary to inject the build directory into the application layout.
+	private class TestApplicationLayout extends GhidraTestApplicationLayout {
+		public TestApplicationLayout(File path) throws IOException {
+			super(path);
+		}
+
+		@Override
+		public Map<String, GModule> findGhidraModules() throws IOException {
+			var ret = new HashMap<String, GModule>(super.findGhidraModules());
+
+			ret.put("6800", new GModule(applicationRootDirs, new ResourceFile("./build")));
+			return ret;
+		}
+	}
+
+	protected final Language language;
+	protected final ProgramDB program;
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/CC.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/CC.java
new file mode 100644
index 0000000000..ac8787b175
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/CC.java
@@ -0,0 +1,24 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+public class CC {
+	public static final int C = 0x01;
+	public static final int V = 0x02;
+	public static final int Z = 0x04;
+	public static final int N = 0x08;
+	public static final int I = 0x10;
+	public static final int H = 0x20;
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyCommonTest.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyCommonTest.java
new file mode 100644
index 0000000000..a7f4a546ff
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyCommonTest.java
@@ -0,0 +1,553 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+
+import java.io.ByteArrayOutputStream;
+
+import org.junit.jupiter.api.Test;
+
+import ghidra.program.model.listing.CodeUnit;
+import ghidra.program.model.listing.Data;
+import ghidra.program.model.listing.Instruction;
+
+public abstract class DisassemblyCommonTest extends AbstractIntegrationTest {
+	protected DisassemblyCommonTest(String lang) {
+		super(lang);
+	}
+
+	// The instructions are tested in the order of appearance in the
+	// Motorola M6800 Programming Reference Manual.
+	// http://www.bitsavers.org/components/motorola/6800/Motorola_M6800_Programming_Reference_Manual_M68PRM(D)_Nov76.pdf
+
+	@Test
+	public void ABA() {
+		test(0x1B, "ABA");
+	}
+
+	@Test
+	public void ADC() {
+		test(0x89, "ADCA #0xa", 0x0A);
+		test(0x99, "ADCA 0x000a", 0x0A);
+		test(0xB9, "ADCA 0x1234", 0x12, 0x34);
+		test(0xA9, "ADCA 0xa,X", 0x0A);
+
+		test(0xC9, "ADCB #0xa", 0x0A);
+		test(0xD9, "ADCB 0x000a", 0x0A);
+		test(0xF9, "ADCB 0x1234", 0x12, 0x34);
+		test(0xE9, "ADCB 0xa,X", 0x0A);
+	}
+
+	@Test
+	public void ADD() {
+		test(0x8B, "ADDA #0xa", 0x0A);
+		test(0x9B, "ADDA 0x000a", 0x0A);
+		test(0xBB, "ADDA 0x1234", 0x12, 0x34);
+		test(0xAB, "ADDA 0xa,X", 0x0A);
+
+		test(0xCB, "ADDB #0xa", 0x0A);
+		test(0xDB, "ADDB 0x000a", 0x0A);
+		test(0xFB, "ADDB 0x1234", 0x12, 0x34);
+		test(0xEB, "ADDB 0xa,X", 0x0A);
+	}
+
+	@Test
+	public void AND() {
+		test(0x84, "ANDA #0xa", 0x0A);
+		test(0x94, "ANDA 0x000a", 0x0A);
+		test(0xB4, "ANDA 0x1234", 0x12, 0x34);
+		test(0xA4, "ANDA 0xa,X", 0x0A);
+
+		test(0xC4, "ANDB #0xa", 0x0A);
+		test(0xD4, "ANDB 0x000a", 0x0A);
+		test(0xF4, "ANDB 0x1234", 0x12, 0x34);
+		test(0xE4, "ANDB 0xa,X", 0x0A);
+	}
+
+	@Test
+	public void ASL() {
+		test(0x48, "ASLA");
+		test(0x58, "ASLB");
+		test(0x78, "ASL 0x1234", 0x12, 0x34);
+		test(0x68, "ASL 0x12,X", 0x12);
+	}
+
+	@Test
+	public void ASR() {
+		test(0x47, "ASRA");
+		test(0x57, "ASRB");
+		test(0x77, "ASR 0x1234", 0x12, 0x34);
+		test(0x67, "ASR 0x12,X", 0x12);
+	}
+
+	@Test
+	public void BCC() {
+		test(0x24, "BCC 0x0022", 0x20);
+	}
+
+	@Test
+	public void BCS() {
+		test(0x25, "BCS 0x0022", 0x20);
+	}
+
+	@Test
+	public void BEQ() {
+		test(0x27, "BEQ 0x0022", 0x20);
+	}
+
+	@Test
+	public void BGE() {
+		test(0x2C, "BGE 0x0022", 0x20);
+	}
+
+	@Test
+	public void BGT() {
+		test(0x2E, "BGT 0x0022", 0x20);
+	}
+
+	@Test
+	public void BHI() {
+		test(0x22, "BHI 0x0022", 0x20);
+	}
+
+	@Test
+	public void BIT() {
+		test(0x85, "BITA #0xab", 0xAB);
+		test(0x95, "BITA 0x00ab", 0xAB);
+		test(0xB5, "BITA 0x1234", 0x12, 0x34);
+		test(0xA5, "BITA 0xab,X", 0xAB);
+
+		test(0xC5, "BITB #0xab", 0xAB);
+		test(0xD5, "BITB 0x00ab", 0xAB);
+		test(0xF5, "BITB 0x1234", 0x12, 0x34);
+		test(0xE5, "BITB 0xab,X", 0xAB);
+	}
+
+	@Test
+	public void BLE() {
+		test(0x2F, "BLE 0x0022", 0x20);
+	}
+
+	@Test
+	public void BLS() {
+		test(0x23, "BLS 0x0022", 0x20);
+	}
+
+	@Test
+	public void BLT() {
+		test(0x2D, "BLT 0x0022", 0x20);
+	}
+
+	@Test
+	public void BMI() {
+		test(0x2B, "BMI 0x0022", 0x20);
+	}
+
+	@Test
+	public void BNE() {
+		test(0x26, "BNE 0x0022", 0x20);
+	}
+
+	@Test
+	public void BPL() {
+		test(0x2A, "BPL 0x0022", 0x20);
+	}
+
+	@Test
+	public void BRA() {
+		test(0x20, "BRA 0x0022", 0x20);
+	}
+
+	@Test
+	public void BSR() {
+		test(0x8D, "BSR 0x0022", 0x20);
+	}
+
+	@Test
+	public void BVC() {
+		test(0x28, "BVC 0x0022", 0x20);
+	}
+
+	@Test
+	public void BVS() {
+		test(0x29, "BVS 0x0022", 0x20);
+	}
+
+	@Test
+	public void CBA() {
+		test(0x11, "CBA");
+	}
+
+	@Test
+	public void CLC() {
+		test(0x0C, "CLC");
+	}
+
+	@Test
+	public void CLI() {
+		test(0x0E, "CLI");
+	}
+
+	@Test
+	public void CLR() {
+		test(0x4F, "CLRA");
+		test(0x5F, "CLRB");
+		test(0x7F, "CLR 0x1234", 0x12, 0x34);
+		test(0x6F, "CLR 0x12,X", 0x12);
+	}
+
+	@Test
+	public void CLV() {
+		test(0x0A, "CLV");
+	}
+
+	@Test
+	public void CMP() {
+		test(0x81, "CMPA #0xab", 0xAB);
+		test(0x91, "CMPA 0x00ab", 0xAB);
+		test(0xB1, "CMPA 0x1234", 0x12, 0x34);
+		test(0xA1, "CMPA 0xab,X", 0xAB);
+
+		test(0xC1, "CMPB #0xab", 0xAB);
+		test(0xD1, "CMPB 0x00ab", 0xAB);
+		test(0xF1, "CMPB 0x1234", 0x12, 0x34);
+		test(0xE1, "CMPB 0xab,X", 0xAB);
+	}
+
+	@Test
+	public void COM() {
+		test(0x43, "COMA");
+		test(0x53, "COMB");
+		test(0x73, "COM 0x1234", 0x12, 0x34);
+		test(0x63, "COM 0x12,X", 0x12);
+	}
+
+	@Test
+	public void CPX() {
+		test(0x8C, "CPX #0x1234", 0x12, 0x34);
+		test(0x9C, "CPX 0x00ab", 0xAB);
+		test(0xBC, "CPX 0x1234", 0x12, 0x34);
+		test(0xAC, "CPX 0x12,X", 0x12);
+	}
+
+	@Test
+	public void DAA() {
+		test(0x19, "DAA");
+	}
+
+	@Test
+	public void DEC() {
+		test(0x4A, "DECA");
+		test(0x5A, "DECB");
+		test(0x7A, "DEC 0x1234", 0x12, 0x34);
+		test(0x6A, "DEC 0x12,X", 0x12);
+	}
+
+	@Test
+	public void DES() {
+		test(0x34, "DES");
+	}
+
+	@Test
+	public void DEX() {
+		test(0x09, "DEX");
+	}
+
+	@Test
+	public void EOR() {
+		test(0x88, "EORA #0xab", 0xAB);
+		test(0x98, "EORA 0x00ab", 0xAB);
+		test(0xB8, "EORA 0x1234", 0x12, 0x34);
+		test(0xA8, "EORA 0xab,X", 0xAB);
+
+		test(0xC8, "EORB #0xab", 0xAB);
+		test(0xD8, "EORB 0x00ab", 0xAB);
+		test(0xF8, "EORB 0x1234", 0x12, 0x34);
+		test(0xE8, "EORB 0xab,X", 0xAB);
+	}
+
+	@Test
+	public void INC() {
+		test(0x4C, "INCA");
+		test(0x5C, "INCB");
+		test(0x7C, "INC 0x1234", 0x12, 0x34);
+		test(0x6C, "INC 0x12,X", 0x12);
+	}
+
+	@Test
+	public void INS() {
+		test(0x31, "INS");
+	}
+
+	@Test
+	public void INX() {
+		test(0x08, "INX");
+	}
+
+	@Test
+	public void JMP() {
+		test(0x7E, "JMP 0x1234", 0x12, 0x34);
+		test(0x6E, "JMP 0x12,X", 0x12);
+	}
+
+	@Test
+	public void JSR() {
+		test(0xBD, "JSR 0x1234", 0x12, 0x34);
+		test(0xAD, "JSR 0x12,X", 0x12);
+	}
+
+	@Test
+	public void LDA() {
+		test(0x86, "LDAA #0xab", 0xAB);
+		test(0x96, "LDAA 0x00ab", 0xAB);
+		test(0xB6, "LDAA 0x1234", 0x12, 0x34);
+		test(0xA6, "LDAA 0xab,X", 0xAB);
+
+		test(0xC6, "LDAB #0xab", 0xAB);
+		test(0xD6, "LDAB 0x00ab", 0xAB);
+		test(0xF6, "LDAB 0x1234", 0x12, 0x34);
+		test(0xE6, "LDAB 0xab,X", 0xAB);
+	}
+
+	@Test
+	public void LDS() {
+		test(0x8E, "LDS #0x1234", 0x12, 0x34);
+		test(0x9E, "LDS 0x00ab", 0xAB);
+		test(0xBE, "LDS 0x1234", 0x12, 0x34);
+		test(0xAE, "LDS 0x12,X", 0x12);
+	}
+
+	@Test
+	public void LDX() {
+		test(0xCE, "LDX #0x1234", 0x12, 0x34);
+		test(0xDE, "LDX 0x00ab", 0xAB);
+		test(0xFE, "LDX 0x1234", 0x12, 0x34);
+		test(0xEE, "LDX 0x12,X", 0x12);
+	}
+
+	@Test
+	public void LSR() {
+		test(0x44, "LSRA");
+		test(0x54, "LSRB");
+		test(0x74, "LSR 0x1234", 0x12, 0x34);
+		test(0x64, "LSR 0x12,X", 0x12);
+	}
+
+	@Test
+	public void NEG() {
+		test(0x40, "NEGA");
+		test(0x50, "NEGB");
+		test(0x70, "NEG 0x1234", 0x12, 0x34);
+		test(0x60, "NEG 0x12,X", 0x12);
+	}
+
+	@Test
+	public void NOP() {
+		test(0x01, "NOP");
+	}
+
+	@Test
+	public void ORA() {
+		test(0x8A, "ORAA #0xab", 0xAB);
+		test(0x9A, "ORAA 0x00ab", 0xAB);
+		test(0xBA, "ORAA 0x1234", 0x12, 0x34);
+		test(0xAA, "ORAA 0xab,X", 0xAB);
+
+		test(0xCA, "ORAB #0xab", 0xAB);
+		test(0xDA, "ORAB 0x00ab", 0xAB);
+		test(0xFA, "ORAB 0x1234", 0x12, 0x34);
+		test(0xEA, "ORAB 0xab,X", 0xAB);
+	}
+
+	@Test
+	public void PSH() {
+		test(0x36, "PSHA");
+		test(0x37, "PSHB");
+	}
+
+	@Test
+	public void PUL() {
+		test(0x32, "PULA");
+		test(0x33, "PULB");
+	}
+
+	@Test
+	public void ROL() {
+		test(0x49, "ROLA");
+		test(0x59, "ROLB");
+		test(0x79, "ROL 0x1234", 0x12, 0x34);
+		test(0x69, "ROL 0x12,X", 0x12);
+	}
+
+	@Test
+	public void ROR() {
+		test(0x46, "RORA");
+		test(0x56, "RORB");
+		test(0x76, "ROR 0x1234", 0x12, 0x34);
+		test(0x66, "ROR 0x12,X", 0x12);
+	}
+
+	@Test
+	public void RTI() {
+		test(0x3B, "RTI");
+	}
+
+	@Test
+	public void RTS() {
+		test(0x39, "RTS");
+	}
+
+	@Test
+	public void SBA() {
+		test(0x10, "SBA");
+	}
+
+	@Test
+	public void SBC() {
+		test(0x82, "SBCA #0xa", 0x0A);
+		test(0x92, "SBCA 0x000a", 0x0A);
+		test(0xB2, "SBCA 0x1234", 0x12, 0x34);
+		test(0xA2, "SBCA 0xa,X", 0x0A);
+
+		test(0xC2, "SBCB #0xa", 0x0A);
+		test(0xD2, "SBCB 0x000a", 0x0A);
+		test(0xF2, "SBCB 0x1234", 0x12, 0x34);
+		test(0xE2, "SBCB 0xa,X", 0x0A);
+	}
+
+	@Test
+	public void SEC() {
+		test(0x0D, "SEC");
+	}
+
+	@Test
+	public void SEI() {
+		test(0x0F, "SEI");
+	}
+
+	@Test
+	public void SEV() {
+		test(0x0B, "SEV");
+	}
+
+	@Test
+	public void STA() {
+		test(0x97, "STAA 0x000a", 0x0A);
+		test(0xB7, "STAA 0x1234", 0x12, 0x34);
+		test(0xA7, "STAA 0xa,X", 0x0A);
+
+		test(0xD7, "STAB 0x000a", 0x0A);
+		test(0xF7, "STAB 0x1234", 0x12, 0x34);
+		test(0xE7, "STAB 0xa,X", 0x0A);
+	}
+
+	public void STS() {
+		test(0x9F, "STX 0x000a", 0x0A);
+		test(0xBF, "STX 0x1234", 0x12, 0x34);
+		test(0xAF, "STX 0xa,X", 0x0A);
+	}
+
+	public void STX() {
+		test(0xDF, "STX 0x000a", 0x0A);
+		test(0xFF, "STX 0x1234", 0x12, 0x34);
+		test(0xEF, "STX 0xa,X", 0x0A);
+	}
+
+	@Test
+	public void SUB() {
+		test(0x80, "SUBA #0xa", 0x0A);
+		test(0x90, "SUBA 0x000a", 0x0A);
+		test(0xB0, "SUBA 0x1234", 0x12, 0x34);
+		test(0xA0, "SUBA 0xa,X", 0x0A);
+
+		test(0xC0, "SUBB #0xa", 0x0A);
+		test(0xD0, "SUBB 0x000a", 0x0A);
+		test(0xF0, "SUBB 0x1234", 0x12, 0x34);
+		test(0xE0, "SUBB 0xa,X", 0x0A);
+	}
+
+	@Test
+	public void SWI() {
+		test(0x3F, "SWI");
+	}
+
+	@Test
+	public void TAB() {
+		test(0x16, "TAB");
+	}
+
+	@Test
+	public void TAP() {
+		test(0x06, "TAP");
+	}
+
+	@Test
+	public void TBA() {
+		test(0x17, "TBA");
+	}
+
+	@Test
+	public void TPA() {
+		test(0x07, "TPA");
+	}
+
+	@Test
+	public void TST() {
+		test(0x4D, "TSTA");
+		test(0x5D, "TSTB");
+		test(0x7D, "TST 0x1234", 0x12, 0x34);
+		test(0x6D, "TST 0x12,X", 0x12);
+	}
+
+	@Test
+	public void TSX() {
+		test(0x30, "TSX");
+	}
+
+	@Test
+	public void TXS() {
+		test(0x35, "TXS");
+	}
+
+	@Test
+	public void WAI() {
+		test(0x3E, "WAI");
+	}
+
+	protected void assertInvalidOpcode(int opCode) {
+		byte[] code = new byte[] { (byte) opCode, (byte) 0x12, (byte) 0x34 };
+		CodeUnit codeUnit = disassemble(code);
+		assertTrue(codeUnit instanceof Data);
+	}
+
+	protected void test(int opCode, String expected, int... args) {
+		ByteArrayOutputStream stream = new ByteArrayOutputStream();
+
+		stream.write(opCode);
+		for (int arg : args) {
+			stream.write(arg);
+		}
+
+		byte[] bytes = stream.toByteArray();
+		CodeUnit codeUnit = disassemble(bytes);
+		assertTrue(codeUnit instanceof Instruction);
+		assertNotNull(codeUnit);
+		assertEquals(expected, codeUnit.toString());
+		assertEquals(bytes.length, codeUnit.getLength());
+	}
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyHD6301Test.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyHD6301Test.java
new file mode 100644
index 0000000000..4ae6254a34
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyHD6301Test.java
@@ -0,0 +1,93 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import org.junit.jupiter.api.Test;
+
+public class DisassemblyHD6301Test extends DisassemblyMC6801CommonTest {
+	public DisassemblyHD6301Test() {
+		super("HD6301:BE:16:default");
+	}
+
+	@Test
+	public void AIM() {
+		test(0x71, "AIM #0x12,0x0034", 0x12, 0x34);
+		test(0x61, "AIM #0x12,0x34,X", 0x12, 0x34);
+	}
+
+	@Test
+	public void OIM() {
+		test(0x72, "OIM #0x12,0x0034", 0x12, 0x34);
+		test(0x62, "OIM #0x12,0x34,X", 0x12, 0x34);
+	}
+
+	@Test
+	public void EIM() {
+		test(0x75, "EIM #0x12,0x0034", 0x12, 0x34);
+		test(0x65, "EIM #0x12,0x34,X", 0x12, 0x34);
+	}
+
+	@Test
+	public void TIM() {
+		test(0x7B, "TIM #0x12,0x0034", 0x12, 0x34);
+		test(0x6B, "TIM #0x12,0x34,X", 0x12, 0x34);
+	}
+
+	@Test
+	public void XGDX() {
+		test(0x18, "XGDX");
+	}
+
+	@Test
+	public void SLP() {
+		test(0x1A, "SLP");
+	}
+
+	@Test
+	public void InvalidOpCodes() {
+		assertInvalidOpcode(0x00);
+		assertInvalidOpcode(0x02);
+		assertInvalidOpcode(0x03);
+
+		assertInvalidOpcode(0x12);
+		assertInvalidOpcode(0x13);
+		assertInvalidOpcode(0x14);
+		assertInvalidOpcode(0x15);
+
+		assertInvalidOpcode(0x1C);
+		assertInvalidOpcode(0x1D);
+		assertInvalidOpcode(0x1E);
+		assertInvalidOpcode(0x1F);
+
+		assertInvalidOpcode(0x41);
+		assertInvalidOpcode(0x42);
+		assertInvalidOpcode(0x45);
+		assertInvalidOpcode(0x4B);
+		assertInvalidOpcode(0x4E);
+
+		assertInvalidOpcode(0x51);
+		assertInvalidOpcode(0x52);
+		assertInvalidOpcode(0x55);
+		assertInvalidOpcode(0x5B);
+		assertInvalidOpcode(0x5E);
+
+		assertInvalidOpcode(0x87);
+		assertInvalidOpcode(0x8F);
+
+		assertInvalidOpcode(0xC7);
+		assertInvalidOpcode(0xCD);
+		assertInvalidOpcode(0xCF);
+	}
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6800Test.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6800Test.java
new file mode 100644
index 0000000000..1f65475b53
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6800Test.java
@@ -0,0 +1,102 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import org.junit.jupiter.api.Test;
+
+public class DisassemblyMC6800Test extends DisassemblyCommonTest {
+	public DisassemblyMC6800Test() {
+		super("MC6800:BE:16:default");
+	}
+
+	@Test
+	public void InvalidOpCodes() {
+		assertInvalidOpcode(0x00);
+		assertInvalidOpcode(0x02);
+		assertInvalidOpcode(0x03);
+		assertInvalidOpcode(0x04);
+		assertInvalidOpcode(0x05);
+
+		assertInvalidOpcode(0x12);
+		assertInvalidOpcode(0x13);
+		assertInvalidOpcode(0x14);
+		assertInvalidOpcode(0x15);
+		assertInvalidOpcode(0x18);
+
+		assertInvalidOpcode(0x1A);
+		assertInvalidOpcode(0x1C);
+		assertInvalidOpcode(0x1D);
+		assertInvalidOpcode(0x1E);
+		assertInvalidOpcode(0x1F);
+
+		assertInvalidOpcode(0x21);
+
+		assertInvalidOpcode(0x38);
+		assertInvalidOpcode(0x3A);
+		assertInvalidOpcode(0x3C);
+		assertInvalidOpcode(0x3D);
+
+		assertInvalidOpcode(0x41);
+		assertInvalidOpcode(0x42);
+		assertInvalidOpcode(0x45);
+		assertInvalidOpcode(0x4B);
+		assertInvalidOpcode(0x4E);
+
+		assertInvalidOpcode(0x51);
+		assertInvalidOpcode(0x52);
+		assertInvalidOpcode(0x55);
+		assertInvalidOpcode(0x5B);
+		assertInvalidOpcode(0x5E);
+
+		assertInvalidOpcode(0x61);
+		assertInvalidOpcode(0x62);
+		assertInvalidOpcode(0x65);
+		assertInvalidOpcode(0x6B);
+
+		assertInvalidOpcode(0x71);
+		assertInvalidOpcode(0x72);
+		assertInvalidOpcode(0x75);
+		assertInvalidOpcode(0x7B);
+
+		assertInvalidOpcode(0x83);
+		assertInvalidOpcode(0x87);
+		assertInvalidOpcode(0x8F);
+
+		assertInvalidOpcode(0x93);
+		assertInvalidOpcode(0x9D);
+
+		assertInvalidOpcode(0xA3);
+
+		assertInvalidOpcode(0xB3);
+
+		assertInvalidOpcode(0xC3);
+		assertInvalidOpcode(0xC7);
+		assertInvalidOpcode(0xCC);
+		assertInvalidOpcode(0xCD);
+		assertInvalidOpcode(0xCF);
+
+		assertInvalidOpcode(0xD3);
+		assertInvalidOpcode(0xDC);
+		assertInvalidOpcode(0xDD);
+
+		assertInvalidOpcode(0xE3);
+		assertInvalidOpcode(0xEC);
+		assertInvalidOpcode(0xED);
+
+		assertInvalidOpcode(0xF3);
+		assertInvalidOpcode(0xFC);
+		assertInvalidOpcode(0xFD);
+	}
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6801CommonTest.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6801CommonTest.java
new file mode 100644
index 0000000000..b95c2d9165
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6801CommonTest.java
@@ -0,0 +1,95 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import org.junit.jupiter.api.Test;
+
+public abstract class DisassemblyMC6801CommonTest extends DisassemblyCommonTest {
+	public DisassemblyMC6801CommonTest(String lang) {
+		super(lang);
+	}
+
+	@Test
+	public void ABX() {
+		test(0x3A, "ABX");
+	}
+
+	@Test
+	public void ADDD() {
+		test(0xC3, "ADDD #0x1234", 0x12, 0x34);
+		test(0xD3, "ADDD 0x00ab", 0xab);
+		test(0xF3, "ADDD 0x1234", 0x12, 0x34);
+		test(0xE3, "ADDD 0xab,X", 0xAB);
+	}
+
+	@Test
+	public void ASLD() {
+		test(0x05, "ASLD");
+	}
+
+	@Override
+	@Test
+	public void JSR() {
+		// Test the MC6800 variants.
+		super.JSR();
+
+		// The direct JSR is first present in the MC6801.
+		test(0x9D, "JSR 0x00ab", 0xAB);
+	}
+
+	@Test
+	public void LDD() {
+		test(0xCC, "LDD #0x1234", 0x12, 0x34);
+		test(0xDC, "LDD 0x00ab", 0xab);
+		test(0xFC, "LDD 0x1234", 0x12, 0x34);
+		test(0xEC, "LDD 0xab,X", 0xAB);
+	}
+
+	@Test
+	public void LSRD() {
+		test(0x04, "LSRD");
+	}
+
+	@Test
+	public void MUL() {
+		test(0x3D, "MUL");
+	}
+
+	@Test
+	public void PSHX() {
+		test(0x3C, "PSHX");
+	}
+
+	@Test
+	public void PULX() {
+		test(0x38, "PULX");
+	}
+
+	@Test
+	public void STD() {
+		test(0xDD, "STD 0x00ab", 0xAB);
+		test(0xFD, "STD 0x1234", 0x12, 0x34);
+		test(0xED, "STD 0xab,X", 0xAB);
+	}
+
+	@Test
+	public void SUBD() {
+		test(0x83, "SUBD #0x1234", 0x12, 0x34);
+		test(0x93, "SUBD 0x00ab", 0xab);
+		test(0xB3, "SUBD 0x1234", 0x12, 0x34);
+		test(0xA3, "SUBD 0xab,X", 0xAB);
+	}
+
+}
\ No newline at end of file
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6801Test.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6801Test.java
new file mode 100644
index 0000000000..381ce9f14d
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/DisassemblyMC6801Test.java
@@ -0,0 +1,71 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import org.junit.jupiter.api.Test;
+
+public class DisassemblyMC6801Test extends DisassemblyMC6801CommonTest {
+	public DisassemblyMC6801Test() {
+		super("MC6801:BE:16:default");
+	}
+
+	@Test
+	public void InvalidOpCodes() {
+		assertInvalidOpcode(0x00);
+		assertInvalidOpcode(0x02);
+		assertInvalidOpcode(0x03);
+
+		assertInvalidOpcode(0x12);
+		assertInvalidOpcode(0x13);
+		assertInvalidOpcode(0x14);
+		assertInvalidOpcode(0x15);
+		assertInvalidOpcode(0x18);
+
+		assertInvalidOpcode(0x1A);
+		assertInvalidOpcode(0x1C);
+		assertInvalidOpcode(0x1D);
+		assertInvalidOpcode(0x1E);
+		assertInvalidOpcode(0x1F);
+
+		assertInvalidOpcode(0x41);
+		assertInvalidOpcode(0x42);
+		assertInvalidOpcode(0x45);
+		assertInvalidOpcode(0x4B);
+		assertInvalidOpcode(0x4E);
+
+		assertInvalidOpcode(0x51);
+		assertInvalidOpcode(0x52);
+		assertInvalidOpcode(0x55);
+		assertInvalidOpcode(0x5B);
+		assertInvalidOpcode(0x5E);
+
+		assertInvalidOpcode(0x61);
+		assertInvalidOpcode(0x62);
+		assertInvalidOpcode(0x65);
+		assertInvalidOpcode(0x6B);
+
+		assertInvalidOpcode(0x71);
+		assertInvalidOpcode(0x72);
+		assertInvalidOpcode(0x75);
+		assertInvalidOpcode(0x7B);
+
+		assertInvalidOpcode(0x87);
+		assertInvalidOpcode(0x8F);
+
+		assertInvalidOpcode(0xC7);
+		assertInvalidOpcode(0xCD);
+		assertInvalidOpcode(0xCF);
+	}
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorHD6301Test.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorHD6301Test.java
new file mode 100644
index 0000000000..504ca501e1
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorHD6301Test.java
@@ -0,0 +1,79 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import org.junit.jupiter.api.Test;
+
+public class EmulatorHD6301Test extends AbstractEmulatorTest {
+	public EmulatorHD6301Test() {
+		super("HD6301:BE:16:default");
+	}
+
+	@Test
+	public void AIM() {
+		assemble(0x0000,
+			"AIM #0xAA,0x0020",
+			"AIM #0x55,0x10,X");
+		// Set 0x20 to 0x0F.
+		write(0x0020, 0x0F);
+
+		setCC(0x00);
+		stepFrom(0x0000);
+		assertEquals(0, getCC());
+		assertEquals(0x0A, readByte(0x20));
+
+		setX(0x0010);
+		// Test the indexed variant.
+		stepFrom(0x0003);
+		assertEquals(CC.Z, getCC());
+		assertEquals(0x00, readByte(0x20));
+	}
+
+	@Test
+	public void TIM() {
+		assemble(0x0000,
+			"TIM #0xAA,0x0020",
+			"TIM #0xF0,0x10,X");
+		// Set 0x20 to 0x0F.
+		write(0x0020, 0x0F);
+
+		setCC(0x00);
+		stepFrom(0x0000);
+		assertEquals(0, getCC());
+		assertEquals(0x0F, readByte(0x20));
+
+		setX(0x0010);
+		// Test the indexed variant.
+		stepFrom(0x0003);
+		assertEquals(CC.Z, getCC());
+		assertEquals(0x0F, readByte(0x20));
+	}
+
+	@Test
+	public void XGDX() {
+		assemble(0x0000, "XGDX");
+
+		setCC(0x00);
+		setX(0xCAFE);
+		setD(0xBABE);
+		stepFrom(0x0000);
+
+		assertEquals(0xBABE, getX());
+		assertEquals(0xCAFE, getD());
+		assertEquals(0x00, getCC());
+	}
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC6800Test.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC6800Test.java
new file mode 100644
index 0000000000..8a702cd1c6
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC6800Test.java
@@ -0,0 +1,133 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertNotEquals;
+import org.junit.jupiter.api.Test;
+
+public class EmulatorMC6800Test extends AbstractEmulatorTest {
+	public EmulatorMC6800Test() {
+		super("MC6800:BE:16:default");
+	}
+
+	@Test
+	public void NOP() {
+		setA(0x00);
+		setB(0x00);
+		setCC(0x00);
+		setX(0x0000);
+		setS(0x0800);
+
+		assemble(0x0000, "NOP");
+		stepFrom(0x000);
+
+		assertEquals(getA(), 0x00);
+		assertEquals(getB(), 0x00);
+		assertEquals(getCC(), 0x00);
+		assertEquals(getX(), 0x0000);
+		assertEquals(getS(), 0x0800);
+		assertEquals(0x0001, getPC());
+	}
+
+	@Test
+	public void CPX() {
+		assemble(0x0000, "CPX #0x1234");
+
+		// Test the equals case.
+		setX(0x1234);
+		setCC(0x00);
+		stepFrom(0x0000);
+		assertEquals(0x1234, getX());
+		assertEquals(CC.Z, getCC());
+
+		// Test the negative overflow case, as per the
+		// programming manual the carry flag is
+		// unaffected.
+		setX(0x1233);
+		setCC(0x00);
+		stepFrom(0x0000);
+		assertEquals(CC.N, getCC());
+	}
+
+	@Test
+	public void BLT() throws Exception {
+		assemble(0x0100,
+			"CMPA 	#0x10",		// Equals case.
+			"BLT 	0x130");
+		assemble(0x0110,
+			"CMPA	#0x20",		// Less-than case.
+			"BLT 	0x130");
+		assemble(0x0120,
+			"CMPA	#0x0A",		// Greater-than case.
+			"BLT 	0x130");
+
+		setA(0x10);
+		stepFrom(0x0100, 2);
+		assertNotEquals(getPC(), 0x0130);
+
+		stepFrom(0x0110, 2);
+		assertEquals(getPC(), 0x0130);
+
+		stepFrom(0x0120, 2);
+		assertNotEquals(getPC(), 0x0130);
+	}
+
+	@Test
+	public void BGT() throws Exception {
+		assemble(0x0100,
+			"CMPA 	#0x10",		// Equals case.
+			"BGT 	0x130");
+		assemble(0x0110,
+			"CMPA	#0x20",		// Less-than case.
+			"BGT 	0x130");
+		assemble(0x0120,
+			"CMPA	#0x0A",		// Greater-than case.
+			"BGT 	0x130");
+
+		setA(0x10);
+		stepFrom(0x0100, 2);
+		assertNotEquals(getPC(), 0x0130);
+
+		stepFrom(0x0110, 2);
+		assertNotEquals(getPC(), 0x0130);
+
+		stepFrom(0x0120, 2);
+		assertEquals(getPC(), 0x0130);
+	}
+
+	@Test
+	public void BLE() throws Exception {
+		assemble(0x0100,
+			"CMPA 	#0x10",		// Equals case.
+			"BLE 	0x130");
+		assemble(0x0110,
+			"CMPA	#0x20",		// Less-than case.
+			"BLE 	0x130");
+		assemble(0x0120,
+			"CMPA	#0x0A",		// Greater-than case.
+			"BLE 	0x130");
+
+		setA(0x10);
+		stepFrom(0x0100, 2);
+		assertEquals(getPC(), 0x0130);
+
+		stepFrom(0x0110, 2);
+		assertEquals(getPC(), 0x0130);
+
+		stepFrom(0x0120, 2);
+		assertNotEquals(getPC(), 0x0130);
+	}
+}
diff --git a/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC6801Test.java b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC6801Test.java
new file mode 100644
index 0000000000..eaa73387f2
--- /dev/null
+++ b/Ghidra/Processors/MC6800/src/test/java/is/sort/mc6800/EmulatorMC6801Test.java
@@ -0,0 +1,45 @@
+// Copyright 2024 Sigurdur Asgeirsson <siggi@sort.is>
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package is.sort.mc6800;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+
+import org.junit.jupiter.api.Test;
+
+public class EmulatorMC6801Test extends AbstractEmulatorTest {
+	public EmulatorMC6801Test() {
+		super("MC6801:BE:16:default");
+	}
+
+	@Test
+	public void CPX() {
+		assemble(0x0000, "CPX #0x1234");
+
+		// Test the equals case.
+		setX(0x1234);
+		setCC(0x00);
+		stepFrom(0x0000);
+		assertEquals(0x1234, getX());
+		assertEquals(CC.Z, getCC());
+
+		// Test the negative overflow case, as per the
+		// programming manual the carry flag is set,
+		// which is opposite to the 6800 behavior.
+		setX(0x1233);
+		setCC(0x00);
+		stepFrom(0x0000);
+		assertEquals(CC.N + CC.C, getCC());
+	}
+}
-- 
2.45.1

