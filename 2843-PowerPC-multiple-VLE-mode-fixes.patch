From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Alexey Esaulenko <esaulenka@gmail.com>
Date: Sun, 14 Mar 2021 16:13:22 +0300
Subject: [PATCH] 2843: PowerPC: multiple VLE-mode fixes

PowerPC: XOR can be used in VLE mode

PowerPC: float compare should set `great that` flag, but not `overflow`

PowerPC: e_rlwinm fix `remove unreachable block` warning

PowerPC: additional MPC55xx float-point instructions
---
 .../Processors/PowerPC/certification.manifest |   1 +
 .../data/languages/SPE_FloatMulAdd.sinc       | 100 ++++++++++++++++++
 .../PowerPC/data/languages/Scalar_SPFP.sinc   |   3 -
 .../data/languages/ppc_64_isa_vle_be.slaspec  |   1 +
 .../PowerPC/data/languages/ppc_vle.sinc       |  46 ++++----
 5 files changed, 124 insertions(+), 27 deletions(-)
 create mode 100644 Ghidra/Processors/PowerPC/data/languages/SPE_FloatMulAdd.sinc

diff --git a/Ghidra/Processors/PowerPC/certification.manifest b/Ghidra/Processors/PowerPC/certification.manifest
index ad290208f..d97e6d9b6 100644
--- a/Ghidra/Processors/PowerPC/certification.manifest
+++ b/Ghidra/Processors/PowerPC/certification.manifest
@@ -7,6 +7,7 @@ data/languages/SPEF_SCR.sinc||GHIDRA||||END|
 data/languages/SPE_APU.sinc||GHIDRA||||END|
 data/languages/SPE_EFSD.sinc||GHIDRA||||END|
 data/languages/SPE_EFV.sinc||GHIDRA||||END|
+data/languages/SPE_FloatMulAdd.sinc||GHIDRA||||END|
 data/languages/Scalar_SPFP.sinc||GHIDRA||||END|
 data/languages/altivec.sinc||GHIDRA||||END|
 data/languages/evx.sinc||GHIDRA||||END|
diff --git a/Ghidra/Processors/PowerPC/data/languages/SPE_FloatMulAdd.sinc b/Ghidra/Processors/PowerPC/data/languages/SPE_FloatMulAdd.sinc
new file mode 100644
index 000000000..455a8044d
--- /dev/null
+++ b/Ghidra/Processors/PowerPC/data/languages/SPE_FloatMulAdd.sinc
@@ -0,0 +1,100 @@
+
+# Additional SPE Instructions for Devices that Support VLE
+# Freescale engineering bulletin EB689
+# https://www.nxp.com/docs/en/engineering-bulletin/EB689.pdf
+
+# additional SPE instructions that are implemented on devices with an e200z3 or e200z6 core that supports VLE
+# - Vector Floating-Point Single-Precision Multiply-Add
+# - Vector Floating-Point Single-Precision Multiply-Substract
+# - Vector Floating-Point Single-Precision Negative Multiply-Add
+# - Vector Floating-Point Single-Precision Negative Multiply-Substract
+# - Floating-Point Single-Precision Multiply-Add
+# - Floating-Point Single-Precision Multiply-Substract
+# - Floating-Point Single-Precision Negative Multiply-Add
+# - Floating-Point Single-Precision Negative Multiply-Substract
+
+
+
+# evfsmadd rD,rA,rB
+# Vector Floating-Point Single-Precision Multiply-Add
+:evfsmadd D,A,B is OP=4 & D & A & B & XOP_0_10=0x282
+{
+	local tmpAL:4 = A:4; local tmpAH:4 = A(4);
+	local tmpBL:4 = B:4; local tmpBH:4 = B(4);
+	local tmpDL:4 = D:4; local tmpDH:4 = D(4);
+
+	tmpDL = ((tmpAL f* tmpBL) f+ tmpDL);
+	tmpDH = ((tmpAH f* tmpBH) f+ tmpDH);
+	D = (zext(tmpDH) << 32) | zext(tmpDL);
+}
+
+# evfsmsub rD,rA,rB
+# Vector Floating-Point Single-Precision Multiply-Substract
+:evfsmsub D,A,B is OP=4 & D & A & B & XOP_0_10=0x283
+{
+	local tmpAL:4 = A:4; local tmpAH:4 = A(4);
+	local tmpBL:4 = B:4; local tmpBH:4 = B(4);
+	local tmpDL:4 = D:4; local tmpDH:4 = D(4);
+
+	tmpDL = ((tmpAL f* tmpBL) f- tmpDL);
+	tmpDH = ((tmpAH f* tmpBH) f- tmpDH);
+	D = (zext(tmpDH) << 32) | zext(tmpDL);
+}
+
+# evfsnmadd
+# Vector Floating-Point Single-Precision Negative Multiply-Add
+:evfsnmadd D,A,B is OP=4 & D & A & B & XOP_0_10=0x28A
+{
+	local tmpAL:4 = A:4; local tmpAH:4 = A(4);
+	local tmpBL:4 = B:4; local tmpBH:4 = B(4);
+	local tmpDL:4 = D:4; local tmpDH:4 = D(4);
+
+	tmpDL = f- ((tmpAL f* tmpBL) f+ tmpDL);
+	tmpDH = f- ((tmpAH f* tmpBH) f+ tmpDH);
+	D = (zext(tmpDH) << 32) | zext(tmpDL);
+}
+
+# evfsnmsub
+# Vector Floating-Point Single-Precision Negative Multiply-Substract
+:evfsnmsub D,A,B is OP=4 & D & A & B & XOP_0_10=0x28B
+{
+	local tmpAL:4 = A:4; local tmpAH:4 = A(4);
+	local tmpBL:4 = B:4; local tmpBH:4 = B(4);
+	local tmpDL:4 = D:4; local tmpDH:4 = D(4);
+
+	tmpDL = f- ((tmpAL f* tmpBL) f- tmpDL);
+	tmpDH = f- ((tmpAH f* tmpBH) f- tmpDH);
+	D = (zext(tmpDH) << 32) | zext(tmpDL);
+}
+
+# efsmadd rD,rA,rB
+# Floating-Point Single-Precision Multiply-Add
+:efsmadd D,A,B is OP=4 & D & A & B & XOP_0_10=0x2C2
+{
+	local lo:4 = (A:4 f* B:4) f+ D:4;
+	D = (D & 0xFFFFFFFF00000000) | zext(lo);
+}
+
+# efsmsub rD,rA,rB
+# Floating-Point Single-Precision Multiply-Substract
+:efsmsub D,A,B is OP=4 & D & A & B & XOP_0_10=0x2C3
+{
+	local lo:4 = (A:4 f* B:4) f- D:4;
+	D = (D & 0xFFFFFFFF00000000) | zext(lo);
+}
+
+# efsnmadd rD,rA,rB
+# Floating-Point Single-Precision Negative Multiply-Add
+:efsnmadd D,A,B is OP=4 & D & A & B & XOP_0_10=0x2CA
+{
+	local lo:4 = f- ((A:4 f* B:4) f+ D:4);
+	D = (D & 0xFFFFFFFF00000000) | zext(lo);
+}
+
+# efsnmsub rD,rA,rB
+# Floating-Point Single-Precision Negative Multiply-Substract
+:efsnmsub D,A,B is OP=4 & D & A & B & XOP_0_10=0x2CB
+{
+	local lo:4 = f- ((A:4 f* B:4) f- D:4);
+	D = (D & 0xFFFFFFFF00000000) | zext(lo);
+}
diff --git a/Ghidra/Processors/PowerPC/data/languages/Scalar_SPFP.sinc b/Ghidra/Processors/PowerPC/data/languages/Scalar_SPFP.sinc
index f1c10dec5..6f812bcc4 100644
--- a/Ghidra/Processors/PowerPC/data/languages/Scalar_SPFP.sinc
+++ b/Ghidra/Processors/PowerPC/data/languages/Scalar_SPFP.sinc
@@ -138,7 +138,6 @@ define pcodeop ConvertFloatingPointFromUnsignedFraction;
 }
 
 # efscmpeq CRFD,rA,rB        010 1100 1110
-#define pcodeop FloatingPointCompareEqual;
 :efscmpeq CRFD,A,B is OP=4 & CRFD & A & B & XOP_0_10=0x2CE & BITS_21_22=0
 {
   CRFD[2,1] = A:4 f== B:4;
@@ -148,14 +147,12 @@ define pcodeop ConvertFloatingPointFromUnsignedFraction;
 # Page 415
 
 # efscmpgt CRFD,rA,rB        010 1100 1100
-#define pcodeop FloatingPointCompareGreaterThan;
 :efscmpgt CRFD,A,B is OP=4 & CRFD & A & B & XOP_0_10=0x2CC & BITS_21_22=0
 {
   CRFD[2,1] = A:4 f> B:4;
 }
 
 # efscmplt CRFD,rA,rB        010 1100 1101
-#define pcodeop FloatingPointCompareLessThan;
 :efscmplt CRFD,A,B is OP=4 & CRFD & A & B & XOP_0_10=0x2CD & BITS_21_22=0
 {
   CRFD[2,1] = A:4 f< B:4;
diff --git a/Ghidra/Processors/PowerPC/data/languages/ppc_64_isa_vle_be.slaspec b/Ghidra/Processors/PowerPC/data/languages/ppc_64_isa_vle_be.slaspec
index 8a81dc5fe..06e22cb5c 100644
--- a/Ghidra/Processors/PowerPC/data/languages/ppc_64_isa_vle_be.slaspec
+++ b/Ghidra/Processors/PowerPC/data/languages/ppc_64_isa_vle_be.slaspec
@@ -30,5 +30,6 @@
 @include "SPEF_SCR.sinc"
 @include "SPE_EFSD.sinc"
 @include "SPE_EFV.sinc"
+@include "SPE_FloatMulAdd.sinc"
 # OR
 #@include "altivec.sinc"
diff --git a/Ghidra/Processors/PowerPC/data/languages/ppc_vle.sinc b/Ghidra/Processors/PowerPC/data/languages/ppc_vle.sinc
index b685b7503..19915ce50 100644
--- a/Ghidra/Processors/PowerPC/data/languages/ppc_vle.sinc
+++ b/Ghidra/Processors/PowerPC/data/languages/ppc_vle.sinc
@@ -817,36 +817,34 @@ IMM16B: val						is IMM_0_10_VLE & IMM_16_20_VLE [ val = (IMM_16_20_VLE << 11) |
 :e_rlwimi A,S,SHL,MBL,ME			is $(ISVLE) & OP=29 & BIT_0=0 & MBL & ME & A & SHL & S {
 	tmpS:4 = S:4;
 	tmpA:4 = (tmpS << SHL) | (tmpS >> (32 - SHL));
-	tmpM:4 = ~0:4;
-	if (ME:1 < MBL:1) goto <invert>;
-	tmpM = tmpM << MBL;
-	tmpM = tmpM >> ((31-ME) + MBL);
-	tmpM = tmpM << (31-ME);
-	goto <finish>;
-<invert>
-	tmpM = tmpM << ME;
-	tmpM = tmpM >> ((31-MBL) + ME);
-	tmpM = tmpM << (31-MBL);
-	tmpM = ~tmpM;
-<finish>
+
+	tmpM1 = (~0:4) << MBL;
+	tmpM1 = tmpM1 >> ((31-ME) + MBL);
+	tmpM1 = tmpM1 << (31-ME);
+
+	tmpM2 = (~0:4) << ME;
+	tmpM2 = tmpM2 >> ((31-MBL) + ME);
+	tmpM2 = tmpM2 << (31-MBL);
+	tmpM2 = ~tmpM2;
+
+	tmpM = zext(ME:1 >= MBL:1)*tmpM1 + zext(ME:1 < MBL:1)*tmpM2;
 	A = zext(tmpA & tmpM) | (A & zext(~tmpM));	
 }
 
 :e_rlwinm A,S,SHL,MBL,ME			is $(ISVLE) & OP=29 & BIT_0=1 & MBL & ME & A & SHL & S {
 	tmpS:4 = S:4;
 	tmpA:4 = (tmpS << SHL) | (tmpS >> (32 - SHL));
-	tmpM:4 = ~0:4;
-	if (ME:1 < MBL:1) goto <invert>;
-	tmpM = tmpM << MBL;
-	tmpM = tmpM >> ((31-ME) + MBL);
-	tmpM = tmpM << (31-ME);
-	goto <finish>;
-<invert>
-	tmpM = tmpM << ME;
-	tmpM = tmpM >> ((31-MBL) + ME);
-	tmpM = tmpM << (31-MBL);
-	tmpM = ~tmpM;
-<finish>
+
+	tmpM1 = (~0:4) << MBL;
+	tmpM1 = tmpM1 >> ((31-ME) + MBL);
+	tmpM1 = tmpM1 << (31-ME);
+
+	tmpM2 = (~0:4) << ME;
+	tmpM2 = tmpM2 >> ((31-MBL) + ME);
+	tmpM2 = tmpM2 << (31-MBL);
+	tmpM2 = ~tmpM2;
+
+	tmpM = zext(ME:1 >= MBL:1)*tmpM1 + zext(ME:1 < MBL:1)*tmpM2;
 	A = zext(tmpA & tmpM);		
 }
 
-- 
2.43.0

