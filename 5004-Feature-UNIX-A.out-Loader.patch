From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Colin Bourassa <colin.bourassa@gmail.com>
Date: Fri, 17 Feb 2023 11:48:14 -0500
Subject: [PATCH] 5004: Feature: UNIX A.out Loader

Bugfixes for UNIX A.out Loader (#1)
* fix package declarations

* don't special-case defined symbols with zero value

a.out object files can define symbols at the very start of a section.

* mark undefined symbols with non-zero value as bss candidates

* use FSRL to get filename

This is required when invoking loaders on subsets of files, such as
bulk-importing object files from static archives.

* don't use filename in memory block names
---
 .../bin/format/unixaout/UnixAoutHeader.java   | 525 +++++++++++++
 .../format/unixaout/UnixAoutMachineType.java  |  79 ++
 .../UnixAoutRelocationTableEntry.java         |  64 ++
 .../unixaout/UnixAoutSymbolTableEntry.java    |  63 ++
 .../app/util/opinion/UnixAoutLoader.java      | 699 ++++++++++++++++++
 5 files changed, 1430 insertions(+)
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutHeader.java
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutMachineType.java
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutRelocationTableEntry.java
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutSymbolTableEntry.java
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/UnixAoutLoader.java

diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutHeader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutHeader.java
new file mode 100644
index 000000000..46e5412b8
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutHeader.java
@@ -0,0 +1,525 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ghidra.app.util.bin.format.unixaout;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.ByteProvider;
+
+public class UnixAoutHeader {
+
+    public enum ExecutableType {
+        OMAGIC, NMAGIC, ZMAGIC, QMAGIC, CMAGIC, UNKNOWN
+    }
+
+    private long binarySize;
+    private ExecutableType exeType;
+    private boolean machineTypeValid;
+    private String languageSpec;
+    private String compilerSpec = "default";
+    private long pageSize;
+
+    private boolean isNetBSD = false;
+    private boolean isSparc = false;
+
+    private long a_magic;
+    private long a_text;
+    private long a_data;
+    private long a_bss;
+    private long a_syms;
+    private long a_entry;
+    private long a_trsize;
+    private long a_drsize;
+
+    private long txtOffset;
+    private long datOffset;
+    private long txtRelOffset;
+    private long datRelOffset;
+    private long symOffset;
+    private long strOffset;
+
+    private long txtAddr;
+    private long txtEndAddr;
+    private long datAddr;
+    private long bssAddr;
+
+    // The Linux implementation of a.out appears to start the .text content at
+    // file offset 0x400 (rather than immediately after the 0x20 bytes of header
+    // data). It's possible that there exist Linux a.out executabes with other
+    // (unintended?) header sizes caused by a mixture of 32- and 64-bit integers
+    // being padded out in the struct. The intended size is eight 32-bit words
+    // (32 bytes total.)
+    private static final int sizeOfExecHeader = 0x20;
+    private static final int sizeOfLongExecHeader = 0x400;
+
+    /**
+     * Interprets binary data as an exec header from a UNIX-style a.out executable,
+     * and validates the contained fields.
+     *
+     * @param provider       Source of header binary data
+     * @param isLittleEndian Flag indicating whether to interpret the data as
+     *                       little-endian.
+     * @throws IOException
+     */
+    public UnixAoutHeader(ByteProvider provider, boolean isLittleEndian) throws IOException {
+        BinaryReader reader = new BinaryReader(provider, isLittleEndian);
+
+        this.a_magic = reader.readNextUnsignedInt();
+        this.a_text = reader.readNextUnsignedInt();
+        this.a_data = reader.readNextUnsignedInt();
+        this.a_bss = reader.readNextUnsignedInt();
+        this.a_syms = reader.readNextUnsignedInt();
+        this.a_entry = reader.readNextUnsignedInt();
+        this.a_trsize = reader.readNextUnsignedInt();
+        this.a_drsize = reader.readNextUnsignedInt();
+        this.binarySize = reader.length();
+
+        checkExecutableType();
+
+        // NOTE: In NetBSD/i386 examples of a.out, the "new-style" 32-bit a_magic/midmag word
+        // is written in big-endian regardless of the data endianness in the rest of the file.
+        if ((this.exeType == ExecutableType.UNKNOWN) && isLittleEndian) {
+            this.a_magic = Integer.reverseBytes((int)this.a_magic);
+            checkExecutableType();
+        }
+
+        checkMachineTypeValidity(isLittleEndian);
+        determineTextOffset(reader, isLittleEndian);
+
+        this.datOffset = this.txtOffset + this.a_text;
+        this.txtRelOffset = this.datOffset + this.a_data;
+        this.datRelOffset = this.txtRelOffset + this.a_trsize;
+        this.symOffset = this.datRelOffset + this.a_drsize;
+        this.strOffset = this.symOffset + this.a_syms;
+
+        determineTextAddr();
+        this.txtEndAddr = this.txtAddr + this.a_text;
+        this.datAddr = (this.exeType == ExecutableType.OMAGIC) ?
+                       this.txtEndAddr : segmentRound(this.txtEndAddr);
+        this.bssAddr = this.datAddr + this.a_data;
+    }
+
+    /**
+     * Returns the processor/language specified by this header.
+     */
+    public String getLanguageSpec() {
+        return this.languageSpec;
+    }
+
+    /**
+     * Returns the compiler used by this executable. This is left as 'default' for
+     * all machine types other than i386, where it is assumed to be gcc.
+     */
+    public String getCompilerSpec() {
+        return this.compilerSpec;
+    }
+
+    /**
+     * Returns the enumerated type of executable contained in this A.out file.
+     */
+    public ExecutableType getExecutableType() {
+        return this.exeType;
+    }
+
+    /**
+     * Returns an indication of whether this header's fields are all valid; this
+     * includes the machine type, executable type, and section offsets.
+     */
+    public boolean isValid() {
+        return isMachineTypeValid() &&
+               (this.exeType != ExecutableType.UNKNOWN) &&
+               areOffsetsValid();
+    }
+
+    public long getTextSize() {
+        return this.a_text;
+    }
+
+    public long getDataSize() {
+        return this.a_data;
+    }
+
+    public long getBssSize() {
+        return this.a_bss;
+    }
+
+    public long getSymSize() {
+        return this.a_syms;
+    }
+
+    public long getEntryPoint() {
+        return this.a_entry;
+    }
+
+    public long getTextRelocSize() {
+        return this.a_trsize;
+    }
+
+    public long getDataRelocSize() {
+        return this.a_drsize;
+    }
+
+    public long getTextOffset() {
+        return this.txtOffset;
+    }
+
+    public long getDataOffset() {
+        return this.datOffset;
+    }
+
+    public long getTextRelocOffset() {
+        return this.txtRelOffset;
+    }
+
+    public long getDataRelocOffset() {
+        return this.datRelOffset;
+    }
+
+    public long getSymOffset() {
+        return this.symOffset;
+    }
+
+    public long getStrOffset() {
+        return this.strOffset;
+    }
+
+    public long getTextAddr() {
+        return this.txtAddr;
+    }
+
+    public long getDataAddr() {
+        return this.datAddr;
+    }
+
+    public long getBssAddr() {
+        return this.bssAddr;
+    }
+
+    /**
+     * Checks the magic word in the header for a known machine type ID, and sets the
+     * languageSpec string accordingly.
+     */
+    private void checkMachineTypeValidity(boolean readingAsLittleEndian) {
+
+        this.machineTypeValid = true;
+        this.pageSize = 4096;
+        final short machtype = (short) ((this.a_magic >> 16) & 0xFF);
+        final String readEndianness = readingAsLittleEndian ? "LE" : "BE";
+
+        switch (machtype) {
+        /**
+         * Motorola 68K family
+         */
+        case UnixAoutMachineType.M_68010:
+            this.languageSpec = "68000:BE:32:MC68010";
+            break;
+        case UnixAoutMachineType.M_68020:
+            this.languageSpec = "68000:BE:32:MC68020";
+            break;
+        case UnixAoutMachineType.M_M68K_NETBSD:
+            this.pageSize = 8192;
+        case UnixAoutMachineType.M_M68K4K_NETBSD:
+            this.isNetBSD = true;
+            this.languageSpec = "68000:BE:32:default";
+            break;
+
+        /**
+         * SPARC family
+         */
+        case UnixAoutMachineType.M_SPARC_NETBSD:
+            this.isNetBSD = true;
+        case UnixAoutMachineType.M_SPARC:
+        case UnixAoutMachineType.M_SPARCLET:
+            this.isSparc = true;
+            this.pageSize = 8192;
+            this.languageSpec = "sparc:BE:32:default";
+            break;
+        case UnixAoutMachineType.M_SPARC64_NETBSD:
+            this.isNetBSD = true;
+            this.isSparc = true;
+            this.languageSpec = "sparc:BE:64:default";
+            break;
+
+        /**
+         * MIPS family
+         */
+        case UnixAoutMachineType.M_PMAX_NETBSD:
+            this.isNetBSD = true;
+        case UnixAoutMachineType.M_MIPS1:
+        case UnixAoutMachineType.M_MIPS2:
+        case UnixAoutMachineType.M_R3000:
+            this.languageSpec = "MIPS:LE:32:default";
+            break;
+        case UnixAoutMachineType.M_MIPS:
+            this.languageSpec = "MIPS:BE:32:default";
+            break;
+
+        /**
+         * National Semiconductor NS32000 family
+         */
+        case UnixAoutMachineType.M_532_NETBSD:
+            this.isNetBSD = true;
+        case UnixAoutMachineType.M_NS32032:
+        case UnixAoutMachineType.M_NS32532:
+            this.languageSpec = "UNKNOWN:LE:32:default";
+            break;
+
+        /**
+         * x86 family
+         */
+        case UnixAoutMachineType.M_386_NETBSD:
+            this.isNetBSD = true;
+        case UnixAoutMachineType.M_386:
+        case UnixAoutMachineType.M_386_DYNIX:
+            this.compilerSpec = "gcc";
+            this.languageSpec = "x86:LE:32:default";
+            break;
+        case UnixAoutMachineType.M_X86_64_NETBSD:
+            this.compilerSpec = "gcc";
+            this.languageSpec = "x86:LE:64:default";
+            break;
+
+        /**
+         * ARM family
+         */
+        case UnixAoutMachineType.M_ARM6_NETBSD:
+            this.isNetBSD = true;
+        case UnixAoutMachineType.M_ARM:
+            this.languageSpec = "ARM:" + readEndianness + ":32:default";
+            break;
+        case UnixAoutMachineType.M_AARCH64:
+            this.languageSpec = "AARCH64:" + readEndianness + ":64:default";
+            break;
+
+        /**
+         * RISC family
+         */
+        case UnixAoutMachineType.M_OR1K:
+            this.languageSpec = "UNKNOWN:BE:32:default";
+            break;
+        case UnixAoutMachineType.M_RISCV:
+            this.languageSpec = "RISCV:LE:32:default";
+            break;
+        case UnixAoutMachineType.M_HPPA_OPENBSD:
+            this.languageSpec = "pa-risc:BE:32:default";
+            break;
+
+        /**
+         * PowerPC family
+         */
+        case UnixAoutMachineType.M_POWERPC_NETBSD:
+            this.isNetBSD = true;
+            this.languageSpec = "PowerPC:" + readEndianness + ":32:default";
+            break;
+        case UnixAoutMachineType.M_POWERPC64:
+            this.languageSpec = "PowerPC:" + readEndianness + ":64:default";
+            break;
+
+        /**
+         * SuperH family
+         * NOTE: It's unclear if there is support for SuperH SH-3 or SH-5 cores;
+         * the primary SuperH language seems to support SH-1 and SH-2 variants
+         * and the alternative is the SuperH4 language.
+         */
+        case UnixAoutMachineType.M_SH3:
+        case UnixAoutMachineType.M_SH5_32:
+            this.languageSpec = "SuperH:BE:32:default";
+            break;
+        case UnixAoutMachineType.M_SH5_64:
+            this.languageSpec = "SuperH:BE:64:default";
+            break;
+
+        /**
+         * VAX family
+         */
+        case UnixAoutMachineType.M_VAX_NETBSD:
+            this.pageSize = 512;
+        case UnixAoutMachineType.M_VAX4K_NETBSD:
+            this.isNetBSD = true;
+            this.languageSpec = "UNKNOWN:LE:32:default";
+            break;
+
+        /**
+         * Other
+         */
+        case UnixAoutMachineType.M_CRIS:
+            this.languageSpec = "UNKNOWN:LE:32:default";
+            break;
+        case UnixAoutMachineType.M_ALPHA_NETBSD:
+            this.isNetBSD = true;
+        case UnixAoutMachineType.M_IA64:
+            this.languageSpec = "UNKNOWN:" + readEndianness + ":64:default";
+            break;
+        case UnixAoutMachineType.M_29K:
+        case UnixAoutMachineType.M_88K_OPENBSD:
+            this.languageSpec = "UNKNOWN:" + readEndianness + ":32:default";
+            break;
+        case UnixAoutMachineType.M_UNKNOWN:
+            this.languageSpec = "UNKNOWN:" + readEndianness + ":32:default";
+            break;
+        default:
+            this.machineTypeValid = false;
+        }
+
+        // Check that the detected architecture's endianness matches the endianness
+        // with which we're reading the file; if there's a mismatch, clear the
+        // machineTypeValid flag because this was evidently a false reading.
+        if (this.machineTypeValid) {
+            String[] languageTokens = this.languageSpec.split(":");
+            if ((languageTokens.length < 2) ||
+                    !languageTokens[1].equalsIgnoreCase(readEndianness)) {
+                this.machineTypeValid = false;
+            }
+        }
+    }
+
+    /**
+     * Returns a flag indicating whether the header contains a known machine type
+     * ID.
+     */
+    private boolean isMachineTypeValid() {
+        return this.machineTypeValid;
+    }
+
+    /**
+     * Returns a flag indicating whether this header contains a representation of a
+     * valid executable type.
+     */
+    private void checkExecutableType() {
+        final short exetypeMagic = (short) (this.a_magic & 0xFFFF);
+
+        switch (exetypeMagic) {
+        case 0x111: // 0421: core file
+            this.exeType = ExecutableType.CMAGIC;
+            break;
+        case 0x108: // 0410: pure executable
+            this.exeType = ExecutableType.NMAGIC;
+            break;
+        case 0x107: // 0407: object file or impure executable
+            this.exeType = ExecutableType.OMAGIC;
+            break;
+        case 0x0CC: // 0314: demand-paged exe w/ header in .text
+            this.exeType = ExecutableType.QMAGIC;
+            break;
+        case 0x10B: // 0413: demand-paged executable
+            this.exeType = ExecutableType.ZMAGIC;
+            break;
+        default:
+            this.exeType = ExecutableType.UNKNOWN;
+        }
+    }
+
+    /**
+     * Determines the offset in the binary file at which the .text segment begins.
+     * This routine should attempt to replicate the logic from the N_TXTOFF macro
+     * that appears in the different incarnations of a.out.h.
+     *
+     * NOTE: The FreeBSD imgact_aout.h implies that, if the a_magic word contains
+     * ZMAGIC when read as little endian, the file offset for .text is __LDPGSZ;
+     * otherwise, if a_magic contains ZMAGIC when read as big endian, the file offset
+     * for .text is 0. Indeed, it looks like NetBSD uses big-endian ordering for
+     * the a_magic word even when the file contains code for a little-endian
+     * processor.
+     */
+    private void determineTextOffset(BinaryReader reader, boolean isLittleEndian) {
+
+        boolean isLinuxStyle = false;
+        final long fixedContentSize =
+            this.a_text + this.a_data + this.a_syms + this.a_trsize + this.a_drsize;
+
+        // If the file is large enough to read at least one word beyond a long-style header
+        // of 0x400 bytes plus all the sections whose sizes are specified in the header...
+        if (reader.isValidIndex(sizeOfLongExecHeader + fixedContentSize)) {
+            try {
+                // The word that immediately follows the symbol table will contain the size of
+                // the string table.
+                final long stringTableLength =
+                    reader.readUnsignedInt(sizeOfLongExecHeader + fixedContentSize);
+                final long longHeaderExpectedFileSize =
+                    sizeOfLongExecHeader + fixedContentSize + stringTableLength;
+
+                // If the size of the file exactly matches what we'd expect if the .text content
+                // starts at offset 0x400 rather than 0, this implies that the a.out is a
+                // Linux-style binary.
+                if (this.binarySize == longHeaderExpectedFileSize) {
+                    isLinuxStyle = true;
+                }
+            } catch (IOException e) {
+                e.printStackTrace();
+            }
+        }
+
+        if (isLinuxStyle && (this.exeType == ExecutableType.ZMAGIC)) {
+            // Linux ZMAGICs don't start the .text content until 0x400
+            this.txtOffset = sizeOfLongExecHeader;
+
+        } else if ((this.exeType == ExecutableType.QMAGIC) ||
+                   (this.exeType == ExecutableType.ZMAGIC)) {
+            // ZMAGIC for other platforms (as well as QMAGIC) include the file header itself
+            // in the .text content
+            this.txtOffset = 0;
+
+        } else {
+            // Otherwise, the .text content starts immediately after the 0x20-byte header
+            this.txtOffset = sizeOfExecHeader;
+        }
+    }
+
+    /**
+     * Uses the combination of executable type and architecture to set the appropriate
+     * base address of the .text segment when loaded.
+     */
+    private void determineTextAddr() {
+
+        if ((this.isSparc && (this.exeType == ExecutableType.NMAGIC)) ||
+                (this.isNetBSD) ||
+                (this.exeType == ExecutableType.QMAGIC)) {
+            this.txtAddr = this.pageSize;
+
+        } else {
+            this.txtAddr = 0;
+        }
+    }
+
+    /**
+     * Returns a flag indicating whether all the file offsets in the header
+     * (for the segments of nonzero size) fall within the size of the file.
+     */
+    private boolean areOffsetsValid() {
+        // Note that we can't check the string table validity because, if it
+        // doesn't exist, its offset will be computed to be beyond the end of
+        // the file. The string table is also not given an explicit size in
+        // the header.
+        boolean status =
+            ((this.a_text == 0)   || (this.txtOffset    < this.binarySize)  &&
+             ((this.a_data == 0)   || (this.datOffset    < this.binarySize)) &&
+             ((this.a_trsize == 0) || (this.txtRelOffset < this.binarySize)) &&
+             ((this.a_drsize == 0) || (this.datRelOffset < this.binarySize)) &&
+             ((this.a_syms == 0)   || (this.symOffset    < this.binarySize)));
+        return status;
+    }
+
+    /**
+     * Rounds the provided address up to the next page boundary.
+     */
+    private long segmentRound(long addr) {
+        final long mask = this.pageSize - 1;
+        long rounded = ((addr + mask) & ~mask);
+        return rounded;
+    }
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutMachineType.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutMachineType.java
new file mode 100644
index 000000000..5de54d7ea
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutMachineType.java
@@ -0,0 +1,79 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ghidra.app.util.bin.format.unixaout;
+
+public class UnixAoutMachineType {
+
+    // These values come from a combination of sources, including NetBSD's aout_mids.h
+    // and the GNU BFD Library's libaout.h.
+    //
+    // Note: some a.out header files list a few HP values (for the 300 Series, 800 Series, etc.)
+    // and these values exceed a full eight-bit count. Occasionally, this is accounted for by
+    // extending the Machine ID field of the a_magic word two bits higher, leaving only six bits
+    // in the MSB for other flags. This may not be correct, because those high-value HP machine
+    // IDs probably only appear in HP UX binaries, which use a different format. (This format is
+    // still named "a.out", but has a completely different header and internal organization.)
+    // The 10-bit Machine ID field would also interfere with flags used by VxWorks, NetBSD, and
+    // probably others.
+
+    public final static short M_UNKNOWN        = 0x00;
+    public final static short M_68010          = 0x01;
+    public final static short M_68020          = 0x02;
+    public final static short M_SPARC          = 0x03;
+    public final static short M_R3000          = 0x04;
+    public final static short M_NS32032        = 0x40;
+    public final static short M_NS32532        = 0x45;
+    public final static short M_386            = 0x64;
+    public final static short M_29K            = 0x65; // AMD 29000
+    public final static short M_386_DYNIX      = 0x66; // i386-based Sequet machine running DYNIX
+    public final static short M_ARM            = 0x67;
+    public final static short M_SPARCLET       = 0x83; // Sparclet = M_SPARC + 128
+    public final static short M_386_NETBSD     = 0x86; // NetBSD/i386
+    public final static short M_M68K_NETBSD    = 0x87; // NetBSD/m68k, 8K pages
+    public final static short M_M68K4K_NETBSD  = 0x88; // NetBSD/m68k, 4K pages
+    public final static short M_532_NETBSD     = 0x89; // NetBSD/ns32k
+    public final static short M_SPARC_NETBSD   = 0x8a; // NetBSD/sparc
+    public final static short M_PMAX_NETBSD    = 0x8b; // NetBSD/pmax (MIPS little-endian)
+    public final static short M_VAX_NETBSD     = 0x8c; // NetBSD/VAX (1K pages?)
+    public final static short M_ALPHA_NETBSD   = 0x8d; // NetBSD/Alpha
+    public final static short M_MIPS           = 0x8e; // big-endian
+    public final static short M_ARM6_NETBSD    = 0x8f; // NetBSD/arm32
+    public final static short M_SH3            = 0x91;
+    public final static short M_POWERPC64      = 0x94; // PowerPC 64
+    public final static short M_POWERPC_NETBSD = 0x95; // NetBSD/PowerPC (big-endian)
+    public final static short M_VAX4K_NETBSD   = 0x96; // NetBSD/VAX (4K pages)
+    public final static short M_MIPS1          = 0x97; // MIPS R2000/R3000
+    public final static short M_MIPS2          = 0x98; // MIPS R4000/R6000
+    public final static short M_88K_OPENBSD    = 0x99; // OpenBSD/m88k
+    public final static short M_HPPA_OPENBSD   = 0x9a; // OpenBSD/hppa (PA-RISC)
+    public final static short M_SH5_64         = 0x9b; // SuperH 64-bit
+    public final static short M_SPARC64_NETBSD = 0x9c; // NetBSD/sparc64
+    public final static short M_X86_64_NETBSD  = 0x9d; // NetBSD/amd64
+    public final static short M_SH5_32         = 0x9e; // SuperH 32-bit (ILP 32)
+    public final static short M_IA64           = 0x9f; // Itanium
+    public final static short M_AARCH64        = 0xb7; // ARM AARCH64
+    public final static short M_OR1K           = 0xb8; // OpenRISC 1000
+    public final static short M_RISCV          = 0xb9; // RISC-V
+    public final static short M_CRIS           = 0xff; // Axis ETRAX CRIS
+
+    /**
+     * Machine IDs that should only appear in the incompatible HP UX a.out format:
+     *   HP300 (68020+68881): 0x12c
+     *   HP200/300          : 0x20c
+     *   HP800              : 0x20b
+     */
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutRelocationTableEntry.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutRelocationTableEntry.java
new file mode 100644
index 000000000..5df9b6eb9
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutRelocationTableEntry.java
@@ -0,0 +1,64 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ghidra.app.util.bin.format.unixaout;
+
+/**
+ * Represents the content of a single entry in the relocation table format used
+ * by the UNIX a.out executable.
+ */
+public class UnixAoutRelocationTableEntry {
+    public long address;
+    public long symbolNum;
+    public boolean pcRelativeAddressing;
+    public byte pointerLength;
+    public boolean extern;
+    public boolean baseRelative;
+    public boolean jmpTable;
+    public boolean relative;
+    public boolean copy;
+
+    /**
+     *
+     * @param address First of the two words in the table entry (a 32-bit address)
+     * @param flags   Second of the two words in the table entry (containing several
+     *                bitfields)
+     */
+    public UnixAoutRelocationTableEntry(long address, long flags, boolean bigEndian) {
+        this.address = (0xFFFFFFFF & address);
+
+        if (bigEndian) {
+            this.symbolNum = ((flags & 0xFFFFFF00) >> 8);
+            this.pcRelativeAddressing = ((flags & 0x80) != 0);
+            this.pointerLength = (byte) (1 << ((flags & 0x60) >> 5));
+            this.extern = ((flags & 0x10) != 0);
+            this.baseRelative = ((flags & 0x8) != 0);
+            this.jmpTable = ((flags & 0x4) != 0);
+            this.relative = ((flags & 0x2) != 0);
+            this.copy = ((flags & 0x1) != 0);
+        } else {
+            this.symbolNum = (flags & 0x00FFFFFF);
+            final byte hibyte = (byte) ((flags & 0xFF000000) >> 24);
+            this.pcRelativeAddressing = ((hibyte & 0x01) != 0);
+            this.pointerLength = (byte) (1 << ((hibyte & 0x06) >> 1));
+            this.extern = ((hibyte & 0x08) != 0);
+            this.baseRelative = ((hibyte & 0x10) != 0);
+            this.jmpTable = ((hibyte & 0x20) != 0);
+            this.relative = ((hibyte & 0x40) != 0);
+            this.copy = ((hibyte & 0x80) != 0);
+        }
+    }
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutSymbolTableEntry.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutSymbolTableEntry.java
new file mode 100644
index 000000000..587a853ee
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutSymbolTableEntry.java
@@ -0,0 +1,63 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ghidra.app.util.bin.format.unixaout;
+
+/**
+ * Represents the content of a single entry in the symbol table format used by
+ * the UNIX a.out executable.
+ */
+public class UnixAoutSymbolTableEntry {
+
+    public enum SymbolType { N_UNDF, N_ABS, N_TEXT, N_DATA, N_BSS, N_FN, N_EXT, UNKNOWN }
+
+    public long nameStringOffset;
+    public String name;
+    public SymbolType type;
+    public byte otherByte;
+    public short desc;
+    public long value;
+    public boolean isExt;
+
+    public UnixAoutSymbolTableEntry(long nameStringOffset, byte typeByte, byte otherByte,
+                                    short desc, long value) {
+        this.nameStringOffset = nameStringOffset;
+        this.otherByte = otherByte;
+        this.desc = desc;
+        this.value = value;
+        this.isExt = (typeByte & 1) == 1;
+
+        switch (typeByte & 0xfe) {
+        case 0:
+            type = SymbolType.N_UNDF;
+            break;
+        case 2:
+            type = SymbolType.N_ABS;
+            break;
+        case 4:
+            type = SymbolType.N_TEXT;
+            break;
+        case 6:
+            type = SymbolType.N_DATA;
+            break;
+        case 8:
+            type = SymbolType.N_BSS;
+            break;
+        default:
+            type = SymbolType.UNKNOWN;
+        }
+    }
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/UnixAoutLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/UnixAoutLoader.java
new file mode 100644
index 000000000..cdfd7cc01
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/UnixAoutLoader.java
@@ -0,0 +1,699 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.opinion;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.*;
+
+import ghidra.app.util.Option;
+import ghidra.app.util.OptionException;
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.ByteProvider;
+import ghidra.app.util.bin.format.unixaout.UnixAoutHeader;
+import ghidra.app.util.bin.format.unixaout.UnixAoutHeader.ExecutableType;
+import ghidra.app.util.bin.format.unixaout.UnixAoutRelocationTableEntry;
+import ghidra.app.util.bin.format.unixaout.UnixAoutSymbolTableEntry;
+import ghidra.app.util.importer.MessageLog;
+import ghidra.framework.model.DomainObject;
+import ghidra.framework.store.LockException;
+import ghidra.program.flatapi.FlatProgramAPI;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.address.AddressFactory;
+import ghidra.program.model.address.AddressOverflowException;
+import ghidra.program.model.address.AddressSpace;
+import ghidra.program.model.lang.LanguageCompilerSpecPair;
+import ghidra.program.model.listing.Function;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.mem.MemoryAccessException;
+import ghidra.program.model.mem.MemoryBlock;
+import ghidra.program.model.mem.MemoryConflictException;
+import ghidra.program.model.symbol.Namespace;
+import ghidra.program.model.symbol.RefType;
+import ghidra.program.model.symbol.SourceType;
+import ghidra.program.model.symbol.Symbol;
+import ghidra.util.exception.CancelledException;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.exception.InvalidInputException;
+import ghidra.util.task.TaskMonitor;
+
+/**
+ * A {@link Loader} for processing UNIX-style A.out executables
+ *
+ * This style was also used by UNIX-like systems such as SunOS, BSD, and
+ * VxWorks, as well as some early distributions of Linux. Although there do
+ * exist implementations of A.out with 64-bit and GNU extensions, this loader
+ * does not currently support them.
+ *
+ * @see <a href="https://wiki.osdev.org/A.out">OSDev.org A.out</a>
+ * @see <a href="https://man.freebsd.org/cgi/man.cgi?a.out(5)">FreeBSD
+ *      manpage</a>
+ */
+public class UnixAoutLoader extends AbstractProgramWrapperLoader {
+
+    private MemoryBlock textBlock;
+    private AddressSpace textAddrSpace;
+    private MemoryBlock dataBlock;
+    private AddressSpace dataAddrSpace;
+    private MemoryBlock bssBlock;
+    private AddressSpace bssAddrSpace;
+    private Hashtable<String,Long> bssSymbols;
+    private Hashtable<String,Long> possibleBssSymbols;
+    private Namespace namespace;
+    private Vector<UnixAoutSymbolTableEntry> symTab;
+    private Vector<UnixAoutRelocationTableEntry> textRelocTab;
+    private Vector<UnixAoutRelocationTableEntry> dataRelocTab;
+    private Hashtable<Address,String> localFunctions = new Hashtable<Address, String>();
+    private long bssLocation = 0;
+    private FlatProgramAPI api;
+    private Program program;
+    private MessageLog log;
+    private UnixAoutHeader header;
+    private String filename;
+    private boolean isOverlay;
+    private boolean bigEndian;
+
+    public static final String OPTION_NAME_BASE_ADDR = "Base Address";
+
+    @Override
+    public String getName() {
+        return "UNIX A.out executable";
+    }
+
+    @Override
+    public boolean supportsLoadIntoProgram() {
+        return true;
+    }
+
+    /**
+     * Retrieves the Address offset given in the "Base Address" option.
+     * Returns 0 if the option could not be found or contains an invalid value.
+     */
+    private long getBaseAddrOffset(List<Option> options) {
+        Address baseAddr = null;
+        if (options != null) {
+            for (Option option : options) {
+                String optName = option.getName();
+                if (optName.equals(OPTION_NAME_BASE_ADDR)) {
+                    baseAddr = (Address) option.getValue();
+                }
+            }
+        }
+
+        long offset = 0;
+        if (baseAddr != null) {
+            offset = baseAddr.getOffset();
+        }
+
+        return offset;
+    }
+
+    @Override
+    public String validateOptions(ByteProvider provider, LoadSpec loadSpec, List<Option> options,
+                                  Program program) {
+
+        Address baseAddr = null;
+
+        for (Option option : options) {
+            String optName = option.getName();
+            try {
+                if (optName.equals(OPTION_NAME_BASE_ADDR)) {
+                    baseAddr = (Address) option.getValue();
+                }
+            } catch (Exception e) {
+                if (e instanceof OptionException) {
+                    return e.getMessage();
+                }
+                return "Invalid value for " + optName + " - " + option.getValue();
+            }
+        }
+        if (baseAddr == null) {
+            return "Invalid base address";
+        }
+
+        return super.validateOptions(provider, loadSpec, options, program);
+    }
+
+    @Override
+    public List<Option> getDefaultOptions(ByteProvider provider, LoadSpec loadSpec,
+                                          DomainObject domainObject, boolean loadIntoProgram) {
+
+        Address baseAddr = null;
+
+        if (domainObject instanceof Program) {
+            Program program = (Program)domainObject;
+            AddressFactory addressFactory = program.getAddressFactory();
+            if (addressFactory != null) {
+                AddressSpace defaultAddressSpace = addressFactory.getDefaultAddressSpace();
+                if (defaultAddressSpace != null) {
+                    baseAddr = defaultAddressSpace.getAddress(0);
+                }
+            }
+        }
+
+        List<Option> list = new ArrayList<Option>();
+        list.add(new Option(OPTION_NAME_BASE_ADDR, baseAddr, Address.class,
+                            Loader.COMMAND_LINE_ARG_PREFIX + "-baseAddr"));
+
+        list.addAll(super.getDefaultOptions(provider, loadSpec, domainObject, loadIntoProgram));
+        return list;
+    }
+
+    @Override
+    public Collection<LoadSpec> findSupportedLoadSpecs(ByteProvider provider) throws IOException {
+        List<LoadSpec> loadSpecs = new ArrayList<>();
+
+        // Attempt to parse the header as both little- and big-endian.
+        // It is likely that only one of these will produce sensible values.
+        UnixAoutHeader hdrBE = new UnixAoutHeader(provider, false);
+        UnixAoutHeader hdrLE = new UnixAoutHeader(provider, true);
+        boolean beValid = false;
+
+        if (hdrBE.isValid()) {
+            final String lang = hdrBE.getLanguageSpec();
+            final String comp = hdrBE.getCompilerSpec();
+            loadSpecs.add(new LoadSpec(this, 0, new LanguageCompilerSpecPair(lang, comp), true));
+            beValid = true;
+        }
+        if (hdrLE.isValid()) {
+            final String lang = hdrLE.getLanguageSpec();
+            final String comp = hdrLE.getCompilerSpec();
+            loadSpecs.add(new LoadSpec(this, 0, new LanguageCompilerSpecPair(lang, comp), !beValid));
+        }
+
+        return loadSpecs;
+    }
+
+    /**
+     * Creates an AddressSpace and MemoryBlock for the .text section of the binary, reading its
+     * contents from the provider.
+     */
+    protected void createTextSection(ByteProvider provider, TaskMonitor monitor, long size,
+                                     long addressFromHeader, long fileOffset) {
+
+        this.log.appendMsg(".text section: " + size + " bytes loaded to address " +
+                           String.format("%08X", addressFromHeader) + " from file offset " +
+                           String.format("%08X", fileOffset));
+
+        if (size > 0) {
+            Address address = this.program.getAddressFactory().getDefaultAddressSpace().getAddress(
+				addressFromHeader);
+            try {
+                InputStream stream = provider.getInputStream(fileOffset);
+                this.textBlock = this.program.getMemory().createInitializedBlock(
+                        ".text", address, stream, size, monitor, this.isOverlay);
+                this.textBlock.setRead(true);
+                this.textBlock.setWrite(false);
+                this.textBlock.setExecute(true);
+                this.textAddrSpace = textBlock.getStart().getAddressSpace();
+            } catch (LockException | MemoryConflictException | AddressOverflowException |
+                         CancelledException | IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    /**
+     * Creates an AddressSpace and MemoryBlock for the .data section of the binary, reading its
+     * contents from the provider.
+     */
+    protected void createDataSection(ByteProvider provider, TaskMonitor monitor, long size,
+                                     long addressFromHeader, long fileOffset) {
+
+        this.log.appendMsg(".data section: " + size + " bytes loaded to address " +
+                           String.format("%08X", addressFromHeader) + " from file offset " +
+                           String.format("%08X", fileOffset));
+
+        if (size > 0) {
+            Address address =
+                program.getAddressFactory().getDefaultAddressSpace().getAddress(addressFromHeader);
+            try {
+                InputStream stream = provider.getInputStream(fileOffset);
+                this.dataBlock = program.getMemory().createInitializedBlock(
+                        ".data", address, stream, size, monitor, this.isOverlay);
+                this.dataBlock.setRead(true);
+                this.dataBlock.setWrite(true);
+                this.dataBlock.setExecute(false);
+                this.dataAddrSpace = dataBlock.getStart().getAddressSpace();
+            } catch (LockException | MemoryConflictException | AddressOverflowException |
+                         CancelledException | IOException e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    /**
+     * Creates a .bss section for this binary, ensuring that it has enough space to accommodate
+     * all of the symbols that are explictly assigned to .bss and also the symbols marked as
+     * N_UNDF and that need to be dynamically assigned space in this section.
+     */
+    protected void createBssSection(long bssAddrVal) {
+        // Add up the sizes of all the symbols that are supposed to be allocated
+        // in .bss, and ensure that our .bss segment has enough additional space
+        // to accommodate them (beyond the size allocated by the header.)
+        // Until we search the global symbol table for the symbols in the
+        // 'possibleBssSymbols' list (which will happen as we walk the relocation
+        // table, below), we won't know whether these symbols exist in another
+        // binary file that was previously loaded, or, instead, if we'll need to
+        // mimic the linker behavior and assign them space in .bss.
+        Long additionalBssSpace = (long) 0;
+        for (Long symbolSize : this.possibleBssSymbols.values()) {
+            additionalBssSpace += symbolSize;
+        }
+
+        final long givenBssSize = this.header.getBssSize();
+
+        // Keep track of the next available location in .bss. The dynamically
+        // located symbols (of N_UNDF type) will start after the fix section.
+        this.bssLocation = givenBssSize;
+
+        final long totalBssSize = givenBssSize + additionalBssSpace;
+
+        this.log.appendMsg(".bss section: " + totalBssSize + " bytes (" + givenBssSize + " + " +
+                           additionalBssSpace + " additional) loaded to address " +
+                           String.format("%08X", bssAddrVal));
+
+        if (totalBssSize > 0) {
+            Address bssAddr =
+                this.program.getAddressFactory().getDefaultAddressSpace().getAddress(bssAddrVal);
+            try {
+                this.bssBlock = this.program.getMemory().createUninitializedBlock(
+                        ".bss", bssAddr, totalBssSize, this.isOverlay);
+                this.bssAddrSpace = bssBlock.getStart().getAddressSpace();
+                this.bssBlock.setRead(true);
+                this.bssBlock.setWrite(true);
+                this.bssBlock.setExecute(false);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    /**
+     * Labels the known symbols in the .bss section.
+     */
+    protected void placeBssSymbols() {
+        if (this.bssSymbols.size() > 0) {
+            if (this.bssAddrSpace != null) {
+                try {
+                    for (String bssSymbolName : this.bssSymbols.keySet()) {
+                        final Long bssSymbolAddr = this.bssSymbols.get(bssSymbolName);
+                        this.api.createLabel(this.bssAddrSpace.getAddress(bssSymbolAddr),
+                            bssSymbolName, this.namespace, true, SourceType.IMPORTED);
+                    }
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            } else {
+                this.log.appendMsg("Warning: some symbols were identified as being in .bss, but" +
+                                   " .bss could not be created.");
+            }
+        }
+    }
+
+    /**
+     * Processes the binary's symbol table, taking one of four different actions depending on the
+     * symbol type:
+     *  - N_TEXT are added to a list for disassembly later.
+     *  - N_DATA are labeled immediately.
+     *  - N_BSS are added to a list for labeling after the .bss section size has been established.
+     *  - N_UNDF are added to a list for address assignment and labeling in .bss if the symbol is
+     *    not found to already exist in a global symbol table (i.e. provided by another binary.)
+     */
+    protected void processSymbolTable() {
+
+        this.bssSymbols = new Hashtable<String, Long>();
+        this.possibleBssSymbols = new Hashtable<String, Long>();
+
+        // Process the symbol table by applying labels to identify any symbols whose
+        // addresses are given
+        for (Integer i = 0; i < this.symTab.size(); i++) {
+            UnixAoutSymbolTableEntry symTabEntry = this.symTab.elementAt(i);
+            try {
+                if (symTabEntry.type == UnixAoutSymbolTableEntry.SymbolType.N_TEXT) {
+                    if (symTabEntry.isExt) {
+                        // Save the entry point to this function in a list. Disassembly should
+                        // wait until after we've processed the relocation tables.
+                        Address funcAddr = this.textAddrSpace.getAddress(symTabEntry.value);
+                        this.localFunctions.put(funcAddr, symTabEntry.name);
+                    }
+                } else if (symTabEntry.type == UnixAoutSymbolTableEntry.SymbolType.N_DATA) {
+                    this.api.createLabel(this.dataAddrSpace.getAddress(symTabEntry.value),
+                        symTabEntry.name, this.namespace, true, SourceType.IMPORTED);
+
+                } else if (symTabEntry.type == UnixAoutSymbolTableEntry.SymbolType.N_BSS) {
+                    // Save the symbols that are explicitly identified as being in .bss
+                    // to a list so that they can be labeled later (after we actually
+                    // create the .bss block, which must wait until after we total all
+                    // the space used by N_UNDF symbols; see below.)
+                    this.bssSymbols.put(symTabEntry.name, symTabEntry.value);
+
+                } else if (symTabEntry.type == UnixAoutSymbolTableEntry.SymbolType.N_UNDF) {
+                    // This is a special case given by the A.out spec: if the linker cannot find
+                    // this symbol in any of the other binary files, then the fact that it is
+                    // marked as N_UNDF but has a non-zero value means that its value should be
+                    // interpreted as a size, and the linker should reserve space in .bss for it.
+                    if (symTabEntry.value > 0) {
+                        this.possibleBssSymbols.put(symTabEntry.name, symTabEntry.value);
+                    }
+                }
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+    }
+
+    /**
+     * Processes the text relocation table by fixing addresses based on the true location of each
+     * symbol.
+     */
+    protected void processTextRelocation() {
+        for (Integer i = 0; i < this.textRelocTab.size(); i++) {
+
+            UnixAoutRelocationTableEntry relocationEntry = this.textRelocTab.elementAt(i);
+            if (relocationEntry.symbolNum < symTab.size()) {
+
+                UnixAoutSymbolTableEntry symbolEntry =
+                    this.symTab.elementAt((int) relocationEntry.symbolNum);
+                AddressSpace addrSpace = this.textBlock.getStart().getAddressSpace();
+                Address relocAddr =
+                    addrSpace.getAddress(relocationEntry.address + this.header.getTextAddr());
+
+                // If this symbol's N_EXT flag is clear, then we didn't mark it as a function when
+                // we were processing the symbol table (above). This is because special symbols like
+                // "gcc2_compiled", "___gnu_compiled_c", and names of object files are in the symbol
+                // table for this segment, but do not point to disassemblable code. However, since
+                // there is now a reference from the relocation table, we should be able to
+                // disassemble at its address. Save the address for disassembly later.
+                if (!symbolEntry.isExt) {
+                    Address funcAddr = textAddrSpace.getAddress(symbolEntry.value);
+                    this.localFunctions.put(funcAddr, symbolEntry.name);
+                }
+
+                if (relocationEntry.extern && this.textBlock.contains(relocAddr)) {
+
+                    List<Function> funcs = this.api.getCurrentProgram().getListing().
+                                           getGlobalFunctions(symbolEntry.name);
+                    List<Symbol> symbolsGlobal = this.api.getSymbols(symbolEntry.name, null);
+                    List<Symbol> symbolsLocal = this.api.getSymbols(symbolEntry.name, namespace);
+
+                    if (funcs.size() > 0) {
+                        Address funcAddr = funcs.get(0).getEntryPoint();
+                        fixAddress(this.textBlock, relocAddr, funcAddr,
+                                   relocationEntry.pcRelativeAddressing, this.bigEndian,
+                                   relocationEntry.pointerLength);
+
+                    } else if (symbolsGlobal.size() > 0) {
+                        Address globalSymbolAddr = symbolsGlobal.get(0).getAddress();
+                        fixAddress(this.textBlock, relocAddr, globalSymbolAddr,
+                                   relocationEntry.pcRelativeAddressing, this.bigEndian,
+                                   relocationEntry.pointerLength);
+
+                    } else if (symbolsLocal.size() > 0) {
+                        Address localSymbolAddr = symbolsLocal.get(0).getAddress();
+                        fixAddress(this.textBlock, relocAddr, localSymbolAddr,
+                                   relocationEntry.pcRelativeAddressing, this.bigEndian,
+                                   relocationEntry.pointerLength);
+
+                    } else if (this.possibleBssSymbols.containsKey(symbolEntry.name)) {
+                        try {
+                            Address bssSymbolAddress =
+                                this.bssBlock.getStart().getAddressSpace().getAddress(bssLocation);
+                            long bssSymbolSize = this.possibleBssSymbols.get(symbolEntry.name);
+                            this.api.createLabel(bssSymbolAddress, symbolEntry.name, this.namespace,
+                                                 true, SourceType.IMPORTED);
+                            fixAddress(this.textBlock, relocAddr, bssSymbolAddress,
+                                       relocationEntry.pcRelativeAddressing, this.bigEndian,
+                                       relocationEntry.pointerLength);
+                            this.program.getReferenceManager().addMemoryReference(relocAddr,
+                                    bssSymbolAddress, RefType.DATA, SourceType.IMPORTED, 0);
+                            this.bssLocation += bssSymbolSize;
+
+                        } catch (Exception e) {
+                            e.printStackTrace();
+                        }
+                    } else {
+                        this.log.appendMsg("Symbol '" + symbolEntry.name +
+                            "' was not found and was not a candidate for allocation in .bss.");
+                    }
+                }
+            } else {
+                this.log.appendMsg("Symbol number " + relocationEntry.symbolNum +
+                                   " is beyond symbol table length of " + symTab.size());
+            }
+        }
+    }
+
+    /**
+     * Processes the data relocation table by fixing addresses based on the true location of each
+     * symbol.
+     */
+    protected void processDataRelocation() {
+        for (Integer i = 0; i < this.dataRelocTab.size(); i++) {
+
+            UnixAoutRelocationTableEntry relocationEntry = this.dataRelocTab.elementAt(i);
+            if (relocationEntry.symbolNum < symTab.size()) {
+
+                UnixAoutSymbolTableEntry symbolEntry =
+                    this.symTab.elementAt((int) relocationEntry.symbolNum);
+                AddressSpace addrSpace = this.dataBlock.getStart().getAddressSpace();
+                Address relocAddr =
+                    addrSpace.getAddress(relocationEntry.address + this.header.getDataAddr());
+
+                if (this.dataBlock.contains(relocAddr)) {
+
+                    List<Function> funcs = this.api.getCurrentProgram().getListing().
+                                           getGlobalFunctions(symbolEntry.name);
+                    List<Symbol> symbolsGlobal = this.api.getSymbols(symbolEntry.name, null);
+                    List<Symbol> symbolsLocal = this.api.getSymbols(symbolEntry.name, namespace);
+
+                    if (funcs.size() > 0) {
+                        Address funcAddr = funcs.get(0).getEntryPoint();
+                        fixAddress(this.dataBlock, relocAddr, funcAddr,
+                                   relocationEntry.pcRelativeAddressing, this.bigEndian,
+                                   relocationEntry.pointerLength);
+
+                    } else if (symbolsGlobal.size() > 0) {
+                        Address globalSymbolAddr = symbolsGlobal.get(0).getAddress();
+                        fixAddress(this.dataBlock, relocAddr, globalSymbolAddr,
+                                   relocationEntry.pcRelativeAddressing, this.bigEndian,
+                                   relocationEntry.pointerLength);
+
+                    } else if (symbolsLocal.size() > 0) {
+                        Address localSymbolAddr = symbolsLocal.get(0).getAddress();
+                        fixAddress(this.dataBlock, relocAddr, localSymbolAddr,
+                                   relocationEntry.pcRelativeAddressing, this.bigEndian,
+                                   relocationEntry.pointerLength);
+
+                    } else if (this.possibleBssSymbols.containsKey(symbolEntry.name)) {
+                        try {
+                            Address bssSymbolAddress =
+                                this.bssBlock.getStart().getAddressSpace().getAddress(bssLocation);
+                            this.api.createLabel(bssSymbolAddress, symbolEntry.name, namespace,
+												 true, SourceType.IMPORTED);
+                            fixAddress(this.dataBlock, relocAddr, bssSymbolAddress,
+                                       relocationEntry.pcRelativeAddressing, this.bigEndian,
+                                       relocationEntry.pointerLength);
+                            this.program.getReferenceManager().addMemoryReference(relocAddr,
+                                    bssSymbolAddress, RefType.DATA, SourceType.IMPORTED, 0);
+                            this.bssLocation += this.possibleBssSymbols.get(symbolEntry.name);
+
+                        } catch (Exception e) {
+                            e.printStackTrace();
+                        }
+                    } else {
+                        this.log.appendMsg("Symbol '" + symbolEntry.name +
+                            "' was not found and was not a candidate for allocation in .bss.");
+                    }
+                }
+            } else {
+                this.log.appendMsg("Symbol number " + relocationEntry.symbolNum +
+                                   " is beyond symbol table length of " + symTab.size());
+            }
+        }
+    }
+
+    /**
+     * Walks through the table of local function addresses, marks the locations as functions, and
+     * starts disassembly of those routines.
+     */
+    protected void disassembleKnownFuncs() {
+        // Now that all relocation addresses have been rewritten, it's safe to start disassembly
+        // at all the known function entry points.
+        for (Address funcAddr : this.localFunctions.keySet()) {
+            this.api.disassemble(funcAddr);
+            this.api.createFunction(funcAddr, this.localFunctions.get(funcAddr));
+        }
+
+        if ((this.header.getExecutableType() != UnixAoutHeader.ExecutableType.OMAGIC)
+                && (this.header.getExecutableType() != UnixAoutHeader.ExecutableType.CMAGIC)) {
+            this.api.disassemble(textAddrSpace.getAddress(this.header.getEntryPoint()));
+        }
+    }
+
+    @Override
+    protected void load(ByteProvider provider, LoadSpec loadSpec, List<Option> options,
+                        Program program, TaskMonitor monitor, MessageLog log)
+    throws CancelledException, IOException {
+
+        this.bigEndian = program.getLanguage().isBigEndian();
+        this.program = program;
+        this.log = log;
+        this.api = new FlatProgramAPI(program, monitor);
+        this.header = new UnixAoutHeader(provider, !this.bigEndian);
+        this.filename = provider.getFSRL().getName();
+        this.isOverlay = (header.getExecutableType() == ExecutableType.OMAGIC);
+
+        try {
+            this.namespace = this.api.createNamespace(program.getGlobalNamespace(), this.filename);
+        } catch (DuplicateNameException | InvalidInputException e1) {
+            e1.printStackTrace();
+        }
+
+        this.log.appendMsg("Found executable type " + this.header.getExecutableType().name() + ".");
+
+        final long baseAddr = getBaseAddrOffset(options);
+
+        createTextSection(provider, monitor, this.header.getTextSize(),
+                          baseAddr + this.header.getTextAddr(), this.header.getTextOffset());
+        createDataSection(provider, monitor, this.header.getDataSize(),
+                          baseAddr + this.header.getDataAddr(), this.header.getDataOffset());
+
+        BinaryReader reader = new BinaryReader(provider, !this.bigEndian);
+
+        this.symTab = getSymbolTable(reader, this.header.getSymOffset(), this.header.getSymSize(),
+                                     this.header.getStrOffset());
+        this.textRelocTab = getRelocationTable(reader, this.header.getTextRelocOffset(),
+                                               this.header.getTextRelocSize());
+        this.dataRelocTab = getRelocationTable(reader, this.header.getDataRelocOffset(),
+                                               this.header.getDataRelocSize());
+
+        final long bssAddrVal = baseAddr + this.header.getBssAddr();
+
+        processSymbolTable();
+        createBssSection(bssAddrVal);
+        placeBssSymbols();
+        processTextRelocation();
+        processDataRelocation();
+        disassembleKnownFuncs();
+    }
+
+    /**
+     * Rewrites the pointer at the specified location to instead point to the
+     * provided address.
+     *
+     * @param block           Memory block containing the pointer to be rewritten.
+     * @param pointerLocation Address at which the pointer to be rewritten is.
+     * @param newAddress      Address that will be the new pointer target.
+     * @param isPcRelative    Indicates whether the address is program counter
+     *                        relative, in which case the pointer will be written
+     *                        with the delta between the pointer location and the
+     *                        new destination address. Otherwise it will be written
+     *                        with the absolute address.
+     * @param isBigEndian     True if the program (and therefore the byte order of
+     *                        the pointer) is big endian. False if little endian.
+     * @param pointerSize     1, 2, and 4-byte pointers are supported.
+     */
+    private void fixAddress(MemoryBlock block, Address pointerLocation, Address newAddress,
+                            boolean isPcRelative, boolean isBigEndian, int pointerSize) {
+
+        final long value = isPcRelative ? (newAddress.getOffset() - pointerLocation.getOffset())
+                           : newAddress.getOffset();
+
+        byte[] valueBytes = new byte[pointerSize];
+
+        for (int i = 0; i < pointerSize; i++) {
+            int shiftCount = isBigEndian ? (24 - (i * 8)) : (i * 8);
+            valueBytes[i] = (byte) ((value >> shiftCount) & 0xff);
+        }
+        try {
+            block.putBytes(pointerLocation, valueBytes);
+        } catch (MemoryAccessException e) {
+            e.printStackTrace();
+        }
+    }
+
+    /**
+     * Reads a single relocation table for either text or data relocations,
+     * depending on the offset/length provided.
+     *
+     * @param reader Source of file data
+     * @param offset File byte offset to the start of the relocation table
+     * @param len    Length of the relocation table in bytes
+     * @return Vector of relocation table entries
+     */
+    private Vector<UnixAoutRelocationTableEntry> getRelocationTable(BinaryReader reader,
+		long offset, long len) {
+        Vector<UnixAoutRelocationTableEntry> relocTable =
+			new Vector<UnixAoutRelocationTableEntry>();
+        reader.setPointerIndex(offset);
+
+        try {
+            while (reader.getPointerIndex() < (offset + len)) {
+                long address = reader.readNextUnsignedInt();
+                long flags = reader.readNextUnsignedInt();
+                relocTable.add(
+					new UnixAoutRelocationTableEntry(address, flags, reader.isBigEndian()));
+            }
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        return relocTable;
+    }
+
+    /**
+     * Reads all the symbol table entries from the file, returning their
+     * representation.
+     *
+     * @param reader           Source of file data
+     * @param offset           File byte offset to the start of the symbol table
+     * @param len              Length of the symbol table in bytes
+     * @param strTabBaseOffset File byte offset to the start of the string table
+     *                         (containing symbol names)
+     * @return Vector of symbol table entries
+     */
+    private Vector<UnixAoutSymbolTableEntry> getSymbolTable(BinaryReader reader, long offset,
+		long len, long strTabBaseOffset) {
+        Vector<UnixAoutSymbolTableEntry> symtab = new Vector<UnixAoutSymbolTableEntry>();
+        reader.setPointerIndex(offset);
+
+        try {
+            // read each symbol table entry
+            while (reader.getPointerIndex() < (offset + len)) {
+                long strOffset = reader.readNextUnsignedInt();
+                byte typeByte = reader.readNextByte();
+                byte otherByte = reader.readNextByte();
+                short desc = reader.readNextShort();
+                long value = reader.readNextUnsignedInt();
+                symtab.add(
+					new UnixAoutSymbolTableEntry(strOffset, typeByte, otherByte, desc, value));
+            }
+
+            // lookup and set each string table symbol name
+            for (Integer i = 0; i < symtab.size(); i++) {
+                String symstr =
+					reader.readAsciiString(strTabBaseOffset + symtab.get(i).nameStringOffset);
+                symtab.get(i).name = symstr;
+            }
+
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+
+        return symtab;
+    }
+}
-- 
2.41.0

