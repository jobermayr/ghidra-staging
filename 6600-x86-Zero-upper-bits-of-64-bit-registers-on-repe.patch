From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Sleigh-InSPECtor <sleighinspector@outlook.com>
Date: Thu, 30 May 2024 16:14:49 +0930
Subject: [PATCH] 6600: x86: Zero upper bits of 64-bit registers on
 repeat/loop/string instructions

x86: zero upper bits of 32-bit registers in string memory access constructors

x86: Zero upper bits of ECX in instructions with a REP prefix

x86: Zero upper bits of RAX in LODSD

x86: Zero upper bits of `ECX` for LOOP instructions
---
 Ghidra/Processors/x86/data/languages/ia.sinc | 57 +++++++++++---------
 1 file changed, 33 insertions(+), 24 deletions(-)

diff --git a/Ghidra/Processors/x86/data/languages/ia.sinc b/Ghidra/Processors/x86/data/languages/ia.sinc
index a86a498ae4..1bc931c8e2 100644
--- a/Ghidra/Processors/x86/data/languages/ia.sinc
+++ b/Ghidra/Processors/x86/data/languages/ia.sinc
@@ -1455,26 +1455,35 @@ moffs64: segWide^[imm32]  is addrsize=1 & highseg=1 & segWide & imm32   { tmp:8
 @endif
 # TODO: segment register offset in 64bit might not be right
 
+@ifdef IA64
+check_EDI_dest: is $(LONGMODE_ON)	{ RDI = zext(EDI); }
+check_ESI_dest: is $(LONGMODE_ON)	{ RSI = zext(ESI); }
+check_ECX_dest: is $(LONGMODE_ON)	{ RCX = zext(ECX); }
+@endif
+check_EDI_dest:	is epsilon  		{ }
+check_ESI_dest:	is epsilon  		{ }
+check_ECX_dest:	is epsilon  		{ }
+
 # String memory access
 @ifdef IA64
 dseSI1: seg16^SI    is addrsize=0 & seg16 & SI  { tmp1:4 = segment(seg16,SI); tmp:8 = zext(tmp1); export tmp; }
-dseSI1: segWide^ESI   is addrsize=1 & segWide & ESI { tmp:8 = zext(ESI); export tmp; }
+dseSI1: segWide^ESI   is addrsize=1 & segWide & ESI & check_ESI_dest { tmp:8 = zext(ESI); build check_ESI_dest; export tmp; }
 dseSI2: seg16^SI    is addrsize=0 & seg16 & SI  { tmp1:4 = segment(seg16,SI); tmp:8 = zext(tmp1); export tmp; }
-dseSI2: segWide^ESI   is addrsize=1 & segWide & ESI { tmp:8 = zext(ESI); export tmp; }
+dseSI2: segWide^ESI   is addrsize=1 & segWide & ESI & check_ESI_dest { tmp:8 = zext(ESI); build check_ESI_dest; export tmp; }
 dseSI4: seg16^SI    is addrsize=0 & seg16 & SI  { tmp1:4 = segment(seg16,SI); tmp:8 = zext(tmp1); export tmp; }
-dseSI4: segWide^ESI   is addrsize=1 & segWide & ESI { tmp:8 = zext(ESI); export tmp; }
+dseSI4: segWide^ESI   is addrsize=1 & segWide & ESI & check_ESI_dest { tmp:8 = zext(ESI); build check_ESI_dest; export tmp; }
 eseDI1: ES:DI       is addrsize=0 & ES & DI     { tmp1:4 = segment(ES,DI); tmp:8 = zext(tmp1); export tmp; }
-eseDI1: ES:EDI      is addrsize=1 & ES & EDI { tmp:8 = zext(EDI); export tmp; }
+eseDI1: ES:EDI      is addrsize=1 & ES & EDI & check_EDI_dest { tmp:8 = zext(EDI); build check_EDI_dest; export tmp; }
 eseDI2: ES:DI       is addrsize=0 & ES & DI     { tmp1:4 = segment(ES,DI); tmp:8 = zext(tmp1); export tmp; }
-eseDI2: ES:EDI      is addrsize=1 & ES & EDI { tmp:8 = zext(EDI); export tmp; }
+eseDI2: ES:EDI      is addrsize=1 & ES & EDI & check_EDI_dest { tmp:8 = zext(EDI); build check_EDI_dest; export tmp; }
 eseDI4: ES:DI       is addrsize=0 & ES & DI     { tmp1:4 = segment(ES,DI); tmp:8 = zext(tmp1); export tmp; }
-eseDI4: ES:EDI      is addrsize=1 & ES & EDI { tmp:8 = zext(EDI); export tmp; }
+eseDI4: ES:EDI      is addrsize=1 & ES & EDI & check_EDI_dest { tmp:8 = zext(EDI); build check_EDI_dest; export tmp; }
 
 # quadword string functions
 dseSI8: seg16^SI    is addrsize=0 & seg16 & SI  { tmp1:4 = segment(seg16,SI); tmp:8 = zext(tmp1); export tmp; }
-dseSI8: segWide^ESI   is addrsize=1 & segWide & ESI { tmp:8 = zext(ESI); export tmp; }
+dseSI8: segWide^ESI   is addrsize=1 & segWide & ESI & check_ESI_dest { tmp:8 = zext(ESI); build check_ESI_dest; export tmp; }
 eseDI8: ES:DI       is addrsize=0 & ES & DI     { tmp1:4 = segment(ES,DI); tmp:8 = zext(tmp1); export tmp; }
-eseDI8: ES:EDI      is addrsize=1 & ES & EDI { tmp:8 = zext(EDI); export tmp; }
+eseDI8: ES:EDI      is addrsize=1 & ES & EDI & check_EDI_dest { tmp:8 = zext(EDI); build check_EDI_dest; export tmp; }
 
 dseSI1: RSI   is addrsize=2 & RSI { export RSI; }
 dseSI2: RSI   is addrsize=2 & RSI { export RSI; }
@@ -1487,17 +1496,17 @@ eseDI8: RDI   is addrsize=2 & RDI { export RDI; }
 
 @else
 dseSI1: seg16^SI    is addrsize=0 & seg16 & SI  { tmp:4 = segment(seg16,SI); export tmp; }
-dseSI1: segWide^ESI   is addrsize=1 & segWide & ESI { tmp:4 = ESI; export tmp; }
+dseSI1: segWide^ESI   is addrsize=1 & segWide & ESI & check_ESI_dest { tmp:4 = ESI; build check_ESI_dest; export tmp; }
 dseSI2: seg16^SI    is addrsize=0 & seg16 & SI  { tmp:4 = segment(seg16,SI); export tmp; }
-dseSI2: segWide^ESI   is addrsize=1 & segWide & ESI { tmp:4 = ESI; export tmp; }
+dseSI2: segWide^ESI   is addrsize=1 & segWide & ESI & check_ESI_dest { tmp:4 = ESI; build check_ESI_dest; export tmp; }
 dseSI4: seg16^SI    is addrsize=0 & seg16 & SI  { tmp:4 = segment(seg16,SI); export tmp; }
-dseSI4: segWide^ESI   is addrsize=1 & segWide & ESI { tmp:4 = ESI; export tmp; }
+dseSI4: segWide^ESI   is addrsize=1 & segWide & ESI & check_ESI_dest { tmp:4 = ESI; build check_ESI_dest; export tmp; }
 eseDI1: ES:DI       is addrsize=0 & ES & DI     { tmp:4 = segment(ES,DI); export tmp; }
-eseDI1: ES:EDI      is addrsize=1 & ES & EDI { tmp:4 = EDI; export tmp; }
+eseDI1: ES:EDI      is addrsize=1 & ES & EDI & check_EDI_dest { tmp:4 = EDI; build check_EDI_dest; export tmp; }
 eseDI2: ES:DI       is addrsize=0 & ES & DI     { tmp:4 = segment(ES,DI); export tmp; }
-eseDI2: ES:EDI      is addrsize=1 & ES & EDI { tmp:4 = EDI; export tmp; }
+eseDI2: ES:EDI      is addrsize=1 & ES & EDI & check_EDI_dest { tmp:4 = EDI; build check_EDI_dest; export tmp; }
 eseDI4: ES:DI       is addrsize=0 & ES & DI     { tmp:4 = segment(ES,DI); export tmp; }
-eseDI4: ES:EDI      is addrsize=1 & ES & EDI { tmp:4 = EDI; export tmp; }
+eseDI4: ES:EDI      is addrsize=1 & ES & EDI & check_EDI_dest { tmp:4 = EDI; build check_EDI_dest; export tmp; }
 @endif
 
 rm8: Rmr8   is mod=3 & Rmr8     { export Rmr8; }
@@ -1567,7 +1576,7 @@ cc: "G" is cond=15          { local tmp = !ZF && (OF == SF); export tmp; }
 
 # repeat prefixes
 rep: ".REP" is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1)) & addrsize=0  { if (CX==0) goto inst_next; CX=CX-1; }
-rep: ".REP" is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1)) & addrsize=1  { if (ECX==0) goto inst_next; ECX=ECX-1; }
+rep: ".REP" is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1)) & addrsize=1 & check_ECX_dest  { if (ECX==0) goto inst_next; ECX=ECX-1; build check_ECX_dest; }
 @ifdef IA64
 rep: ".REP" is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1)) & addrsize=2  { if (RCX==0) goto inst_next; RCX=RCX-1; }
 @endif
@@ -1579,12 +1588,12 @@ reptail:	is ((repprefx=1 & repneprefx=0)|(repprefx=0 & repneprefx=1))			{ goto i
 reptail:	is repprefx=0 & repneprefx=0			{ }
 
 repe: ".REPE"   is repprefx=1 & repneprefx=0 & addrsize=0  { if (CX==0) goto inst_next; CX=CX-1; }
-repe: ".REPE"   is repprefx=1 & repneprefx=0 & addrsize=1  { if (ECX==0) goto inst_next; ECX=ECX-1; }
+repe: ".REPE"   is repprefx=1 & repneprefx=0 & addrsize=1 & check_ECX_dest { if (ECX==0) goto inst_next; ECX=ECX-1; build check_ECX_dest; }
 @ifdef IA64
 repe: ".REPE"   is repprefx=1 & repneprefx=0 & addrsize=2  { if (RCX==0) goto inst_next; RCX=RCX-1; }
 @endif
 repe: ".REPNE"  is repneprefx=1 & repprefx=0 & addrsize=0    { if (CX==0) goto inst_next; CX=CX-1; }
-repe: ".REPNE"  is repneprefx=1 & repprefx=0 & addrsize=1    { if (ECX==0) goto inst_next; ECX=ECX-1; }
+repe: ".REPNE"  is repneprefx=1 & repprefx=0 & addrsize=1 & check_ECX_dest { if (ECX==0) goto inst_next; ECX=ECX-1; build check_ECX_dest; }
 @ifdef IA64
 repe: ".REPNE"  is repneprefx=1 & repprefx=0 & addrsize=2    { if (RCX==0) goto inst_next; RCX=RCX-1; }
 @endif
@@ -5155,7 +5164,7 @@ define pcodeop lodsw;
 <end>
 }
 define pcodeop lodsd;
-:LODSD^repx dseSI4	is vexMode=0 & repx & opsize=1 & byte=0xAD & dseSI4
+:LODSD^repx dseSI4	is vexMode=0 & repx & opsize=1 & byte=0xAD & dseSI4 & check_EAX_dest
 {
   if (repx) goto <loop>;
   EAX = *:4 dseSI4;
@@ -5193,20 +5202,20 @@ define pcodeop lodsq;
 }
 @endif
 
-:LOOP   rel8        is vexMode=0 & addrsize=0 & byte=0xE2; rel8             { CX = CX -1; if (CX!=0) goto rel8; }
-:LOOP   rel8        is vexMode=0 & addrsize=1 & byte=0xE2; rel8             { ECX = ECX -1; if (ECX!=0) goto rel8; }
+:LOOP   rel8        is vexMode=0 & addrsize=0 & byte=0xE2; rel8                  { CX = CX -1; if (CX!=0) goto rel8; }
+:LOOP   rel8        is vexMode=0 & addrsize=1 & byte=0xE2; rel8 & check_ECX_dest { ECX = ECX -1; build check_ECX_dest; if (ECX!=0) goto rel8; }
 @ifdef IA64
 :LOOP   rel8        is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & byte=0xE2; rel8             { RCX = RCX -1; if (RCX!=0) goto rel8; }
 @endif
 
-:LOOPZ  rel8        is vexMode=0 & addrsize=0 & byte=0xE1; rel8             { CX = CX -1; if (CX!=0 && ZF!=0) goto rel8; }
-:LOOPZ  rel8        is vexMode=0 & addrsize=1 & byte=0xE1; rel8             { ECX = ECX -1; if (ECX!=0 && ZF!=0) goto rel8; }
+:LOOPZ  rel8        is vexMode=0 & addrsize=0 & byte=0xE1; rel8                  { CX = CX -1; if (CX!=0 && ZF!=0) goto rel8; }
+:LOOPZ  rel8        is vexMode=0 & addrsize=1 & byte=0xE1; rel8 & check_ECX_dest { ECX = ECX -1; build check_ECX_dest; if (ECX!=0 && ZF!=0) goto rel8; }
 @ifdef IA64
 :LOOPZ  rel8        is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & byte=0xE1; rel8             { RCX = RCX -1; if (RCX!=0 && ZF!=0) goto rel8; }
 @endif
 
-:LOOPNZ rel8        is vexMode=0 & addrsize=0 & byte=0xE0; rel8             { CX = CX -1; if (CX!=0 && ZF==0) goto rel8; }
-:LOOPNZ rel8        is vexMode=0 & addrsize=1 & byte=0xE0; rel8             { ECX = ECX -1; if (ECX!=0 && ZF==0) goto rel8; }
+:LOOPNZ rel8        is vexMode=0 & addrsize=0 & byte=0xE0; rel8                  { CX = CX -1; if (CX!=0 && ZF==0) goto rel8; }
+:LOOPNZ rel8        is vexMode=0 & addrsize=1 & byte=0xE0; rel8 & check_ECX_dest { ECX = ECX -1; build check_ECX_dest; if (ECX!=0 && ZF==0) goto rel8; }
 @ifdef IA64
 :LOOPNZ rel8        is $(LONGMODE_ON) & vexMode=0 & addrsize=2 & byte=0xE0; rel8             { RCX = RCX -1; if (RCX!=0 && ZF==0) goto rel8; }
 @endif
-- 
2.45.1

