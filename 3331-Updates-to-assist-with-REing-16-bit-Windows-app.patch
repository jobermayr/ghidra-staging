From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Allan F Wall <Allan.F.Wall@users.noreply.github.com>
Date: Tue, 29 Sep 2020 10:20:23 +0100
Subject: [PATCH] 3331: Updates to assist with REing 16-bit Windows
 applications

"#2315: Support for mixed-size pointers, PASCAL calling convention, 'based' types +"

"NationalSecurityAgency#2233 NeLoader and supporting classes fail to recognise"

Move properties file within Ghidra's module

Created independent 'AddressModel' and fix references

Add new Windows API names with class and make loader understand new format

NationalSecurityAgency#3314 - Enums sharing names not recognised in decompiled output

Update Ghidra/Features/Base/ghidra_scripts/FixPascalCallingConvention.java
Better use of string manipulation.
Co-authored-by: Andrew Strelsky <ajs222@njit.edu>

Corrected earlier StringBuffer to String suggestion

Removed dropped overrides for method isDynamicallySized

Update for 'this' calling conventions for near/far calls & pointers

Rebase to my master

Add missing null check

Merge conflicts on Enum 'n' EnumDataType in SoftwareModeling resolved.

Resolve conflict in C.jj, AbstractDataType.java & DataTypeDB.java

Re-added tag HUGE and optionalised prepeneded '_' for NEAR, FAR & HUGE tags.

Resolved merge by dropping my 'always save' change in class LibraryLookupTable.

Resolve C.jj merge conflicts.

Add specific 'import ghidra.program.model.data.AddressModel;'.

Resolve merge confict in certification.manifest by moving FunctionNames.properties to below win16 components

Fix merge conflict by applying Ghira's change

Replaced with their version

Removed unnecessary files

More sized pointer support.

Resolved conflics

Added new override of getAlignedLength to class AddressModelDB

Remove old HEAD commented out code and add import .../AddressModel

Resolved new isEquivalent interface.

Reconciled updates in LibrarySymbolTable and corrected spelling of 'forward' in LibraryExport

In merging the previous commit, I missed that I'd commented out the loop that was updated, so this fixes it!!!

Replace DBConstants class with OpenMode and READ_ONLY with IMMUTABLE.

Fix merge conflict on 'LibraryLookupTable.java'.

Fix C++ Pascal style parameter allocation

Corrected merge of C.jj & implemented new DockingAction's to CreateLPUnionStructAction.

Merged by resolving attribute 'isRightToLeft' and adjusted attribute 'XMLunknown' to compensate.
---
 Ghidra/Features/Base/certification.manifest   |    1 +
 .../Base/data/FunctionNames.properties        | 2308 +++++++++++++++++
 .../FixPascalCallingConvention.java           |  280 ++
 .../FixWin16LibraryFunctionNames.java         |  171 ++
 .../Base/ghidra_scripts/MakeUnionsForLPs.java |  587 +++++
 .../_GetAllFunctionsCallingConvention.java    |  106 +
 .../_SetFunctonNameFromLPSTR.java             |  249 ++
 .../ghidra_scripts/_SetSSRegForAllFuncs.java  |  112 +
 .../function/ApplyFunctionSignatureCmd.java   |    2 +-
 .../SegmentedCallingConventionAnalyzer.java   |   21 +-
 .../actions/CreateLPUnionStructAction.java    |  326 +++
 .../function/editor/FunctionEditorModel.java  |    6 +-
 .../app/util/cparser/C/Declaration.java       |   80 +-
 .../app/util/opinion/LibraryExport.java       |   85 +
 .../app/util/opinion/LibraryLookupTable.java  |    8 +-
 .../app/util/opinion/LibrarySymbolTable.java  |   79 +-
 .../ghidra/app/util/opinion/NeLoader.java     |    9 +-
 .../javacc/ghidra/app/util/cparser/C/C.jj     |  175 +-
 .../EditFunctionSignatureDialogTest.java      |   33 +
 .../Decompiler/src/decompile/cpp/fspec.cc     |   89 +-
 .../Decompiler/src/decompile/cpp/fspec.hh     |   12 +-
 .../Decompiler/src/decompile/cpp/marshal.cc   |    2 +-
 .../src/decompile/cpp/modelrules.cc           |    2 +-
 .../data/languages/compiler_spec.rxg          |    1 +
 .../program/database/data/AddressModelDB.java |  221 ++
 .../database/data/AddressModelDBAdapter.java  |  190 ++
 .../data/AddressModelDBAdapterNoTable.java    |   70 +
 .../data/AddressModelDBAdapterV0.java         |  112 +
 .../program/database/data/DataTypeDB.java     |   11 +
 .../program/database/data/PointerDB.java      |    3 +
 .../program/database/function/FunctionDB.java |    6 +-
 .../program/model/data/AbstractDataType.java  |   18 +-
 .../program/model/data/AddressModel.java      |   71 +
 .../model/data/AddressModelDataType.java      |  120 +
 .../ghidra/program/model/data/DataType.java   |    4 +
 .../program/model/data/DataTypeWriter.java    |    6 +-
 .../model/data/GenericCallingConvention.java  |   13 +-
 .../model/data/OffsetCodePointerDataType.java |  100 +
 .../program/model/data/PointerDataType.java   |    6 +-
 .../data/SegmentCodePointerDataType.java      |  101 +
 .../program/model/lang/ParamListStandard.java |   18 +-
 .../model/lang/ParamListStandardOut.java      |   10 +-
 .../program/model/lang/PrototypeModel.java    |   86 +-
 .../lang/protorules/ConvertToPointer.java     |    3 +-
 .../model/listing/FunctionSignature.java      |    6 +
 .../program/model/pcode/AttributeId.java      |    5 +-
 .../model/TestDoubleFunctionSignature.java    |    6 +
 .../program/model/data/StubDataType.java      |   10 +
 .../x86/data/languages/x86-16.cspec           |  288 +-
 49 files changed, 6108 insertions(+), 120 deletions(-)
 create mode 100644 Ghidra/Features/Base/data/FunctionNames.properties
 create mode 100644 Ghidra/Features/Base/ghidra_scripts/FixPascalCallingConvention.java
 create mode 100644 Ghidra/Features/Base/ghidra_scripts/FixWin16LibraryFunctionNames.java
 create mode 100644 Ghidra/Features/Base/ghidra_scripts/MakeUnionsForLPs.java
 create mode 100644 Ghidra/Features/Base/ghidra_scripts/_GetAllFunctionsCallingConvention.java
 create mode 100644 Ghidra/Features/Base/ghidra_scripts/_SetFunctonNameFromLPSTR.java
 create mode 100644 Ghidra/Features/Base/ghidra_scripts/_SetSSRegForAllFuncs.java
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/actions/CreateLPUnionStructAction.java
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibraryExport.java
 create mode 100644 Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/AddressModelDB.java
 create mode 100644 Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/AddressModelDBAdapter.java
 create mode 100644 Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/AddressModelDBAdapterNoTable.java
 create mode 100644 Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/AddressModelDBAdapterV0.java
 create mode 100644 Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/AddressModel.java
 create mode 100644 Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/AddressModelDataType.java
 create mode 100644 Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/OffsetCodePointerDataType.java
 create mode 100644 Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/SegmentCodePointerDataType.java

diff --git a/Ghidra/Features/Base/certification.manifest b/Ghidra/Features/Base/certification.manifest
index e41a8e4482..785ec0eea2 100644
--- a/Ghidra/Features/Base/certification.manifest
+++ b/Ghidra/Features/Base/certification.manifest
@@ -59,6 +59,7 @@ data/symbols/win16/toolhelp.exports||GHIDRA||||END|
 data/symbols/win16/user.exports||GHIDRA||||END|
 data/symbols/win16/ver.exports||GHIDRA||||END|
 data/symbols/win16/win87em.exports||GHIDRA||||END|
+data/FunctionNames.properties||GHIDRA||||END|
 data/symbols/win32/kernel32.hints||GHIDRA||||END|
 data/symbols/win32/mfc100.exports||GHIDRA||||END|
 data/symbols/win32/mfc100u.exports||GHIDRA||||END|
diff --git a/Ghidra/Features/Base/data/FunctionNames.properties b/Ghidra/Features/Base/data/FunctionNames.properties
new file mode 100644
index 0000000000..e94e6c9334
--- /dev/null
+++ b/Ghidra/Features/Base/data/FunctionNames.properties
@@ -0,0 +1,2308 @@
+COMMDLG\:\:CHOOSEFONT=ChooseFont
+COMMDLG\:\:COMMDLGEXTENDEDERROR=CommDlgExtendedError
+COMMDLG\:\:GETSAVEFILENAME=GetSaveFileName
+COMMDLG\:\:CHOOSECOLOR=ChooseColor
+COMMDLG\:\:GETOPENFILENAME=GetOpenFileName
+COMMDLG\:\:REPLACETEXT=ReplaceText
+COMMDLG\:\:PRINTDLG=PrintDlg
+COMMDLG\:\:GETFILETITLE=GetFileTitle
+COMMDLG\:\:FINDTEXT=FindText
+GDI\:\:lineto=LineTo
+GDI\:\:moveto=MoveTo
+GDI\:\:ABORTDOC=AbortDoc
+GDI\:\:ADDFONTRESOURCE=AddFontResource
+GDI\:\:ANIMATEPALETTE=AnimatePalette
+GDI\:\:ARC=Arc
+GDI\:\:BITBLT=BitBlt
+GDI\:\:CHORD=Chord
+GDI\:\:CLOSEJOB=CloseJob
+GDI\:\:CLOSEMETAFILE=CloseMetaFile
+GDI\:\:COMBINERGN=CombineRgn
+GDI\:\:COPY=Copy
+GDI\:\:COPYMETAFILE=CopyMetaFile
+GDI\:\:CREATEBITMAP=CreateBitmap
+GDI\:\:CREATEBITMAPINDIRECT=CreateBitmapIndirect
+GDI\:\:CREATEBRUSHINDIRECT=CreateBrushIndirect
+GDI\:\:CREATECOMPATIBLEBITMAP=CreateCompatibleBitmap
+GDI\:\:CREATECOMPATIBLEDC=CreateCompatibleDC
+GDI\:\:CREATEDC=CreateDC
+GDI\:\:CREATEDIBITMAP=CreateDIBitmap
+GDI\:\:CREATEDIBPATTERNBRUSH=CreateDIBPatternBrush
+GDI\:\:CREATEDISCARDABLEBITMAP=CreateDiscardableBitmap
+GDI\:\:CREATEELLIPTICRGN=CreateEllipticRgn
+GDI\:\:CREATEELLIPTICRGNINDIRECT=CreateEllipticRgnIndirect
+GDI\:\:CREATEFONT=CreateFont
+GDI\:\:CREATEFONTINDIRECT=CreateFontIndirect
+GDI\:\:CREATEHATCHBRUSH=CreateHatchBrush
+GDI\:\:CREATEIC=CreateIC
+GDI\:\:CREATEMETAFILE=CreateMetaFile
+GDI\:\:CREATEPALETTE=CreatePalette
+GDI\:\:CREATEPATTERNBRUSH=CreatePatternBrush
+GDI\:\:CREATEPEN=CreatePen
+GDI\:\:CREATEPENINDIRECT=CreatePenIndirect
+GDI\:\:CREATEPOLYGONRGN=CreatePolygonRgn
+GDI\:\:CREATEPOLYPOLYGONRGN=CreatePolyPolygonRgn
+GDI\:\:CREATEPQ=CreatePQ
+GDI\:\:CREATERECTRGN=CreateRectRgn
+GDI\:\:CREATERECTRGNINDIRECT=CreateRectRgnIndirect
+GDI\:\:CREATEROUNDRECTRGN=CreateRoundRectRgn
+GDI\:\:CREATESCALABLEFONTRESOURCE=CreateScalableFontResource
+GDI\:\:CREATESOLIDBRUSH=CreateSolidBrush
+GDI\:\:DELETEDC=DeleteDC
+GDI\:\:DELETEJOB=DeleteJob
+GDI\:\:DELETEMETAFILE=DeleteMetaFile
+GDI\:\:DELETEOBJECT=DeleteObject
+GDI\:\:DELETEPQ=DeletePQ
+GDI\:\:DELETESPOOLPAGE=DeleteSpoolPage
+GDI\:\:DPTOLP=DPtoLP
+GDI\:\:ELLIPSE=Ellipse
+GDI\:\:ENDDOC=EndDoc
+GDI\:\:ENDPAGE=EndPage
+GDI\:\:ENDSPOOLPAGE=EndSpoolPage
+GDI\:\:ENUMFONTFAMILIES=EnumFontFamilies
+GDI\:\:ENUMFONTS=EnumFonts
+GDI\:\:ENUMMETAFILE=EnumMetaFile
+GDI\:\:ENUMOBJECTS=EnumObjects
+GDI\:\:EQUALRGN=EqualRgn
+GDI\:\:ESCAPE=Escape
+GDI\:\:EXCLUDECLIPRECT=ExcludeClipRect
+GDI\:\:EXTFLOODFILL=ExtFloodFill
+GDI\:\:EXTRACTPQ=ExtractPQ
+GDI\:\:EXTTEXTOUT=ExtTextOut
+GDI\:\:FILLRGN=FillRgn
+GDI\:\:FLOODFILL=FloodFill
+GDI\:\:FRAMERGN=FrameRgn
+GDI\:\:GETASPECTRATIOFILTER=GetAspectRatioFilter
+GDI\:\:GETASPECTRATIOFILTEREX=GetAspectRatioFilterEx
+GDI\:\:GETBITMAPBITS=GetBitmapBits
+GDI\:\:GETBITMAPDIMENSION=GetBitmapDimension
+GDI\:\:GETBITMAPDIMENSIONEX=GetBitmapDimensionEx
+GDI\:\:GETBKCOLOR=GetBkColor
+GDI\:\:GETBKMODE=GetBkMode
+GDI\:\:GETBOUNDSRECT=GetBoundsRect
+GDI\:\:GETBRUSHORG=GetBrushOrg
+GDI\:\:GETBRUSHORGEX=GetBrushOrgEx
+GDI\:\:GETCHARABCWIDTHS=GetCharABCWidths
+GDI\:\:GETCHARWIDTH=GetCharWidth
+GDI\:\:GETCLIPBOX=GetClipBox
+GDI\:\:GETCLIPRGN=GetClipRgn
+GDI\:\:GETCURRENTPOSITION=GetCurrentPosition
+GDI\:\:GETCURRENTPOSITIONEX=GetCurrentPositionEx
+GDI\:\:GETDCORG=GetDCOrg
+GDI\:\:GETDEVICECAPS=GetDeviceCaps
+GDI\:\:GETDIBITS=GetDIBits
+GDI\:\:GETENVIRONMENT=GetEnvironment
+GDI\:\:GETFONTDATA=GetFontData
+GDI\:\:GETGLYPHOUTLINE=GetGlyphOutline
+GDI\:\:GETKERNINGPAIRS=GetKerningPairs
+GDI\:\:GETMAPMODE=GetMapMode
+GDI\:\:GETMETAFILE=GetMetaFile
+GDI\:\:GETMETAFILEBITS=GetMetaFileBits
+GDI\:\:GETNEARESTCOLOR=GetNearestColor
+GDI\:\:GETNEARESTPALETTEINDEX=GetNearestPaletteIndex
+GDI\:\:GETOBJECT=GetObject
+GDI\:\:GETOUTLINETEXTMETRICS=GetOutlineTextMetrics
+GDI\:\:GETPALETTEENTRIES=GetPaletteEntries
+GDI\:\:GETPIXEL=GetPixel
+GDI\:\:GETPOLYFILLMODE=GetPolyFillMode
+GDI\:\:GETRASTERIZERCAPS=GetRasterizerCaps
+GDI\:\:GETRGNBOX=GetRgnBox
+GDI\:\:GETROP2=GetROP2
+GDI\:\:GETSTOCKOBJECT=GetStockObject
+GDI\:\:GETSTRETCHBLTMODE=GetStretchBltMode
+GDI\:\:GETSYSTEMPALETTEENTRIES=GetSystemPaletteEntries
+GDI\:\:GETSYSTEMPALETTEUSE=GetSystemPaletteUse
+GDI\:\:GETTEXTALIGN=GetTextAlign
+GDI\:\:GETTEXTCHARACTEREXTRA=GetTextCharacterExtra
+GDI\:\:GETTEXTCOLOR=GetTextColor
+GDI\:\:GETTEXTEXTENT=GetTextExtent
+GDI\:\:GETTEXTEXTENTPOINT=GetTextExtentPoint
+GDI\:\:GETTEXTFACE=GetTextFace
+GDI\:\:GETTEXTMETRICS=GetTextMetrics
+GDI\:\:GETVIEWPORTEXT=GetViewportExt
+GDI\:\:GETVIEWPORTEXTEX=GetViewportExtEx
+GDI\:\:GETVIEWPORTORG=GetViewportOrg
+GDI\:\:GETVIEWPORTORGEX=GetViewportOrgEx
+GDI\:\:GETWINDOWEXT=GetWindowExt
+GDI\:\:GETWINDOWEXTEX=GetWindowExtEx
+GDI\:\:GETWINDOWORG=GetWindowOrg
+GDI\:\:GETWINDOWORGEX=GetWindowOrgEx
+GDI\:\:INSERTPQ=InsertPQ
+GDI\:\:INTERSECTCLIPRECT=IntersectClipRect
+GDI\:\:INVERTRGN=InvertRgn
+GDI\:\:ISGDIOBJECT=IsGDIObject
+GDI\:\:LINEDDA=LineDDA
+GDI\:\:LINETO=LineTo
+GDI\:\:LPTODP=LPtoDP
+GDI\:\:MINPQ=MinPQ
+GDI\:\:MOVETO=MoveTo
+GDI\:\:MOVETOEX=MoveToEx
+GDI\:\:MULDIV=MulDiv
+GDI\:\:OFFSETCLIPRGN=OffsetClipRgn
+GDI\:\:OFFSETRGN=OffsetRgn
+GDI\:\:OFFSETVIEWPORTORG=OffsetViewportOrg
+GDI\:\:OFFSETVIEWPORTORGEX=OffsetViewportOrgEx
+GDI\:\:OFFSETWINDOWORG=OffsetWindowOrg
+GDI\:\:OFFSETWINDOWORGEX=OffsetWindowOrgEx
+GDI\:\:OPENJOB=OpenJob
+GDI\:\:PAINTRGN=PaintRgn
+GDI\:\:PATBLT=PatBlt
+GDI\:\:PIE=Pie
+GDI\:\:PLAYMETAFILE=PlayMetaFile
+GDI\:\:PLAYMETAFILERECORD=PlayMetaFileRecord
+GDI\:\:POLYGON=Polygon
+GDI\:\:POLYLINE=Polyline
+GDI\:\:POLYPOLYGON=PolyPolygon
+GDI\:\:PTINREGION=PtInRegion
+GDI\:\:PTVISIBLE=PtVisible
+GDI\:\:QUERYABORT=QueryAbort
+GDI\:\:RECTANGLE=Rectangle
+GDI\:\:RECTINREGION=RectInRegion
+GDI\:\:RECTVISIBLE=RectVisible
+GDI\:\:REMOVEFONTRESOURCE=RemoveFontResource
+GDI\:\:RESETDC=ResetDC
+GDI\:\:RESIZEPALETTE=ResizePalette
+GDI\:\:RESTOREDC=RestoreDC
+GDI\:\:ROUNDRECT=RoundRect
+GDI\:\:SAVEDC=SaveDC
+GDI\:\:SCALEVIEWPORTEXT=ScaleViewportExt
+GDI\:\:SCALEVIEWPORTEXTEX=ScaleViewportExtEx
+GDI\:\:SCALEWINDOWEXT=ScaleWindowExt
+GDI\:\:SCALEWINDOWEXTEX=ScaleWindowExtEx
+GDI\:\:SELECTBITMAP=SelectBitmap
+GDI\:\:SELECTCLIPRGN=SelectClipRgn
+GDI\:\:SELECTOBJECT=SelectObject
+GDI\:\:SETABORTPROC=SetAbortProc
+GDI\:\:SETBITMAPBITS=SetBitmapBits
+GDI\:\:SETBITMAPDIMENSION=SetBitmapDimension
+GDI\:\:SETBITMAPDIMENSIONEX=SetBitmapDimensionEx
+GDI\:\:SETBKCOLOR=SetBkColor
+GDI\:\:SETBKMODE=SetBkMode
+GDI\:\:SETBOUNDSRECT=SetBoundsRect
+GDI\:\:SETBRUSHORG=SetBrushOrg
+GDI\:\:SETDIBITS=SetDIBits
+GDI\:\:SETDIBITSTODEVICE=SetDIBitsToDevice
+GDI\:\:SETENVIRONMENT=SetEnvironment
+GDI\:\:SETMAPMODE=SetMapMode
+GDI\:\:SETMAPPERFLAGS=SetMapperFlags
+GDI\:\:SETMETAFILEBITS=SetMetaFileBits
+GDI\:\:SETMETAFILEBITSBETTER=SetMetaFileBitsBetter
+GDI\:\:SETPALETTEENTRIES=SetPaletteEntries
+GDI\:\:SETPIXEL=SetPixel
+GDI\:\:SETPOLYFILLMODE=SetPolyFillMode
+GDI\:\:SETRECTRGN=SetRectRgn
+GDI\:\:SETROP2=SetROP2
+GDI\:\:SETSTRETCHBLTMODE=SetStretchBltMode
+GDI\:\:SETSYSTEMPALETTEUSE=SetSystemPaletteUse
+GDI\:\:SETTEXTALIGN=SetTextAlign
+GDI\:\:SETTEXTCHARACTEREXTRA=SetTextCharacterExtra
+GDI\:\:SETTEXTCOLOR=SetTextColor
+GDI\:\:SETTEXTJUSTIFICATION=SetTextJustification
+GDI\:\:SETVIEWPORTEXT=SetViewportExt
+GDI\:\:SETVIEWPORTEXTEX=SetViewportExtEx
+GDI\:\:SETVIEWPORTORG=SetViewportOrg
+GDI\:\:SETVIEWPORTORGEX=SetViewportOrgEx
+GDI\:\:SETWINDOWEXT=SetWindowExt
+GDI\:\:SETWINDOWEXTEX=SetWindowExtEx
+GDI\:\:SETWINDOWORG=SetWindowOrg
+GDI\:\:SETWINDOWORGEX=SetWindowOrgEx
+GDI\:\:SIZEPQ=SizePQ
+GDI\:\:SPOOLFILE=SpoolFile
+GDI\:\:STARTDOC=StartDoc
+GDI\:\:STARTPAGE=StartPage
+GDI\:\:STARTSPOOLPAGE=StartSpoolPage
+GDI\:\:STRETCHBLT=StretchBlt
+GDI\:\:STRETCHDIBITS=StretchDIBits
+GDI\:\:TEXTOUT=TextOut
+GDI\:\:UNREALIZEOBJECT=UnrealizeObject
+GDI\:\:UPDATECOLORS=UpdateColors
+GDI\:\:WEP=WEP
+GDI\:\:WRITEDIALOG=WriteDialog
+GDI\:\:WRITESPOOL=WriteSpool
+KERNEL\:\:FATALEXIT=FatalExit
+KERNEL\:\:GETVERSION=GetVersion
+KERNEL\:\:LOCALINIT=LocalInit
+KERNEL\:\:LOCALALLOC=LocalAlloc
+KERNEL\:\:LOCALREALLOC=LocalReAlloc
+KERNEL\:\:LOCALFREE=LocalFree
+KERNEL\:\:LOCALLOCK=LocalLock
+KERNEL\:\:LOCALUNLOCK=LocalUnlock
+KERNEL\:\:LOCALSIZE=LocalSize
+KERNEL\:\:LOCALHANDLE=LocalHandle
+KERNEL\:\:LOCALFLAGS=LocalFlags
+KERNEL\:\:LOCALCOMPACT=LocalCompact
+KERNEL\:\:GLOBALALLOC=GlobalAlloc
+KERNEL\:\:GLOBALREALLOC=GlobalReAlloc
+KERNEL\:\:GLOBALFREE=GlobalFree
+KERNEL\:\:GLOBALLOCK=GlobalLock
+KERNEL\:\:GLOBALUNLOCK=GlobalUnlock
+KERNEL\:\:GLOBALSIZE=GlobalSize
+KERNEL\:\:GLOBALHANDLE=GlobalHandle
+KERNEL\:\:GLOBALFLAGS=GlobalFlags
+KERNEL\:\:LOCKSEGMENT=LockSegment
+KERNEL\:\:UNLOCKSEGMENT=UnlockSegment
+KERNEL\:\:GLOBALCOMPACT=GlobalCompact
+KERNEL\:\:YIELD=Yield
+KERNEL\:\:GETCURRENTTASK=GetCurrentTask
+KERNEL\:\:GETCURRENTPDB=GetCurrentPDB
+KERNEL\:\:LOADMODULE=LoadModule
+KERNEL\:\:FREEMODULE=FreeModule
+KERNEL\:\:GETMODULEHANDLE=GetModuleHandle
+KERNEL\:\:GETMODULEUSAGE=GetModuleUsage
+KERNEL\:\:GETMODULEFILENAME=GetModuleFileName
+KERNEL\:\:GETPROCADDRESS=GetProcAddress
+KERNEL\:\:MAKEPROCINSTANCE=MakeProcInstance
+KERNEL\:\:FREEPROCINSTANCE=FreeProcInstance
+KERNEL\:\:GETINSTANCEDATA=GetInstanceData
+KERNEL\:\:CATCH=Catch
+KERNEL\:\:THROW=THROW
+KERNEL\:\:GETPROFILEINT=GetProfileInt
+KERNEL\:\:GETPROFILESTRING=GetProfileString
+KERNEL\:\:WRITEPROFILESTRING=WriteProfileString
+KERNEL\:\:FINDRESOURCE=FindResource
+KERNEL\:\:LOADRESOURCE=LoadResource
+KERNEL\:\:LOCKRESOURCE=LockResource
+KERNEL\:\:FREERESOURCE=FreeResource
+KERNEL\:\:ACCESSRESOURCE=AccessResource
+KERNEL\:\:SIZEOFRESOURCE=SizeofResource
+KERNEL\:\:ALLOCRESOURCE=AllocResource
+KERNEL\:\:SETRESOURCEHANDLER=SetResourceHandler
+KERNEL\:\:INITATOMTABLE=InitAtomTable
+KERNEL\:\:FINDATOM=FindAtom
+KERNEL\:\:ADDATOM=AddAtom
+KERNEL\:\:DELETEATOM=DeleteAtom
+KERNEL\:\:GETATOMNAME=GetAtomName
+KERNEL\:\:GETATOMHANDLE=GetAtomHandle
+KERNEL\:\:OPENFILE=OpenFile
+KERNEL\:\:_LCLOSE=_lclose
+KERNEL\:\:_LREAD=_lread
+KERNEL\:\:_LCREAT=_lcreat
+KERNEL\:\:_LLSEEK=_llseek
+KERNEL\:\:_LOPEN=_lopen
+KERNEL\:\:_LWRITE=_lwrite
+KERNEL\:\:LSTRCPY=lstrcpy
+KERNEL\:\:LSTRCAT=lstrcat
+KERNEL\:\:LSTRLEN=lstrlen
+KERNEL\:\:GETTEMPDRIVE=GetTempDrive
+KERNEL\:\:GETCODEHANDLE=GetCodeHandle
+KERNEL\:\:DEFINEHANDLETABLE=DefineHandleTable
+KERNEL\:\:LOADLIBRARY=LoadLibrary
+KERNEL\:\:FREELIBRARY=FreeLibrary
+KERNEL\:\:GETTEMPFILENAME=GetTempFileName
+KERNEL\:\:VALIDATECODESEGMENTS=ValidateCodeSegments
+KERNEL\:\:GETCODEINFO=GetCodeInfo
+KERNEL\:\:SETSWAPAREASIZE=SetSwapAreaSize
+KERNEL\:\:SETERRORMODE=SetErrorMode
+KERNEL\:\:SWITCHSTACKTO=SwitchStackTo
+KERNEL\:\:SWITCHSTACKBACK=SwitchStackBack
+KERNEL\:\:GLOBALWIRE=GlobalWire
+KERNEL\:\:GLOBALUNWIRE=GlobalUnWire
+KERNEL\:\:OUTPUTDEBUGSTRING=OutputDebugString
+KERNEL\:\:LOCALSHRINK=LocalShrink
+KERNEL\:\:GETPRIVATEPROFILEINT=GetPrivateProfileInt
+KERNEL\:\:GETPRIVATEPROFILESTRING=GetPrivateProfileString
+KERNEL\:\:WRITEPRIVATEPROFILESTRING=WritePrivateProfileString
+KERNEL\:\:GETDOSENVIRONMENT=GetDOSEnvironment
+KERNEL\:\:GETWINFLAGS=GetWinFlags
+KERNEL\:\:GETWINDOWSDIRECTORY=GetWindowsDirectory
+KERNEL\:\:GETSYSTEMDIRECTORY=GetSystemDirectory
+KERNEL\:\:GETDRIVETYPE=GetDriveType
+KERNEL\:\:FATALAPPEXIT=FatalAppExit
+KERNEL\:\:DIRECTEDYIELD=DirectedYield
+KERNEL\:\:GETNUMTASKS=GetNumTasks
+KERNEL\:\:GLOBALNOTIFY=GlobalNotify
+KERNEL\:\:LIMITEMSPAGES=LimitEmsPages
+KERNEL\:\:GLOBALLRUOLDEST=GlobalLRUOldest
+KERNEL\:\:GLOBALLRUNEWEST=GlobalLRUNewest
+KERNEL\:\:WINEXEC=WinExec
+KERNEL\:\:GETFREESPACE=GetFreeSpace
+KERNEL\:\:ALLOCDSTOCSALIAS=AllocDStoCSAlias
+KERNEL\:\:ALLOCSELECTOR=AllocSelector
+KERNEL\:\:FREESELECTOR=FreeSelector
+KERNEL\:\:PRESTOCHANGOSELECTOR=PrestoChangoSelector
+KERNEL\:\:GLOBALDOSALLOC=GlobalDosAlloc
+KERNEL\:\:GLOBALDOSFREE=GlobalDosFree
+KERNEL\:\:GETSELECTORBASE=GetSelectorBase
+KERNEL\:\:SETSELECTORBASE=SetSelectorBase
+KERNEL\:\:GETSELECTORLIMIT=GetSelectorLimit
+KERNEL\:\:SETSELECTORLIMIT=SetSelectorLimit
+KERNEL\:\:GLOBALPAGELOCK=GlobalPageLock
+KERNEL\:\:GLOBALPAGEUNLOCK=GlobalPageUnlock
+KERNEL\:\:GLOBALFIX=GlobalFix
+KERNEL\:\:GLOBALUNFIX=GlobalUnfix
+KERNEL\:\:SETHANDLECOUNT=SetHandleCount
+KERNEL\:\:VALIDATEFREESPACES=ValidateFreeSpaces
+KERNEL\:\:DEBUGBREAK=DebugBreak
+KERNEL\:\:SWAPRECORDING=SwapRecording
+KERNEL\:\:ISDBCSLEADBYTE=IsDBCSLeadByte
+KERNEL\:\:ISTASK=IsTask
+KERNEL\:\:LOGERROR=LOGERROR
+KERNEL\:\:LOGPARAMERROR=LogParamError
+KERNEL\:\:ISBADREADPTR=IsBadReadPtr
+KERNEL\:\:ISBADWRITEPTR=IsBadWritePtr
+KERNEL\:\:ISBADCODEPTR=IsBadCodePtr
+KERNEL\:\:ISBADSTRINGPTR=IsBadStringPtr
+KERNEL\:\:ISBADHUGEREADPTR=IsBadHugeReadPtr
+KERNEL\:\:ISBADHUGEWRITEPTR=IsBadHugeWritePtr
+KERNEL\:\:HMEMCPY=hmemcpy
+KERNEL\:\:_HREAD=_hread
+KERNEL\:\:_HWRITE=_hwrite
+KERNEL\:\:LSTRCPYN=lstrcpyn
+KERNEL\:\:GETWINDEBUGINFO=GetWinDebugInfo
+KERNEL\:\:SETWINDEBUGINFO=SetWinDebugInfo
+KEYBOARD\:\:ENABLE=Enable
+KEYBOARD\:\:DISABLE=disable
+KEYBOARD\:\:TOASCII=toascii
+KEYBOARD\:\:ANSITOOEM=AnsiToOem
+KEYBOARD\:\:OEMTOANSI=OemToAnsi
+KEYBOARD\:\:WEP=WEP
+KEYBOARD\:\:OEMKEYSCAN=OemKeyScan
+KEYBOARD\:\:VKKEYSCAN=VkKeyScan
+KEYBOARD\:\:GETKEYBOARDTYPE=GetKeyboardType
+KEYBOARD\:\:MAPVIRTUALKEY=MapVirtualKey
+KEYBOARD\:\:GETKBCODEPAGE=GetKBCodePage
+KEYBOARD\:\:GETKEYNAMETEXT=GetKeyNameText
+KEYBOARD\:\:ANSITOOEMBUFF=AnsiToOemBuff
+KEYBOARD\:\:OEMTOANSIBUFF=OemToAnsiBuff
+LZEXPAND\:\:LZREAD=LZRead
+LZEXPAND\:\:LZCOPY=LZCopy
+LZEXPAND\:\:LZCLOSE=LZClose
+LZEXPAND\:\:LZINIT=LZInit
+LZEXPAND\:\:GETEXPANDEDNAME=GetExpandedName
+LZEXPAND\:\:LZSEEK=LZSeek
+LZEXPAND\:\:LZOPENFILE=LZOpenFile
+LZEXPAND\:\:COPYLZFILE=CopyLZFile
+LZEXPAND\:\:LZDONE=LZDone
+LZEXPAND\:\:LZSTART=LZStart
+LZEXPAND\:\:WEP=WEP
+MMSYSTEM\:\:WEP=WEP
+MMSYSTEM\:\:SNDPLAYSOUND=sndPlaySound
+MMSYSTEM\:\:MMSYSTEMGETVERSION=mmsystemGetVersion
+MMSYSTEM\:\:DRIVERPROC=DriverProc
+MMSYSTEM\:\:OUTPUTDEBUGSTR=OutputDebugStr
+MMSYSTEM\:\:JOYGETNUMDEVS=joyGetNumDevs
+MMSYSTEM\:\:JOYGETDEVCAPS=joyGetDevCaps
+MMSYSTEM\:\:JOYGETPOS=joyGetPos
+MMSYSTEM\:\:JOYGETTHRESHOLD=joyGetThreshold
+MMSYSTEM\:\:JOYRELEASECAPTURE=joyReleaseCapture
+MMSYSTEM\:\:JOYSETCAPTURE=joySetCapture
+MMSYSTEM\:\:JOYSETTHRESHOLD=joySetThreshold
+MMSYSTEM\:\:JOYSETCALIBRATION=joySetCalibration
+MMSYSTEM\:\:MIDIOUTGETNUMDEVS=midiOutGetNumDevs
+MMSYSTEM\:\:MIDIOUTGETDEVCAPS=midiOutGetDevCaps
+MMSYSTEM\:\:MIDIOUTGETERRORTEXT=midiOutGetErrorText
+MMSYSTEM\:\:MIDIOUTOPEN=midiOutOpen
+MMSYSTEM\:\:MIDIOUTCLOSE=midiOutClose
+MMSYSTEM\:\:MIDIOUTPREPAREHEADER=midiOutPrepareHeader
+MMSYSTEM\:\:MIDIOUTUNPREPAREHEADER=midiOutUnprepareHeader
+MMSYSTEM\:\:MIDIOUTSHORTMSG=midiOutShortMsg
+MMSYSTEM\:\:MIDIOUTLONGMSG=midiOutLongMsg
+MMSYSTEM\:\:MIDIOUTRESET=midiOutReset
+MMSYSTEM\:\:MIDIOUTGETVOLUME=midiOutGetVolume
+MMSYSTEM\:\:MIDIOUTSETVOLUME=midiOutSetVolume
+MMSYSTEM\:\:MIDIOUTCACHEPATCHES=midiOutCachePatches
+MMSYSTEM\:\:MIDIOUTCACHEDRUMPATCHES=midiOutCacheDrumPatches
+MMSYSTEM\:\:MIDIOUTGETID=midiOutGetID
+MMSYSTEM\:\:MIDIOUTMESSAGE=midiOutMessage
+MMSYSTEM\:\:MIDIINGETNUMDEVS=midiInGetNumDevs
+MMSYSTEM\:\:MIDIINGETDEVCAPS=midiInGetDevCaps
+MMSYSTEM\:\:MIDIINGETERRORTEXT=midiInGetErrorText
+MMSYSTEM\:\:MIDIINOPEN=midiInOpen
+MMSYSTEM\:\:MIDIINCLOSE=midiInClose
+MMSYSTEM\:\:MIDIINPREPAREHEADER=midiInPrepareHeader
+MMSYSTEM\:\:MIDIINUNPREPAREHEADER=midiInUnprepareHeader
+MMSYSTEM\:\:MIDIINADDBUFFER=midiInAddBuffer
+MMSYSTEM\:\:MIDIINSTART=midiInStart
+MMSYSTEM\:\:MIDIINSTOP=midiInStop
+MMSYSTEM\:\:MIDIINRESET=midiInReset
+MMSYSTEM\:\:MIDIINGETID=midiInGetID
+MMSYSTEM\:\:MIDIINMESSAGE=midiInMessage
+MMSYSTEM\:\:AUXGETNUMDEVS=auxGetNumDevs
+MMSYSTEM\:\:AUXGETDEVCAPS=auxGetDevCaps
+MMSYSTEM\:\:AUXGETVOLUME=auxGetVolume
+MMSYSTEM\:\:AUXSETVOLUME=auxSetVolume
+MMSYSTEM\:\:AUXOUTMESSAGE=auxOutMessage
+MMSYSTEM\:\:WAVEOUTGETNUMDEVS=waveOutGetNumDevs
+MMSYSTEM\:\:WAVEOUTGETDEVCAPS=waveOutGetDevCaps
+MMSYSTEM\:\:WAVEOUTGETERRORTEXT=waveOutGetErrorText
+MMSYSTEM\:\:WAVEOUTOPEN=waveOutOpen
+MMSYSTEM\:\:WAVEOUTCLOSE=waveOutClose
+MMSYSTEM\:\:WAVEOUTPREPAREHEADER=waveOutPrepareHeader
+MMSYSTEM\:\:WAVEOUTUNPREPAREHEADER=waveOutUnprepareHeader
+MMSYSTEM\:\:WAVEOUTWRITE=waveOutWrite
+MMSYSTEM\:\:WAVEOUTPAUSE=waveOutPause
+MMSYSTEM\:\:WAVEOUTRESTART=waveOutRestart
+MMSYSTEM\:\:WAVEOUTRESET=waveOutReset
+MMSYSTEM\:\:WAVEOUTGETPOSITION=waveOutGetPosition
+MMSYSTEM\:\:WAVEOUTGETPITCH=waveOutGetPitch
+MMSYSTEM\:\:WAVEOUTSETPITCH=waveOutSetPitch
+MMSYSTEM\:\:WAVEOUTGETVOLUME=waveOutGetVolume
+MMSYSTEM\:\:WAVEOUTSETVOLUME=waveOutSetVolume
+MMSYSTEM\:\:WAVEOUTGETPLAYBACKRATE=waveOutGetPlaybackRate
+MMSYSTEM\:\:WAVEOUTSETPLAYBACKRATE=waveOutSetPlaybackRate
+MMSYSTEM\:\:WAVEOUTBREAKLOOP=waveOutBreakLoop
+MMSYSTEM\:\:WAVEOUTGETID=waveOutGetID
+MMSYSTEM\:\:WAVEOUTMESSAGE=waveOutMessage
+MMSYSTEM\:\:WAVEINGETNUMDEVS=waveInGetNumDevs
+MMSYSTEM\:\:WAVEINGETDEVCAPS=waveInGetDevCaps
+MMSYSTEM\:\:WAVEINGETERRORTEXT=waveInGetErrorText
+MMSYSTEM\:\:WAVEINOPEN=waveInOpen
+MMSYSTEM\:\:WAVEINCLOSE=waveInClose
+MMSYSTEM\:\:WAVEINPREPAREHEADER=waveInPrepareHeader
+MMSYSTEM\:\:WAVEINUNPREPAREHEADER=waveInUnprepareHeader
+MMSYSTEM\:\:WAVEINADDBUFFER=waveInAddBuffer
+MMSYSTEM\:\:WAVEINSTART=waveInStart
+MMSYSTEM\:\:WAVEINSTOP=waveInStop
+MMSYSTEM\:\:WAVEINRESET=waveInReset
+MMSYSTEM\:\:WAVEINGETPOSITION=waveInGetPosition
+MMSYSTEM\:\:WAVEINGETID=waveInGetID
+MMSYSTEM\:\:WAVEINMESSAGE=waveInMessage
+MMSYSTEM\:\:TIMEGETSYSTEMTIME=timeGetSystemTime
+MMSYSTEM\:\:TIMESETEVENT=timeSetEvent
+MMSYSTEM\:\:TIMEKILLEVENT=timeKillEvent
+MMSYSTEM\:\:TIMEGETDEVCAPS=timeGetDevCaps
+MMSYSTEM\:\:TIMEBEGINPERIOD=timeBeginPeriod
+MMSYSTEM\:\:TIMEENDPERIOD=timeEndPeriod
+MMSYSTEM\:\:TIMEGETTIME=timeGetTime
+MMSYSTEM\:\:MCISENDCOMMAND=mciSendCommand
+MMSYSTEM\:\:MCISENDSTRING=mciSendString
+MMSYSTEM\:\:MCIGETDEVICEID=mciGetDeviceID
+MMSYSTEM\:\:MCIGETERRORSTRING=mciGetErrorString
+MMSYSTEM\:\:MCIEXECUTE=mciExecute
+MMSYSTEM\:\:MCISETYIELDPROC=mciSetYieldProc
+MMSYSTEM\:\:MCIGETDEVICEIDFROMELEMENTID=mciGetDeviceIDFromElementID
+MMSYSTEM\:\:MCIGETYIELDPROC=mciGetYieldProc
+MMSYSTEM\:\:MCIGETCREATORTASK=mciGetCreatorTask
+MMSYSTEM\:\:DRVOPEN=DrvOpen
+MMSYSTEM\:\:DRVCLOSE=DrvClose
+MMSYSTEM\:\:DRVSENDMESSAGE=DrvSendMessage
+MMSYSTEM\:\:DRVGETMODULEHANDLE=DrvGetModuleHandle
+MMSYSTEM\:\:DRVDEFDRIVERPROC=DrvDefDriverProc
+MMSYSTEM\:\:MMIOOPEN=mmioOpen
+MMSYSTEM\:\:MMIOCLOSE=mmioClose
+MMSYSTEM\:\:MMIOREAD=mmioRead
+MMSYSTEM\:\:MMIOWRITE=mmioWrite
+MMSYSTEM\:\:MMIOSEEK=mmioSeek
+MMSYSTEM\:\:MMIOGETINFO=mmioGetInfo
+MMSYSTEM\:\:MMIOSETINFO=mmioSetInfo
+MMSYSTEM\:\:MMIOSETBUFFER=mmioSetBuffer
+MMSYSTEM\:\:MMIOFLUSH=mmioFlush
+MMSYSTEM\:\:MMIOADVANCE=mmioAdvance
+MMSYSTEM\:\:MMIOSTRINGTOFOURCC=mmioStringToFOURCC
+MMSYSTEM\:\:MMIOINSTALLIOPROC=mmioInstallIOProc
+MMSYSTEM\:\:MMIOSENDMESSAGE=mmioSendMessage
+MMSYSTEM\:\:MMIODESCEND=mmioDescend
+MMSYSTEM\:\:MMIOASCEND=mmioAscend
+MMSYSTEM\:\:MMIOCREATECHUNK=mmioCreateChunk
+MMSYSTEM\:\:MMIORENAME=mmioRename
+SHELL\:\:REGOPENKEY=RegOpenKey
+SHELL\:\:REGCREATEKEY=RegCreateKey
+SHELL\:\:REGCLOSEKEY=RegCloseKey
+SHELL\:\:REGDELETEKEY=RegDeleteKey
+SHELL\:\:REGSETVALUE=RegSetValue
+SHELL\:\:REGQUERYVALUE=RegQueryValue
+SHELL\:\:REGENUMKEY=RegEnumKey
+SHELL\:\:WEP=WEP
+SHELL\:\:DRAGACCEPTFILES=DragAcceptFiles
+SHELL\:\:DRAGQUERYFILE=DragQueryFile
+SHELL\:\:DRAGFINISH=DragFinish
+SHELL\:\:DRAGQUERYPOINT=DragQueryPoint
+SHELL\:\:SHELLEXECUTE=ShellExecute
+SHELL\:\:FINDEXECUTABLE=FindExecutable
+SHELL\:\:SHELLABOUT=ShellAbout
+SHELL\:\:EXTRACTICON=ExtractIcon
+SHELL\:\:EXTRACTASSOCIATEDICON=ExtractAssociatedIcon
+TOOLHELP\:\:WEP=WEP
+TOOLHELP\:\:GLOBALHANDLETOSEL=GlobalHandleToSel
+TOOLHELP\:\:GLOBALFIRST=GlobalFirst
+TOOLHELP\:\:GLOBALNEXT=GlobalNext
+TOOLHELP\:\:GLOBALINFO=GlobalInfo
+TOOLHELP\:\:GLOBALENTRYHANDLE=GlobalEntryHandle
+TOOLHELP\:\:GLOBALENTRYMODULE=GlobalEntryModule
+TOOLHELP\:\:LOCALINFO=LocalInfo
+TOOLHELP\:\:LOCALFIRST=LocalFirst
+TOOLHELP\:\:LOCALNEXT=LocalNext
+TOOLHELP\:\:MODULEFIRST=ModuleFirst
+TOOLHELP\:\:MODULENEXT=ModuleNext
+TOOLHELP\:\:MODULEFINDNAME=ModuleFindName
+TOOLHELP\:\:MODULEFINDHANDLE=ModuleFindHandle
+TOOLHELP\:\:TASKFIRST=TaskFirst
+TOOLHELP\:\:TASKNEXT=TaskNext
+TOOLHELP\:\:TASKFINDHANDLE=TaskFindHandle
+TOOLHELP\:\:STACKTRACEFIRST=StackTraceFirst
+TOOLHELP\:\:STACKTRACECSIPFIRST=StackTraceCSIPFirst
+TOOLHELP\:\:STACKTRACENEXT=StackTraceNext
+TOOLHELP\:\:CLASSFIRST=ClassFirst
+TOOLHELP\:\:CLASSNEXT=ClassNext
+TOOLHELP\:\:SYSTEMHEAPINFO=SystemHeapInfo
+TOOLHELP\:\:MEMMANINFO=MemManInfo
+TOOLHELP\:\:NOTIFYREGISTER=NotifyRegister
+TOOLHELP\:\:NOTIFYUNREGISTER=NotifyUnRegister
+TOOLHELP\:\:INTERRUPTREGISTER=InterruptRegister
+TOOLHELP\:\:INTERRUPTUNREGISTER=InterruptUnRegister
+TOOLHELP\:\:TERMINATEAPP=TerminateApp
+TOOLHELP\:\:MEMORYREAD=MemoryRead
+TOOLHELP\:\:MEMORYWRITE=MemoryWrite
+TOOLHELP\:\:TIMERCOUNT=TimerCount
+TOOLHELP\:\:TASKSETCSIP=TaskSetCSIP
+TOOLHELP\:\:TASKGETCSIP=TaskGetCSIP
+TOOLHELP\:\:TASKSWITCH=TaskSwitch
+USER\:\:MESSAGEBOX=MessageBox
+USER\:\:POSTQUITMESSAGE=PostQuitMessage
+USER\:\:EXITWINDOWS=ExitWindows
+USER\:\:WEP=WEP
+USER\:\:SETTIMER=SetTimer
+USER\:\:KILLTIMER=KillTimer
+USER\:\:GETCURRENTTIME=GetCurrentTime
+USER\:\:GETTIMERRESOLUTION=GetTimerResolution
+USER\:\:GETTICKCOUNT=GetTickCount
+USER\:\:CLIPCURSOR=ClipCursor
+USER\:\:GETCURSORPOS=GetCursorPos
+USER\:\:SETCAPTURE=SetCapture
+USER\:\:RELEASECAPTURE=ReleaseCapture
+USER\:\:SETDOUBLECLICKTIME=SetDoubleClickTime
+USER\:\:GETDOUBLECLICKTIME=GetDoubleClickTime
+USER\:\:SETFOCUS=SetFocus
+USER\:\:GETFOCUS=GetFocus
+USER\:\:REMOVEPROP=RemoveProp
+USER\:\:GETPROP=GetProp
+USER\:\:SETPROP=SetProp
+USER\:\:ENUMPROPS=EnumProps
+USER\:\:CLIENTTOSCREEN=ClientToScreen
+USER\:\:SCREENTOCLIENT=ScreenToClient
+USER\:\:WINDOWFROMPOINT=WindowFromPoint
+USER\:\:ISICONIC=IsIconic
+USER\:\:GETWINDOWRECT=GetWindowRect
+USER\:\:GETCLIENTRECT=GetClientRect
+USER\:\:ENABLEWINDOW=EnableWindow
+USER\:\:ISWINDOWENABLED=IsWindowEnabled
+USER\:\:GETWINDOWTEXT=GetWindowText
+USER\:\:SETWINDOWTEXT=SetWindowText
+USER\:\:GETWINDOWTEXTLENGTH=GetWindowTextLength
+USER\:\:BEGINPAINT=BeginPaint
+USER\:\:ENDPAINT=EndPaint
+USER\:\:CREATEWINDOW=CreateWindow
+USER\:\:SHOWWINDOW=ShowWindow
+USER\:\:CLOSEWINDOW=CloseWindow
+USER\:\:OPENICON=OpenIcon
+USER\:\:BRINGWINDOWTOTOP=BringWindowToTop
+USER\:\:GETPARENT=GetParent
+USER\:\:ISWINDOW=IsWindow
+USER\:\:ISCHILD=IsChild
+USER\:\:ISWINDOWVISIBLE=IsWindowVisible
+USER\:\:FINDWINDOW=FindWindow
+USER\:\:ANYPOPUP=AnyPopup
+USER\:\:DESTROYWINDOW=DestroyWindow
+USER\:\:ENUMWINDOWS=EnumWindows
+USER\:\:ENUMCHILDWINDOWS=EnumChildWindows
+USER\:\:MOVEWINDOW=MoveWindow
+USER\:\:REGISTERCLASS=RegisterClass
+USER\:\:GETCLASSNAME=GetClassName
+USER\:\:SETACTIVEWINDOW=SetActiveWindow
+USER\:\:GETACTIVEWINDOW=GetActiveWindow
+USER\:\:SCROLLWINDOW=ScrollWindow
+USER\:\:SETSCROLLPOS=SetScrollPos
+USER\:\:GETSCROLLPOS=GetScrollPos
+USER\:\:SETSCROLLRANGE=SetScrollRange
+USER\:\:GETSCROLLRANGE=GetScrollRange
+USER\:\:GETDC=GetDC
+USER\:\:GETWINDOWDC=GetWindowDC
+USER\:\:RELEASEDC=ReleaseDC
+USER\:\:SETCURSOR=setcursor
+USER\:\:SETCURSORPOS=SetCursorPos
+USER\:\:SHOWCURSOR=ShowCursor
+USER\:\:SETRECT=SetRect
+USER\:\:SETRECTEMPTY=SetRectEmpty
+USER\:\:COPYRECT=CopyRect
+USER\:\:ISRECTEMPTY=IsRectEmpty
+USER\:\:PTINRECT=PtInRect
+USER\:\:OFFSETRECT=OffsetRect
+USER\:\:INFLATERECT=InflateRect
+USER\:\:INTERSECTRECT=IntersectRect
+USER\:\:UNIONRECT=UnionRect
+USER\:\:FILLRECT=FillRect
+USER\:\:INVERTRECT=InvertRect
+USER\:\:FRAMERECT=FrameRect
+USER\:\:DRAWICON=DrawIcon
+USER\:\:DRAWTEXT=DRAWTEXT
+USER\:\:DIALOGBOX=DialogBox
+USER\:\:ENDDIALOG=EndDialog
+USER\:\:CREATEDIALOG=CreateDialog
+USER\:\:ISDIALOGMESSAGE=IsDialogMessage
+USER\:\:GETDLGITEM=GetDlgItem
+USER\:\:SETDLGITEMTEXT=SetDlgItemText
+USER\:\:GETDLGITEMTEXT=GetDlgItemText
+USER\:\:SETDLGITEMINT=SetDlgItemInt
+USER\:\:GETDLGITEMINT=GetDlgItemInt
+USER\:\:CHECKRADIOBUTTON=CheckRadioButton
+USER\:\:CHECKDLGBUTTON=CheckDlgButton
+USER\:\:ISDLGBUTTONCHECKED=IsDlgButtonChecked
+USER\:\:DLGDIRSELECT=DlgDirSelect
+USER\:\:DLGDIRLIST=DlgDirList
+USER\:\:SENDDLGITEMMESSAGE=SendDlgItemMessage
+USER\:\:ADJUSTWINDOWRECT=AdjustWindowRect
+USER\:\:MAPDIALOGRECT=MapDialogRect
+USER\:\:MESSAGEBEEP=MessageBeep
+USER\:\:FLASHWINDOW=FlashWindow
+USER\:\:GETKEYSTATE=GetKeyState
+USER\:\:DEFWINDOWPROC=DefWindowProc
+USER\:\:GETMESSAGE=GetMessage
+USER\:\:PEEKMESSAGE=PeekMessage
+USER\:\:POSTMESSAGE=PostMessage
+USER\:\:SENDMESSAGE=SendMessage
+USER\:\:WAITMESSAGE=WaitMessage
+USER\:\:TRANSLATEMESSAGE=TranslateMessage
+USER\:\:DISPATCHMESSAGE=DispatchMessage
+USER\:\:REPLYMESSAGE=ReplyMessage
+USER\:\:POSTAPPMESSAGE=PostAppMessage
+USER\:\:REGISTERCLIPBOARDFORMAT=RegisterClipboardFormat
+USER\:\:GETMESSAGEPOS=GetMessagePos
+USER\:\:GETMESSAGETIME=GetMessageTime
+USER\:\:SETWINDOWSHOOK=SetWindowsHook
+USER\:\:CALLWINDOWPROC=CallWindowProc
+USER\:\:CALLMSGFILTER=CallMsgFilter
+USER\:\:UPDATEWINDOW=UpdateWindow
+USER\:\:INVALIDATERECT=InvalidateRect
+USER\:\:INVALIDATERGN=InvalidateRgn
+USER\:\:VALIDATERECT=ValidateRect
+USER\:\:VALIDATERGN=ValidateRgn
+USER\:\:GETCLASSWORD=GetClassWord
+USER\:\:SETCLASSWORD=SetClassWord
+USER\:\:GETCLASSLONG=GetClassLong
+USER\:\:SETCLASSLONG=SetClassLong
+USER\:\:GETWINDOWWORD=GetWindowWord
+USER\:\:SETWINDOWWORD=SetWindowWord
+USER\:\:GETWINDOWLONG=GetWindowLong
+USER\:\:SETWINDOWLONG=SetWindowLong
+USER\:\:OPENCLIPBOARD=OpenClipboard
+USER\:\:CLOSECLIPBOARD=CloseClipboard
+USER\:\:EMPTYCLIPBOARD=EmptyClipboard
+USER\:\:GETCLIPBOARDOWNER=GetClipboardOwner
+USER\:\:SETCLIPBOARDDATA=SetClipboardData
+USER\:\:GETCLIPBOARDDATA=GetClipboardData
+USER\:\:COUNTCLIPBOARDFORMATS=CountClipboardFormats
+USER\:\:ENUMCLIPBOARDFORMATS=EnumClipboardFormats
+USER\:\:REGISTERWINDOWMESSAGE=RegisterWindowMessage
+USER\:\:GETCLIPBOARDFORMATNAME=GetClipboardFormatName
+USER\:\:SETCLIPBOARDVIEWER=SetClipboardViewer
+USER\:\:GETCLIPBOARDVIEWER=GetClipboardViewer
+USER\:\:CHANGECLIPBOARDCHAIN=ChangeClipboardChain
+USER\:\:LOADMENU=LoadMenu
+USER\:\:CREATEMENU=CreateMenu
+USER\:\:DESTROYMENU=DestroyMenu
+USER\:\:CHANGEMENU=ChangeMenu
+USER\:\:CHECKMENUITEM=CheckMenuItem
+USER\:\:ENABLEMENUITEM=EnableMenuItem
+USER\:\:GETSYSTEMMENU=GetSystemMenu
+USER\:\:GETMENU=GetMenu
+USER\:\:SETMENU=SetMenu
+USER\:\:GETSUBMENU=GetSubMenu
+USER\:\:DRAWMENUBAR=DrawMenuBar
+USER\:\:GETMENUSTRING=GetMenuString
+USER\:\:HILITEMENUITEM=HiliteMenuItem
+USER\:\:CREATECARET=CreateCaret
+USER\:\:DESTROYCARET=DestroyCaret
+USER\:\:SETCARETPOS=SetCaretPos
+USER\:\:HIDECARET=HideCaret
+USER\:\:SHOWCARET=ShowCaret
+USER\:\:SETCARETBLINKTIME=SetCaretBlinkTime
+USER\:\:GETCARETBLINKTIME=GetCaretBlinkTime
+USER\:\:ARRANGEICONICWINDOWS=ArrangeIconicWindows
+USER\:\:WINHELP=WinHelp
+USER\:\:LOADCURSOR=LoadCursor
+USER\:\:LOADICON=LoadIcon
+USER\:\:LOADBITMAP=LoadBitmap
+USER\:\:LOADSTRING=LoadString
+USER\:\:LOADACCELERATORS=LoadAccelerators
+USER\:\:TRANSLATEACCELERATOR=TranslateAccelerator
+USER\:\:GETSYSTEMMETRICS=GetSystemMetrics
+USER\:\:GETSYSCOLOR=GetSysColor
+USER\:\:SETSYSCOLORS=SetSysColors
+USER\:\:GETCARETPOS=GetCaretPos
+USER\:\:QUERYSENDMESSAGE=QuerySendMessage
+USER\:\:GRAYSTRING=GRAYSTRING
+USER\:\:SWAPMOUSEBUTTON=SwapMouseButton
+USER\:\:SETSYSMODALWINDOW=SetSysModalWindow
+USER\:\:GETSYSMODALWINDOW=GetSysModalWindow
+USER\:\:GETUPDATERECT=GetUpdateRect
+USER\:\:CHILDWINDOWFROMPOINT=ChildWindowFromPoint
+USER\:\:INSENDMESSAGE=InSendMessage
+USER\:\:ISCLIPBOARDFORMATAVAILABLE=IsClipboardFormatAvailable
+USER\:\:DLGDIRSELECTCOMBOBOX=DlgDirSelectComboBox
+USER\:\:DLGDIRLISTCOMBOBOX=DlgDirListComboBox
+USER\:\:TABBEDTEXTOUT=TabbedTextOut
+USER\:\:GETTABBEDTEXTEXTENT=GetTabbedTextExtent
+USER\:\:OPENCOMM=OpenComm
+USER\:\:SETCOMMSTATE=SetCommState
+USER\:\:GETCOMMSTATE=GetCommState
+USER\:\:GETCOMMERROR=GetCommError
+USER\:\:READCOMM=ReadComm
+USER\:\:WRITECOMM=WriteComm
+USER\:\:TRANSMITCOMMCHAR=TransmitCommChar
+USER\:\:CLOSECOMM=CloseComm
+USER\:\:SETCOMMEVENTMASK=SetCommEventMask
+USER\:\:GETCOMMEVENTMASK=GetCommEventMask
+USER\:\:SETCOMMBREAK=SetCommBreak
+USER\:\:CLEARCOMMBREAK=ClearCommBreak
+USER\:\:UNGETCOMMCHAR=UngetCommChar
+USER\:\:BUILDCOMMDCB=BuildCommDCB
+USER\:\:ESCAPECOMMFUNCTION=EscapeCommFunction
+USER\:\:FLUSHCOMM=FlushComm
+USER\:\:DIALOGBOXINDIRECT=DialogBoxIndirect
+USER\:\:CREATEDIALOGINDIRECT=CreateDialogIndirect
+USER\:\:LOADMENUINDIRECT=LoadMenuIndirect
+USER\:\:SCROLLDC=ScrollDC
+USER\:\:GETKEYBOARDSTATE=GetKeyboardState
+USER\:\:SETKEYBOARDSTATE=SetKeyboardState
+USER\:\:GETWINDOWTASK=GetWindowTask
+USER\:\:ENUMTASKWINDOWS=EnumTaskWindows
+USER\:\:LOCKINPUT=LockInput
+USER\:\:GETNEXTDLGGROUPITEM=GetNextDlgGroupItem
+USER\:\:GETNEXTDLGTABITEM=GetNextDlgTabItem
+USER\:\:GETTOPWINDOW=GetTopWindow
+USER\:\:GETNEXTWINDOW=GetNextWindow
+USER\:\:GETSYSTEMDEBUGSTATE=GetSystemDebugState
+USER\:\:SETWINDOWPOS=SetWindowPos
+USER\:\:SETPARENT=SetParent
+USER\:\:UNHOOKWINDOWSHOOK=UnhookWindowsHook
+USER\:\:DEFHOOKPROC=DefHookProc
+USER\:\:GETCAPTURE=GetCapture
+USER\:\:GETUPDATERGN=GetUpdateRgn
+USER\:\:EXCLUDEUPDATERGN=ExcludeUpdateRgn
+USER\:\:DIALOGBOXPARAM=DialogBoxParam
+USER\:\:DIALOGBOXINDIRECTPARAM=DialogBoxIndirectParam
+USER\:\:CREATEDIALOGPARAM=CreateDialogParam
+USER\:\:CREATEDIALOGINDIRECTPARAM=CreateDialogIndirectParam
+USER\:\:GETDIALOGBASEUNITS=GetDialogBaseUnits
+USER\:\:EQUALRECT=EqualRect
+USER\:\:ENABLECOMMNOTIFICATION=EnableCommNotification
+USER\:\:EXITWINDOWSEXEC=ExitWindowsExec
+USER\:\:GETCURSOR=GetCursor
+USER\:\:GETOPENCLIPBOARDWINDOW=GetOpenClipboardWindow
+USER\:\:GETASYNCKEYSTATE=GetAsyncKeyState
+USER\:\:GETMENUSTATE=GetMenuState
+USER\:\:SENDDRIVERMESSAGE=SendDriverMessage
+USER\:\:OPENDRIVER=OpenDriver
+USER\:\:CLOSEDRIVER=CloseDriver
+USER\:\:GETDRIVERMODULEHANDLE=GetDriverModuleHandle
+USER\:\:DEFDRIVERPROC=DefDriverProc
+USER\:\:GETDRIVERINFO=GetDriverInfo
+USER\:\:GETNEXTDRIVER=GetNextDriver
+USER\:\:MAPWINDOWPOINTS=MapWindowPoints
+USER\:\:BEGINDEFERWINDOWPOS=BeginDeferWindowPos
+USER\:\:DEFERWINDOWPOS=DeferWindowPos
+USER\:\:ENDDEFERWINDOWPOS=EndDeferWindowPos
+USER\:\:GETWINDOW=GetWindow
+USER\:\:GETMENUITEMCOUNT=GetMenuItemCount
+USER\:\:GETMENUITEMID=GetMenuItemID
+USER\:\:SHOWOWNEDPOPUPS=ShowOwnedPopups
+USER\:\:SETMESSAGEQUEUE=SetMessageQueue
+USER\:\:SHOWSCROLLBAR=ShowScrollBar
+USER\:\:GLOBALADDATOM=GlobalAddAtom
+USER\:\:GLOBALDELETEATOM=GlobalDeleteAtom
+USER\:\:GLOBALFINDATOM=GlobalFindAtom
+USER\:\:GLOBALGETATOMNAME=GlobalGetAtomName
+USER\:\:ISZOOMED=IsZoomed
+USER\:\:GETDLGCTRLID=GetDlgCtrlID
+USER\:\:GETDESKTOPHWND=GetDesktopHWND
+USER\:\:GETDESKTOPWINDOW=GetDesktopWindow
+USER\:\:SELECTPALETTE=SelectPalette
+USER\:\:REALIZEPALETTE=RealizePalette
+USER\:\:GETFREESYSTEMRESOURCES=GetFreeSystemResources
+USER\:\:GETLASTACTIVEPOPUP=GetLastActivePopup
+USER\:\:GETMESSAGEEXTRAINFO=GetMessageExtraInfo
+USER\:\:REDRAWWINDOW=RedrawWindow
+USER\:\:SETWINDOWSHOOKEX=SetWindowsHookEx
+USER\:\:UNHOOKWINDOWSHOOKEX=UnhookWindowsHookEx
+USER\:\:CALLNEXTHOOKEX=CallNextHookEx
+USER\:\:LOCKWINDOWUPDATE=LockWindowUpdate
+USER\:\:DEFDLGPROC=DefDlgProc
+USER\:\:GETCLIPCURSOR=GetClipCursor
+USER\:\:SCROLLWINDOWEX=ScrollWindowEx
+USER\:\:ENABLEHARDWAREINPUT=EnableHardwareInput
+USER\:\:GETQUEUESTATUS=GetQueueStatus
+USER\:\:GETINPUTSTATE=GetInputState
+USER\:\:ISMENU=IsMenu
+USER\:\:GETDCEX=GetDCEx
+USER\:\:COPYICON=CopyIcon
+USER\:\:COPYCURSOR=CopyCursor
+USER\:\:GETWINDOWPLACEMENT=GetWindowPlacement
+USER\:\:SETWINDOWPLACEMENT=SetWindowPlacement
+USER\:\:SUBTRACTRECT=SubtractRect
+USER\:\:GETPRIORITYCLIPBOARDFORMAT=GetPriorityClipboardFormat
+USER\:\:UNREGISTERCLASS=UnregisterClass
+USER\:\:GETCLASSINFO=GetClassInfo
+USER\:\:CREATECURSOR=CreateCursor
+USER\:\:CREATEICON=CreateIcon
+USER\:\:INSERTMENU=InsertMenu
+USER\:\:APPENDMENU=AppendMenu
+USER\:\:REMOVEMENU=RemoveMenu
+USER\:\:DELETEMENU=DeleteMenu
+USER\:\:MODIFYMENU=ModifyMenu
+USER\:\:CREATEPOPUPMENU=CreatePopupMenu
+USER\:\:TRACKPOPUPMENU=TrackPopupMenu
+USER\:\:GETMENUCHECKMARKDIMENSIONS=GetMenuCheckMarkDimensions
+USER\:\:SETMENUITEMBITMAPS=SetMenuItemBitmaps
+USER\:\:WVSPRINTF=wvsprintf
+USER\:\:DLGDIRSELECTEX=DlgDirSelectEx
+USER\:\:DLGDIRSELECTCOMBOBOXEX=DlgDirSelectComboBoxEx
+USER\:\:LSTRCMP=lstrcmp
+USER\:\:ANSIUPPER=AnsiUpper
+USER\:\:ANSILOWER=AnsiLower
+USER\:\:ISCHARALPHA=IsCharAlpha
+USER\:\:ISCHARALPHANUMERIC=IsCharAlphaNumeric
+USER\:\:ISCHARUPPER=IsCharUpper
+USER\:\:ISCHARLOWER=IsCharLower
+USER\:\:ANSIUPPERBUFF=AnsiUpperBuff
+USER\:\:ANSILOWERBUFF=AnsiLowerBuff
+USER\:\:DEFFRAMEPROC=DefFrameProc
+USER\:\:DEFMDICHILDPROC=DefMDIChildProc
+USER\:\:TRANSLATEMDISYSACCEL=TranslateMDISysAccel
+USER\:\:CREATEWINDOWEX=CreateWindowEx
+USER\:\:ADJUSTWINDOWRECTEX=AdjustWindowRectEx
+USER\:\:DESTROYICON=DestroyIcon
+USER\:\:DESTROYCURSOR=DestroyCursor
+USER\:\:DRAWFOCUSRECT=DrawFocusRect
+USER\:\:LSTRCMPI=lstrcmpi
+USER\:\:ANSINEXT=AnsiNext
+USER\:\:ANSIPREV=AnsiPrev
+USER\:\:ENABLESCROLLBAR=EnableScrollBar
+USER\:\:SYSTEMPARAMETERSINFO=SystemParametersInfo
+USER\:\:WNETGETCONNECTION=WNetGetConnection
+USER\:\:WNETADDCONNECTION=WNetAddConnection
+USER\:\:WNETCANCELCONNECTION=WNetCancelConnection
+USER\:\:WNETDISCONNECTDIALOG=WNetDisconnectDialog
+USER\:\:WNETCONNECTIONDIALOG=WNetConnectionDialog
+VER\:\:WEP=WEP
+VER\:\:GETFILERESOURCESIZE=GetFileResourceSize
+VER\:\:GETFILERESOURCE=GetFileResource
+VER\:\:GETFILEVERSIONINFOSIZE=GetFileVersionInfoSize
+VER\:\:GETFILEVERSIONINFO=GetFileVersionInfo
+VER\:\:VERFINDFILE=VerFindFile
+VER\:\:VERINSTALLFILE=VerInstallFile
+VER\:\:VERLANGUAGENAME=VerLanguageName
+VER\:\:VERQUERYVALUE=VerQueryValue
+
+
+COMMDLG\:\:Ordinal_15=ChooseFont
+COMMDLG\:\:Ordinal_26=CommDlgExtendedError
+COMMDLG\:\:Ordinal_2=GetSaveFileName
+COMMDLG\:\:Ordinal_5=ChooseColor
+COMMDLG\:\:Ordinal_1=GetOpenFileName
+COMMDLG\:\:Ordinal_12=ReplaceText
+COMMDLG\:\:Ordinal_20=PrintDlg
+COMMDLG\:\:Ordinal_27=GetFileTitle
+COMMDLG\:\:Ordinal_11=FindText
+COMMDLG\:\:Ordinal_28=WEP
+GDI\:\:Ordinal_382=AbortDoc
+GDI\:\:Ordinal_119=AddFontResource
+GDI\:\:Ordinal_367=AnimatePalette
+GDI\:\:Ordinal_23=Arc
+GDI\:\:Ordinal_34=BitBlt
+GDI\:\:Ordinal_348=Chord
+GDI\:\:Ordinal_243=CloseJob
+GDI\:\:Ordinal_126=CloseMetaFile
+GDI\:\:Ordinal_47=CombineRgn
+GDI\:\:Ordinal_250=Copy
+GDI\:\:Ordinal_151=CopyMetaFile
+GDI\:\:Ordinal_48=CreateBitmap
+GDI\:\:Ordinal_49=CreateBitmapIndirect
+GDI\:\:Ordinal_50=CreateBrushIndirect
+GDI\:\:Ordinal_51=CreateCompatibleBitmap
+GDI\:\:Ordinal_52=CreateCompatibleDC
+GDI\:\:Ordinal_53=CreateDC
+GDI\:\:Ordinal_442=CreateDIBitmap
+GDI\:\:Ordinal_445=CreateDIBPatternBrush
+GDI\:\:Ordinal_156=CreateDiscardableBitmap
+GDI\:\:Ordinal_54=CreateEllipticRgn
+GDI\:\:Ordinal_55=CreateEllipticRgnIndirect
+GDI\:\:Ordinal_56=CreateFont
+GDI\:\:Ordinal_57=CreateFontIndirect
+GDI\:\:Ordinal_58=CreateHatchBrush
+GDI\:\:Ordinal_153=CreateIC
+GDI\:\:Ordinal_125=CreateMetaFile
+GDI\:\:Ordinal_360=CreatePalette
+GDI\:\:Ordinal_60=CreatePatternBrush
+GDI\:\:Ordinal_61=CreatePen
+GDI\:\:Ordinal_62=CreatePenIndirect
+GDI\:\:Ordinal_63=CreatePolygonRgn
+GDI\:\:Ordinal_451=CreatePolyPolygonRgn
+GDI\:\:Ordinal_230=CreatePQ
+GDI\:\:Ordinal_64=CreateRectRgn
+GDI\:\:Ordinal_65=CreateRectRgnIndirect
+GDI\:\:Ordinal_444=CreateRoundRectRgn
+GDI\:\:Ordinal_310=CreateScalableFontResource
+GDI\:\:Ordinal_66=CreateSolidBrush
+GDI\:\:Ordinal_68=DeleteDC
+GDI\:\:Ordinal_244=DeleteJob
+GDI\:\:Ordinal_127=DeleteMetaFile
+GDI\:\:Ordinal_69=DeleteObject
+GDI\:\:Ordinal_235=DeletePQ
+GDI\:\:Ordinal_253=DeleteSpoolPage
+GDI\:\:Ordinal_67=DPtoLP
+GDI\:\:Ordinal_24=Ellipse
+GDI\:\:Ordinal_378=EndDoc
+GDI\:\:Ordinal_380=EndPage
+GDI\:\:Ordinal_247=EndSpoolPage
+GDI\:\:Ordinal_330=EnumFontFamilies
+GDI\:\:Ordinal_70=EnumFonts
+GDI\:\:Ordinal_175=EnumMetaFile
+GDI\:\:Ordinal_71=EnumObjects
+GDI\:\:Ordinal_72=EqualRgn
+GDI\:\:Ordinal_38=Escape
+GDI\:\:Ordinal_21=ExcludeClipRect
+GDI\:\:Ordinal_372=ExtFloodFill
+GDI\:\:Ordinal_232=ExtractPQ
+GDI\:\:Ordinal_351=ExtTextOut
+GDI\:\:Ordinal_40=FillRgn
+GDI\:\:Ordinal_25=FloodFill
+GDI\:\:Ordinal_41=FrameRgn
+GDI\:\:Ordinal_353=GetAspectRatioFilter
+GDI\:\:Ordinal_486=GetAspectRatioFilterEx
+GDI\:\:Ordinal_74=GetBitmapBits
+GDI\:\:Ordinal_162=GetBitmapDimension
+GDI\:\:Ordinal_468=GetBitmapDimensionEx
+GDI\:\:Ordinal_75=GetBkColor
+GDI\:\:Ordinal_76=GetBkMode
+GDI\:\:Ordinal_194=GetBoundsRect
+GDI\:\:Ordinal_149=GetBrushOrg
+GDI\:\:Ordinal_469=GetBrushOrgEx
+GDI\:\:Ordinal_307=GetCharABCWidths
+GDI\:\:Ordinal_350=GetCharWidth
+GDI\:\:Ordinal_77=GetClipBox
+GDI\:\:Ordinal_173=GetClipRgn
+GDI\:\:Ordinal_78=GetCurrentPosition
+GDI\:\:Ordinal_470=GetCurrentPositionEx
+GDI\:\:Ordinal_79=GetDCOrg
+GDI\:\:Ordinal_80=GetDeviceCaps
+GDI\:\:Ordinal_441=GetDIBits
+GDI\:\:Ordinal_133=GetEnvironment
+GDI\:\:Ordinal_311=GetFontData
+GDI\:\:Ordinal_309=GetGlyphOutline
+GDI\:\:Ordinal_332=GetKerningPairs
+GDI\:\:Ordinal_81=GetMapMode
+GDI\:\:Ordinal_124=GetMetaFile
+GDI\:\:Ordinal_159=GetMetaFileBits
+GDI\:\:Ordinal_154=GetNearestColor
+GDI\:\:Ordinal_370=GetNearestPaletteIndex
+GDI\:\:Ordinal_82=GetObject
+GDI\:\:Ordinal_308=GetOutlineTextMetrics
+GDI\:\:Ordinal_363=GetPaletteEntries
+GDI\:\:Ordinal_83=GetPixel
+GDI\:\:Ordinal_84=GetPolyFillMode
+GDI\:\:Ordinal_313=GetRasterizerCaps
+GDI\:\:Ordinal_134=GetRgnBox
+GDI\:\:Ordinal_85=GetROP2
+GDI\:\:Ordinal_87=GetStockObject
+GDI\:\:Ordinal_88=GetStretchBltMode
+GDI\:\:Ordinal_375=GetSystemPaletteEntries
+GDI\:\:Ordinal_374=GetSystemPaletteUse
+GDI\:\:Ordinal_345=GetTextAlign
+GDI\:\:Ordinal_89=GetTextCharacterExtra
+GDI\:\:Ordinal_90=GetTextColor
+GDI\:\:Ordinal_91=GetTextExtent
+GDI\:\:Ordinal_471=GetTextExtentPoint
+GDI\:\:Ordinal_92=GetTextFace
+GDI\:\:Ordinal_93=GetTextMetrics
+GDI\:\:Ordinal_94=GetViewportExt
+GDI\:\:Ordinal_472=GetViewportExtEx
+GDI\:\:Ordinal_95=GetViewportOrg
+GDI\:\:Ordinal_473=GetViewportOrgEx
+GDI\:\:Ordinal_96=GetWindowExt
+GDI\:\:Ordinal_474=GetWindowExtEx
+GDI\:\:Ordinal_97=GetWindowOrg
+GDI\:\:Ordinal_475=GetWindowOrgEx
+GDI\:\:Ordinal_233=InsertPQ
+GDI\:\:Ordinal_22=IntersectClipRect
+GDI\:\:Ordinal_42=InvertRgn
+GDI\:\:Ordinal_462=IsGDIObject
+GDI\:\:Ordinal_100=LineDDA
+GDI\:\:Ordinal_19=LineTo
+GDI\:\:Ordinal_99=LPtoDP
+GDI\:\:Ordinal_231=MinPQ
+GDI\:\:Ordinal_20=MoveTo
+GDI\:\:Ordinal_483=MoveToEx
+GDI\:\:Ordinal_128=MulDiv
+GDI\:\:Ordinal_32=OffsetClipRgn
+GDI\:\:Ordinal_101=OffsetRgn
+GDI\:\:Ordinal_17=OffsetViewportOrg
+GDI\:\:Ordinal_476=OffsetViewportOrgEx
+GDI\:\:Ordinal_15=OffsetWindowOrg
+GDI\:\:Ordinal_477=OffsetWindowOrgEx
+GDI\:\:Ordinal_240=OpenJob
+GDI\:\:Ordinal_43=PaintRgn
+GDI\:\:Ordinal_29=PatBlt
+GDI\:\:Ordinal_26=Pie
+GDI\:\:Ordinal_123=PlayMetaFile
+GDI\:\:Ordinal_176=PlayMetaFileRecord
+GDI\:\:Ordinal_36=Polygon
+GDI\:\:Ordinal_37=Polyline
+GDI\:\:Ordinal_450=PolyPolygon
+GDI\:\:Ordinal_161=PtInRegion
+GDI\:\:Ordinal_103=PtVisible
+GDI\:\:Ordinal_155=QueryAbort
+GDI\:\:Ordinal_27=Rectangle
+GDI\:\:Ordinal_181=RectInRegion
+GDI\:\:Ordinal_104=RectVisible
+GDI\:\:Ordinal_136=RemoveFontResource
+GDI\:\:Ordinal_376=ResetDC
+GDI\:\:Ordinal_368=ResizePalette
+GDI\:\:Ordinal_39=RestoreDC
+GDI\:\:Ordinal_28=RoundRect
+GDI\:\:Ordinal_30=SaveDC
+GDI\:\:Ordinal_18=ScaleViewportExt
+GDI\:\:Ordinal_484=ScaleViewportExtEx
+GDI\:\:Ordinal_16=ScaleWindowExt
+GDI\:\:Ordinal_485=ScaleWindowExtEx
+GDI\:\:Ordinal_195=SelectBitmap
+GDI\:\:Ordinal_44=SelectClipRgn
+GDI\:\:Ordinal_45=SelectObject
+GDI\:\:Ordinal_381=SetAbortProc
+GDI\:\:Ordinal_106=SetBitmapBits
+GDI\:\:Ordinal_163=SetBitmapDimension
+GDI\:\:Ordinal_478=SetBitmapDimensionEx
+GDI\:\:Ordinal_1=SetBkColor
+GDI\:\:Ordinal_2=SetBkMode
+GDI\:\:Ordinal_193=SetBoundsRect
+GDI\:\:Ordinal_148=SetBrushOrg
+GDI\:\:Ordinal_440=SetDIBits
+GDI\:\:Ordinal_443=SetDIBitsToDevice
+GDI\:\:Ordinal_132=SetEnvironment
+GDI\:\:Ordinal_3=SetMapMode
+GDI\:\:Ordinal_349=SetMapperFlags
+GDI\:\:Ordinal_160=SetMetaFileBits
+GDI\:\:Ordinal_196=SetMetaFileBitsBetter
+GDI\:\:Ordinal_364=SetPaletteEntries
+GDI\:\:Ordinal_31=SetPixel
+GDI\:\:Ordinal_6=SetPolyFillMode
+GDI\:\:Ordinal_172=SetRectRgn
+GDI\:\:Ordinal_4=SetROP2
+GDI\:\:Ordinal_7=SetStretchBltMode
+GDI\:\:Ordinal_373=SetSystemPaletteUse
+GDI\:\:Ordinal_346=SetTextAlign
+GDI\:\:Ordinal_8=SetTextCharacterExtra
+GDI\:\:Ordinal_9=SetTextColor
+GDI\:\:Ordinal_10=SetTextJustification
+GDI\:\:Ordinal_14=SetViewportExt
+GDI\:\:Ordinal_479=SetViewportExtEx
+GDI\:\:Ordinal_13=SetViewportOrg
+GDI\:\:Ordinal_480=SetViewportOrgEx
+GDI\:\:Ordinal_12=SetWindowExt
+GDI\:\:Ordinal_481=SetWindowExtEx
+GDI\:\:Ordinal_11=SetWindowOrg
+GDI\:\:Ordinal_482=SetWindowOrgEx
+GDI\:\:Ordinal_234=SizePQ
+GDI\:\:Ordinal_254=SpoolFile
+GDI\:\:Ordinal_377=StartDoc
+GDI\:\:Ordinal_379=StartPage
+GDI\:\:Ordinal_246=StartSpoolPage
+GDI\:\:Ordinal_35=StretchBlt
+GDI\:\:Ordinal_439=StretchDIBits
+GDI\:\:Ordinal_33=TextOut
+GDI\:\:Ordinal_150=UnrealizeObject
+GDI\:\:Ordinal_366=UpdateColors
+GDI\:\:Ordinal_59=WEP
+GDI\:\:Ordinal_242=WriteDialog
+GDI\:\:Ordinal_241=WriteSpool
+KERNEL\:\:Ordinal_1=FatalExit
+KERNEL\:\:Ordinal_3=GetVersion
+KERNEL\:\:Ordinal_4=LocalInit
+KERNEL\:\:Ordinal_5=LocalAlloc
+KERNEL\:\:Ordinal_6=LocalReAlloc
+KERNEL\:\:Ordinal_7=LocalFree
+KERNEL\:\:Ordinal_8=LocalLock
+KERNEL\:\:Ordinal_9=LocalUnlock
+KERNEL\:\:Ordinal_10=LocalSize
+KERNEL\:\:Ordinal_11=LocalHandle
+KERNEL\:\:Ordinal_12=LocalFlags
+KERNEL\:\:Ordinal_13=LocalCompact
+KERNEL\:\:Ordinal_15=GlobalAlloc
+KERNEL\:\:Ordinal_16=GlobalReAlloc
+KERNEL\:\:Ordinal_17=GlobalFree
+KERNEL\:\:Ordinal_18=GlobalLock
+KERNEL\:\:Ordinal_19=GlobalUnlock
+KERNEL\:\:Ordinal_20=GlobalSize
+KERNEL\:\:Ordinal_21=GlobalHandle
+KERNEL\:\:Ordinal_22=GlobalFlags
+KERNEL\:\:Ordinal_23=LockSegment
+KERNEL\:\:Ordinal_24=UnlockSegment
+KERNEL\:\:Ordinal_25=GlobalCompact
+KERNEL\:\:Ordinal_29=Yield
+KERNEL\:\:Ordinal_36=GetCurrentTask
+KERNEL\:\:Ordinal_37=GetCurrentPDB
+KERNEL\:\:Ordinal_45=LoadModule
+KERNEL\:\:Ordinal_46=FreeModule
+KERNEL\:\:Ordinal_47=GetModuleHandle
+KERNEL\:\:Ordinal_48=GetModuleUsage
+KERNEL\:\:Ordinal_49=GetModuleFileName
+KERNEL\:\:Ordinal_50=GetProcAddress
+KERNEL\:\:Ordinal_51=MakeProcInstance
+KERNEL\:\:Ordinal_52=FreeProcInstance
+KERNEL\:\:Ordinal_54=GetInstanceData
+KERNEL\:\:Ordinal_55=Catch
+KERNEL\:\:Ordinal_56=THROW
+KERNEL\:\:Ordinal_57=GetProfileInt
+KERNEL\:\:Ordinal_58=GetProfileString
+KERNEL\:\:Ordinal_59=WriteProfileString
+KERNEL\:\:Ordinal_60=FindResource
+KERNEL\:\:Ordinal_61=LoadResource
+KERNEL\:\:Ordinal_62=LockResource
+KERNEL\:\:Ordinal_63=FreeResource
+KERNEL\:\:Ordinal_64=AccessResource
+KERNEL\:\:Ordinal_65=SizeofResource
+KERNEL\:\:Ordinal_66=AllocResource
+KERNEL\:\:Ordinal_67=SetResourceHandler
+KERNEL\:\:Ordinal_68=InitAtomTable
+KERNEL\:\:Ordinal_69=FindAtom
+KERNEL\:\:Ordinal_70=AddAtom
+KERNEL\:\:Ordinal_71=DeleteAtom
+KERNEL\:\:Ordinal_72=GetAtomName
+KERNEL\:\:Ordinal_73=GetAtomHandle
+KERNEL\:\:Ordinal_74=OpenFile
+KERNEL\:\:Ordinal_81=_lclose
+KERNEL\:\:Ordinal_82=_lread
+KERNEL\:\:Ordinal_83=_lcreat
+KERNEL\:\:Ordinal_84=_llseek
+KERNEL\:\:Ordinal_85=_lopen
+KERNEL\:\:Ordinal_86=_lwrite
+KERNEL\:\:Ordinal_88=lstrcpy
+KERNEL\:\:Ordinal_89=lstrcat
+KERNEL\:\:Ordinal_90=lstrlen
+KERNEL\:\:Ordinal_92=GetTempDrive
+KERNEL\:\:Ordinal_93=GetCodeHandle
+KERNEL\:\:Ordinal_94=DefineHandleTable
+KERNEL\:\:Ordinal_95=LoadLibrary
+KERNEL\:\:Ordinal_96=FreeLibrary
+KERNEL\:\:Ordinal_97=GetTempFileName
+KERNEL\:\:Ordinal_100=ValidateCodeSegments
+KERNEL\:\:Ordinal_104=GetCodeInfo
+KERNEL\:\:Ordinal_106=SetSwapAreaSize
+KERNEL\:\:Ordinal_107=SetErrorMode
+KERNEL\:\:Ordinal_108=SwitchStackTo
+KERNEL\:\:Ordinal_109=SwitchStackBack
+KERNEL\:\:Ordinal_111=GlobalWire
+KERNEL\:\:Ordinal_112=GlobalUnWire
+KERNEL\:\:Ordinal_115=OutputDebugString
+KERNEL\:\:Ordinal_121=LocalShrink
+KERNEL\:\:Ordinal_127=GetPrivateProfileInt
+KERNEL\:\:Ordinal_128=GetPrivateProfileString
+KERNEL\:\:Ordinal_129=WritePrivateProfileString
+KERNEL\:\:Ordinal_131=GetDOSEnvironment
+KERNEL\:\:Ordinal_132=GetWinFlags
+KERNEL\:\:Ordinal_134=GetWindowsDirectory
+KERNEL\:\:Ordinal_135=GetSystemDirectory
+KERNEL\:\:Ordinal_136=GetDriveType
+KERNEL\:\:Ordinal_137=FatalAppExit
+KERNEL\:\:Ordinal_150=DirectedYield
+KERNEL\:\:Ordinal_152=GetNumTasks
+KERNEL\:\:Ordinal_154=GlobalNotify
+KERNEL\:\:Ordinal_156=LimitEmsPages
+KERNEL\:\:Ordinal_163=GlobalLRUOldest
+KERNEL\:\:Ordinal_164=GlobalLRUNewest
+KERNEL\:\:Ordinal_166=WinExec
+KERNEL\:\:Ordinal_169=GetFreeSpace
+KERNEL\:\:Ordinal_171=AllocDStoCSAlias
+KERNEL\:\:Ordinal_175=AllocSelector
+KERNEL\:\:Ordinal_176=FreeSelector
+KERNEL\:\:Ordinal_177=PrestoChangoSelector
+KERNEL\:\:Ordinal_184=GlobalDosAlloc
+KERNEL\:\:Ordinal_185=GlobalDosFree
+KERNEL\:\:Ordinal_186=GetSelectorBase
+KERNEL\:\:Ordinal_187=SetSelectorBase
+KERNEL\:\:Ordinal_188=GetSelectorLimit
+KERNEL\:\:Ordinal_189=SetSelectorLimit
+KERNEL\:\:Ordinal_191=GlobalPageLock
+KERNEL\:\:Ordinal_192=GlobalPageUnlock
+KERNEL\:\:Ordinal_197=GlobalFix
+KERNEL\:\:Ordinal_198=GlobalUnfix
+KERNEL\:\:Ordinal_199=SetHandleCount
+KERNEL\:\:Ordinal_200=ValidateFreeSpaces
+KERNEL\:\:Ordinal_203=DebugBreak
+KERNEL\:\:Ordinal_204=SwapRecording
+KERNEL\:\:Ordinal_207=IsDBCSLeadByte
+KERNEL\:\:Ordinal_320=IsTask
+KERNEL\:\:Ordinal_324=LOGERROR
+KERNEL\:\:Ordinal_325=LogParamError
+KERNEL\:\:Ordinal_334=IsBadReadPtr
+KERNEL\:\:Ordinal_335=IsBadWritePtr
+KERNEL\:\:Ordinal_336=IsBadCodePtr
+KERNEL\:\:Ordinal_337=IsBadStringPtr
+KERNEL\:\:Ordinal_346=IsBadHugeReadPtr
+KERNEL\:\:Ordinal_347=IsBadHugeWritePtr
+KERNEL\:\:Ordinal_348=hmemcpy
+KERNEL\:\:Ordinal_349=_hread
+KERNEL\:\:Ordinal_350=_hwrite
+KERNEL\:\:Ordinal_353=lstrcpyn
+KERNEL\:\:Ordinal_355=GetWinDebugInfo
+KERNEL\:\:Ordinal_356=SetWinDebugInfo
+KEYBOARD\:\:Ordinal_2=Enable
+KEYBOARD\:\:Ordinal_3=disable
+KEYBOARD\:\:Ordinal_4=toascii
+KEYBOARD\:\:Ordinal_5=AnsiToOem
+KEYBOARD\:\:Ordinal_6=OemToAnsi
+KEYBOARD\:\:Ordinal_8=WEP
+KEYBOARD\:\:Ordinal_128=OemKeyScan
+KEYBOARD\:\:Ordinal_129=VkKeyScan
+KEYBOARD\:\:Ordinal_130=GetKeyboardType
+KEYBOARD\:\:Ordinal_131=MapVirtualKey
+KEYBOARD\:\:Ordinal_132=GetKBCodePage
+KEYBOARD\:\:Ordinal_133=GetKeyNameText
+KEYBOARD\:\:Ordinal_134=AnsiToOemBuff
+KEYBOARD\:\:Ordinal_135=OemToAnsiBuff
+LZEXPAND\:\:Ordinal_5=LZRead
+LZEXPAND\:\:Ordinal_1=LZCopy
+LZEXPAND\:\:Ordinal_6=LZClose
+LZEXPAND\:\:Ordinal_3=LZInit
+LZEXPAND\:\:Ordinal_10=GetExpandedName
+LZEXPAND\:\:Ordinal_4=LZSeek
+LZEXPAND\:\:Ordinal_2=LZOpenFile
+LZEXPAND\:\:Ordinal_8=CopyLZFile
+LZEXPAND\:\:Ordinal_9=LZDone
+LZEXPAND\:\:Ordinal_7=LZStart
+LZEXPAND\:\:Ordinal_11=WEP
+MMSYSTEM\:\:Ordinal_1=WEP
+MMSYSTEM\:\:Ordinal_2=sndPlaySound
+MMSYSTEM\:\:Ordinal_5=mmsystemGetVersion
+MMSYSTEM\:\:Ordinal_6=DriverProc
+MMSYSTEM\:\:Ordinal_30=OutputDebugStr
+MMSYSTEM\:\:Ordinal_101=joyGetNumDevs
+MMSYSTEM\:\:Ordinal_102=joyGetDevCaps
+MMSYSTEM\:\:Ordinal_103=joyGetPos
+MMSYSTEM\:\:Ordinal_104=joyGetThreshold
+MMSYSTEM\:\:Ordinal_105=joyReleaseCapture
+MMSYSTEM\:\:Ordinal_106=joySetCapture
+MMSYSTEM\:\:Ordinal_107=joySetThreshold
+MMSYSTEM\:\:Ordinal_109=joySetCalibration
+MMSYSTEM\:\:Ordinal_201=midiOutGetNumDevs
+MMSYSTEM\:\:Ordinal_202=midiOutGetDevCaps
+MMSYSTEM\:\:Ordinal_203=midiOutGetErrorText
+MMSYSTEM\:\:Ordinal_204=midiOutOpen
+MMSYSTEM\:\:Ordinal_205=midiOutClose
+MMSYSTEM\:\:Ordinal_206=midiOutPrepareHeader
+MMSYSTEM\:\:Ordinal_207=midiOutUnprepareHeader
+MMSYSTEM\:\:Ordinal_208=midiOutShortMsg
+MMSYSTEM\:\:Ordinal_209=midiOutLongMsg
+MMSYSTEM\:\:Ordinal_210=midiOutReset
+MMSYSTEM\:\:Ordinal_211=midiOutGetVolume
+MMSYSTEM\:\:Ordinal_212=midiOutSetVolume
+MMSYSTEM\:\:Ordinal_213=midiOutCachePatches
+MMSYSTEM\:\:Ordinal_214=midiOutCacheDrumPatches
+MMSYSTEM\:\:Ordinal_215=midiOutGetID
+MMSYSTEM\:\:Ordinal_216=midiOutMessage
+MMSYSTEM\:\:Ordinal_301=midiInGetNumDevs
+MMSYSTEM\:\:Ordinal_302=midiInGetDevCaps
+MMSYSTEM\:\:Ordinal_303=midiInGetErrorText
+MMSYSTEM\:\:Ordinal_304=midiInOpen
+MMSYSTEM\:\:Ordinal_305=midiInClose
+MMSYSTEM\:\:Ordinal_306=midiInPrepareHeader
+MMSYSTEM\:\:Ordinal_307=midiInUnprepareHeader
+MMSYSTEM\:\:Ordinal_308=midiInAddBuffer
+MMSYSTEM\:\:Ordinal_309=midiInStart
+MMSYSTEM\:\:Ordinal_310=midiInStop
+MMSYSTEM\:\:Ordinal_311=midiInReset
+MMSYSTEM\:\:Ordinal_312=midiInGetID
+MMSYSTEM\:\:Ordinal_313=midiInMessage
+MMSYSTEM\:\:Ordinal_350=auxGetNumDevs
+MMSYSTEM\:\:Ordinal_351=auxGetDevCaps
+MMSYSTEM\:\:Ordinal_352=auxGetVolume
+MMSYSTEM\:\:Ordinal_353=auxSetVolume
+MMSYSTEM\:\:Ordinal_354=auxOutMessage
+MMSYSTEM\:\:Ordinal_401=waveOutGetNumDevs
+MMSYSTEM\:\:Ordinal_402=waveOutGetDevCaps
+MMSYSTEM\:\:Ordinal_403=waveOutGetErrorText
+MMSYSTEM\:\:Ordinal_404=waveOutOpen
+MMSYSTEM\:\:Ordinal_405=waveOutClose
+MMSYSTEM\:\:Ordinal_406=waveOutPrepareHeader
+MMSYSTEM\:\:Ordinal_407=waveOutUnprepareHeader
+MMSYSTEM\:\:Ordinal_408=waveOutWrite
+MMSYSTEM\:\:Ordinal_409=waveOutPause
+MMSYSTEM\:\:Ordinal_410=waveOutRestart
+MMSYSTEM\:\:Ordinal_411=waveOutReset
+MMSYSTEM\:\:Ordinal_412=waveOutGetPosition
+MMSYSTEM\:\:Ordinal_413=waveOutGetPitch
+MMSYSTEM\:\:Ordinal_414=waveOutSetPitch
+MMSYSTEM\:\:Ordinal_415=waveOutGetVolume
+MMSYSTEM\:\:Ordinal_416=waveOutSetVolume
+MMSYSTEM\:\:Ordinal_417=waveOutGetPlaybackRate
+MMSYSTEM\:\:Ordinal_418=waveOutSetPlaybackRate
+MMSYSTEM\:\:Ordinal_419=waveOutBreakLoop
+MMSYSTEM\:\:Ordinal_420=waveOutGetID
+MMSYSTEM\:\:Ordinal_421=waveOutMessage
+MMSYSTEM\:\:Ordinal_501=waveInGetNumDevs
+MMSYSTEM\:\:Ordinal_502=waveInGetDevCaps
+MMSYSTEM\:\:Ordinal_503=waveInGetErrorText
+MMSYSTEM\:\:Ordinal_504=waveInOpen
+MMSYSTEM\:\:Ordinal_505=waveInClose
+MMSYSTEM\:\:Ordinal_506=waveInPrepareHeader
+MMSYSTEM\:\:Ordinal_507=waveInUnprepareHeader
+MMSYSTEM\:\:Ordinal_508=waveInAddBuffer
+MMSYSTEM\:\:Ordinal_509=waveInStart
+MMSYSTEM\:\:Ordinal_510=waveInStop
+MMSYSTEM\:\:Ordinal_511=waveInReset
+MMSYSTEM\:\:Ordinal_512=waveInGetPosition
+MMSYSTEM\:\:Ordinal_513=waveInGetID
+MMSYSTEM\:\:Ordinal_514=waveInMessage
+MMSYSTEM\:\:Ordinal_601=timeGetSystemTime
+MMSYSTEM\:\:Ordinal_602=timeSetEvent
+MMSYSTEM\:\:Ordinal_603=timeKillEvent
+MMSYSTEM\:\:Ordinal_604=timeGetDevCaps
+MMSYSTEM\:\:Ordinal_605=timeBeginPeriod
+MMSYSTEM\:\:Ordinal_606=timeEndPeriod
+MMSYSTEM\:\:Ordinal_607=timeGetTime
+MMSYSTEM\:\:Ordinal_701=mciSendCommand
+MMSYSTEM\:\:Ordinal_702=mciSendString
+MMSYSTEM\:\:Ordinal_703=mciGetDeviceID
+MMSYSTEM\:\:Ordinal_706=mciGetErrorString
+MMSYSTEM\:\:Ordinal_712=mciExecute
+MMSYSTEM\:\:Ordinal_714=mciSetYieldProc
+MMSYSTEM\:\:Ordinal_715=mciGetDeviceIDFromElementID
+MMSYSTEM\:\:Ordinal_716=mciGetYieldProc
+MMSYSTEM\:\:Ordinal_717=mciGetCreatorTask
+MMSYSTEM\:\:Ordinal_1100=DrvOpen
+MMSYSTEM\:\:Ordinal_1101=DrvClose
+MMSYSTEM\:\:Ordinal_1102=DrvSendMessage
+MMSYSTEM\:\:Ordinal_1103=DrvGetModuleHandle
+MMSYSTEM\:\:Ordinal_1104=DrvDefDriverProc
+MMSYSTEM\:\:Ordinal_1210=mmioOpen
+MMSYSTEM\:\:Ordinal_1211=mmioClose
+MMSYSTEM\:\:Ordinal_1212=mmioRead
+MMSYSTEM\:\:Ordinal_1213=mmioWrite
+MMSYSTEM\:\:Ordinal_1214=mmioSeek
+MMSYSTEM\:\:Ordinal_1215=mmioGetInfo
+MMSYSTEM\:\:Ordinal_1216=mmioSetInfo
+MMSYSTEM\:\:Ordinal_1217=mmioSetBuffer
+MMSYSTEM\:\:Ordinal_1218=mmioFlush
+MMSYSTEM\:\:Ordinal_1219=mmioAdvance
+MMSYSTEM\:\:Ordinal_1220=mmioStringToFOURCC
+MMSYSTEM\:\:Ordinal_1221=mmioInstallIOProc
+MMSYSTEM\:\:Ordinal_1222=mmioSendMessage
+MMSYSTEM\:\:Ordinal_1223=mmioDescend
+MMSYSTEM\:\:Ordinal_1224=mmioAscend
+MMSYSTEM\:\:Ordinal_1225=mmioCreateChunk
+MMSYSTEM\:\:Ordinal_1226=mmioRename
+SHELL\:\:Ordinal_1=RegOpenKey
+SHELL\:\:Ordinal_2=RegCreateKey
+SHELL\:\:Ordinal_3=RegCloseKey
+SHELL\:\:Ordinal_4=RegDeleteKey
+SHELL\:\:Ordinal_5=RegSetValue
+SHELL\:\:Ordinal_6=RegQueryValue
+SHELL\:\:Ordinal_7=RegEnumKey
+SHELL\:\:Ordinal_8=WEP
+SHELL\:\:Ordinal_9=DragAcceptFiles
+SHELL\:\:Ordinal_11=DragQueryFile
+SHELL\:\:Ordinal_12=DragFinish
+SHELL\:\:Ordinal_13=DragQueryPoint
+SHELL\:\:Ordinal_20=ShellExecute
+SHELL\:\:Ordinal_21=FindExecutable
+SHELL\:\:Ordinal_22=ShellAbout
+SHELL\:\:Ordinal_34=ExtractIcon
+SHELL\:\:Ordinal_36=ExtractAssociatedIcon
+TOOLHELP\:\:Ordinal_1=WEP
+TOOLHELP\:\:Ordinal_50=GlobalHandleToSel
+TOOLHELP\:\:Ordinal_51=GlobalFirst
+TOOLHELP\:\:Ordinal_52=GlobalNext
+TOOLHELP\:\:Ordinal_53=GlobalInfo
+TOOLHELP\:\:Ordinal_54=GlobalEntryHandle
+TOOLHELP\:\:Ordinal_55=GlobalEntryModule
+TOOLHELP\:\:Ordinal_56=LocalInfo
+TOOLHELP\:\:Ordinal_57=LocalFirst
+TOOLHELP\:\:Ordinal_58=LocalNext
+TOOLHELP\:\:Ordinal_59=ModuleFirst
+TOOLHELP\:\:Ordinal_60=ModuleNext
+TOOLHELP\:\:Ordinal_61=ModuleFindName
+TOOLHELP\:\:Ordinal_62=ModuleFindHandle
+TOOLHELP\:\:Ordinal_63=TaskFirst
+TOOLHELP\:\:Ordinal_64=TaskNext
+TOOLHELP\:\:Ordinal_65=TaskFindHandle
+TOOLHELP\:\:Ordinal_66=StackTraceFirst
+TOOLHELP\:\:Ordinal_67=StackTraceCSIPFirst
+TOOLHELP\:\:Ordinal_68=StackTraceNext
+TOOLHELP\:\:Ordinal_69=ClassFirst
+TOOLHELP\:\:Ordinal_70=ClassNext
+TOOLHELP\:\:Ordinal_71=SystemHeapInfo
+TOOLHELP\:\:Ordinal_72=MemManInfo
+TOOLHELP\:\:Ordinal_73=NotifyRegister
+TOOLHELP\:\:Ordinal_74=NotifyUnRegister
+TOOLHELP\:\:Ordinal_75=InterruptRegister
+TOOLHELP\:\:Ordinal_76=InterruptUnRegister
+TOOLHELP\:\:Ordinal_77=TerminateApp
+TOOLHELP\:\:Ordinal_78=MemoryRead
+TOOLHELP\:\:Ordinal_79=MemoryWrite
+TOOLHELP\:\:Ordinal_80=TimerCount
+TOOLHELP\:\:Ordinal_81=TaskSetCSIP
+TOOLHELP\:\:Ordinal_82=TaskGetCSIP
+TOOLHELP\:\:Ordinal_83=TaskSwitch
+USER\:\:Ordinal_1=MessageBox
+USER\:\:Ordinal_6=PostQuitMessage
+USER\:\:Ordinal_7=ExitWindows
+USER\:\:Ordinal_8=WEP
+USER\:\:Ordinal_10=SetTimer
+USER\:\:Ordinal_12=KillTimer
+USER\:\:Ordinal_13=GetCurrentTime
+USER\:\:Ordinal_14=GetTimerResolution
+USER\:\:Ordinal_15=GetTickCount
+USER\:\:Ordinal_16=ClipCursor
+USER\:\:Ordinal_17=GetCursorPos
+USER\:\:Ordinal_18=SetCapture
+USER\:\:Ordinal_19=ReleaseCapture
+USER\:\:Ordinal_20=SetDoubleClickTime
+USER\:\:Ordinal_21=GetDoubleClickTime
+USER\:\:Ordinal_22=SetFocus
+USER\:\:Ordinal_23=GetFocus
+USER\:\:Ordinal_24=RemoveProp
+USER\:\:Ordinal_25=GetProp
+USER\:\:Ordinal_26=SetProp
+USER\:\:Ordinal_27=EnumProps
+USER\:\:Ordinal_28=ClientToScreen
+USER\:\:Ordinal_29=ScreenToClient
+USER\:\:Ordinal_30=WindowFromPoint
+USER\:\:Ordinal_31=IsIconic
+USER\:\:Ordinal_32=GetWindowRect
+USER\:\:Ordinal_33=GetClientRect
+USER\:\:Ordinal_34=EnableWindow
+USER\:\:Ordinal_35=IsWindowEnabled
+USER\:\:Ordinal_36=GetWindowText
+USER\:\:Ordinal_37=SetWindowText
+USER\:\:Ordinal_38=GetWindowTextLength
+USER\:\:Ordinal_39=BeginPaint
+USER\:\:Ordinal_40=EndPaint
+USER\:\:Ordinal_41=CreateWindow
+USER\:\:Ordinal_42=ShowWindow
+USER\:\:Ordinal_43=CloseWindow
+USER\:\:Ordinal_44=OpenIcon
+USER\:\:Ordinal_45=BringWindowToTop
+USER\:\:Ordinal_46=GetParent
+USER\:\:Ordinal_47=IsWindow
+USER\:\:Ordinal_48=IsChild
+USER\:\:Ordinal_49=IsWindowVisible
+USER\:\:Ordinal_50=FindWindow
+USER\:\:Ordinal_52=AnyPopup
+USER\:\:Ordinal_53=DestroyWindow
+USER\:\:Ordinal_54=EnumWindows
+USER\:\:Ordinal_55=EnumChildWindows
+USER\:\:Ordinal_56=MoveWindow
+USER\:\:Ordinal_57=RegisterClass
+USER\:\:Ordinal_58=GetClassName
+USER\:\:Ordinal_59=SetActiveWindow
+USER\:\:Ordinal_60=GetActiveWindow
+USER\:\:Ordinal_61=ScrollWindow
+USER\:\:Ordinal_62=SetScrollPos
+USER\:\:Ordinal_63=GetScrollPos
+USER\:\:Ordinal_64=SetScrollRange
+USER\:\:Ordinal_65=GetScrollRange
+USER\:\:Ordinal_66=GetDC
+USER\:\:Ordinal_67=GetWindowDC
+USER\:\:Ordinal_68=ReleaseDC
+USER\:\:Ordinal_69=setcursor
+USER\:\:Ordinal_70=SetCursorPos
+USER\:\:Ordinal_71=ShowCursor
+USER\:\:Ordinal_72=SetRect
+USER\:\:Ordinal_73=SetRectEmpty
+USER\:\:Ordinal_74=CopyRect
+USER\:\:Ordinal_75=IsRectEmpty
+USER\:\:Ordinal_76=PtInRect
+USER\:\:Ordinal_77=OffsetRect
+USER\:\:Ordinal_78=InflateRect
+USER\:\:Ordinal_79=IntersectRect
+USER\:\:Ordinal_80=UnionRect
+USER\:\:Ordinal_81=FillRect
+USER\:\:Ordinal_82=InvertRect
+USER\:\:Ordinal_83=FrameRect
+USER\:\:Ordinal_84=DrawIcon
+USER\:\:Ordinal_85=DRAWTEXT
+USER\:\:Ordinal_87=DialogBox
+USER\:\:Ordinal_88=EndDialog
+USER\:\:Ordinal_89=CreateDialog
+USER\:\:Ordinal_90=IsDialogMessage
+USER\:\:Ordinal_91=GetDlgItem
+USER\:\:Ordinal_92=SetDlgItemText
+USER\:\:Ordinal_93=GetDlgItemText
+USER\:\:Ordinal_94=SetDlgItemInt
+USER\:\:Ordinal_95=GetDlgItemInt
+USER\:\:Ordinal_96=CheckRadioButton
+USER\:\:Ordinal_97=CheckDlgButton
+USER\:\:Ordinal_98=IsDlgButtonChecked
+USER\:\:Ordinal_99=DlgDirSelect
+USER\:\:Ordinal_100=DlgDirList
+USER\:\:Ordinal_101=SendDlgItemMessage
+USER\:\:Ordinal_102=AdjustWindowRect
+USER\:\:Ordinal_103=MapDialogRect
+USER\:\:Ordinal_104=MessageBeep
+USER\:\:Ordinal_105=FlashWindow
+USER\:\:Ordinal_106=GetKeyState
+USER\:\:Ordinal_107=DefWindowProc
+USER\:\:Ordinal_108=GetMessage
+USER\:\:Ordinal_109=PeekMessage
+USER\:\:Ordinal_110=PostMessage
+USER\:\:Ordinal_111=SendMessage
+USER\:\:Ordinal_112=WaitMessage
+USER\:\:Ordinal_113=TranslateMessage
+USER\:\:Ordinal_114=DispatchMessage
+USER\:\:Ordinal_115=ReplyMessage
+USER\:\:Ordinal_116=PostAppMessage
+USER\:\:Ordinal_118=RegisterClipboardFormat
+USER\:\:Ordinal_119=GetMessagePos
+USER\:\:Ordinal_120=GetMessageTime
+USER\:\:Ordinal_121=SetWindowsHook
+USER\:\:Ordinal_122=CallWindowProc
+USER\:\:Ordinal_123=CallMsgFilter
+USER\:\:Ordinal_124=UpdateWindow
+USER\:\:Ordinal_125=InvalidateRect
+USER\:\:Ordinal_126=InvalidateRgn
+USER\:\:Ordinal_127=ValidateRect
+USER\:\:Ordinal_128=ValidateRgn
+USER\:\:Ordinal_129=GetClassWord
+USER\:\:Ordinal_130=SetClassWord
+USER\:\:Ordinal_131=GetClassLong
+USER\:\:Ordinal_132=SetClassLong
+USER\:\:Ordinal_133=GetWindowWord
+USER\:\:Ordinal_134=SetWindowWord
+USER\:\:Ordinal_135=GetWindowLong
+USER\:\:Ordinal_136=SetWindowLong
+USER\:\:Ordinal_137=OpenClipboard
+USER\:\:Ordinal_138=CloseClipboard
+USER\:\:Ordinal_139=EmptyClipboard
+USER\:\:Ordinal_140=GetClipboardOwner
+USER\:\:Ordinal_141=SetClipboardData
+USER\:\:Ordinal_142=GetClipboardData
+USER\:\:Ordinal_143=CountClipboardFormats
+USER\:\:Ordinal_144=EnumClipboardFormats
+USER\:\:Ordinal_145=RegisterWindowMessage
+USER\:\:Ordinal_146=GetClipboardFormatName
+USER\:\:Ordinal_147=SetClipboardViewer
+USER\:\:Ordinal_148=GetClipboardViewer
+USER\:\:Ordinal_149=ChangeClipboardChain
+USER\:\:Ordinal_150=LoadMenu
+USER\:\:Ordinal_151=CreateMenu
+USER\:\:Ordinal_152=DestroyMenu
+USER\:\:Ordinal_153=ChangeMenu
+USER\:\:Ordinal_154=CheckMenuItem
+USER\:\:Ordinal_155=EnableMenuItem
+USER\:\:Ordinal_156=GetSystemMenu
+USER\:\:Ordinal_157=GetMenu
+USER\:\:Ordinal_158=SetMenu
+USER\:\:Ordinal_159=GetSubMenu
+USER\:\:Ordinal_160=DrawMenuBar
+USER\:\:Ordinal_161=GetMenuString
+USER\:\:Ordinal_162=HiliteMenuItem
+USER\:\:Ordinal_163=CreateCaret
+USER\:\:Ordinal_164=DestroyCaret
+USER\:\:Ordinal_165=SetCaretPos
+USER\:\:Ordinal_166=HideCaret
+USER\:\:Ordinal_167=ShowCaret
+USER\:\:Ordinal_168=SetCaretBlinkTime
+USER\:\:Ordinal_169=GetCaretBlinkTime
+USER\:\:Ordinal_170=ArrangeIconicWindows
+USER\:\:Ordinal_171=WinHelp
+USER\:\:Ordinal_173=LoadCursor
+USER\:\:Ordinal_174=LoadIcon
+USER\:\:Ordinal_175=LoadBitmap
+USER\:\:Ordinal_176=LoadString
+USER\:\:Ordinal_177=LoadAccelerators
+USER\:\:Ordinal_178=TranslateAccelerator
+USER\:\:Ordinal_179=GetSystemMetrics
+USER\:\:Ordinal_180=GetSysColor
+USER\:\:Ordinal_181=SetSysColors
+USER\:\:Ordinal_183=GetCaretPos
+USER\:\:Ordinal_184=QuerySendMessage
+USER\:\:Ordinal_185=GRAYSTRING
+USER\:\:Ordinal_186=SwapMouseButton
+USER\:\:Ordinal_188=SetSysModalWindow
+USER\:\:Ordinal_189=GetSysModalWindow
+USER\:\:Ordinal_190=GetUpdateRect
+USER\:\:Ordinal_191=ChildWindowFromPoint
+USER\:\:Ordinal_192=InSendMessage
+USER\:\:Ordinal_193=IsClipboardFormatAvailable
+USER\:\:Ordinal_194=DlgDirSelectComboBox
+USER\:\:Ordinal_195=DlgDirListComboBox
+USER\:\:Ordinal_196=TabbedTextOut
+USER\:\:Ordinal_197=GetTabbedTextExtent
+USER\:\:Ordinal_200=OpenComm
+USER\:\:Ordinal_201=SetCommState
+USER\:\:Ordinal_202=GetCommState
+USER\:\:Ordinal_203=GetCommError
+USER\:\:Ordinal_204=ReadComm
+USER\:\:Ordinal_205=WriteComm
+USER\:\:Ordinal_206=TransmitCommChar
+USER\:\:Ordinal_207=CloseComm
+USER\:\:Ordinal_208=SetCommEventMask
+USER\:\:Ordinal_209=GetCommEventMask
+USER\:\:Ordinal_210=SetCommBreak
+USER\:\:Ordinal_211=ClearCommBreak
+USER\:\:Ordinal_212=UngetCommChar
+USER\:\:Ordinal_213=BuildCommDCB
+USER\:\:Ordinal_214=EscapeCommFunction
+USER\:\:Ordinal_215=FlushComm
+USER\:\:Ordinal_218=DialogBoxIndirect
+USER\:\:Ordinal_219=CreateDialogIndirect
+USER\:\:Ordinal_220=LoadMenuIndirect
+USER\:\:Ordinal_221=ScrollDC
+USER\:\:Ordinal_222=GetKeyboardState
+USER\:\:Ordinal_223=SetKeyboardState
+USER\:\:Ordinal_224=GetWindowTask
+USER\:\:Ordinal_225=EnumTaskWindows
+USER\:\:Ordinal_226=LockInput
+USER\:\:Ordinal_227=GetNextDlgGroupItem
+USER\:\:Ordinal_228=GetNextDlgTabItem
+USER\:\:Ordinal_229=GetTopWindow
+USER\:\:Ordinal_230=GetNextWindow
+USER\:\:Ordinal_231=GetSystemDebugState
+USER\:\:Ordinal_232=SetWindowPos
+USER\:\:Ordinal_233=SetParent
+USER\:\:Ordinal_234=UnhookWindowsHook
+USER\:\:Ordinal_235=DefHookProc
+USER\:\:Ordinal_236=GetCapture
+USER\:\:Ordinal_237=GetUpdateRgn
+USER\:\:Ordinal_238=ExcludeUpdateRgn
+USER\:\:Ordinal_239=DialogBoxParam
+USER\:\:Ordinal_240=DialogBoxIndirectParam
+USER\:\:Ordinal_241=CreateDialogParam
+USER\:\:Ordinal_242=CreateDialogIndirectParam
+USER\:\:Ordinal_243=GetDialogBaseUnits
+USER\:\:Ordinal_244=EqualRect
+USER\:\:Ordinal_245=EnableCommNotification
+USER\:\:Ordinal_246=ExitWindowsExec
+USER\:\:Ordinal_247=GetCursor
+USER\:\:Ordinal_248=GetOpenClipboardWindow
+USER\:\:Ordinal_249=GetAsyncKeyState
+USER\:\:Ordinal_250=GetMenuState
+USER\:\:Ordinal_251=SendDriverMessage
+USER\:\:Ordinal_252=OpenDriver
+USER\:\:Ordinal_253=CloseDriver
+USER\:\:Ordinal_254=GetDriverModuleHandle
+USER\:\:Ordinal_255=DefDriverProc
+USER\:\:Ordinal_256=GetDriverInfo
+USER\:\:Ordinal_257=GetNextDriver
+USER\:\:Ordinal_258=MapWindowPoints
+USER\:\:Ordinal_259=BeginDeferWindowPos
+USER\:\:Ordinal_260=DeferWindowPos
+USER\:\:Ordinal_261=EndDeferWindowPos
+USER\:\:Ordinal_262=GetWindow
+USER\:\:Ordinal_263=GetMenuItemCount
+USER\:\:Ordinal_264=GetMenuItemID
+USER\:\:Ordinal_265=ShowOwnedPopups
+USER\:\:Ordinal_266=SetMessageQueue
+USER\:\:Ordinal_267=ShowScrollBar
+USER\:\:Ordinal_268=GlobalAddAtom
+USER\:\:Ordinal_269=GlobalDeleteAtom
+USER\:\:Ordinal_270=GlobalFindAtom
+USER\:\:Ordinal_271=GlobalGetAtomName
+USER\:\:Ordinal_272=IsZoomed
+USER\:\:Ordinal_277=GetDlgCtrlID
+USER\:\:Ordinal_278=GetDesktopWindow
+USER\:\:Ordinal_282=SelectPalette
+USER\:\:Ordinal_283=RealizePalette
+USER\:\:Ordinal_284=GetFreeSystemResources
+USER\:\:Ordinal_286=GetDesktopHWND
+USER\:\:Ordinal_287=GetLastActivePopup
+USER\:\:Ordinal_288=GetMessageExtraInfo
+USER\:\:Ordinal_290=RedrawWindow
+USER\:\:Ordinal_291=SetWindowsHookEx
+USER\:\:Ordinal_292=UnhookWindowsHookEx
+USER\:\:Ordinal_293=CallNextHookEx
+USER\:\:Ordinal_294=LockWindowUpdate
+USER\:\:Ordinal_308=DefDlgProc
+USER\:\:Ordinal_309=GetClipCursor
+USER\:\:Ordinal_319=ScrollWindowEx
+USER\:\:Ordinal_331=EnableHardwareInput
+USER\:\:Ordinal_334=GetQueueStatus
+USER\:\:Ordinal_335=GetInputState
+USER\:\:Ordinal_358=IsMenu
+USER\:\:Ordinal_359=GetDCEx
+USER\:\:Ordinal_368=CopyIcon
+USER\:\:Ordinal_369=CopyCursor
+USER\:\:Ordinal_370=GetWindowPlacement
+USER\:\:Ordinal_371=SetWindowPlacement
+USER\:\:Ordinal_373=SubtractRect
+USER\:\:Ordinal_402=GetPriorityClipboardFormat
+USER\:\:Ordinal_403=UnregisterClass
+USER\:\:Ordinal_404=GetClassInfo
+USER\:\:Ordinal_406=CreateCursor
+USER\:\:Ordinal_407=CreateIcon
+USER\:\:Ordinal_410=InsertMenu
+USER\:\:Ordinal_411=AppendMenu
+USER\:\:Ordinal_412=RemoveMenu
+USER\:\:Ordinal_413=DeleteMenu
+USER\:\:Ordinal_414=ModifyMenu
+USER\:\:Ordinal_415=CreatePopupMenu
+USER\:\:Ordinal_416=TrackPopupMenu
+USER\:\:Ordinal_417=GetMenuCheckMarkDimensions
+USER\:\:Ordinal_418=SetMenuItemBitmaps
+USER\:\:Ordinal_421=wvsprintf
+USER\:\:Ordinal_422=DlgDirSelectEx
+USER\:\:Ordinal_423=DlgDirSelectComboBoxEx
+USER\:\:Ordinal_430=lstrcmp
+USER\:\:Ordinal_431=AnsiUpper
+USER\:\:Ordinal_432=AnsiLower
+USER\:\:Ordinal_433=IsCharAlpha
+USER\:\:Ordinal_434=IsCharAlphaNumeric
+USER\:\:Ordinal_435=IsCharUpper
+USER\:\:Ordinal_436=IsCharLower
+USER\:\:Ordinal_437=AnsiUpperBuff
+USER\:\:Ordinal_438=AnsiLowerBuff
+USER\:\:Ordinal_445=DefFrameProc
+USER\:\:Ordinal_447=DefMDIChildProc
+USER\:\:Ordinal_451=TranslateMDISysAccel
+USER\:\:Ordinal_452=CreateWindowEx
+USER\:\:Ordinal_454=AdjustWindowRectEx
+USER\:\:Ordinal_457=DestroyIcon
+USER\:\:Ordinal_458=DestroyCursor
+USER\:\:Ordinal_466=DrawFocusRect
+USER\:\:Ordinal_471=lstrcmpi
+USER\:\:Ordinal_472=AnsiNext
+USER\:\:Ordinal_473=AnsiPrev
+USER\:\:Ordinal_482=EnableScrollBar
+USER\:\:Ordinal_483=SystemParametersInfo
+USER\:\:Ordinal_512=WNetGetConnection
+USER\:\:Ordinal_517=WNetAddConnection
+USER\:\:Ordinal_518=WNetCancelConnection
+USER\:\:Ordinal_526=WNetDisconnectDialog
+USER\:\:Ordinal_527=WNetConnectionDialog
+VER\:\:Ordinal_1=WEP
+VER\:\:Ordinal_2=GetFileResourceSize
+VER\:\:Ordinal_3=GetFileResource
+VER\:\:Ordinal_6=GetFileVersionInfoSize
+VER\:\:Ordinal_7=GetFileVersionInfo
+VER\:\:Ordinal_8=VerFindFile
+VER\:\:Ordinal_9=VerInstallFile
+VER\:\:Ordinal_10=VerLanguageName
+VER\:\:Ordinal_11=VerQueryValue
+
+DGNSCRIP\:\:Ordinal_1=DGNSCRIPT_COMPILE
+DGNSCRIP\:\:Ordinal_2=DGNSCRIPT_GETERRORTEXT
+DGNSCRIP\:\:Ordinal_3=LIBMAIN
+DGNSCRIP\:\:Ordinal_4=DGNSCRIPT_INTERPRET
+DGNSCRIP\:\:Ordinal_5=DGNSCRIPT_GETSTATUS
+DGNSCRIP\:\:Ordinal_6=DGNINTERP_GETSTATE
+DGNSCRIP\:\:Ordinal_7=DGNINTERP_SETSTATE
+DGNSCRIP\:\:Ordinal_8=DGNINTERP_CLEARSTATE
+DGNSCRIP\:\:Ordinal_9=DGNSCRIPT_CHECKSTATE
+DGNSCRIP\:\:Ordinal_10=DGNSCRIPT_GETCMDNAME
+DGNSCRIP\:\:Ordinal_11=DGNINTERP_FORMATERRORTEXT
+DGNSCRIP\:\:Ordinal_12=DGNINTERP_GETTHREADLIST
+DGNSCRIP\:\:Ordinal_13=WEP
+DGNSCRIP\:\:Ordinal_14=DGNSCRIPT_COMPILESENTENCE
+DGNSCRIP\:\:Ordinal_15=DGNSCRIPT_FREESENTENCE
+DGNSRVR\:\:Ordinal_1=DGNSERVER_INITIALIZE
+DGNSRVR\:\:Ordinal_2=DGNSERVER_UNINITIALIZE
+DGNSRVR\:\:Ordinal_3=DGNSERVER_REGISTERMESSAGE
+DGNSRVR\:\:Ordinal_4=DGNSERVER_OPENVOC
+DGNSRVR\:\:Ordinal_5=DGNAP_DETACH
+DGNSRVR\:\:Ordinal_6=DGNAP_DESTROY
+DGNSRVR\:\:Ordinal_7=DGNAPVOC_CREATE
+DGNSRVR\:\:Ordinal_8=DGNAPSTATE_CREATE
+DGNSRVR\:\:Ordinal_9=DGNAPWORD_CREATE
+DGNSRVR\:\:Ordinal_10=DGNAP_ATTACHTOVOC
+DGNSRVR\:\:Ordinal_11=DGNAP_ATTACHTOSTATE
+DGNSRVR\:\:Ordinal_12=DGNAP_ATTACHTOWORD
+DGNSRVR\:\:Ordinal_13=DGNAP_ISATTACHEDTOVOC
+DGNSRVR\:\:Ordinal_14=DGNAP_ISATTACHEDTOSTATE
+DGNSRVR\:\:Ordinal_15=DGNAP_ISATTACHEDTOWORD
+DGNSRVR\:\:Ordinal_16=DGNVOC_CLOSE
+DGNSRVR\:\:Ordinal_17=DGNVOC_SAVE
+DGNSRVR\:\:Ordinal_18=DGNVOC_FINDSTATE
+DGNSRVR\:\:Ordinal_19=DGNAP_GETTYPE
+DGNSRVR\:\:Ordinal_20=DGNDAEMON_INITIALIZE
+DGNSRVR\:\:Ordinal_21=DGNDAEMON_UNINITIALIZE
+DGNSRVR\:\:Ordinal_22=DGNDAEMON_MICSETSTATE
+DGNSRVR\:\:Ordinal_23=DGNDAEMON_TIMERSETEVENT
+DGNSRVR\:\:Ordinal_24=DGNDAEMON_UTTSTART
+DGNSRVR\:\:Ordinal_25=DGNSERVER_SETCURRENTUSER
+DGNSRVR\:\:Ordinal_26=DGNSERVER_GETPARAMETER
+DGNSRVR\:\:Ordinal_27=DGNSERVER_SETPARAMETER
+DGNSRVR\:\:Ordinal_28=DGNWORD_GETPROP
+DGNSRVR\:\:Ordinal_29=DGNUTT_GETWORD
+DGNSRVR\:\:Ordinal_30=DGNVOC_CREATESTATE
+DGNSRVR\:\:Ordinal_31=DGNSTATE_ADDWORD
+DGNSRVR\:\:Ordinal_32=DGNSERVER_DEFPROC
+DGNSRVR\:\:Ordinal_33=DGNSERVER_SETMIC
+DGNSRVR\:\:Ordinal_34=DGNSERVER_SETRECOGSTATES
+DGNSRVR\:\:Ordinal_35=DGNINPUT_LOCK
+DGNSRVR\:\:Ordinal_36=DGNINPUT_GENEVENTS
+DGNSRVR\:\:Ordinal_37=DGNINPUT_PLAYEVENTS
+DGNSRVR\:\:Ordinal_38=DGNINPUT_PLAYSTRING
+DGNSRVR\:\:Ordinal_39=DGNUTT_GETINFO
+DGNSRVR\:\:Ordinal_40=DGNWORD_GETNAME
+DGNSRVR\:\:Ordinal_41=DGNSERVER_GETCURRENTUSER
+DGNSRVR\:\:Ordinal_42=DGNSERVER_ISVALID
+DGNSRVR\:\:Ordinal_43=DGNWORD_SETPROP
+DGNSRVR\:\:Ordinal_44=DGNWORD_FIRST
+DGNSRVR\:\:Ordinal_45=DGNWORD_LAST
+DGNSRVR\:\:Ordinal_46=DGNWORD_NEXT
+DGNSRVR\:\:Ordinal_47=DGNWORD_PREV
+DGNSRVR\:\:Ordinal_48=DGNSERVER_GETERRTEXT
+DGNSRVR\:\:Ordinal_49=DGNTASKMAP_FINDBYNAME
+DGNSRVR\:\:Ordinal_50=DGNTASKMAP_FINDBYEXENAME
+DGNSRVR\:\:Ordinal_51=DGNTASKMAP_EXEC
+DGNSRVR\:\:Ordinal_52=DGNSTATE_GETNAME
+DGNSRVR\:\:Ordinal_53=DGNSTATE_FIRST
+DGNSRVR\:\:Ordinal_54=DGNSTATE_LAST
+DGNSRVR\:\:Ordinal_55=DGNSTATE_NEXT
+DGNSRVR\:\:Ordinal_56=DGNSTATE_PREV
+DGNSRVR\:\:Ordinal_57=DGNSTATE_SETORDER
+DGNSRVR\:\:Ordinal_58=DGNSTATE_GETINFO
+DGNSRVR\:\:Ordinal_59=DGNSTATE_DESTROY
+DGNSRVR\:\:Ordinal_60=DGNSTATE_ADDINCLUDE
+DGNSRVR\:\:Ordinal_61=DGNSTATE_REMOVEINCLUDE
+DGNSRVR\:\:Ordinal_62=DGNSTATE_FIRSTINCLUDE
+DGNSRVR\:\:Ordinal_63=DGNSTATE_LASTINCLUDE
+DGNSRVR\:\:Ordinal_64=DGNSTATE_NEXTINCLUDE
+DGNSRVR\:\:Ordinal_65=DGNSTATE_PREVINCLUDE
+DGNSRVR\:\:Ordinal_66=DGNTASKMAP_SETNAME
+DGNSRVR\:\:Ordinal_67=DGNTASKMAP_GETNAME
+DGNSRVR\:\:Ordinal_68=DGNTASKMAP_GETCURRENTWINDOW
+DGNSRVR\:\:Ordinal_69=DGNSERVER_DISABLETRACKING
+DGNSRVR\:\:Ordinal_70=DGNSTATE_FINDWORD
+DGNSRVR\:\:Ordinal_71=DGNSTATE_FINDWORDBYINDEX
+DGNSRVR\:\:Ordinal_72=DGNWORD_GETINDEX
+DGNSRVR\:\:Ordinal_73=VLISTBOXWNDPROC
+DGNSRVR\:\:Ordinal_74=LBSUBCLASSPROC
+DGNSRVR\:\:Ordinal_75=WLISTWNDPROC
+DGNSRVR\:\:Ordinal_76=DGNTASKMAP_GETEXEFROMALIAS
+DGNSRVR\:\:Ordinal_77=DGNTASKMAP_GETALIASFROMEXE
+DGNSRVR\:\:Ordinal_78=DGNTASKMAP_GETACTIVETASK
+DGNSRVR\:\:Ordinal_79=DGNTASKMAP_GETEXENAME
+DGNSRVR\:\:Ordinal_80=DGNPRIVATE_GETMOVEMODEWINDOW
+DGNSRVR\:\:Ordinal_81=DGNSTATE_GETPROP
+DGNSRVR\:\:Ordinal_82=DGNSTATE_SETPROP
+DGNSRVR\:\:Ordinal_83=DGNPRIVATE_SETTUTORIALHOOK
+DGNSRVR\:\:Ordinal_84=DGNPRIVATE_GETTUTORIALHOOK
+DGNSRVR\:\:Ordinal_85=DGNDAEMON_RECOGBEGIN
+DGNSRVR\:\:Ordinal_86=DGNINPUT_PLAYBACKCOUNT
+DGNSRVR\:\:Ordinal_87=DGNSERVER_FINDVOC
+DGNSRVR\:\:Ordinal_88=DGNSERVER_GETINFO
+DGNSRVR\:\:Ordinal_89=DGNSERVER_CREATEUSER
+DGNSRVR\:\:Ordinal_90=DGNSERVER_GETVERSION
+DGNSRVR\:\:Ordinal_91=DGNSERVER_DESTROYUSER
+DGNSRVR\:\:Ordinal_92=DGNSERVER_SAVEUSER
+DGNSRVR\:\:Ordinal_93=DGNSERVER_SAVEALLUSERS
+DGNSRVR\:\:Ordinal_94=DGNSERVER_ISLOADEDUSER
+DGNSRVR\:\:Ordinal_95=DGNSERVER_GETUSERNAMES
+DGNSRVR\:\:Ordinal_96=DGNSERVER_UNLOADUSER
+DGNSRVR\:\:Ordinal_97=DGNWORD_DESTROY
+DGNSRVR\:\:Ordinal_98=DGNPRIVATE_LOGINVOCMAN
+DGNSRVR\:\:Ordinal_99=DGNPRIVATE_GETVOCMANINFO
+DGNSRVR\:\:Ordinal_100=DGNWORD_GETPROPNAMES
+DGNSRVR\:\:Ordinal_101=DGNSTATE_GETPROPNAMES
+DGNSRVR\:\:Ordinal_102=DGNAP_ISATTACHEDTOAVOC
+DGNSRVR\:\:Ordinal_103=DGNAP_ISATTACHEDTOASTATE
+DGNSRVR\:\:Ordinal_104=DGNAP_ISATTACHEDTOAWORD
+DGNSRVR\:\:Ordinal_105=DGNAP_ISDETACHED
+DGNSRVR\:\:Ordinal_106=DGNWORD_HASSAMEWORDNAME
+DGNSRVR\:\:Ordinal_107=DGNVOC_COPYSTATE
+DGNSRVR\:\:Ordinal_108=DGNSTATE_COPYWORD
+DGNSRVR\:\:Ordinal_109=DGNINPUT_FORCEUNLOCK
+DGNSRVR\:\:Ordinal_110=DGNSTATE_SETNAME
+DGNSRVR\:\:Ordinal_111=DGNSTATE_TRAIN
+DGNSRVR\:\:Ordinal_112=DGNPRIVATE_SETENVSOUNDSSTATE
+DGNSRVR\:\:Ordinal_113=DGNWORD_TRAIN
+DGNSRVR\:\:Ordinal_114=DGNVOC_TRAINWORD
+DGNSRVR\:\:Ordinal_115=DGNUTT_ISSAMEAS
+DGNSRVR\:\:Ordinal_116=DGNSTATE_FINDWORDGE
+DGNSRVR\:\:Ordinal_117=DGNVOC_FIRST
+DGNSRVR\:\:Ordinal_118=DGNVOC_NEXT
+DGNSRVR\:\:Ordinal_119=DGNVOC_LAST
+DGNSRVR\:\:Ordinal_120=DGNVOC_PREV
+DGNSRVR\:\:Ordinal_121=DGNVOC_GETPROP
+DGNSRVR\:\:Ordinal_122=DGNVOC_SETPROP
+DGNSRVR\:\:Ordinal_123=DGNVOC_SETNAME
+DGNSRVR\:\:Ordinal_124=DGNVOC_GETPROPNAMES
+DGNSRVR\:\:Ordinal_125=DGNPRIVATE_DESTROYTRAINSTATE
+DGNSRVR\:\:Ordinal_126=DGNVOC_GETNAME
+DGNSRVR\:\:Ordinal_127=DGNVOC_GETINFO
+DGNSRVR\:\:Ordinal_128=DGNDAEMON_SHUTDOWNMESSAGEBOX
+DGNSRVR\:\:Ordinal_129=DGNSERVER_GETMIC
+DGNSRVR\:\:Ordinal_130=DGNSERVER_ISUSERMODIFIED
+DGNSRVR\:\:Ordinal_131=DGNPRIVATE_GETPROFILESTRING
+DGNSRVR\:\:Ordinal_132=DGNPRIVATE_SETPROFILESTRING
+DGNSRVR\:\:Ordinal_133=DGNPRIVATE_POSTDRAGONMSG
+DGNSRVR\:\:Ordinal_134=DGNPRIVATE_GETVOICEBARUIWINDOW
+DGNSRVR\:\:Ordinal_135=DGNPRIVATE_GETINTERPRETERWINDOW
+DGNSRVR\:\:Ordinal_136=DGNPRIVATE_LOGINVOICEBARUI
+DGNSRVR\:\:Ordinal_137=DGNPRIVATE_LOGININTERPRETER
+DGNSRVR\:\:Ordinal_138=DGNWORD_SETNAME
+DGNSRVR\:\:Ordinal_139=DGNSTATE_BUILDWORD
+DGNSRVR\:\:Ordinal_140=DGNSERVER_GETERRCALLBACK
+DGNSRVR\:\:Ordinal_141=DGNSERVER_SETERRCALLBACK
+DGNSRVR\:\:Ordinal_142=DGNTASKMAP_GETMENUINFO
+DGNSRVR\:\:Ordinal_143=DGNPRIVATE_CREATEUSER
+DGNSRVR\:\:Ordinal_144=DGNSERVER_GETPROP
+DGNSRVR\:\:Ordinal_145=DGNSERVER_SETPROP
+DGNSRVR\:\:Ordinal_146=DGNSERVER_INSTALLVOC
+DGNSRVR\:\:Ordinal_147=DGNSERVER_UNINSTALLVOC
+DGNSRVR\:\:Ordinal_148=DGNSERVER_CREATEUSERVOC
+DGNSRVR\:\:Ordinal_149=DGNSERVER_FINDUSERVOC
+DGNSRVR\:\:Ordinal_150=DGNSERVER_OPENUSERVOC
+DGNSRVR\:\:Ordinal_151=DGNPRIVATE_SETUSERPROFILESTRING
+DGNSRVR\:\:Ordinal_152=DGNPRIVATE_GETUSERPROFILESTRING
+DGNSRVR\:\:Ordinal_153=DGNINPUT_LOCKCOUNT
+DGNSRVR\:\:Ordinal_154=DGNPRIVATE_SETCAPTURE
+DGNSRVR\:\:Ordinal_155=DGNPRIVATE_RELEASECAPTURE
+DGNSRVR\:\:Ordinal_156=DGNPRIVATE_GETCAPTURE
+DGNSRVR\:\:Ordinal_157=DGNPRIVATE_VBREQUEST
+DGNSRVR\:\:Ordinal_158=DGNPRIVATE_VBREPLY
+DGNSRVR\:\:Ordinal_159=DGNPRIVATE_SETCOLLECT
+DGNSRVR\:\:Ordinal_160=DGNPRIVATE_CANCELCOLLECT
+DGNSRVR\:\:Ordinal_161=DGNSERVER_SETNOTIFYWINDOW
+DGNSRVR\:\:Ordinal_162=DGNWORD_EDITDLG
+DGNSRVR\:\:Ordinal_163=DGNWORD_ADDDLG
+DGNSRVR\:\:Ordinal_164=DGNPRIVATE_SETGLOBAL
+DGNSRVR\:\:Ordinal_165=DGNAP_CREATE
+DGNSRVR\:\:Ordinal_166=DGNDAEMON_COLLECTBEGIN
+DGNSRVR\:\:Ordinal_167=DGNDAEMON_COLLECTABORT
+DGNSRVR\:\:Ordinal_168=DGNPRIVATE_COLLECTBEGIN
+DGNSRVR\:\:Ordinal_169=DGNPRIVATE_VBDLGREPLY
+DGNSRVR\:\:Ordinal_170=DGNPRIVATE_GETPUNCTUATIONFLAGS
+DGNSRVR\:\:Ordinal_171=DGNPRIVATE_SETPUNCTUATIONFLAGS
+DGNSRVR\:\:Ordinal_172=DGNSERVER_GETDICTATIONMODE
+DGNSRVR\:\:Ordinal_173=DGNSERVER_SETDICTATIONMODE
+DGNSRVR\:\:Ordinal_174=DGNPRIVATE_GETCHOICELIST
+DGNSRVR\:\:Ordinal_175=DGNPRIVATE_RERECOGNIZE
+DGNSRVR\:\:Ordinal_176=DGNSERVER_GETLATESTUTT
+DGNSRVR\:\:Ordinal_177=DGNUTT_NEXT
+DGNSRVR\:\:Ordinal_178=DGNUTT_PREV
+DGNSRVR\:\:Ordinal_179=DGNPRIVATE_PUSHUTTHISTORY
+DGNSRVR\:\:Ordinal_180=DGNPRIVATE_POPUTTHISTORY
+DGNSRVR\:\:Ordinal_181=DGNPRIVATE_SETTOPCHOICE
+DGNSRVR\:\:Ordinal_182=DGNUTT_GETPROP
+DGNSRVR\:\:Ordinal_183=DGNUTT_SETPROP
+DGNSRVR\:\:Ordinal_184=DGNPRIVATE_CANCELRERECOGNIZE
+DGNSRVR\:\:Ordinal_185=DGNPRIVATE_GETRERECOGNIZERESULTS
+DGNSRVR\:\:Ordinal_186=DGNDAEMON_RERECOGNIZE
+DGNSRVR\:\:Ordinal_187=DGNSERVER_CONTEXTUPDATED
+DGNSRVR\:\:Ordinal_188=DGNPRIVATE_SETUTTMASTER
+DGNSRVR\:\:Ordinal_189=DGNPRIVATE_SETUTTMASTERSTATE
+DGNSRVR\:\:Ordinal_190=DGNSERVER_ACKUTTACTION
+DGNSRVR\:\:Ordinal_191=INISECTIONFINDITEM
+DGNSRVR\:\:Ordinal_192=DGNPRIVATE_LOCKUTTQUEUE
+DGNSRVR\:\:Ordinal_193=DGNDAEMON_STARTUTTPROCESSING
+DGNSRVR\:\:Ordinal_194=DGNUTT_FINDWORD
+DGNSRVR\:\:Ordinal_195=DGNTASKMAP_NOTIFYONDESTROY
+DGNSRVR\:\:Ordinal_196=DGNPRIVATE_STARTWRITINGSCRIPT
+DGNSRVR\:\:Ordinal_197=DGNPRIVATE_STOPWRITINGSCRIPT
+DGNSRVR\:\:Ordinal_198=DGNPRIVATE_STARTSCORING
+DGNSRVR\:\:Ordinal_199=DGNDAEMON_TIMERTICK
+DGNSRVR\:\:Ordinal_200=DGNSERVER_GETUSERVOCS
+DGNSRVR\:\:Ordinal_201=DGNPRIVATE_VBREQUESTDLG
+DGNSRVR\:\:Ordinal_202=DGNPRIVATE_STOPSCORING
+DGNSRVR\:\:Ordinal_203=DGNPRIVATE_SETUPREADINGSCRIPT
+DGNSRVR\:\:Ordinal_204=DGNPRIVATE_STOPREADINGSCRIPT
+DGNSRVR\:\:Ordinal_205=DGNPRIVATE_GETWRITINGFILENAME
+DGNSRVR\:\:Ordinal_206=DGNPRIVATE_GETREADINGFILENAME
+DGNSRVR\:\:Ordinal_207=DGNPRIVATE_GETSCORINGFILENAME
+DGNSRVR\:\:Ordinal_208=DGNPRIVATE_CLOSEINTERPRETER
+DGNSRVR\:\:Ordinal_209=DGNPRIVATE_SETMICPRESSTOTALKHOTK
+DGNSRVR\:\:Ordinal_210=DGNPRIVATE_SETMICTOGGLEONOFFHOTK
+DGNSRVR\:\:Ordinal_211=DGNPRIVATE_GETDDWINENGINEWINDOW
+DGNSRVR\:\:Ordinal_212=DGNPRIVATE_LOGINDDWINENGINE
+DGNSRVR\:\:Ordinal_213=DGNWORD_COPYDLG
+DGNSRVR\:\:Ordinal_214=DGNWORD_MOVEDLG
+DGNSRVR\:\:Ordinal_215=DGNWORD_FINDDLG
+DGNSRVR\:\:Ordinal_216=DGNPRIVATE_CLOSEDDWINENGINE
+DGNSRVR\:\:Ordinal_217=DGNPRIVATE_STARTDDWINENGINE
+DGNSRVR\:\:Ordinal_218=DGNSERVER_STARTVOICEBAR
+DGNSRVR\:\:Ordinal_219=DGNDAEMON_UPDATETASKMAP
+DGNSRVR\:\:Ordinal_220=DGNVOC_CREATETRAININGSTATE
+DGNSRVR\:\:Ordinal_221=DGNINPUT_NAMEFROMKEY
+DGNSRVR\:\:Ordinal_222=DGNPRIVATE_SETTIMEREVENT
+DGNSRVR\:\:Ordinal_223=DGNPRIVATE_KILLTIMEREVENT
+DGNSRVR\:\:Ordinal_224=DGNINPUT_STRTOEVENTS
+DGNSRVR\:\:Ordinal_225=DGNPRIVATE_ACKCAPTURE
+DGNSRVR\:\:Ordinal_226=DGNSERVER_ADDTRACKINGSTATE
+DGNSRVR\:\:Ordinal_227=DGNPRIVATE_SETRUNSCRIPTHOTKEY
+DGNSRVR\:\:Ordinal_228=DGNSERVER_SETCONTEXT
+DGNSRVR\:\:Ordinal_229=DGNSERVER_SETCLIENTNAME
+DGNSRVR\:\:Ordinal_230=DGNSERVER_DUMPDEBUGINFO
+DGNSRVR\:\:Ordinal_231=DGNDEBUG_SDPARGETLIST
+DGNSRVR\:\:Ordinal_232=DGNDEBUG_SDPARGETTYPE
+DGNSRVR\:\:Ordinal_233=DGNDEBUG_SDPARGETVALUE
+DGNSRVR\:\:Ordinal_234=DGNDEBUG_SDPARSETVALUE
+DGNSRVR\:\:Ordinal_235=DGNSERVER_SUGGESTEDCOMPUTATION
+DGNSRVR\:\:Ordinal_236=DGNSERVER_LISTEN
+DGNSRVR\:\:Ordinal_237=DGNSERVER_HEARDWORD
+DGNSRVR\:\:Ordinal_238=USERSTATE_SETHDRAGON
+DGNSRVR\:\:Ordinal_239=USERSTATE_HDRAGON
+DGNSRVR\:\:Ordinal_240=USERSTATE_GETLASTWORDLOCATION
+DGNSRVR\:\:Ordinal_241=USERSTATE_SETLASTWORDLOCATION
+DGNSRVR\:\:Ordinal_242=USERSTATE_REPORTERROR1
+DGNSRVR\:\:Ordinal_243=USERSTATE_REPORTERROR2
+DGNSRVR\:\:Ordinal_244=USERSTATE_REPORTERROR3
+DGNSRVR\:\:Ordinal_245=USERSTATE_ISCHOICELISTCAPTURING
+DGNSRVR\:\:Ordinal_246=USERSTATE_SETCHOICELISTCAPTURING
+DGNSRVR\:\:Ordinal_247=USERSTATE_GETNEXTPENDINGERROR
+DGNSRVR\:\:Ordinal_248=INISECTIONGETITEMINT
+DGNSRVR\:\:Ordinal_249=INISECTIONSETITEMINT
+DGNSRVR\:\:Ordinal_250=INISECTIONGETITEMSTRING
+DGNSRVR\:\:Ordinal_251=INISECTIONSETITEMSTRING
+DGNSRVR\:\:Ordinal_252=INISECTIONGETITEMCOUNT
+DGNSRVR\:\:Ordinal_253=INISECTIONGETITEMNAME
+DGNSRVR\:\:Ordinal_254=USERSTATE_INIFILEGET1
+DGNSRVR\:\:Ordinal_255=USERSTATE_INIFILEGET2
+DGNSRVR\:\:Ordinal_256=USERSTATE_INIFILEGET3
+DGNSRVR\:\:Ordinal_257=USERSTATE_INIFILESET1
+DGNSRVR\:\:Ordinal_258=USERSTATE_INIFILESET2
+DGNSRVR\:\:Ordinal_259=USERSTATE_INIFILESET3
+DGNSRVR\:\:Ordinal_260=USERSTATE_INIFILELOAD
+DGNSRVR\:\:Ordinal_261=USERSTATE_INIFILEUNLOAD
+DGNSRVR\:\:Ordinal_262=USERSTATE_INIFILESAVE
+DGNSRVR\:\:Ordinal_263=USERSTATE_INIFILEDELETE
+DGNSRVR\:\:Ordinal_264=USERSTATE_INIFILETEST1
+DGNSRVR\:\:Ordinal_265=USERSTATE_INIFILETEST2
+DGNSRVR\:\:Ordinal_266=USERSTATE_INIFILETEST3
+DGNSRVR\:\:Ordinal_267=USERSTATE_INIFILEGETMIN
+DGNSRVR\:\:Ordinal_268=USERSTATE_INIFILEGETMAX
+DGNSRVR\:\:Ordinal_269=USERSTATE_INIFILEGETDEFAULT1
+DGNSRVR\:\:Ordinal_270=USERSTATE_INIFILEGETDEFAULT3
+DGNSRVR\:\:Ordinal_271=DGNINPUT_RESUMEPLAYBACK
+DGNSRVR\:\:Ordinal_272=DGNPRIVATE_MICSETSLEEPING
+DGNSRVR\:\:Ordinal_273=DGNPRIVATE_MICSETFAKE
+DGNSRVR\:\:Ordinal_274=DGNAP_UNLOCK
+DGNSRVR\:\:Ordinal_275=DGNAP_LOCK
+DGNSRVR\:\:Ordinal_276=DGNSERVER_GETMODIFICATIONFLAGS
+DGNSRVR\:\:Ordinal_277=DGNPRIVATE_SETDICTATIONSTATE
+DGNSRVR\:\:Ordinal_278=DGNPRIVATE_USERSELECTION
+DGNSRVR\:\:Ordinal_279=DGNPRIVATE_RECOGNIZE
+DGNSRVR\:\:Ordinal_280=DGNSTATE_GETNAMES
+DGNSRVR\:\:Ordinal_281=DGNPRIVATE_GETUTTDISTANCES
+DGNSRVR\:\:Ordinal_282=INISECTIONGETITEMMIN
+DGNSRVR\:\:Ordinal_283=INISECTIONGETITEMMAX
+DGNSRVR\:\:Ordinal_284=INISECTIONGETITEMDEFAULT
+DGNSRVR\:\:Ordinal_285=DGNTASKMAP_GETTASKMAP
+DGNSRVR\:\:Ordinal_286=DGNPRIVATE_ISPHYSUSERVOCLOADED
+DGNSRVR\:\:Ordinal_287=DGNDAEMON_MICSETPARAMETERS
+DGNSRVR\:\:Ordinal_288=DGNSERVER_GETUSERCHANGEDCOUNT
+DGNSRVR\:\:Ordinal_289=DGNPRIVATE_GETUTTRECOGSTATES
+DGNSRVR\:\:Ordinal_290=DGNWORD_DESTROYBUTLEAVE0MODEL
+DGNSRVR\:\:Ordinal_291=DGNVOC_DESTROY
+DGNSRVR\:\:Ordinal_292=DGNSERVER_CREATEVOC
+DGNSRVR\:\:Ordinal_293=DGNPRIVATE_GETUSERFILEINFO
+DGNSRVR\:\:Ordinal_294=DGNPRIVATE_GETVOCFILEINFO
+DGNSRVR\:\:Ordinal_295=DGNPRIVATE_GETDRIVERVERSION
+DGNSRVR\:\:Ordinal_296=DGNPRIVATE_STARTREADINGSCRIPT
+DGNSRVR\:\:Ordinal_297=DGNPRIVATE_TOGGLECHANNELCLAIM
+DGNSRVR\:\:Ordinal_298=DGNPRIVATE_SAVEUSER
+DGNSRVR\:\:Ordinal_299=DGNPRIVATE_RESTOREUSER
+DGNSRVR\:\:Ordinal_300=DGNDAEMON_TOGGLECHANNELCLAIM
+DGNSRVR\:\:Ordinal_301=DGNPRIVATE_VBDIALOG
+DGNSRVR\:\:Ordinal_302=DGNPRIVATE_WORDDELETETRAINING
+DGNSRVR\:\:Ordinal_303=DGNUTT_GETWORDNAME
+DGNSRVR\:\:Ordinal_304=DGNUTT_GETWORDANDOPEN
+DGNSRVR\:\:Ordinal_305=DGNSERVER_USERHASBACKUP
+DGNSRVR\:\:Ordinal_306=DGNSERVER_GETTRACKINGVOC
+DGNSRVR\:\:Ordinal_307=DGNSERVER_CLOSEALLVOCS
+DGNSRVR\:\:Ordinal_308=DGNSERVER_CLOSEALLUSERVOCS
+DGNSRVR\:\:Ordinal_309=DGNWORD_GETWORDDATA
+DGNSRVR\:\:Ordinal_310=DGNSERVER_STRCMP
+DGNSRVR\:\:Ordinal_311=DGNSERVER_STRNCMP
+DGNSRVR\:\:Ordinal_312=DGNSERVER_STRCMPI
+DGNSRVR\:\:Ordinal_313=DGNSERVER_STRNCMPI
+DGNSRVR\:\:Ordinal_314=DGNSERVER_TOUPPER
+DGNSRVR\:\:Ordinal_315=DGNSERVER_STRUPR
+DGNSRVR\:\:Ordinal_316=DGNSERVER_TOLOWER
+DGNSRVR\:\:Ordinal_317=DGNSERVER_STRLWR
+DGNSRVR\:\:Ordinal_318=DGNPRIVATE_LOGERROR
+DGNSRVR\:\:Ordinal_319=WEP
+DGNSRVR\:\:Ordinal_320=LIBMAIN
+DGNSRVR\:\:Ordinal_321=DGNSERVER_STOPLISTENING
+DGNSRVR\:\:Ordinal_322=@GETMSGHOOK$QIUIL
+DGNSRVR\:\:Ordinal_323=@JPLAYHOOK$QIUSUL
+DGNSRVR\:\:Ordinal_324=@JRECORDHOOK$QIUSUL
+DGNSRVR\:\:Ordinal_325=@KEYHOOK$QIUSUL
+DGNSRVR\:\:Ordinal_326=@MOUSEHOOK$QIUIL
+DGNSRVR\:\:Ordinal_327=_mySdErrorHandler
+DGNSRVR\:\:Ordinal_328=@CWHOOK$QIUSN7CWH_MSG
+DGNSRVR\:\:Ordinal_329=@CBTHOOK$QIUSUL
+DGNSRVR\:\:Ordinal_330=_UttFileEventHandler
+DGNSRVR\:\:Ordinal_331=_watchDog
+DGNSRVR\:\:Ordinal_332=_watchDogForListMatches
+DGNSRVR\:\:Ordinal_333=_UttEventHandler
+DGNSRVR\:\:Ordinal_334=@MultimediaCallback$qi
+DGNSRVR\:\:Ordinal_335=@RPCWNDPROC$QPX6HWND__UIUIL
+DGNSRVR\:\:Ordinal_338=DGNPRIVATE_GETDAEMONTASK
+DGNSRVR\:\:Ordinal_339=DGNPRIVATE_SETMIC
+DGNSRVR\:\:Ordinal_340=DGNPRIVATE_HAVEMEMFORUSER
+DGNSRVR\:\:Ordinal_341=DGNPRIVATE_UPGRADEUSER
+DGNSRVR\:\:Ordinal_342=DGNSERVER_STRNCMPII
+DGNSRVR\:\:Ordinal_343=DGNSERVER_STRCMPII
+DGNSRVR\:\:Ordinal_344=DGNSERVER_STRMATCHII
+DGNSRVR\:\:Ordinal_345=DGNSERVER_EXTENDEDTRACKING
+DGNSRVR\:\:Ordinal_346=DGNPRIVATE_ENCRYPT
+DGNSRVR\:\:Ordinal_347=DGNPRIVATE_DECRYPT
+DGNSRVR\:\:Ordinal_348=USERSTATE_REPORTERROR4
+DGNSRVR\:\:Ordinal_349=DGNSERVER_OPENUSERVOCFROMMODULE
+DGNSRVR\:\:Ordinal_350=DGNSERVER_GETNOTIFYWINDOW
+DGNSRVR\:\:Ordinal_351=DGNSERVER_LINKUSERCRVOC
+DGNSRVR\:\:Ordinal_352=DGNVOC_COPYDLG
+DGNSRVR\:\:Ordinal_353=DGNVOC_MOVEDLG
+DGNSRVR\:\:Ordinal_354=DGNVOC_DELETEDLG
+DGNSRVR\:\:Ordinal_355=DGNUTT_GETCRWORD
+DGNSRVR\:\:Ordinal_356=DGNUTT_GETCRSENTENCE
+DGNSRVR\:\:Ordinal_357=DGNUTT_GETCRINFO
+DGNSRVR\:\:Ordinal_358=DGNSTATE_HASSENTENCES
+DGNSRVR\:\:Ordinal_359=DGNPRIVATE_GETCRCHOICELIST
+DGNSRVR\:\:Ordinal_360=DGNGROUPBOXWNDPROC
+DGNSRVR\:\:Ordinal_361=DGNPROMPTWNDPROC
+DGNSRVR\:\:Ordinal_362=DGNFILEBUTTONWNDPROC
+DGNSRVR\:\:Ordinal_363=DGNSLIDECONTROLWNDPROC
+DGNSRVR\:\:Ordinal_364=LASTRECOGNIZEDWORDWNDPROC
+DGNSRVR\:\:Ordinal_365=MICBUTTONWNDPROC
+DGNSRVR\:\:Ordinal_366=DGNHOTKEYEDITWNDPROC
+DGNSRVR\:\:Ordinal_367=INISECTIONGETITEMDEFAULTSTRING
+DGNSRVR\:\:Ordinal_368=DGNUTT_FINDSENTENCE
+DGNSRVR\:\:Ordinal_369=DGNPRIVATE_SETTOPCRCHOICE
+DGNSRVR\:\:Ordinal_370=DGNPRIVATE_GETCRNAME
+DGNSRVR\:\:Ordinal_371=DGNSENTENCE_INSTANTIATE
+DGNSRVR\:\:Ordinal_372=DGNPRIVATE_SETTOPQTCHOICE
+DGNSRVR\:\:Ordinal_373=DGNPRIVATE_GETQTNAME
+DGNSRVR\:\:Ordinal_374=DGNUTT_FINDPHRASE
+DGNSRVR\:\:Ordinal_375=DGNUTT_GETPHRASEPREFIX
+DGNSRVR\:\:Ordinal_376=DGNPRIVATE_USESYSTEMCOLORS
+DGNSRVR\:\:Ordinal_377=DGNPRIVATE_LEARNCORRECTEDWORDS
+DGNSRVR\:\:Ordinal_378=DGNSERVER_REJECTPARTIALSENTENCE
+DGNSRVR\:\:Ordinal_379=DGNDAEMON_GETSTATISTICS
+DGNSRVR\:\:Ordinal_380=DGNDAEMON_RESETSTATISTICS
+DGNSRVR\:\:Ordinal_381=DGNPRIVATE_LOADOVERRIDES
+DGNSRVR\:\:Ordinal_382=DGNSERVER_VALIDATECURRENTUSER
+DGNSRVR\:\:Ordinal_383=DGNPRIVATE_CHECKUPGRADEUSER
+DGNSRVR\:\:Ordinal_384=DGNUTT_GETCRFRAGMENTS
+DGNSRVR\:\:Ordinal_385=DGNUTT_WRITE
+DGNSRVR\:\:Ordinal_386=DGNPRIVATE_PLAYSYSTEMSTRING
+DGNSRVR\:\:Ordinal_387=DGNPRIVATE_SETNOPREFILTERSTATE
+DGNSRVR\:\:Ordinal_388=DGNINPUT_RESETKEYCOUNT
+DGNSRVR\:\:Ordinal_389=DGNINPUT_ADDKEYCOUNT
+DGNSRVR\:\:Ordinal_390=DGNINPUT_GETKEYCOUNT
+DGNSRVR\:\:Ordinal_391=DGNSTATE_COPYWORDPROPS
+DGNSRVR\:\:Ordinal_392=DGNSERVER_SETLASTRECOGNIZEDWORD
+DGNSRVR\:\:Ordinal_393=DGNPRIVATE_ISTASKALLOWED
+DGNSRVR\:\:Ordinal_394=DGNPRIVATE_ENABLETASK
+DGNSRVR\:\:Ordinal_395=DGNPRIVATE_ISWINNT
+DGNSRVR\:\:Ordinal_396=DGNPRIVATE_ISWIN40
+DGNSRVR\:\:Ordinal_397=DGNDAEMON_HOOK32NOTIFY
+DGNSRVR\:\:Ordinal_398=DGNTASKMAP_GETACTIVEANDFOCUS
+DGNSRVR\:\:Ordinal_399=DGNPRIVATE_TTSPLAYSTRING
+DGNSRVR\:\:Ordinal_400=DGNPRIVATE_TTSABORT
+DGNSRVR\:\:Ordinal_401=DGNPRIVATE_TTSDOOPTIONSDLG
+DGNSRVR\:\:Ordinal_402=DGNDAEMON_TTSCOMPLETE
+DGNSRVR\:\:Ordinal_403=DGNPRIVATE_TTSISENABLED
+DGNSRVR\:\:Ordinal_404=DGNPRIVATE_TTSISBUSY
+DGNSRVR\:\:Ordinal_405=DGNPRIVATE_GETTTSSERVERVERSION
+DGNSRVR\:\:Ordinal_406=DGNWORD_BUILDDLG
+DGNSRVR\:\:Ordinal_407=DGNSTATE_BUILDPRON
+DGNSRVR\:\:Ordinal_408=DGNVOC_LOADPRONGUESS
+DGNSRVR\:\:Ordinal_409=DGNVOC_UNLOADPRONGUESS
+DGNSRVR\:\:Ordinal_410=DGNSERVER_ISPRONGUESSERLOADED
+DGNSRVR\:\:Ordinal_411=DGNSERVER_HASPRONDATA
+DGNSRVR\:\:Ordinal_412=DGNSERVER_SETTASK
+DGNSRVR\:\:Ordinal_413=DGNDAEMON_GETSTATE
+DGNSRVR\:\:Ordinal_414=DGNINPUT_GETPLAYBACKDELAYRANGE
+DGNSRVR\:\:Ordinal_415=DGNINPUT_GETPLAYBACKDELAY
+DGNSRVR\:\:Ordinal_416=DGNINPUT_SETPLAYBACKDELAY
+DRAGDEV\:\:Ordinal_1=WEP
+DRAGDEV\:\:Ordinal_2=FEP_WAVE_GETNEWUTTERANCE_ERROR
+DRAGDEV\:\:Ordinal_3=FEP_MICON_ERROR
+DRAGDEV\:\:Ordinal_4=DEVOPEN
+DRAGDEV\:\:Ordinal_5=DEVCLOSE
+DRAGDEV\:\:Ordinal_6=DEVREAD
+DRAGDEV\:\:Ordinal_7=GETDEVERROR
+DRAGDEV\:\:Ordinal_8=GETNUMUNREADITEMS
+DRAGDEV\:\:Ordinal_9=FEP_MICON
+DRAGDEV\:\:Ordinal_10=FEP_STOP
+DRAGDEV\:\:Ordinal_11=FEP_STATUS
+DRAGDEV\:\:Ordinal_12=FEP_LISTEN
+DRAGDEV\:\:Ordinal_13=FEP_CALPARS
+DRAGDEV\:\:Ordinal_14=FEP_GETPAR
+DRAGDEV\:\:Ordinal_15=FEP_SETPAR
+DRAGDEV\:\:Ordinal_16=FEP_SAMPLE
+DRAGDEV\:\:Ordinal_17=FEP_RECORD
+DRAGDEV\:\:Ordinal_18=FEP_PLAY
+DRAGDEV\:\:Ordinal_19=FEP_FLUSHQUE
+DRAGDEV\:\:Ordinal_20=FEP_BEGSIL
+DRAGDEV\:\:Ordinal_21=FEP_LPKT
+DRAGDEV\:\:Ordinal_22=ERR_SCODE
+DRAGDEV\:\:Ordinal_23=FEP_DEFPAR
+DRAGDEV\:\:Ordinal_24=FEP_ADDBUFFER_ERROR
+DRAGDEV\:\:Ordinal_25=SENDWAVEBUF
+DRAGDEV\:\:Ordinal_26=OPENWAVERECORD
+DRAGDEV\:\:Ordinal_27=CLOSEWAVERECORD
+DRAGDEV\:\:Ordinal_28=FEP_SETMICCALLBACK
+DRAGDEV\:\:Ordinal_29=FEP_SETMICVOLUME
+DRAGDEV\:\:Ordinal_30=FEP_GETMICVOLUME
+DRAGDEV\:\:Ordinal_31=FEPGETCHANNELINFO
+DRAGDEV\:\:Ordinal_32=FEPSETSPECIFICDEVICE
+DRAGDEV\:\:Ordinal_33=FEPGETUTTMEASURE
+DRAGDEV\:\:Ordinal_34=FEP_OPENPLAY
+DRAGDEV\:\:Ordinal_35=FEP_CLOSEPLAY
+DRAGDEV\:\:Ordinal_36=FEP_ADDBUFFER
+DRAGDEV\:\:Ordinal_37=FEP_STARTPLAY
+DRAGDEV\:\:Ordinal_38=FEP_STOPPLAY
+DRAGDEV\:\:Ordinal_39=FEP_STATUSPLAY
+DRAGDEV\:\:Ordinal_40=FEP_RESETPLAY
+DRAGDEV\:\:Ordinal_41=FEP_OPENPLAY_ERROR
+DRAGDEV\:\:Ordinal_42=FEP_WAVE_OPEN
+DRAGDEV\:\:Ordinal_43=FEP_WAVE_CLOSE
+DRAGDEV\:\:Ordinal_44=FEP_WAVE_GETWAVEWITHINDEX
+DRAGDEV\:\:Ordinal_45=FEP_WAVE_SAVEUTTWAVE
+DRAGDEV\:\:Ordinal_46=FEP_WAVE_READUTTWAVE
+DRAGDEV\:\:Ordinal_47=FEP_WAVE_PLAYBACK
+DRAGDEV\:\:Ordinal_48=FEP_WAVE_ALLOCWAVE
+DRAGDEV\:\:Ordinal_49=FEP_WAVE_FREEWAVE
+DRAGDEV\:\:Ordinal_50=FEP_WAVE_PLAYUTTERANCE
+DRAGDEV\:\:Ordinal_51=FEP_WAVE_GETNEWUTTERANCE
+DRAGDEV\:\:Ordinal_52=FEP_WAVE_GETLASTUTTERANCE
+DRAGDEV\:\:Ordinal_53=FEP_WAVE_GETUTTERANCEWITHINDEX
+DRAGDEV\:\:Ordinal_54=FEP_WAVE_GETWORKINGBUFFER
+DRAGDEV\:\:Ordinal_55=FEP_WAVE_GETFRAMECOUNT
+DRAGDEV\:\:Ordinal_56=FEP_WAVE_GETHEADER
+DRAGDEV\:\:Ordinal_57=FEP_GETHINSTANCE
+DRAGDEV\:\:Ordinal_58=ERR_SCODE_ERROR
+DRAGDEV\:\:Ordinal_59=FEP_WAVE_READUTTWAVE_ERROR
+DRAGDEV\:\:Ordinal_60=DEVOPEN_ERROR
+DRAGDEV\:\:Ordinal_61=FEP_PLAY_ERROR
+DRAGDEV\:\:Ordinal_62=FEP_WAVE_SAVEUTTWAVE_ERROR
+DRAGDEV\:\:Ordinal_63=GETDEVERROR_ERROR
+DRAGDEV\:\:Ordinal_64=DEVCLOSE_ERROR
+DRAGDEV\:\:Ordinal_65=FEP_STOPPLAY_ERROR
+DRAGDEV\:\:Ordinal_66=FEP_STATUSPLAY_ERROR
+DRAGDEV\:\:Ordinal_67=OPENWAVERECORD_ERROR
+DRAGDEV\:\:Ordinal_68=FEP_SETMICCALLBACK_ERROR
+DRAGDEV\:\:Ordinal_69=FEP_RECORD_ERROR
+DRAGDEV\:\:Ordinal_70=FEP_WAVE_GETWAVEWITHINDEX_ERROR
+DRAGDEV\:\:Ordinal_71=FEP_LPKT_ERROR
+DRAGDEV\:\:Ordinal_72=FEP_SETPAR_ERROR
+DRAGDEV\:\:Ordinal_73=FEP_SAMPLE_ERROR
+DRAGDEV\:\:Ordinal_74=FEP_STARTPLAY_ERROR
+DRAGDEV\:\:Ordinal_75=FEP_GETHINSTANCE_ERROR
+DRAGDEV\:\:Ordinal_76=FEP_WAVE_GETWORKINGBUFFER_ERROR
+DRAGDEV\:\:Ordinal_77=SENDWAVEBUF_ERROR
+DRAGDEV\:\:Ordinal_78=FEP_STATUS_ERROR
+DRAGDEV\:\:Ordinal_79=FEP_STOP_ERROR
+DRAGDEV\:\:Ordinal_80=CLOSEWAVERECORD_ERROR
+DRAGDEV\:\:Ordinal_81=FEP_CALPARS_ERROR
+DRAGDEV\:\:Ordinal_82=FEPGETCHANNELINFO_ERROR
+DRAGDEV\:\:Ordinal_83=FEP_CLOSEPLAY_ERROR
+DRAGDEV\:\:Ordinal_84=FEP_WAVE_OPEN_ERROR
+DRAGDEV\:\:Ordinal_85=FEP_WAVE_PLAYUTTERANCE_ERROR
+DRAGDEV\:\:Ordinal_86=FEP_WAVE_GETLASTUTTERANCE_ERROR
+DRAGDEV\:\:Ordinal_87=FEP_WAVE_GETFRAMECOUNT_ERROR
+DRAGDEV\:\:Ordinal_88=FEP_WAVE_GETHEADER_ERROR
+DRAGDEV\:\:Ordinal_89=GETNUMUNREADITEMS_ERROR
+DRAGDEV\:\:Ordinal_90=FEP_GETMICVOLUME_ERROR
+DRAGDEV\:\:Ordinal_91=FEP_GETPAR_ERROR
+DRAGDEV\:\:Ordinal_92=FEPSETSPECIFICDEVICE_ERROR
+DRAGDEV\:\:Ordinal_93=FEP_RESETPLAY_ERROR
+DRAGDEV\:\:Ordinal_94=FEP_SETMICVOLUME_ERROR
+DRAGDEV\:\:Ordinal_95=FEP_DEFPAR_ERROR
+DRAGDEV\:\:Ordinal_96=FEP_LISTEN_ERROR
+DRAGDEV\:\:Ordinal_97=FEP_BEGSIL_ERROR
+DRAGDEV\:\:Ordinal_98=LIBMAIN
+DRAGDEV\:\:Ordinal_99=FEP_FLUSHQUE_ERROR
+DRAGDEV\:\:Ordinal_100=FEP_WAVE_PLAYBACK_ERROR
+DRAGDEV\:\:Ordinal_101=FEP_WAVE_CLOSE_ERROR
+DRAGDEV\:\:Ordinal_102=FEPGETUTTMEASURE_ERROR
+DRAGDEV\:\:Ordinal_103=DEVREAD_ERROR
+DRAGDEV\:\:Ordinal_104=FEP_WAVE_ALLOCWAVE_ERROR
+DRAGDEV\:\:Ordinal_105=FEP_WAVE_GETUTTERANCEWITHINDEX_E
+DRAGDEV\:\:Ordinal_106=FEP_WAVE_FREEWAVE_ERROR
+DRAGON\:\:Ordinal_1=WEP
+DRAGON\:\:Ordinal_2=@TIMERPROC$QUIUIUIUL
+DRAGON\:\:Ordinal_6=SDXDISPATCH
diff --git a/Ghidra/Features/Base/ghidra_scripts/FixPascalCallingConvention.java b/Ghidra/Features/Base/ghidra_scripts/FixPascalCallingConvention.java
new file mode 100644
index 0000000000..10d3f45b57
--- /dev/null
+++ b/Ghidra/Features/Base/ghidra_scripts/FixPascalCallingConvention.java
@@ -0,0 +1,280 @@
+
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+// Script ensures that the PASCAL calling convention replaces STDCALL
+// on function parameters and changes the stack reference for left-to-
+// right stacking.  On the way, it also ensures that all Thunks are
+// also converted.  This applies to Windows 16-bit apps.
+//
+//@category Repair
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import ghidra.app.script.GhidraScript;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.address.AddressSet;
+import ghidra.program.model.data.GenericCallingConvention;
+import ghidra.program.model.listing.Function;
+import ghidra.program.model.listing.FunctionIterator;
+import ghidra.program.model.listing.FunctionManager;
+import ghidra.program.model.listing.Parameter;
+import ghidra.program.model.listing.ParameterImpl;
+import ghidra.program.model.listing.VariableStorage;
+import ghidra.program.model.pcode.Varnode;
+import ghidra.program.model.symbol.SourceType;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.exception.InvalidInputException;
+
+public class FixPascalCallingConvention extends GhidraScript {
+
+	private static final String PASCAL16FAR = "__pascal16far";
+
+	private int cntFnsUpdated;
+	private int cntParamsTotal;
+	private int cntParamsReplaced;
+	private int cntConvertionTotal;
+	private int cntConvertionChanged;
+
+	private List<String> warningMessages = new ArrayList<String>();
+
+	@Override
+	public void run() throws Exception {
+
+		// reset for this run
+		cntConvertionTotal = 0;
+		cntConvertionChanged = 0;
+		cntFnsUpdated = 0;
+		cntParamsTotal = 0;
+		cntParamsReplaced = 0;
+
+		warningMessages.clear();
+
+		if (currentProgram != null) {
+			FunctionManager fnMgr = currentProgram.getFunctionManager();
+			if (fnMgr == null) {
+				return;
+			}
+
+			Iterator<Function> functions = null;
+
+			// add function if pointing at its entry point ...
+			if (isAddressAtFunctionStart(fnMgr, currentAddress)) {
+				functions = fnMgr.getFunctionsOverlapping(new AddressSet(currentAddress));
+			}
+
+			// ... if not pointing at start of any function, try those currently selected
+			// ...
+			if (((functions == null) || !functions.hasNext()) && (currentSelection != null)) {
+				functions = fnMgr.getFunctionsOverlapping(currentSelection);
+			}
+
+			// ... otherwise, choose them all
+			if ((functions == null) || !functions.hasNext()) {
+				functions = fnMgr.getFunctions(true);
+			}
+
+			// update details
+			doRun(functions);
+
+			// build popup information
+			String buf = "Update " + cntConvertionChanged
+					+ " calling convertions out of " + cntConvertionTotal + " to " + PASCAL16FAR
+					+ ".\n\nUpdated " + cntFnsUpdated + " functions having " + cntParamsReplaced
+					+ " parameters reversed out of " + cntParamsTotal + " parameters found.";
+			if (!warningMessages.isEmpty()) {
+				buf = buf + "\n\n" + String.join("\n\n", warningMessages);
+			}
+
+			popup(buf);
+
+		}
+	}
+
+	/**
+	 * @param fnMgr
+	 * @param address
+	 * @return
+	 */
+	private boolean isAddressAtFunctionStart(FunctionManager fnMgr, Address address) {
+		boolean isAtStart = false;
+
+		if ((address != null) && fnMgr.isInFunction(address)) {
+			Function func = fnMgr.getFunctionContaining(address);
+			isAtStart = ((func != null) && (func.getEntryPoint().compareTo(address) == 0));
+		}
+
+		return isAtStart;
+	}
+
+	/**
+	 * Do for all function in program
+	 */
+	protected void doRun() {
+		doRun(currentProgram.getFunctionManager().getFunctions(true));
+	}
+
+	/**
+	 * @param functions
+	 */
+	private void doRun(Iterator<Function> functions) {
+		while (functions.hasNext()) {
+			if ((getMonitor() != null) && getMonitor().isCancelled()) {
+				return;
+			}
+
+			doRun(functions.next());
+		}
+	}
+
+	/**
+	 * Do for individually identified function
+	 *
+	 * @param func this function
+	 * @throws InvalidInputException
+	 */
+	protected void doRun(Function func) {
+
+		try {
+			println("Before: " + func.getName() + ": " + func.getCallingConventionName()
+					+ " and isExternal()=" + func.isExternal() + ", isThunk()=" + func.isThunk()
+					+ getDescription(func));
+
+			if (!func.getCallingConventionName().contains(GenericCallingConvention.pascal.name())
+					&& (func.isExternal() || func.isThunk())) {
+				try {
+					++cntConvertionTotal;
+					func.setCallingConvention(PASCAL16FAR);
+					++cntConvertionChanged;
+				} catch (InvalidInputException e) {
+					warningMessages.add("Failed to change function '" + func.getName() + "' from "
+							+ func.getCallingConventionName() + " to " + PASCAL16FAR + ".");
+				}
+			}
+
+			// ensure External and Thunks were updated above!
+			if (!func.getCallingConventionName().contains(GenericCallingConvention.pascal.name())) {
+				return;
+			}
+
+			// only applicable to functions with 2 or more parameters
+			int paramCnt = func.getParameterCount();
+			if (paramCnt < 2) {
+				return;
+			}
+
+			int firstLoc = func.getParameter(0).getStackOffset();
+			int lastLoc = func.getParameter(paramCnt - 1).getStackOffset();
+			// is already reversed
+			if (lastLoc < firstLoc) {
+				return;
+			}
+
+			++cntFnsUpdated;
+
+			List<ParameterImpl> newParams = new ArrayList<>();
+
+			for (int paramPos = paramCnt - 1; paramPos >= 0; --paramPos) {
+				++cntParamsTotal;
+				Parameter param = func.getParameter(paramPos);
+				Varnode varnode = param.getLastStorageVarnode();
+				Address addr = varnode.getAddress();
+				if (!addr.isStackAddress()) {
+					println("Param '" + param.getName() + "' isn't on the stack!");
+					continue;
+				}
+
+				try {
+					VariableStorage storage = new VariableStorage(currentProgram, firstLoc,
+							varnode.getSize());
+//				if (param instanceof ParameterDB) {
+//					ParameterDB paramDB = (ParameterDB) param;
+//					paramDB.setDynamicStorage(storage);
+//				} else {
+//					println("SCREWED");
+//				}
+
+					ParameterImpl pi = new ParameterImpl(param.getName(), param.getDataType(),
+							storage, currentProgram);
+
+					newParams.add(pi);
+
+					firstLoc += varnode.getSize();
+
+					func.removeParameter(paramPos); // Had to use!
+				} catch (InvalidInputException e) {
+					warningMessages.add("Unable to adjust storage location for function "
+							+ func.getName() + ", parameter " + param.getName() + ".");
+				}
+			}
+
+			SourceType source = func.getSignatureSource();
+			StringBuffer buf = new StringBuffer();
+			for (int paramPos = paramCnt - 1; paramPos >= 0; --paramPos) {
+				ParameterImpl param = newParams.get(paramPos);
+				try {
+					buf.append(" ").append(param.getName()).append("[")
+							.append(param.getLastStorageVarnode().toString()).append("]");
+					func.setCustomVariableStorage(true); // TODO: should not need to be "Custom"!
+					func.addParameter(param, source); // Had to use!
+
+					++cntParamsReplaced;
+				} catch (DuplicateNameException | InvalidInputException e) {
+					warningMessages.add("Failed to reinsert function " + func.getName()
+							+ " parameter " + param.getName() + ".");
+				}
+			}
+			println("Params: " + buf.toString());
+
+		} finally {
+			println(" After: " + func.getName() + ":" + getDescription(func));
+		}
+
+//		The code below failed.
+//		try {
+//			func.replaceParameters(newParams, FunctionUpdateType.CUSTOM_STORAGE, true, func.getSignatureSource());
+//			cntParamsReplaced += newParams.size();
+//			++cntTotalFns;
+//			println(" After: " + func.getName() + ":" + getDesc(func));
+//		}
+//		catch (InvalidInputException e) {
+//			println("Failed to replace params for " + func.getName() + "@" + func.getEntryPoint() + ":" +
+//					e.toString());
+//			try {
+//				func.replaceParameters(newParams, FunctionUpdateType.CUSTOM_STORAGE, true, func.getSignatureSource());
+//			}
+//			catch (InvalidInputException e2) {
+//				println("Failed to replace params for " + func.getName() + "@" + func.getEntryPoint() + ":" +
+//						e2.toString());
+//			}
+//		}
+	}
+
+	/**
+	 * @param f Function object
+	 * @return string to print out
+	 */
+	private static String getDescription(Function f) {
+		StringBuilder s = new StringBuilder();
+		for (int i = 0; i < f.getParameters().length; i++) {
+			Parameter p = f.getParameter(i);
+			s.append(" ").append(p.getName()).append("[")
+					.append(p.getLastStorageVarnode().toString()).append("]");
+		}
+		return s.toString();
+	}
+
+}
diff --git a/Ghidra/Features/Base/ghidra_scripts/FixWin16LibraryFunctionNames.java b/Ghidra/Features/Base/ghidra_scripts/FixWin16LibraryFunctionNames.java
new file mode 100644
index 0000000000..6a8bba9021
--- /dev/null
+++ b/Ghidra/Features/Base/ghidra_scripts/FixWin16LibraryFunctionNames.java
@@ -0,0 +1,171 @@
+
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+// Script ensures that the PASCAL calling convention replaces STDCALL
+// on function parameters and changes the stack reference for left-to-
+// right stacking.  On the way, it also ensures that all Thunks are
+// also converted.  This applies to Windows 16-bit apps.
+//
+//@category Repair
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map.Entry;
+
+import generic.jar.ResourceFile;
+
+import java.util.Properties;
+
+import ghidra.app.script.GhidraScript;
+import ghidra.framework.Application;
+import ghidra.program.model.listing.Function;
+import ghidra.program.model.listing.FunctionIterator;
+import ghidra.program.model.listing.FunctionManager;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.exception.InvalidInputException;
+
+public class FixWin16LibraryFunctionNames extends GhidraScript {
+
+	private static HashMap<String, String> fnNameMap = new HashMap<>();
+	private static long fnNameMapModified = 0;
+
+	private int cntFilenamesTotal;
+	private int cntFilenamesChanged;
+
+	private List<String> warningMessages = new ArrayList<String>();
+
+	@Override
+	public void run() throws Exception {
+
+		// reset for this run
+		cntFilenamesTotal = 0;
+		cntFilenamesChanged = 0;
+
+		warningMessages.clear();
+
+		if (currentProgram != null) {
+			FunctionManager fnMgr = currentProgram.getFunctionManager();
+			if (fnMgr == null) {
+				return;
+			}
+
+			doRun(fnMgr.getFunctions(true));
+			doRun(fnMgr.getExternalFunctions());
+
+			// build popup information
+			String buf = "Updated " + cntFilenamesChanged + " out of " + cntFilenamesTotal + " functions found.";
+			if (!warningMessages.isEmpty()) {
+				buf = buf + "\n\n" + String.join("\n\n", warningMessages);
+			}
+
+			popup(buf);
+
+		}
+	}
+
+	/**
+	 * @param functions
+	 */
+	private void doRun(FunctionIterator functions) {
+		while (functions.hasNext()) {
+			if ((getMonitor() != null) && getMonitor().isCancelled()) {
+				return;
+			}
+
+			doRun(functions.next());
+		}
+	}
+
+	/**
+	 * Do for individually identified function
+	 *
+	 * @param func this function
+	 * @throws InvalidInputException
+	 */
+	protected void doRun(Function func) {
+
+//		println("Before: " + func.getName() + ": " + func.getCallingConventionName()
+//				+ " and isExternal()=" + func.isExternal() + ", isThunk()=" + func.isThunk()
+//				+ getDescription(func));
+
+		String updatedName = null;
+		String currentName = null;
+		try {
+			currentName = func.getName();
+			updatedName = translateFunctionName(func);
+			if (!updatedName.contentEquals(currentName)) {
+				++cntFilenamesTotal;
+				func.setName(updatedName, func.getSignatureSource());
+				++cntFilenamesChanged;
+				println("Renamed function " + currentName + " to " + updatedName);
+			}
+		} catch (DuplicateNameException | InvalidInputException e) {
+			warningMessages.add("Could not rename function " + currentName + " to " + updatedName + ".  Error "
+					+ e.getStackTrace());
+		}
+
+//		println(" After: " + func.getName() + ":" + getDescription(func));
+	}
+
+	/**
+	 * @param f Function object
+	 * @return string to print out
+	 */
+//	private static String getDescription(Function f) {
+//		StringBuilder s = new StringBuilder();
+//		for (int i = 0; i < f.getParameters().length; i++) {
+//			Parameter p = f.getParameter(i);
+//			s.append(" ").append(p.getName()).append("[")
+//					.append(p.getLastStorageVarnode().toString()).append("]");
+//		}
+//		return s.toString();
+//	}
+
+	/**
+	 * @param func current Function object
+	 * @return the updated function name
+	 */
+	private String translateFunctionName(Function func) {
+		String currentQualifiedName = func.getName(true);
+		String currentName = func.getName();
+
+		ResourceFile file = Application.findDataFileInAnyModule("FunctionNames.properties");
+		if (fnNameMap.isEmpty() || (file != null && file.lastModified() != fnNameMapModified)) {
+			// reload property file
+			Properties prop = new Properties();
+			try {
+				prop.load(file.getInputStream());
+				fnNameMapModified = file.lastModified();
+			} catch (Exception e) {
+				e.printStackTrace();
+				warningMessages.add("Some issue finding or loading file....!!! " + e.getMessage());
+				return currentName;
+			}
+			fnNameMap.clear();
+			for (final Entry<Object, Object> entry : prop.entrySet()) {
+				if (fnNameMap.containsKey(entry.getKey().toString())) {
+					warningMessages.add("Multiple translations exist for " + entry.getKey().toString());
+				}
+				fnNameMap.put(entry.getKey().toString(), entry.getValue().toString());
+			}
+		}
+
+		// return lookup value or default (original)
+		return fnNameMap.getOrDefault(currentQualifiedName, currentName);
+	}
+
+}
diff --git a/Ghidra/Features/Base/ghidra_scripts/MakeUnionsForLPs.java b/Ghidra/Features/Base/ghidra_scripts/MakeUnionsForLPs.java
new file mode 100644
index 0000000000..513d439358
--- /dev/null
+++ b/Ghidra/Features/Base/ghidra_scripts/MakeUnionsForLPs.java
@@ -0,0 +1,587 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+// Create unions to replace *32 pointer references
+//
+//@category Data Types
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+import ghidra.app.script.GhidraScript;
+import ghidra.app.script.GhidraState;
+import ghidra.app.services.DataTypeManagerService;
+import ghidra.app.util.cparser.C.ParseException;
+import ghidra.framework.plugintool.PluginTool;
+import ghidra.program.model.data.Array;
+import ghidra.program.model.data.CategoryPath;
+import ghidra.program.model.data.Composite;
+import ghidra.program.model.data.DataType;
+import ghidra.program.model.data.DataTypeComponent;
+import ghidra.program.model.data.DataTypeConflictHandler;
+import ghidra.program.model.data.DataTypeDependencyException;
+import ghidra.program.model.data.DataTypeManager;
+import ghidra.program.model.data.FunctionDefinition;
+import ghidra.program.model.data.FunctionDefinitionDataType;
+import ghidra.program.model.data.InternalDataTypeComponent;
+import ghidra.program.model.data.ParameterDefinition;
+import ghidra.program.model.data.Pointer;
+import ghidra.program.model.data.PointerDataType;
+import ghidra.program.model.data.PointerTypedef;
+import ghidra.program.model.data.Structure;
+import ghidra.program.model.data.StructureDataType;
+import ghidra.program.model.data.TypeDef;
+import ghidra.program.model.data.TypedefDataType;
+import ghidra.program.model.data.Union;
+import ghidra.program.model.data.UnionDataType;
+import ghidra.program.model.listing.Function;
+import ghidra.program.model.listing.FunctionIterator;
+import ghidra.program.model.listing.FunctionManager;
+import ghidra.program.model.listing.Parameter;
+import ghidra.program.model.listing.Variable;
+import ghidra.program.model.symbol.SourceType;
+import ghidra.util.InvalidNameException;
+import ghidra.util.Msg;
+import ghidra.util.exception.CancelledException;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.exception.InvalidInputException;
+
+public class MakeUnionsForLPs extends GhidraScript {
+
+	protected static final String OFFSET_NAME = "__offset__";
+	protected static final String SEGMENT_NAME = "__segment__";
+	protected static final String NEAR_NAME = "__np__";
+	protected static final String FAR_NAME = "__lp__";
+	protected static final CategoryPath GHIDRA_LP_UNION_CATEGORY = new CategoryPath("/_GhidraLpUnions");
+	protected static final CategoryPath GHIDRA_LP_UNION_STRUCT_CATEGORY = new CategoryPath("/_GhidraLpUnions/_seg");
+
+	protected static final String UNDEFINED = "undefined";
+	protected static final String NEAR_P = " * ".concat(NEAR_NAME);
+	protected static final String FAR_LP = " far * ".concat(FAR_NAME);
+	protected static final String UNION_PREFIX = "LP";
+	protected static final String SEGMENT_PREFIX = "__seg";
+
+	@Override
+	protected void run() throws Exception, CancelledException {
+
+		DataTypeManager dtMgr = currentProgram.getDataTypeManager();
+		if (dtMgr == null) {
+			return;
+		}
+
+//		// do a test of creating a data type
+//		int transTest = dtMgr.startTransaction("Test add new 'LPvoid' union");
+//		try {
+//			testCreateNewLPUnion(dtMgr);
+//		}
+//		catch (Exception e) {
+//			dtMgr.endTransaction(transTest, false);
+//			Msg.error(this, e.getMessage());
+//			throw e;
+//		}
+//		dtMgr.endTransaction(transTest, true);
+
+		// start for real
+		String message = "Getting list of pre-created unions from: " + dtMgr.getName();
+		monitor.setMessage(message);
+		Msg.info(this, message);
+
+		Map<String, Union> lpTypes = setupCurrentLPUnionList(dtMgr);
+
+		message = "Creating new unions in: " + dtMgr.getName();
+		monitor.setMessage(message);
+		Msg.info(this, message);
+
+		// create new unions
+		int trans = dtMgr.startTransaction("Add new ".concat(UNION_PREFIX).concat(" unions"));
+		try {
+			lpTypes = createNewLPUnions(dtMgr, lpTypes, trans);
+		}
+		catch (Exception e) {
+			dtMgr.endTransaction(trans, false);
+			Msg.error(this, e.getMessage());
+			throw e;
+		}
+		dtMgr.endTransaction(trans, true);
+
+		message = "Replacing usage of *32 within Composites with new unions in: " + dtMgr.getName();
+		monitor.setMessage(message);
+		Msg.info(this, message);
+
+		// update uses of pointer *32 types with new union types
+		trans = dtMgr.startTransaction("Change all *32 uses to the new unions");
+		try {
+			updatePointer32References(dtMgr, lpTypes);
+		}
+		catch (Exception e) {
+			dtMgr.endTransaction(trans, false);
+			Msg.error(this, e.getMessage());
+			throw e;
+		}
+		dtMgr.endTransaction(trans, true);
+
+		message = "Replacing usage of *32 with new unions in: " + dtMgr.getName();
+		monitor.setMessage(message);
+		Msg.info(this, message);
+
+		// update uses of pointer *32 within function declarations with new union types
+		trans = dtMgr.startTransaction("Change all *32 uses within function declarations to the new unions");
+		try {
+			FunctionManager fnMgr = currentProgram.getFunctionManager();
+			updatePointer32FunctionParamReferences(fnMgr.getFunctions(false), lpTypes);
+		}
+		catch (Exception e) {
+			dtMgr.endTransaction(trans, false);
+			Msg.error(this, e.getMessage());
+			throw e;
+		}
+		dtMgr.endTransaction(trans, true);
+
+//		message = "Results located in: " + dumpFile.getAbsoluteFile();
+//		monitor.setMessage(message);
+//		Msg.info(this, message);
+	}
+
+	/**
+	 * Test creation of Union (and Category) using 'void' as an example
+	 *
+	 * @param dtMgr
+	 * @throws CancelledException
+	 * @throws DuplicateNameException
+	 * @throws ParseException
+	 */
+	private void testCreateNewLPUnion(DataTypeManager dtMgr) throws ParseException {
+//		CParser parser = new CParser(dtMgr);
+//
+//		String name = "void";
+//		String newUnion = "union ".concat(PREFIX).concat(name ).concat(" {")
+//				.concat(name).concat(NEAR_P)
+//				.concat(name).concat(FAR_LP)
+//				.concat("};")
+//				;
+////			union GhidraLP_Dgn11e0_1c7b_0x1c_t {
+////			    Dgn11e0_1c7b_0x1c_t * np;
+////			    Dgn11e0_1c7b_0x1c_t*32 lp;
+////			};
+//
+//		try {
+//			Union ut = (Union) parser.parse(newUnion);
+//			ut.setCategoryPath(GHIDRALPUNIONCATEGORY);
+//			dtMgr.addDataType(ut , null);
+//		} catch (ParseException e) {
+//			e.printStackTrace();
+//			Msg.error(this, e.getMessage());
+////			throw e;
+//		} catch (DuplicateNameException e) {
+//			// Don't care
+//			e.printStackTrace();
+//		}
+
+		StructureDataType structPtrComp = new StructureDataType(GHIDRA_LP_UNION_STRUCT_CATEGORY, "__segLPVOID", 0, dtMgr);
+		structPtrComp.add(dtMgr.getDataType("/void *"), -1, OFFSET_NAME, "");
+		try {
+			structPtrComp.add(dtMgr.getDataType("/SegmentCodeAddress"), 2, SEGMENT_NAME, "");
+		}
+		catch (Exception e) {
+			PluginTool tool = state.getTool();
+			DataTypeManagerService service = tool.getService(DataTypeManagerService.class);
+			DataTypeManager[] dataTypeManagers = service.getDataTypeManagers();
+			for (DataTypeManager dataTypeManager : dataTypeManagers) {
+				try {
+					structPtrComp.add(dataTypeManager.getDataType("/SegmentCodeAddress"), 2, SEGMENT_NAME, "");
+					break;
+				}
+				catch (Exception e1) {
+					// Try next!
+				}
+			}
+		}
+		UnionDataType ut = new UnionDataType(GHIDRA_LP_UNION_CATEGORY, "LPVOID_test");
+		ut.add(structPtrComp, 4, NEAR_NAME, "");
+		ut.add(dtMgr.getDataType("/windows.h/LPVOID"), 4, FAR_NAME, "");
+		dtMgr.addDataType(ut, DataTypeConflictHandler.REPLACE_HANDLER);
+	}
+
+	/**
+	 * Setup list of pre-created LP union types
+	 *
+	 * @param dtMgr
+	 * @return
+	 * @throws CancelledException
+	 */
+	protected Map<String, Union> setupCurrentLPUnionList(DataTypeManager dtMgr) throws CancelledException {
+		Map<String,Union> lpTypeNames = new HashMap<>();
+		Iterator<Composite> allCompositeTypes = dtMgr.getAllComposites();
+		while (allCompositeTypes.hasNext()) {
+			monitor.checkCanceled();
+			Composite dataType = allCompositeTypes.next();
+			if (!dataType.getCategoryPath().equals(GHIDRA_LP_UNION_CATEGORY)) continue;
+			if (!(dataType instanceof Union)) continue;
+			Union ut = (Union) dataType;
+			String unionName = ut.getName();
+			if (!unionName.startsWith(UNION_PREFIX)) continue;
+			if (2 != ut.getNumComponents()) continue;
+			if (4 != ut.getLength()) continue;
+			DataTypeComponent[] cdts = ut.getComponents();
+			DataTypeComponent dtc0 = cdts[0];
+			DataType dt0 = dtc0.getDataType();
+			if (!(dt0 instanceof Structure)) continue;
+			Structure st = (Structure) dt0;
+			if (2 != st.getNumComponents()) continue;
+			dtc0 = st.getComponent(0);
+			dt0 = dtc0.getDataType();
+			if (!(dt0 instanceof Pointer)) continue;
+			DataTypeComponent dtc1 = cdts[1];
+			DataType dt1 = dtc1.getDataType();
+			if (!(dt1 instanceof Pointer)) continue;
+			Pointer pDt0 = (Pointer) dt0;
+			Pointer pDt1 = (Pointer) dt1;
+			if (8 != pDt0.getLength() * pDt1.getLength()) continue;
+			if (pDt0.getDataType() != pDt1.getDataType()) continue;
+
+			// otherwise
+			lpTypeNames.put(unionName.substring(UNION_PREFIX.length()).toLowerCase(), ut);
+		}
+		return lpTypeNames;
+	}
+
+	/**
+	 * Ensure pointer to data type exists, create if not.
+	 *
+	 * @param dtMgr
+	 * @param dt
+	 * @param ptrType
+	 * @param size
+	 * @return
+	 * @throws DuplicateNameException
+	 */
+	private static DataType getPointerType(DataTypeManager dtMgr, DataType dt, String ptrType, int size)
+			throws DuplicateNameException {
+		if (!ptrType.startsWith("/")) {
+			ptrType = "/" + ptrType;
+		}
+		DataType pDt = dtMgr.getDataType(ptrType);
+		if (null == pDt) {
+			pDt = new PointerDataType(dt, size, dtMgr);
+			pDt.setCategoryPath(dt.getCategoryPath());
+		}
+		return pDt;
+	}
+
+	/**
+	 * Add new LP Union types for ones not allocated
+	 *
+	 * @param dtMgr
+	 * @param lpTypeNames
+	 * @param trans
+	 * @return
+	 * @throws CancelledException
+	 * @throws DuplicateNameException
+	 * @throws ParseException
+	 */
+	protected Map<String, Union> createNewLPUnions(DataTypeManager dtMgr, Map<String, Union> lpTypeNames, int trans)
+			throws CancelledException, DuplicateNameException {
+		Iterator<DataType> allDataTypes = dtMgr.getAllDataTypes();
+
+		while (allDataTypes.hasNext()) {
+			monitor.checkCanceled();
+			DataType dataType = allDataTypes.next();
+			if (dataType.getName().startsWith("Dgn1210_0756_0x1a_t")) {
+				System.out.println(dataType.getName());
+			}
+			if (!(dataType instanceof Pointer)) continue;
+			Pointer pDt = (Pointer) dataType;
+			if (4 != pDt.getLength()) continue;
+			DataType dt = pDt.getDataType();
+			if (null == dt) continue;
+			if (dt instanceof Pointer) continue;
+			if (dt instanceof Array) continue;
+			String name = dt.getName();
+			if (name.startsWith(UNDEFINED)) continue;
+			if (lpTypeNames.containsKey(name.toLowerCase())) continue;
+			String newUnion = "union ".concat(UNION_PREFIX).concat(name).concat(" {")
+					.concat(name).concat(NEAR_P).concat(";")
+					.concat(name).concat(FAR_LP).concat(";")
+					.concat("};")
+					;
+//			union GhidraLP_Dgn11e0_1c7b_0x1c_t {
+//			    Dgn11e0_1c7b_0x1c_t * np;
+//			    Dgn11e0_1c7b_0x1c_t*32 lp;
+//			};
+
+			UnionDataType ut = CreateNewLPUnion(dtMgr, dt);
+			lpTypeNames.put(name.toLowerCase(), ut);
+		}
+
+		return lpTypeNames;
+	}
+
+	public UnionDataType CreateNewLPUnion(DataTypeManager dtMgr, DataType dt)
+			throws DuplicateNameException {
+		String name = dt.getName();
+		String unionName = UNION_PREFIX.concat(name);
+System.out.println(unionName);
+if ("LPpfn01AddToMemoryManager".equals(unionName)) {
+System.out.println("");
+}
+		String structName = SEGMENT_PREFIX.concat(unionName);
+		String nearPtrType = dt.getCategoryPath().getName().concat("/").concat(name).concat(" *");
+		String farPtrType = dt.getCategoryPath().getName().concat("/").concat(name).concat(" *32");
+
+		StructureDataType structPtrComp = new StructureDataType(GHIDRA_LP_UNION_STRUCT_CATEGORY, structName , 0, dtMgr);
+		DataType nearPDt = getPointerType(dtMgr, dt, nearPtrType, 2);
+		structPtrComp.add(nearPDt , -1, OFFSET_NAME, "");
+		try {
+			structPtrComp.add(dtMgr.getDataType("/SegmentCodeAddress"), 2, SEGMENT_NAME, "");
+		}
+		catch (Exception e) {
+			PluginTool tool = state.getTool();
+			DataTypeManagerService service = tool.getService(DataTypeManagerService.class);
+			DataTypeManager[] dataTypeManagers = service.getDataTypeManagers();
+			for (DataTypeManager dataTypeManager : dataTypeManagers) {
+				try {
+					structPtrComp.add(dataTypeManager.getDataType("/SegmentCodeAddress"), 2, SEGMENT_NAME, "");
+					break;
+				}
+				catch (Exception e1) {
+					// Try next!
+				}
+			}
+		}
+
+		UnionDataType ut = new UnionDataType(GHIDRA_LP_UNION_CATEGORY, UNION_PREFIX.concat(name));
+		ut.add(structPtrComp, 4, NEAR_NAME, "");
+		DataType farPDt = getPointerType(dtMgr, dt, farPtrType, 4);
+		ut.add(farPDt, 4, FAR_NAME, "");
+		dtMgr.addDataType(ut, DataTypeConflictHandler.REPLACE_HANDLER);
+
+		return ut;
+	}
+
+	/**
+	 * Search and replace uses of *32 references with LP union version
+	 *
+	 * @param dtMgr
+	 * @param lpTypes
+	 * @throws Exception
+	 */
+	protected void updatePointer32References(DataTypeManager dtMgr, Map<String, Union> lpTypes)
+			throws Exception {
+		Iterator<DataType> allTypes = dtMgr.getAllDataTypes();
+		while (allTypes.hasNext()) {
+			monitor.checkCanceled();
+			DataType dataType = allTypes.next();
+			if (dataType.getCategoryPath().equals(GHIDRA_LP_UNION_CATEGORY)) continue;
+			if (dataType instanceof Composite) {
+				updatePointer32CompositeReferences((Composite) dataType, lpTypes);
+			}
+			else if (dataType instanceof FunctionDefinition) {
+				updatePointer32FunctionDefinitionReferences((FunctionDefinition) dataType, lpTypes);
+			}
+			else if (dataType instanceof TypeDef) {
+				updatePointer32TypeDefReferences((TypeDef) dataType, lpTypes, dtMgr);
+			}
+			else if (dataType instanceof Array) {
+				;
+			}
+			else {
+//				System.out.println(dataType);
+			}
+		}
+	}
+
+	/**
+	 *
+	 * @param dataType
+	 * @param lpTypes
+	 * @param dtMgr
+	 */
+	private void updatePointer32TypeDefReferences(TypeDef dataType, Map<String, Union> lpTypes,
+			DataTypeManager dtMgr) {
+		DataType dt = dataType.getDataType();
+
+		if (!(dt instanceof Pointer)) return;
+		Pointer pDt = (Pointer) dt;
+		if (4 != pDt.getLength()) return;
+		DataType dtBase = pDt.getDataType();
+		if (null == dtBase) return;
+		if (dtBase instanceof Pointer) return;
+		String name = dtBase.getName();
+		DataType lpType = lpTypes.get(name.toLowerCase());
+		if (null == lpType) return;
+		String newName = dataType.getName();
+		if (newName.equals(lpType.getName())) {
+			newName = "TD_" + newName;
+		}
+		TypedefDataType td = new TypedefDataType(dataType.getCategoryPath(), newName, lpType);
+		TypedefDataType.copyTypeDefSettings(dataType, td, false);
+		try {
+			dtMgr.replaceDataType(dataType, td, false);
+		} catch (DataTypeDependencyException e) {
+			Msg.error(this, e.getMessage());
+		}
+	}
+
+	/**
+	 *
+	 *
+	 * @param dataType
+	 * @param lpTypes
+	 */
+	private void updatePointer32FunctionDefinitionReferences(FunctionDefinition dataType,
+			Map<String, Union> lpTypes) {
+		ParameterDefinition[] params = dataType.getArguments();
+
+		for (int idx=0; idx<params.length; ++idx) {
+			ParameterDefinition param = params[idx];
+			DataType dt = param.getDataType();
+			if (!(dt instanceof Pointer)) continue;
+			Pointer pDt = (Pointer) dt;
+			if (4 != pDt.getLength()) continue;
+			DataType dtBase = pDt.getDataType();
+			if (null == dtBase) continue;
+			if (dtBase instanceof Pointer) continue;
+			String name = dtBase.getName();
+			DataType lpType = lpTypes.get(name.toLowerCase());
+			if (null == lpType) continue;
+			try {
+				param.setDataType(lpType);
+			} catch (IllegalArgumentException e) {
+				Msg.error(this, e.getMessage());
+			}
+		}
+
+		dataType.setArguments(params);
+	}
+
+	/**
+	 * In all Composite types, search and replace uses of *32 references with LP union version
+	 *
+	 * @param dtMgr
+	 * @param lpTypes
+	 * @param dataType
+	 * @throws CancelledException
+	 */
+	protected void updatePointer32CompositeReferences(Composite dataType, Map<String, Union> lpTypes)
+			throws CancelledException {
+		if (dataType instanceof FunctionDefinitionDataType) {
+			throw new CancelledException("Found FunctionDefinitionDataType");
+		}
+
+		DataTypeComponent[] cdts = dataType.getComponents();
+		for (int idx=0; idx<cdts.length; ++idx) {
+			DataTypeComponent dtc = cdts[idx];
+			if (!(dtc instanceof InternalDataTypeComponent)) continue;
+			InternalDataTypeComponent idtc = (InternalDataTypeComponent) dtc;
+			DataType dt = idtc.getDataType();
+			if (!(dt instanceof Pointer)) continue;
+			Pointer pDt = (Pointer) dt;
+			if (4 != pDt.getLength()) continue;
+			DataType dtBase = pDt.getDataType();
+			if (null == dtBase) continue;
+
+if("DgnDFileStream_vtable".equals(dtBase.getName())) {
+	System.out.println(dtBase);
+}
+			if (dtBase instanceof Pointer) continue;
+			String name = dtBase.getName();
+			DataType lpType = lpTypes.get(name.toLowerCase());
+			if (null == lpType) continue;
+			idtc.setDataType(lpType);
+		}
+	}
+
+	/**
+	 * In all Function definitions, search and replace uses of *32 references with LP union version
+	 *
+	 * @param functionIterator
+	 * @param lpTypes
+	 * @throws CancelledException
+	 */
+	protected void updatePointer32FunctionParamReferences(FunctionIterator functionIterator, Map<String, Union> lpTypes)
+			throws CancelledException {
+int count=0; int stop[] = {2299}; int restart[] = {3001}; int stopstart=0;
+		while ( functionIterator.hasNext()) {
+			monitor.checkCanceled();
+			Function fnType = functionIterator.next();
+System.out.println(fnType.getSignature(false));
+
+			// do return type
+			DataType dt = fnType.getReturnType();
+			if (dt instanceof Pointer) {
+				Pointer pDt = (Pointer) dt;
+				if (4 == pDt.getLength()) {
+					DataType dtBase = pDt.getDataType();
+					if (null != dtBase) {
+						if (!(dtBase instanceof Pointer)) {
+							String name = dtBase.getName();
+							DataType lpType = lpTypes.get(name.toLowerCase());
+							if (null != lpType) {
+								try {
+									fnType.setReturnType(lpType, SourceType.USER_DEFINED);
+								} catch (InvalidInputException e) {
+									Msg.error(this, e.getMessage());
+								}
+							}
+						}
+					}
+				}
+			}
+
+			// do params
+			Parameter[] params = fnType.getParameters();
+			for (int idx=0; idx<params.length; ++idx) {
+				Parameter param = params[idx];
+				dt = param.getDataType();
+				if (!(dt instanceof Pointer)) continue;
+				Pointer pDt = (Pointer) dt;
+				if (4 != pDt.getLength()) continue;
+				DataType dtBase = pDt.getDataType();
+				if (null == dtBase) continue;
+				if (dtBase instanceof Pointer) continue;
+				String name = dtBase.getName();
+				DataType lpType = lpTypes.get(name.toLowerCase());
+				if (null == lpType) continue;
+				try {
+					param.setDataType(lpType, param.getSource());
+				} catch (InvalidInputException e) {
+					Msg.error(this, e.getMessage());
+				}
+			}
+
+			// do locals
+			Variable[] localVars = fnType.getLocalVariables();
+			for (int idx = 0; idx < localVars.length; idx++) {
+				Variable var = localVars[idx];
+				dt = var.getDataType();
+				if (!(dt instanceof Pointer)) continue;
+				Pointer pDt = (Pointer) dt;
+				if (4 != pDt.getLength()) continue;
+				DataType dtBase = pDt.getDataType();
+				if (null == dtBase) continue;
+				if (dtBase instanceof Pointer) continue;
+				String name = dtBase.getName();
+				DataType lpType = lpTypes.get(name.toLowerCase());
+				if (null == lpType) continue;
+				try {
+					var.setDataType(lpType, var.getSource());
+				} catch (InvalidInputException e) {
+					Msg.error(this, e.getMessage());
+				}
+			}
+		}
+	}
+
+}
diff --git a/Ghidra/Features/Base/ghidra_scripts/_GetAllFunctionsCallingConvention.java b/Ghidra/Features/Base/ghidra_scripts/_GetAllFunctionsCallingConvention.java
new file mode 100644
index 0000000000..925590a50c
--- /dev/null
+++ b/Ghidra/Features/Base/ghidra_scripts/_GetAllFunctionsCallingConvention.java
@@ -0,0 +1,106 @@
+
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Script to export ALL function definitions for the @currentProgram
+//@category Export
+import java.io.BufferedWriter;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.Iterator;
+
+import ghidra.app.script.GhidraScript;
+import ghidra.program.model.listing.Function;
+import ghidra.program.model.listing.FunctionManager;
+import ghidra.program.model.listing.Parameter;
+
+public class _GetAllFunctionsCallingConvention extends GhidraScript {
+
+	private BufferedWriter fileWriter;
+
+	@Override
+	public void run() throws Exception {
+
+		if (currentProgram != null) {
+			String DIR = "D:/";
+			String filename = DIR + currentProgram.getName() + "FunctionSpecs.tab";
+System.out.println(filename);
+			fileWriter = new BufferedWriter(new FileWriter(filename));
+
+			FunctionManager fnMgr = currentProgram.getFunctionManager();
+			if (fnMgr == null) {
+				return;
+			}
+
+			// update details
+			doRun(fnMgr.getFunctions(true));
+
+			fileWriter.close();
+		}
+	}
+
+	/**
+	 * @param functions
+	 */
+	private void doRun(Iterator<Function> functions) {
+		while (functions.hasNext()) {
+			if ((getMonitor() != null) && getMonitor().isCancelled()) {
+				return;
+			}
+
+			doRun(functions.next());
+		}
+	}
+
+	/**
+	 * Do for individually identified function
+	 *
+	 * @param func this function
+	 */
+	protected void doRun(Function func) {
+
+		final String SEP = "\t";
+		try {
+			fileWriter.write(func.getBody().getMinAddress() + SEP + func.getName(true)
+					+ SEP + func.getCallingConventionName()
+					+ SEP + getDescription(func));
+			fileWriter.newLine();
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+	}
+
+	/**
+	 * @param f Function object
+	 * @return string to print out
+	 */
+	private static String getDescription(Function f) {
+		StringBuilder s = new StringBuilder();
+		String szSep = "";
+		s.append(f.getReturnType().getName()).append(' ');
+		s.append(f.getName(true)).append(" (");
+		for (int i = 0; i < f.getParameters().length; i++) {
+			Parameter p = f.getParameter(i);
+			s.append(szSep).append(p.getFormalDataType().getName()).append(' ').append(p.getName());
+			//s.append("[").append(p.getLastStorageVarnode().toString()).append("]");
+			szSep = ", ";
+		}
+		s.append(')');
+		return s.toString();
+	}
+
+}
diff --git a/Ghidra/Features/Base/ghidra_scripts/_SetFunctonNameFromLPSTR.java b/Ghidra/Features/Base/ghidra_scripts/_SetFunctonNameFromLPSTR.java
new file mode 100644
index 0000000000..2f0b72a0e8
--- /dev/null
+++ b/Ghidra/Features/Base/ghidra_scripts/_SetFunctonNameFromLPSTR.java
@@ -0,0 +1,249 @@
+
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+// Script ensures that the PASCAL calling convention replaces STDCALL
+// on function parameters and changes the stack reference for left-to-
+// right stacking.  On the way, it also ensures that all Thunks are
+// also converted.  This applies to Windows 16-bit apps.
+//
+//@category Repair
+import java.util.ArrayList;
+import java.util.List;
+
+import ghidra.app.script.GhidraScript;
+import ghidra.pcodeCPort.sleighbase.address_set;
+import ghidra.program.database.symbol.VariableSymbolDB;
+import ghidra.program.flatapi.FlatProgramAPI;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.address.AddressFormatException;
+import ghidra.program.model.address.AddressIterator;
+import ghidra.program.model.address.AddressOutOfBoundsException;
+import ghidra.program.model.address.AddressSetView;
+import ghidra.program.model.data.Array;
+import ghidra.program.model.data.DataType;
+import ghidra.program.model.data.DataTypeComponent;
+import ghidra.program.model.data.DynamicDataType;
+import ghidra.program.model.data.Pointer;
+import ghidra.program.model.data.Structure;
+import ghidra.program.model.data.StructureDataType;
+import ghidra.program.model.data.TypeDef;
+import ghidra.program.model.data.Union;
+import ghidra.program.model.listing.Data;
+import ghidra.program.model.listing.DataIterator;
+import ghidra.program.model.listing.Function;
+import ghidra.program.model.listing.Listing;
+import ghidra.program.model.mem.DumbMemBufferImpl;
+import ghidra.program.model.mem.MemBuffer;
+import ghidra.program.model.mem.Memory;
+import ghidra.program.model.scalar.Scalar;
+import ghidra.program.model.symbol.SourceType;
+import ghidra.program.model.symbol.Symbol;
+import ghidra.program.model.symbol.SymbolTable;
+import ghidra.util.Msg;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.exception.InvalidInputException;
+
+public class _SetFunctonNameFromLPSTR extends GhidraScript {
+
+	private int cntConvertionTotal;
+	private int cntConvertionChanged;
+
+	private List<String> warningMessages = new ArrayList<String>();
+
+	@Override
+	public void run() throws Exception {
+
+		// reset for this run
+		cntConvertionTotal = 0;
+		cntConvertionChanged = 0;
+
+		warningMessages.clear();
+
+		Listing listing = currentProgram.getListing();
+
+		if (currentAddress != null) {
+			AddressSetView view = currentSelection;
+			if ((view == null) || (view.isEmpty())) {
+				doRun(currentAddress, listing);
+			}
+			else {
+				AddressIterator iterAddr = view.getAddresses(true);
+
+				Address lastArrayAddress = null;
+				while (iterAddr.hasNext()) {
+					if (monitor.isCancelled()) {
+						break;
+					}
+
+					Address address = iterAddr.next();
+					if ((null != lastArrayAddress) && (lastArrayAddress.compareTo(address) > 0)) {
+						continue;
+					}
+					doRun(address, listing);
+				}
+			}
+
+			// build popup information
+			String buf = "Update " + cntConvertionChanged + " function names out of " + cntConvertionTotal + ".";
+			if (!warningMessages.isEmpty()) {
+				buf = buf + "\n\n" + String.join("\n\n", warningMessages);
+			}
+
+			popup(buf);
+		}
+	}
+
+	private Address doRun(Address address, Listing listing)
+			throws AddressFormatException, DuplicateNameException, InvalidInputException {
+		Address lastArrayAddress = address;
+		Data data = listing.getDataAt(address);
+		if (null != data) {
+			DataType dt = data.getDataType();
+			if (dt instanceof Array) {
+				Array adt = (Array) dt;
+				dt = adt.getDataType();
+				cntConvertionTotal += adt.getNumElements();
+				for (int i=0; i<adt.getNumElements(); ++i) {
+					if (updateFunctionNamesFromStrings(dt, lastArrayAddress, listing)) {
+						++cntConvertionChanged;
+					};
+					lastArrayAddress = lastArrayAddress.add(adt.getElementLength());
+				}
+
+			} else if (dt instanceof Structure) {
+				++cntConvertionTotal;
+				if (updateFunctionNamesFromStrings(dt, address, listing)) {
+					++cntConvertionChanged;
+				};
+			}
+		}
+		return lastArrayAddress;
+	}
+
+	private boolean updateFunctionNamesFromStrings(DataType dt, Address address, Listing listing)
+			throws AddressFormatException, DuplicateNameException, InvalidInputException {
+		if (!(dt instanceof Structure)) return false;
+		Structure structDt = (Structure) dt;
+
+		if (!"DgnTaskFnList_t".equals(structDt.getName())) return false;
+
+		Memory memory = currentProgram.getMemory();
+
+		MemBuffer buf = new DumbMemBufferImpl(memory, address);
+		DataTypeComponent comp = getComponent(structDt, 0, buf); // points to a string
+		Address addrDatum = getRefAtPointer32(comp, address, buf);
+		if (null == addrDatum) return false;
+
+		Data dataString = listing.getDataAt(addrDatum);
+		if (null == dataString) return false;
+		String fnName = (String) dataString.getValue();
+
+		buf = new DumbMemBufferImpl(memory, address.add(4));
+		comp = getComponent(structDt, 1, buf); // points to a function pointer
+		addrDatum = getRefAtPointer32(comp, address, buf);
+		if (null == addrDatum) return false;
+		Function func = listing.getFunctionAt(addrDatum);
+		if (null == func) {
+			func = createFunction(addrDatum, fnName);
+			writer.println("Created functon '" + func.getName() + "' at " + addrDatum);
+		}
+		else {
+			StringBuffer sb = new StringBuffer("Renamed function '" + func.getName() + "' to '");
+			func.setName(fnName, SourceType.USER_DEFINED);
+			sb.append(func.getName() + "' at " + addrDatum);
+			writer.println(sb.toString());
+		}
+		return true;
+	}
+
+	private DataType getPointer32(DataTypeComponent comp, Address address, MemBuffer memBuf) {
+		DataType dt = comp.getDataType();
+		if (dt instanceof Union) {
+			Union unionDt = (Union) dt;
+			for (int i = 0; i < unionDt.getNumComponents(); i++) {
+				comp = unionDt.getComponent(i);
+				dt = comp.getDataType();
+				if ((dt instanceof Pointer) && (4 == dt.getLength())) {
+					return dt;
+				}
+				else if (dt instanceof Union || dt instanceof Structure) {
+					dt = getPointer32(comp, address, memBuf);
+				}
+			}
+		}
+		else if (dt instanceof Structure) {
+			Structure structDt = (Structure) dt;
+			for (int i = 0; i < structDt.getNumComponents(); i++) {
+				comp = structDt.getComponent(i);
+				dt = comp.getDataType();
+				if ((dt instanceof Pointer) && (4 == dt.getLength())) {
+					return dt;
+				}
+				else if (dt instanceof Union || dt instanceof Structure) {
+					dt = getPointer32(comp, address, memBuf);
+				}
+			}
+		}
+		else if ((dt instanceof Pointer) && (4 == dt.getLength())) {
+			return dt;
+		}
+		return null;
+	}
+
+	private Address getRefAtPointer32(DataTypeComponent comp, Address address, MemBuffer memBuf) throws AddressFormatException {
+		DataType dt = getPointer32(comp, address, memBuf);
+		if (null == dt) return null;
+		Object dataAddress = dt.getValue(memBuf, dt.getDefaultSettings(), dt.getLength());
+		Address addrDatum = address.getAddress(dataAddress.toString());
+		return addrDatum;
+	}
+
+	private static Address getComponentAddress(DataTypeComponent comp, MemBuffer memBuffer) {
+		int offset = comp.getOffset();
+		Address minAddress = memBuffer.getAddress();
+		try {
+			return minAddress.add(offset);
+		}
+		catch (AddressOutOfBoundsException e) {
+			throw new IllegalArgumentException("Can't get component " + comp.getOrdinal() +
+				" from memory buffer for data type " + comp.getParent().getName() + ".", e);
+		}
+	}
+
+	private static DataTypeComponent getComponent(DataType dataType, int componentOrdinal,
+			MemBuffer memBuffer) {
+		if (dataType == null) {
+			throw new IllegalArgumentException("Data type cannot be null.");
+		}
+		if (dataType instanceof DynamicDataType) {
+			DynamicDataType dynamicDt = (DynamicDataType) dataType;
+			return dynamicDt.getComponent(componentOrdinal, memBuffer);
+		}
+		if (dataType instanceof TypeDef) {
+			dataType = ((TypeDef) dataType).getBaseDataType();
+		}
+		if (dataType instanceof Union) {
+			Union unionDt = (Union) dataType;
+			return unionDt.getComponent(componentOrdinal);
+		}
+		if (!(dataType instanceof Structure)) {
+			throw new IllegalArgumentException("Data type " + dataType.getName() +
+				" must be a structure or a typedef on a structure.");
+		}
+		Structure struct = (Structure) dataType;
+		return struct.getComponent(componentOrdinal);
+	}
+}
\ No newline at end of file
diff --git a/Ghidra/Features/Base/ghidra_scripts/_SetSSRegForAllFuncs.java b/Ghidra/Features/Base/ghidra_scripts/_SetSSRegForAllFuncs.java
new file mode 100644
index 0000000000..16bdf47fba
--- /dev/null
+++ b/Ghidra/Features/Base/ghidra_scripts/_SetSSRegForAllFuncs.java
@@ -0,0 +1,112 @@
+
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+// Script to set CS register for ALL function definitions for the @currentProgram
+//@category
+import java.math.BigInteger;
+import java.util.Iterator;
+
+import ghidra.app.script.GhidraScript;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.lang.OperandType;
+import ghidra.program.model.lang.Register;
+import ghidra.program.model.lang.RegisterValue;
+import ghidra.program.model.listing.ContextChangeException;
+import ghidra.program.model.listing.Function;
+import ghidra.program.model.listing.FunctionManager;
+import ghidra.program.model.listing.Instruction;
+import ghidra.program.model.listing.Parameter;
+
+public class _SetSSRegForAllFuncs extends GhidraScript {
+
+	@Override
+	public void run() throws Exception {
+
+		String addr = askString("New Value", "SS");
+		if (addr.isEmpty())
+			return;
+
+		if (currentProgram != null) {
+			FunctionManager fnMgr = currentProgram.getFunctionManager();
+			if (fnMgr == null) {
+				return;
+			}
+
+			BigInteger newAddress = new BigInteger(addr, 16);
+
+			// update details
+			doRun(fnMgr.getFunctions(true), newAddress);
+		}
+	}
+
+	/**
+	 * @param functions
+	 * @param newAddress
+	 */
+	private void doRun(Iterator<Function> functions, BigInteger newAddress) {
+		while (functions.hasNext()) {
+			if ((getMonitor() != null) && getMonitor().isCancelled()) {
+				return;
+			}
+
+			doRun(functions.next(), newAddress);
+		}
+	}
+
+	/**
+	 * Do for individually identified function
+	 *
+	 * @param func this function
+	 * @param newAddress
+	 */
+	protected void doRun(Function func, BigInteger newAddress) {
+
+		final String SEP = "\t";
+
+		if (func.isThunk())
+			return;
+
+		Address addr = func.getEntryPoint();
+		Instruction instr = getInstructionAt(addr);
+		String strInstr = instr.getMnemonicString();
+		if (!"MOV".contentEquals(strInstr))
+			return;
+
+		if (2 != instr.getNumOperands())
+			return;
+
+		if (OperandType.REGISTER != instr.getOperandType(1)
+			 || !"SS".equals(instr.getRegister(1).getName()))
+			return;
+
+		Register reg = instr.getRegister(1);
+		RegisterValue regVal = instr.getRegisterValue(reg);
+
+		if (null != regVal)
+			return;
+
+		regVal = new RegisterValue(reg);
+		try {
+			instr.setRegisterValue(regVal.assign(reg, newAddress));
+		} catch (ContextChangeException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		System.out.println(addr + SEP + strInstr + SEP + reg + SEP + regVal);
+	}
+
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/function/ApplyFunctionSignatureCmd.java b/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/function/ApplyFunctionSignatureCmd.java
index bb2f990d9a..95fa377e9c 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/function/ApplyFunctionSignatureCmd.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/cmd/function/ApplyFunctionSignatureCmd.java
@@ -300,7 +300,7 @@ public class ApplyFunctionSignatureCmd extends BackgroundCommand<Program> {
 			return 0;
 		}
 
-		if (!CompilerSpec.CALLING_CONVENTION_thiscall.equals(conventionName)) {
+		if (!conventionName.startsWith(CompilerSpec.CALLING_CONVENTION_thiscall)) {
 			return 0;
 		}
 
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/SegmentedCallingConventionAnalyzer.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/SegmentedCallingConventionAnalyzer.java
index 526a266aec..4f3817e62f 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/SegmentedCallingConventionAnalyzer.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/analysis/SegmentedCallingConventionAnalyzer.java
@@ -21,6 +21,7 @@ import ghidra.app.services.AnalyzerType;
 import ghidra.app.util.importer.MessageLog;
 import ghidra.program.model.address.AddressSetView;
 import ghidra.program.model.address.SegmentedAddress;
+import ghidra.program.model.data.GenericCallingConvention;
 import ghidra.program.model.listing.*;
 import ghidra.program.model.mem.MemoryAccessException;
 import ghidra.util.Msg;
@@ -57,9 +58,18 @@ public class SegmentedCallingConventionAnalyzer extends AbstractAnalyzer {
 			catch (MemoryAccessException e) {
 				return;
 			}
+			Function func =
+					program.getFunctionManager().getFunctionContaining(instr.getMinAddress());
+			String conv;
+			if (func != null && func.getCallingConventionName().contains(GenericCallingConvention.pascal.toString())) {
+				conv = "__pascal16";
+			} else {
+				conv = "__stdcall16";
+			}
 			switch (b) {
 				case 0xca:
-					convention = "__stdcall16far";
+//					convention = "__stdcall16far";
+					convention = conv + "far";
 					break;
 				case 0xcb:
 					convention = "__cdecl16far";
@@ -68,15 +78,18 @@ public class SegmentedCallingConventionAnalyzer extends AbstractAnalyzer {
 					convention = "__cdecl16near";
 					break;
 				case 0xc2:
-					convention = "__stdcall16near";
+//					convention = "__stdcall16near";
+					convention = conv + "near";
+					break;
+				default:
 					break;
 			}
 			if (convention != null) {
-				Function func =
-					program.getFunctionManager().getFunctionContaining(instr.getMinAddress());
 				if (func != null) {
 					try {
 						func.setCallingConvention(convention);
+						Msg.debug(this, "Set convention to '" + convention + " for " +
+								((func == null) ? "undefined fn" : func.getSignature()) );
 					}
 					catch (InvalidInputException e) {
 						Msg.error(this, "Unexpected Exception: " + e.getMessage(), e);
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/actions/CreateLPUnionStructAction.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/actions/CreateLPUnionStructAction.java
new file mode 100644
index 0000000000..16ac2c52bc
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/datamgr/actions/CreateLPUnionStructAction.java
@@ -0,0 +1,326 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.plugin.core.datamgr.actions;
+
+import javax.swing.tree.TreePath;
+
+import docking.ActionContext;
+import docking.action.DockingAction;
+import docking.action.MenuData;
+import docking.widgets.tree.GTree;
+import ghidra.app.plugin.core.datamgr.DataTypeManagerPlugin;
+import ghidra.app.plugin.core.datamgr.DataTypesActionContext;
+import ghidra.app.plugin.core.datamgr.tree.ArchiveNode;
+import ghidra.app.plugin.core.datamgr.tree.BuiltInArchiveNode;
+import ghidra.app.plugin.core.datamgr.tree.DataTypeArchiveGTree;
+import ghidra.app.plugin.core.datamgr.tree.DataTypeNode;
+import ghidra.app.plugin.core.datamgr.tree.DataTypeTreeNode;
+import ghidra.program.model.data.BuiltInDataTypeManager;
+import ghidra.program.model.data.CategoryPath;
+import ghidra.program.model.data.DataType;
+import ghidra.program.model.data.DataTypeManager;
+import ghidra.program.model.data.DataTypeManagerChangeListener;
+import ghidra.program.model.data.DataTypePath;
+import ghidra.program.model.data.PointerDataType;
+import ghidra.program.model.data.SourceArchive;
+import ghidra.program.model.data.StructureDataType;
+import ghidra.program.model.data.UnionDataType;
+import ghidra.util.InvalidNameException;
+import ghidra.util.StringUtilities;
+import ghidra.util.exception.DuplicateNameException;
+
+public class CreateLPUnionStructAction extends DockingAction implements DataTypeManagerChangeListener {
+
+	private static final String ACTION_NAME = "LPUnion4Pointers";
+	protected static final String OFFSET_NAME = "__offset__";
+	protected static final String SEGMENT_NAME = "__segment__";
+	protected static final String NEAR_NAME = "__np__";
+	protected static final String FAR_NAME = "__lp__";
+	protected static final CategoryPath GHIDRA_LP_UNION_CATEGORY = new CategoryPath("/_GhidraLpUnions");
+	protected static final CategoryPath GHIDRA_LP_UNION_STRUCT_CATEGORY = new CategoryPath("/_GhidraLpUnions/_seg");
+
+	protected static final String UNDEFINED = "undefined";
+	protected static final String NEAR_P = " * ".concat(NEAR_NAME);
+	protected static final String FAR_LP = " far * ".concat(FAR_NAME);
+	protected static final String UNION_PREFIX = "LP";
+	protected static final String SEGMENT_PREFIX = "__seg";
+
+	protected DataTypeManagerPlugin plugin;
+
+	public CreateLPUnionStructAction(DataTypeManagerPlugin plugin) {
+		super("Create " + ACTION_NAME, plugin.getName());
+		this.plugin = plugin;
+		plugin.addDataTypeManagerChangeListener(this);
+		setPopupMenuData(new MenuData(new String[] { "New", ACTION_NAME }, null, "Create"));
+	}
+
+	@Override
+	public void actionPerformed(ActionContext context) {
+		DataTypeArchiveGTree gTree = (DataTypeArchiveGTree) context.getContextObject();
+		TreePath[] selectionPaths = gTree.getSelectionPaths();
+		DataTypeNode dataTypeNode = (DataTypeNode) selectionPaths[0].getLastPathComponent();
+		DataType baseDataType = dataTypeNode.getDataType();
+
+		DerivativeDataTypeInfo info =
+			new DerivativeDataTypeInfo(plugin, gTree, dataTypeNode, baseDataType);
+		DataTypeManager dtMgr = info.getDataTypeManager();
+		DataType ut = CreateNewLPUnion(dtMgr, baseDataType);
+	}
+
+	public DataType CreateNewLPUnion(DataTypeManager dtMgr, DataType dt) {
+		int transactionID = dtMgr.startTransaction("Create Associated DataTypes");
+		try {
+			String name = dt.getName();
+			String unionName = UNION_PREFIX.concat(name);
+			String structName = SEGMENT_PREFIX.concat(unionName);
+			String nearPtrType = dt.getCategoryPath().getName().concat("/").concat(name).concat(" *");
+			String farPtrType = dt.getCategoryPath().getName().concat("/").concat(name).concat(" *32");
+
+			StructureDataType structPtrComp = new StructureDataType(GHIDRA_LP_UNION_STRUCT_CATEGORY, structName , 0, dtMgr);
+			DataType nearPDt = getPointerType(dtMgr, dt, nearPtrType, 2);
+			structPtrComp.add(nearPDt , -1, OFFSET_NAME, "");
+			try {
+				structPtrComp.add(dtMgr.getDataType("/SegmentCodeAddress"), 2, SEGMENT_NAME, "");
+			}
+			catch (Exception e) {
+				DataTypeManager[] dataTypeManagers = plugin.getDataTypeManagers();
+				for (DataTypeManager dataTypeManager : dataTypeManagers) {
+					try {
+						structPtrComp.add(dataTypeManager.getDataType("/SegmentCodeAddress"), 2, SEGMENT_NAME, "");
+						break;
+					}
+					catch (Exception e1) {
+						// Try next!
+					}
+				}
+			}
+
+			UnionDataType ut = new UnionDataType(GHIDRA_LP_UNION_CATEGORY, UNION_PREFIX.concat(name));
+			ut.add(structPtrComp, 4, NEAR_NAME, "");
+			DataType farPDt = getPointerType(dtMgr, dt, farPtrType, 4);
+			ut.add(farPDt, 4, FAR_NAME, "");
+
+			DataType newDt = dtMgr.addDataType(ut, plugin.getConflictHandler());
+			dtMgr.endTransaction(transactionID, true);
+
+			return newDt;
+		} catch (DuplicateNameException e) {
+			dtMgr.endTransaction(transactionID, false);
+			return null;
+		}
+	}
+
+	/**
+	 * Ensure pointer to data type exists, create if not.
+	 *
+	 * @param dtMgr
+	 * @param dt
+	 * @param ptrType
+	 * @param size
+	 * @return
+	 * @throws DuplicateNameException
+	 */
+	private static DataType getPointerType(DataTypeManager dtMgr, DataType dt, String ptrType, int size)
+			throws DuplicateNameException {
+		if (!ptrType.startsWith("/")) {
+			ptrType = "/" + ptrType;
+		}
+		DataType pDt = dtMgr.getDataType(ptrType);
+		if (null == pDt) {
+			pDt = new PointerDataType(dt, size, dtMgr);
+			pDt.setCategoryPath(dt.getCategoryPath());
+		}
+		return pDt;
+	}
+
+	@Override
+	public boolean isEnabledForContext(ActionContext context) {
+		DataTypeTreeNode node = getDataTypeNode(context);
+		if (node == null) {
+			return false;
+		}
+
+		ArchiveNode archiveNode = node.getArchiveNode();
+		if (archiveNode == null) {
+			// this can happen as the tree is changing
+			return false;
+		}
+
+		boolean enabled = archiveNode.isModifiable();
+		if (archiveNode instanceof BuiltInArchiveNode) {
+			// these will be put into the program archive
+			enabled = true;
+		}
+
+		// update the menu item to add the name of the item we are working on
+		if (enabled) {
+			String dtName = node.getName();
+			dtName = StringUtilities.trim(dtName, 10);
+			MenuData newMenuData =
+				new MenuData(new String[] { "New", ACTION_NAME + " to " + dtName }, null, "Create");
+			setPopupMenuData(newMenuData);
+		}
+
+		return enabled;
+	}
+
+	@Override
+	public boolean isAddToPopup(ActionContext context) {
+		DataTypeNode node = getDataTypeNode(context);
+		if (node == null) {
+			return false;
+		}
+
+		DataType dataType = node.getDataType();
+		DataTypeManager dataTypeManager = dataType.getDataTypeManager();
+		if (dataTypeManager instanceof BuiltInDataTypeManager) {
+			DataTypeManager manager = plugin.getProgramDataTypeManager();
+			if (manager == null) {
+				return false; // no program open; can't work from the built-in in this case
+			}
+		}
+
+		return true;
+	}
+
+	private DataTypeNode getDataTypeNode(ActionContext context) {
+		if (!(context instanceof DataTypesActionContext)) {
+			return null;
+		}
+
+		Object contextObject = context.getContextObject();
+		GTree gtree = (GTree) contextObject;
+		TreePath[] selectionPaths = gtree.getSelectionPaths();
+		if (selectionPaths.length != 1) {
+			return null;
+		}
+
+		DataTypeTreeNode node = (DataTypeTreeNode) selectionPaths[0].getLastPathComponent();
+		if (!(node instanceof DataTypeNode)) {
+			return null;
+		}
+		return (DataTypeNode) node;
+	}
+
+	@Override
+	public void categoryAdded(DataTypeManager dtm, CategoryPath path) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void categoryRemoved(DataTypeManager dtm, CategoryPath path) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void categoryRenamed(DataTypeManager dtm, CategoryPath oldPath, CategoryPath newPath) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void categoryMoved(DataTypeManager dtm, CategoryPath oldPath, CategoryPath newPath) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void dataTypeAdded(DataTypeManager dtm, DataTypePath path) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void dataTypeRemoved(DataTypeManager dtm, DataTypePath path) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void dataTypeRenamed(DataTypeManager dtm, DataTypePath oldPath, DataTypePath newPath) {
+		String oldName = oldPath.getDataTypeName();
+		String oldUnionName = UNION_PREFIX.concat(oldName);
+		String oldStructName = SEGMENT_PREFIX.concat(oldUnionName);
+		DataType oldUnion = dtm.getDataType(GHIDRA_LP_UNION_CATEGORY, oldUnionName);
+		DataType oldStruct = dtm.getDataType(GHIDRA_LP_UNION_STRUCT_CATEGORY, oldStructName);
+		if ((null == oldUnion) || (null == oldStruct)) return;
+
+		String newName = newPath.getDataTypeName();
+		String newUnionName = UNION_PREFIX.concat(newName);
+		String newStructName = SEGMENT_PREFIX.concat(newUnionName);
+		int transactionID = dtm.startTransaction("Rename Associated DataType");
+		try {
+			oldStruct.setName(newStructName);
+			oldUnion.setName(newUnionName);
+			dtm.endTransaction(transactionID, true);
+		} catch (InvalidNameException | DuplicateNameException e) {
+			// TODO Auto-generated catch block
+			dtm.endTransaction(transactionID, false);
+			e.printStackTrace();
+		}
+	}
+
+	@Override
+	public void dataTypeMoved(DataTypeManager dtm, DataTypePath oldPath, DataTypePath newPath) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void dataTypeChanged(DataTypeManager dtm, DataTypePath path) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void dataTypeReplaced(DataTypeManager dtm, DataTypePath oldPath, DataTypePath newPath,
+			DataType newDataType) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void favoritesChanged(DataTypeManager dtm, DataTypePath path, boolean isFavorite) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void sourceArchiveChanged(DataTypeManager dataTypeManager, SourceArchive sourceArchive) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void sourceArchiveAdded(DataTypeManager dataTypeManager, SourceArchive sourceArchive) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void programArchitectureChanged(DataTypeManager dataTypeManager) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void restored(DataTypeManager dataTypeManager) {
+		// TODO Auto-generated method stub
+
+	}
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/FunctionEditorModel.java b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/FunctionEditorModel.java
index e8ed536e55..6428cb6c6b 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/FunctionEditorModel.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/plugin/core/function/editor/FunctionEditorModel.java
@@ -252,7 +252,7 @@ public class FunctionEditorModel {
 	}
 
 	/**
-	 * Mark all storage conflicts identified by 
+	 * Mark all storage conflicts identified by
 	 * {@link VariableUtilities#checkVariableConflict(List, Variable, VariableStorage, VariableConflictHandler)}
 	 * @param conflicts parameters whose storage conflicts
 	 * @return return false to indicate conflicts have not been resolved and additional checks
@@ -1038,8 +1038,8 @@ public class FunctionEditorModel {
 	}
 
 	/**
-	 * Sets the change state of the model to unchanged. Normally, the model sets the modelChanged 
-	 * variable to true every time something is changed. This provides a way to for applications 
+	 * Sets the change state of the model to unchanged. Normally, the model sets the modelChanged
+	 * variable to true every time something is changed. This provides a way to for applications
 	 * to make some initial changes but make the dialog think that nothing has changed.
 	 */
 	public void setModelUnchanged() {
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/cparser/C/Declaration.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/cparser/C/Declaration.java
index a93b06e43b..15335dadac 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/cparser/C/Declaration.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/cparser/C/Declaration.java
@@ -5,9 +5,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -20,6 +20,7 @@ import java.util.ArrayList;
 import java.util.List;
 
 import ghidra.program.model.data.AbstractIntegerDataType;
+import ghidra.program.model.data.AddressModel;
 import ghidra.program.model.data.DataType;
 import ghidra.program.model.data.PointerDataType;
 
@@ -123,7 +124,7 @@ public class Declaration {
 		}
 		qualifierList.add(qualifier);
 	}
-	
+
 	public void addQualifiers(Declaration dec) {
 		if (dec.qualifierList == null) {
 			return;
@@ -170,7 +171,7 @@ public class Declaration {
 	 * Set the bitfield size for this data type
 	 * More checking could be done here if the bitfield is set on something that
 	 * isn't a bitfield, but that probably isn't necessary.
-	 * 
+	 *
 	 * @param bits number of bits in the bitfield
 	 * @throws ParseException exception if bitfield to large for the current data type.
 	 */
@@ -181,4 +182,75 @@ public class Declaration {
 		bitSize = bits;
 	}
 
+	/**
+	 * @return the near address model from the datatype or false if null
+	 */
+	public boolean isNear() {
+		if ((dt == null) || (dt.getAddressModel() == null)) {
+			return false;
+		} else {
+			return dt.getAddressModel().equals(AddressModel.near);
+		}
+	}
+
+	/**
+	 * @param isNear if true set, otherwise clear
+	 */
+	public void setNear(boolean isNear) {
+		if (dt == null) {
+			return;
+		} else if (isNear) {
+			dt.setAddressModel(AddressModel.near);
+		} else {
+			dt.setAddressModel(AddressModel.unknown);
+		}
+	}
+
+	/**
+	 * @return the far address model from the datatype or false if null
+	 */
+	public boolean isFar() {
+		if ((dt == null) || (dt.getAddressModel() == null)) {
+			return false;
+		} else {
+			return dt.getAddressModel().equals(AddressModel.far);
+		}
+	}
+
+	/**
+	 * @param isFar if true set, otherwise clear
+	 */
+	public void setFar(boolean isFar) {
+		if (dt == null) {
+			return;
+		} else if (isFar) {
+			dt.setAddressModel(AddressModel.far);
+		} else {
+			dt.setAddressModel(null);
+		}
+	}
+
+	/**
+	 * @return the huge address model from the datatype or false if null
+	 */
+	public boolean isHuge() {
+		if ((dt == null) || (dt.getAddressModel() == null)) {
+			return false;
+		} else {
+			return dt.getAddressModel().equals(AddressModel.huge);
+		}
+	}
+
+	/**
+	 * @param isHuge if true set, otherwise clear
+	 */
+	public void setHuge(boolean isHuge) {
+		if (dt == null) {
+			return;
+		} else if (isHuge) {
+			dt.setAddressModel(AddressModel.huge);
+		} else {
+			dt.setAddressModel(AddressModel.unknown);
+		}
+	}
 }
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibraryExport.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibraryExport.java
new file mode 100644
index 0000000000..c73aaf4b65
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibraryExport.java
@@ -0,0 +1,85 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.opinion;
+
+import org.jdom.Element;
+
+public class LibraryExport {
+
+	private int ordinal;
+	private String symbolName;
+	private int purge;
+	private String comment;
+	private String forwardLibName;
+	private String forwardSymName;
+
+	private String noReturnStr;
+	private boolean noReturn;
+
+
+	public LibraryExport(Element export) {
+		ordinal = Integer.parseInt(export.getAttributeValue("ORDINAL"));
+		symbolName = export.getAttributeValue("NAME");
+		purge = Integer.parseInt(export.getAttributeValue("PURGE"));
+		comment = export.getAttributeValue("COMMENT");
+		forwardLibName = export.getAttributeValue("FOWARDLIBRARY");
+		forwardSymName = export.getAttributeValue("FOWARDSYMBOL");
+
+		noReturnStr = export.getAttributeValue("NO_RETURN");
+		noReturn = noReturnStr != null && "y".equals(noReturnStr);
+	}
+
+
+	public int getOrdinal() {
+		return ordinal;
+	}
+
+
+	public String getName() {
+		return symbolName;
+	}
+
+
+	public int getPurge() {
+		return purge;
+	}
+
+
+	public String getComment() {
+		return comment;
+	}
+
+
+	public String getForwardLibName() {
+		return forwardLibName;
+	}
+
+
+	public String getForwardSymName() {
+		return forwardSymName;
+	}
+
+
+	public String getNoReturnStr() {
+		return noReturnStr;
+	}
+
+
+	public boolean isNoReturn() {
+		return noReturn;
+	}
+
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibraryLookupTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibraryLookupTable.java
index 13cc9933c1..ad56b05d6c 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibraryLookupTable.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibraryLookupTable.java
@@ -181,7 +181,7 @@ public class LibraryLookupTable {
 
 	/**
 	 * Get the symbol table associated with the DLL name
-	 * 
+	 *
 	 * @param dllName The DLL name (including extension)
 	 * @param size The architecture size of the DLL (e.g., 32 or 64).
 	 * @return LibrarySymbolTable associated with dllName
@@ -195,9 +195,9 @@ public class LibraryLookupTable {
 	 * Get the symbol table associated with the DLL name.  If not previously
 	 * generated for the given dllName, it will be constructed from a .exports
 	 * file found within the 'symbols' resource area.  If a .exports file
-	 * is not found a similarly named .ord file will be used if found.  The 
+	 * is not found a similarly named .ord file will be used if found.  The
 	 * .exports file is a Ghidra XML file formatted file, while the .ord file
-	 * is produced with the Visual Studio DUMPBIN /EXPORTS command.  The default 
+	 * is produced with the Visual Studio DUMPBIN /EXPORTS command.  The default
 	 * resource area is located within the directory
 	 * <pre>
 	 *   Ghidra/Features/Base/data/symbols/[win32|win64]
@@ -209,7 +209,7 @@ public class LibraryLookupTable {
 	 * }</pre>
 	 * The cacheMap is a static cache which always returns the same
 	 * instance for a given DLL name.
-	 * 
+	 *
 	 * @param dllName The DLL name (including extension)
 	 * @param size The architecture size of the DLL (e.g., 32 or 64).
 	 * @param log The message log (could be null)
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibrarySymbolTable.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibrarySymbolTable.java
index 6c1a2c9209..33b953fbc2 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibrarySymbolTable.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/LibrarySymbolTable.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -86,7 +86,7 @@ class LibrarySymbolTable {
 	}
 
 	/**
-	 * Construct a library symbol table based upon a specified library in the 
+	 * Construct a library symbol table based upon a specified library in the
 	 * form of a {@link Program} object.
 	 * @param library library program
 	 * @param monitor task monitor
@@ -260,7 +260,7 @@ class LibrarySymbolTable {
 	 * Each ordinal mapping line is expected to have the format, starting with ordinal number and
 	 * ending with symbol name:
 	 *   &lt;ordinal&gt; &lt;other-column-data&gt; &lt;name&gt;
-	 * The name column contains the symbol name followed by an optional demangled form.  If the name starts with 
+	 * The name column contains the symbol name followed by an optional demangled form.  If the name starts with
 	 * [NONAME] this will be stripped.
 	 * @param ordinalExportsFile file path to ordinal mapping file produced by DUMPBIN /EXPORTS
 	 * @param addMissingOrdinals if true new entries will be created for ordinal mappings
@@ -279,7 +279,7 @@ class LibrarySymbolTable {
 			while ((inString = in.readLine()) != null) {
 
 				if (mode == NONE && inString.trim().startsWith("ordinal")) {
-					// rely on column header labels to establish ordinal and name column start/end 
+					// rely on column header labels to establish ordinal and name column start/end
 					int ordinalColumnStartIndex = inString.indexOf("ordinal");
 					if (ordinalColumnStartIndex < 0) {
 						continue;
@@ -367,7 +367,7 @@ class LibrarySymbolTable {
 
 	/**
 	 * Returns the symbol for the specified ordinal.
-	 * 
+	 *
 	 * @param ordinal the ordinal value of the desired symbol
 	 * @return the symbol for the specified ordinal, or null if one does not
 	 *         exist.
@@ -378,7 +378,7 @@ class LibrarySymbolTable {
 
 	/**
 	 * Returns the symbol for the specified name
-	 * 
+	 *
 	 * @param symbol the name of the desired symbol
 	 * @return symbol map entry or null if not found
 	 */
@@ -389,7 +389,7 @@ class LibrarySymbolTable {
 	/**
 	 * Returns a string describing the version of this library. For example,
 	 * "5.100.2566".
-	 * 
+	 *
 	 * @return a string describing the version of this library
 	 */
 	String getVersion() {
@@ -427,6 +427,7 @@ class LibrarySymbolTable {
 			version = root.getAttributeValue("VERSION");
 
 			List<Element> children = CollectionUtils.asList(root.getChildren(), Element.class);
+/*
 			for (Element export : children) {
 				int ordinal = Integer.parseInt(export.getAttributeValue("ORDINAL"));
 				String name = export.getAttributeValue("NAME");
@@ -443,6 +444,66 @@ class LibrarySymbolTable {
 					forwards.add(forwardLibName);
 				}
 
+				LibraryExportedSymbol sym = new LibraryExportedSymbol(tableName, size, ordinal,
+					name, forwardLibName, forwardSymName, purge, noReturn, comment);
+
+				exportList.add(sym);
+				symMap.put(name, sym);
+				ordMap.put(Integer.valueOf(ordinal), sym);
+			}
+*/
+
+			List<LibraryExport> libraryExports = new ArrayList<LibraryExport>();
+
+			for (Element child : children) {
+				libraryExports.add(new LibraryExport(child));
+			}
+
+			try {
+//ShowDebugInfo.printf("Size of %s is %d\n", tableName, libraryExports.size());
+				libraryExports.sort((e1, e2) -> {
+					int result = 0;
+					if (e1.getOrdinal() != e2.getOrdinal()) {
+						result = e1.getOrdinal() - e2.getOrdinal();
+					} else if (e1.getName().startsWith(SymbolUtilities.ORDINAL_PREFIX)) {
+						result = +1;
+					} else if (e2.getName().startsWith(SymbolUtilities.ORDINAL_PREFIX)) {
+						result = -1;
+					} else {
+						result = e1.getName().compareTo(e2.getName());
+					}
+					return result;
+				});
+			}
+			catch (Exception e) {
+				// TODO: handle exception
+				System.out.println(e.getMessage());
+			}
+
+			int preOrdinal = -1;
+			for (LibraryExport export : libraryExports) {
+				int ordinal = export.getOrdinal();
+				if (preOrdinal == ordinal) {
+					continue;
+				}
+
+				preOrdinal = ordinal;
+				String name = export.getName();
+//ShowDebugInfo.printf("In LibrarySymbolTable.read:(...) %s <ord %3d> : '%s'\n", file.getName(), ordinal, name);
+System.out.printf("In LibrarySymbolTable.read:(...) %s <ord %3d> : '%s'\n", file.getName(), ordinal, name);
+				int purge = export.getPurge();
+				String comment = export.getComment();
+				String forwardLibName = export.getForwardLibName();
+				String forwardSymName = export.getForwardSymName();
+
+				String noReturnStr = export.getNoReturnStr();
+				boolean noReturn = noReturnStr != null && "y".equals(noReturnStr);
+
+				if (forwardLibName != null && forwardLibName.length() > 0 &&
+					!forwardLibName.equals(tableName)) {
+					forwards.add(forwardLibName);
+				}
+
 				LibraryExportedSymbol sym = new LibraryExportedSymbol(tableName, size, ordinal,
 					name, forwardLibName, forwardSymName, purge, noReturn, comment);
 
@@ -557,7 +618,7 @@ class LibrarySymbolTable {
 	/**
 	 * Check an existing exports file to verify that it corresponds to the
 	 * specified libraryFile.
-	 * 
+	 *
 	 * @param exportsFile existing exports file
 	 * @param libraryFile library file
 	 * @return true if exports file corresponds to library file
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/NeLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/NeLoader.java
index e47352ed4e..e7152c54f4 100644
--- a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/NeLoader.java
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/NeLoader.java
@@ -433,6 +433,7 @@ public class NeLoader extends AbstractOrdinalSupportLoader {
 		ExternalManager externalManager = program.getExternalManager();
 		FunctionManager functionManager = program.getFunctionManager();
 		Namespace globalNamespace = program.getGlobalNamespace();
+		ReferenceManager refManager = program.getReferenceManager();
 
 		LengthStringSet[] names = mrt.getNames();
 		String[][] mod2proclist = new String[names.length][];
@@ -482,9 +483,15 @@ public class NeLoader extends AbstractOrdinalSupportLoader {
 				try {
 					functionManager.createThunkFunction(null, globalNamespace, addr, body,
 						refFunction, SourceType.IMPORTED);
-				}
+					refManager.addExternalReference(addr, moduleName,
+							callname, null, SourceType.IMPORTED, 0, RefType.DATA);
+					}
 				catch (OverlappingFunctionException e) {
 					log.appendMsg(e.getMessage() + '\n');
+				} catch (InvalidInputException e) {
+					log.appendMsg(e.getMessage() + '\n');
+				} catch (DuplicateNameException e) {
+					log.appendMsg(e.getMessage() + '\n');
 				}
 				addr = addr.addWrap(thunkBodySize);
 			}
diff --git a/Ghidra/Features/Base/src/main/javacc/ghidra/app/util/cparser/C/C.jj b/Ghidra/Features/Base/src/main/javacc/ghidra/app/util/cparser/C/C.jj
index f6e8839509..3e6be0b2e7 100644
--- a/Ghidra/Features/Base/src/main/javacc/ghidra/app/util/cparser/C/C.jj
+++ b/Ghidra/Features/Base/src/main/javacc/ghidra/app/util/cparser/C/C.jj
@@ -48,13 +48,16 @@
 
   TODO:
 
-    Insert the appropiate code to enable C source trees from this grammar.
+    Insert the appropriate code to enable C source trees from this grammar.
 
   */
 
 
 
 options {
+//    DEBUG_LOOKAHEAD=true;
+//    DEBUG_PARSER=true;
+
     // Methods and class variables should not be static to allow multiple parsers to be in use.
     // This is at the expense of some speed.
     STATIC= false;
@@ -129,7 +132,7 @@ public class CParser {
     private final static String ANONYMOUS_UNION_PREFIX = "_union_";
     private final static String ANONYMOUS_FUNC_PREFIX = "_func_";
         
-    // Stack for determining when the parser is parsing a typdef definition.
+    // Stack for determining when the parser is parsing a typedef definition.
     private Stack<Boolean> typedefParsingStack = new Stack<Boolean>();
 
     // Stack for putting defined data types on
@@ -156,7 +159,7 @@ public class CParser {
     private CategoryPath getCurrentCategoryPath() {
         return getCategory(currentCategoryName);
     }
-    
+
     private CategoryPath getCurrentCategoryPath(String subCatName) {
         return getCategory(currentCategoryName).extend(subCatName);
     }
@@ -262,10 +265,10 @@ public class CParser {
             }
         }
 
-        DataType dt = findDataType(type);
+            DataType dt = findDataType(type);
         if (dt != null && (functionsOK || !(dt instanceof FunctionDefinition))) {
-            return dt;
-        }    
+                return dt;
+            }
         
         // check the BuiltinTypeManager
         BuiltInDataTypeManager builtInMgr = BuiltInDataTypeManager.getDataTypeManager();
@@ -462,7 +465,7 @@ public class CParser {
                             }
                     }
                     try {
-                        comp.setName(nameStr);
+                    comp.setName(nameStr);
                     } catch (InvalidNameException e) {
                         // This should not happen
                         e.printStackTrace();
@@ -471,7 +474,7 @@ public class CParser {
                         e.printStackTrace();
                     }
                     comp = (Composite) addDef(composites, nameStr, comp);
-            }
+    }
 
             return comp;
     }
@@ -995,25 +998,31 @@ public class CParser {
 
         // Run the parser
     public static void main(String args[]) {
-            CParser parser = new CParser();
+        CParser parser = new CParser();
 
         try {
             if (args.length == 0) {
                 System.out.println("C Parser:  Reading from standard input . . .");
                 parser.parse(System.in);
-            } else if (args.length == 1) {
-                System.out.println("C Parser:  Reading from file " + args[0] + " . . .");
+            } else if (args.length >= 1) {
+                int i = 0;
+                if (args.length >= 2) {
+                    i = Integer.parseInt(args[0]);
+                }
+                System.out.println("C Parser:  Reading from file " + args[i] + " . . .");
                 try {
-                        parser.parse(new java.io.FileInputStream(args[0]));
+                        parser.parse(new java.io.FileInputStream(args[i]));
                 } catch (java.io.FileNotFoundException e) {
-                        System.out.println("C Parser:  File " + args[0] + " not found.");
-                        return;
+                        System.out.println("C Parser:  File " + args[i] + " not found.");
+                    return;
                 }
             } else {
                 System.out.println("C Parser:  Usage is one of:");
                 System.out.println("         java CParser < inputfile");
                 System.out.println("OR");
                 System.out.println("         java CParser inputfile");
+                System.out.println("OR");
+                System.out.println("         java CParser whichfile inputfile ...");
                 return;
             }
 
@@ -1193,9 +1202,9 @@ TOKEN :
     |
     <CDECL : ( [ "_" ] )+ "cdecl"> 
     |
-    <STDCALL : ( [ "_" ] )+ "stdcall"> 
+    <STDCALL : ( [ "_" ] )+ "stdcall">
     |
-    <FASTCALL : ( [ "_" ] )+ "fastcall"> 
+    <FASTCALL : ( [ "_" ] )+ "fastcall">
     |
     <VECTORCALL : ( [ "_" ] )+ "vectorcall"> 
     |
@@ -1203,6 +1212,14 @@ TOKEN :
     |
     <PASCALCALL : ( [ "_" ] )+ "pascal">
     |
+    <BASEDSPEC : ( [ "_" ] )+ "based">
+    |
+    <SEGNAMESPEC : ( [ "_" ] )+ "segname">
+    |
+    <SEGMENT : ( [ "_" ] )+ "segment">
+    |
+    <OFFSET : ( [ "_" ] )+ "offset">
+    |
     <NORETURN : "_Noreturn" >
     |
     <ALIGNAS : "_Alignas" >
@@ -1261,9 +1278,11 @@ TOKEN :
     |
     <GOTO : "goto"> 
     |
-    <NEAR : "__near"> 
+    <NEAR : ( [ "_" ] )* "near">
+    |
+    <FAR : ( [ "_" ] )* "far">
     |
-    <FAR : "__far"> 
+    <HUGE : ( [ "_" ] )* "huge">
     |
     <FOR : "for"> 
     |
@@ -1284,7 +1303,7 @@ TOKEN :
 
 TOKEN :
 {
-    <IDENTIFIER : <LETTER> ( <LETTER> | <DIGIT> )*> 
+    <IDENTIFIER : <LETTER> ( <LETTER> | <DIGIT> | "::")*>
     |
     <#LETTER : [ "$", "A"-"Z", "_", "a"-"z" ]> 
     |
@@ -1493,6 +1512,7 @@ void TranslationUnit() : {}
     < EOF >
     {
         //jjt         return jjtThis;
+        printTypes();
     }
 }
 
@@ -1612,7 +1632,7 @@ Declaration DeclarationSpecifiers(Declaration specDT) : {
 //            LOOKAHEAD(DeclarationSpecifiers()
 //                     , { (typeDT == null ||
 //                         (!typeDT.getName().equals(getToken(1).image) && !isType(getToken(1).image))) }
- //                     )
+//                     )
             specDT = DeclarationSpecifiers(specDT)
         ]
         |
@@ -1665,6 +1685,10 @@ Declaration BuiltInTypeSpecifier(Declaration dec) : {
 }
 {
     (
+        <SEGMENT>    { dec.setDataType(SegmentCodePointerDataType.dataType); }
+        |
+        <OFFSET>    { dec.setDataType(OffsetCodePointerDataType.dataType); }
+        |
         <VOID>                 { dec.setDataType(resolveInternal(VoidDataType.dataType)); }
         |
         <CHAR>                 {   dt = dec.getDataType();
@@ -1822,13 +1846,15 @@ Declaration TypeQualifier(Declaration dec) : {}
       <CONST>  { dec.addQualifier(CONST); } |
       <VOLATILE> |
       <CDECL> { dec.addQualifier(CDECL); } |
-      <NEAR> |
-      <FAR> |
+      <NEAR> { dec.setNear(true); } |
+      <FAR> { dec.setFar(true); } |
+      <HUGE> { dec.setHuge(true); } |
+      <SEGMENT> |
+      <OFFSET> |
       <STDCALL> { dec.addQualifier(STDCALL); } |
       <FASTCALL> { dec.addQualifier(FASTCALL); } |
       <VECTORCALL> { dec.addQualifier(VECTORCALL); } |
       <RUSTCALL> { dec.addQualifier(RUSTCALL); } |
-      <PASCALCALL> { dec.addQualifier(PASCALCALL); } |
       <NORETURN> { dec.addQualifier(NORETURN); } |
       <W64> |
       <PTR64> |
@@ -1837,6 +1863,7 @@ Declaration TypeQualifier(Declaration dec) : {}
       <RESTRICT> |
       <EXTENSION> |
       <STATIC> |
+      ( BasedSpec() ) |
       <PACKED> |
       <UNALIGNED> |
       ( DeclSpec(dec) )
@@ -1899,6 +1926,25 @@ void SubIdent(Declaration dec) : {
     }
 }
 
+void BasedSpec() : {
+}
+{
+  ( ( <BASEDSPEC> ) "(" BasedSpecifier() ")" )
+}
+
+void BasedSpecifier() : {
+}
+{
+  <VOID> |
+  ( SegnameSpec() )
+}
+
+void SegnameSpec() : {
+}
+{
+  ( ( <SEGNAMESPEC> ) "(" "\"" <IDENTIFIER> "\"" ")" )
+}
+
 void DeclSpec(Declaration dec) : {
 }
 {
@@ -2068,11 +2114,11 @@ DataType StructOrUnionSpecifier() : {
         sname= <IDENTIFIER> 
     )
     {
-        if (t != null) {
-            comp = defineNamedComposite(t, parent, comp);
-        } else if (sname != null) {
-            comp = defineForwardDeclaredComposite(sname, comp);
-        }
+            if (t != null) {
+                comp = defineNamedComposite(t, parent, comp);
+            } else if (sname != null) {
+                comp = defineForwardDeclaredComposite(sname, comp);
+                    }
         typedefParsingStack.pop();
         return comp;
     }
@@ -2088,25 +2134,25 @@ Composite StructOrUnion() : {
         {
             comp =  new StructureDataType(getCurrentCategoryPath(), ANONYMOUS_STRUCT_PREFIX + cnt++, 0, dtMgr);
 
-            // Always set the packing, because by default structures should be aligned
-            if (packSize > 0) {
-                comp.setExplicitPackingValue(packSize);
-            }
-            else {
-                comp.setPackingEnabled(true); // ensure default packing enabled
-            }
+                                        // Always set the packing, because by default structures should be aligned
+                                      if (packSize > 0) {
+                                          comp.setExplicitPackingValue(packSize);
+                                      }
+                                      else {
+                                          comp.setPackingEnabled(true); // ensure default packing enabled
+                                      }
                                    
-        }
+                                }
         |
         <UNION>  ( DeclSpec(dec) )* {
             comp = new UnionDataType(getCurrentCategoryPath(), ANONYMOUS_UNION_PREFIX  + cnt++, dtMgr); 
         
-            // Always set the packing, because by default structures should be aligned
-            if (packSize > 0) {
-                comp.setExplicitPackingValue(packSize);
+                                  // Always set the packing, because by default structures should be aligned
+                                  if (packSize > 0) {
+                                      comp.setExplicitPackingValue(packSize);
             } else {
-                comp.setPackingEnabled(true); // ensure default packing enabled
-            }
+                                      comp.setPackingEnabled(true); // ensure default packing enabled
+                                  }
         }
     )
     {
@@ -2350,7 +2396,7 @@ Declaration DirectDeclarator(Declaration dt, DataType container) : {
     [ PragmaSpec() ]
     (
         (
-            t= <IDENTIFIER>        { dec= new Declaration(dt, t.image); }
+          t= <IDENTIFIER>        { dec= new Declaration(dt, t.image); }
             |
             "(" dec= Declarator(new Declaration(funcDT=newAnonymousFunction(funcDT)), null) ")" 
             {
@@ -2360,27 +2406,27 @@ Declaration DirectDeclarator(Declaration dt, DataType container) : {
         { lastDataType = dec.getDataType(); }
         (
             (
-                "[" [ obj = ConditionalExpression() ] "]" 
-                {
-                    // make a new array given value on constant expression
-                    Integer size = getConstantValue(obj, 0);
-                    if (size == null) {
-                        System.out.println("BAD ARRAY SIZE! " + obj);
-                        size = 0;
-                    }
-                    list.add(0,size);
+            "[" [ obj = ConditionalExpression() ] "]"
+            {
+                // make a new array given value on constant expression
+                Integer size = getConstantValue(obj, 0);
+                if (size == null) {
+                    System.out.println("BAD ARRAY SIZE! " + obj);
+                    size = 0;
+                }
+                list.add(0,size);
                 }
             )*
         )
         {
             if (list.size() > 0) {
-            dec.setDataType(dt.getDataType());
-            for (Iterator iterator = list.iterator(); iterator.hasNext();) {
-                Integer iSize = (Integer) iterator.next();
-                DataType decDt = dec.getDataType();
-                dec.setDataType(new ArrayDataType(decDt, iSize, decDt.getLength()));
-            }
-            //System.out.println("Array expr: for " + dec.getName() + " make an array " + dt.getName() + "["+size+"]");
+                dec.setDataType(dt.getDataType());
+                for (Iterator iterator = list.iterator(); iterator.hasNext();) {
+                    Integer iSize = (Integer) iterator.next();
+                    DataType decDt = dec.getDataType();
+                    dec.setDataType(new ArrayDataType(decDt, iSize, decDt.getLength()));
+                }
+                //System.out.println("Array expr: for " + dec.getName() + " make an array " + dt.getName() + "["+size+"]");
             }
         }
         
@@ -2432,7 +2478,18 @@ Declaration Pointer(Declaration dec) : {}
     ("*" | "&") [ dec = TypeQualifierList(dec) ] [ dec = Pointer(dec) ] 
     {
         // TODO: is this right?
-        dec.setDataType(dtMgr.getPointer(dec.getDataType()));
+        if (dec.isNear() && (dec.isFar() || dec.isHuge())) {
+            Msg.info(this, "Mmm, can't be NEAR and (FAR or HUGE)");
+            dec.setDataType(dtMgr.getPointer(dec.getDataType()));
+        } else if (dec.isNear()) {
+            dec.setDataType(dtMgr.getPointer(dec.getDataType(), 2));
+        } else if (dec.isFar()) {
+            dec.setDataType(dtMgr.getPointer(dec.getDataType(), 4));
+        } else if (dec.isHuge()) {
+            dec.setDataType(dtMgr.getPointer(dec.getDataType(), 4));
+        } else {
+            dec.setDataType(dtMgr.getPointer(dec.getDataType()));
+        }
         return dec;
     }
 }
diff --git a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/function/EditFunctionSignatureDialogTest.java b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/function/EditFunctionSignatureDialogTest.java
index f9f6fda857..d60b8f3b84 100644
--- a/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/function/EditFunctionSignatureDialogTest.java
+++ b/Ghidra/Features/Base/src/test.slow/java/ghidra/app/plugin/core/function/EditFunctionSignatureDialogTest.java
@@ -51,6 +51,39 @@ public class EditFunctionSignatureDialogTest extends AbstractGhidraHeadedIntegra
 		env.dispose();
 	}
 
+	@Test
+	public void testParseSignature_GoodSingleArray() throws Exception {
+
+		String signature = "void test(int [12] a)";
+		Function f = function("test", signature);
+		EditFunctionSignatureDialog dialog = new EditFunctionSignatureDialog(tool, "Title", f);
+		FunctionDefinitionDataType definition = dialog.parseSignature();
+		assertNotNull(definition);
+		assertEquals(signature, definition.getPrototypeString());
+	}
+
+	@Test
+	public void testParseSignature_GoodMultiArray() throws Exception {
+
+		String signature = "void test(int [9][4] a, char [30][10] b)";
+		Function f = function("test", signature);
+		EditFunctionSignatureDialog dialog = new EditFunctionSignatureDialog(tool, "Title", f);
+		FunctionDefinitionDataType definition = dialog.parseSignature();
+		assertNotNull(definition);
+		assertEquals(signature, definition.getPrototypeString());
+	}
+
+	@Test
+	public void testParseSignature_GoodMixedSizePointers() throws Exception {
+
+		String signature = "void *32 test(int *32 a, int *24 b)";
+		Function f = function("test", signature);
+		EditFunctionSignatureDialog dialog = new EditFunctionSignatureDialog(tool, "Title", f);
+		FunctionDefinitionDataType definition = dialog.parseSignature();
+		assertNotNull(definition);
+		assertEquals(signature, definition.getPrototypeString());
+	}
+
 	@Test
 	public void testParseSignature_Good() throws Exception {
 
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.cc
index ab3483d5f3..c9a189b239 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.cc
@@ -34,6 +34,7 @@ AttributeId ATTRIB_STACKSHIFT = AttributeId("stackshift",126);
 AttributeId ATTRIB_STRATEGY = AttributeId("strategy",127);
 AttributeId ATTRIB_THISBEFORERETPOINTER = AttributeId("thisbeforeretpointer",128);
 AttributeId ATTRIB_VOIDLOCK = AttributeId("voidlock",129);
+AttributeId ATTRIB_ISRIGHTTOLEFT = AttributeId("isrighttoleft",153);
 
 ElementId ELEM_GROUP = ElementId("group",160);
 ElementId ELEM_INTERNALLIST = ElementId("internallist",161);
@@ -763,7 +764,7 @@ uint4 ParamListStandard::assignAddress(Datatype *dt,const PrototypePieces &proto
   return assignAddressFallback(store,dt,false,status,res);
 }
 
-void ParamListStandard::assignMap(const PrototypePieces &proto,TypeFactory &typefactory,vector<ParameterPieces> &res) const
+void ParamListStandard::assignMapRtoL(const PrototypePieces &proto,TypeFactory &typefactory,vector<ParameterPieces> &res) const
 
 {
   vector<int4> status(numgroup,0);
@@ -789,6 +790,49 @@ void ParamListStandard::assignMap(const PrototypePieces &proto,TypeFactory &type
   }
 }
 
+void ParamListStandard::assignMapLtoR(const PrototypePieces &proto,TypeFactory &typefactory,vector<ParameterPieces> &res) const
+
+{
+  ParameterPieces* hiddenpiece = (res.size() == 2) ? &res.back() : (ParameterPieces*)0;
+
+  vector<int4> status(numgroup,0);
+
+  // allocate storage backwards in temporary results
+  vector<ParameterPieces> tmpres;
+  for(int4 i=proto.intypes.size()-1;i>=0;--i) {
+    tmpres.emplace_back();
+    Datatype *dt = proto.intypes[i];
+    uint4 responseCode = assignAddress(dt,proto,proto.intypes.size()-1-i,typefactory,status,tmpres.back());
+    if (responseCode == AssignAction::fail || responseCode == AssignAction::no_assignment)
+      throw ParamUnassignedError("Cannot assign parameter address for " + dt->getName());
+  }
+  // add tmpres to res in reverse leaving the hiddenpiece at the end
+  res.resize(res.size() + tmpres.size());
+  reverse_copy(tmpres.begin(),tmpres.end(),res.begin()+1);
+
+  if (hiddenpiece) {	// Check for hidden parameters defined by the output list
+    Datatype *dt = hiddenpiece->type;
+    type_class store;
+    if ((hiddenpiece->flags & ParameterPieces::hiddenretparm) != 0)
+      store = TYPECLASS_HIDDENRET;
+    else
+      store = metatype2typeclass(dt->getMetatype());
+    // Reserve last param for hidden return pointer
+    if (assignAddressFallback(store,dt,false,status,*hiddenpiece) == AssignAction::fail)
+      throw ParamUnassignedError("Cannot assign parameter address for " + hiddenpiece->type->getName());
+    hiddenpiece->flags |= ParameterPieces::hiddenretparm;
+  }
+}
+
+void ParamListStandard::assignMap(const PrototypePieces &proto,TypeFactory &typefactory,vector<ParameterPieces> &res) const
+
+{
+  if (proto.model->getRightToLeft())
+    assignMapRtoL(proto, typefactory, res);
+  else
+    assignMapLtoR(proto, typefactory, res);
+}
+
 /// From among the ParamEntrys matching the given \e group, return the one that best matches
 /// the given \e metatype attribute. If there are no ParamEntrys in the group, null is returned.
 /// \param grp is the given \e group number
@@ -1563,7 +1607,8 @@ void ParamListStandardOut::assignMap(const PrototypePieces &proto,TypeFactory &t
     AddrSpace *spc = spacebase;
     if (spc == (AddrSpace *)0)
       spc = typefactory.getArch()->getDefaultDataSpace();
-    int4 pointersize = spc->getAddrSize();
+//    int4 pointersize = spc->getAddrSize();
+    int4 pointersize = proto.model->getPointerSize(spc);
     int4 wordsize = spc->getWordSize();
     Datatype *pointertp = typefactory.getTypePointer(pointersize, proto.outtype, wordsize);
     if (responseCode == AssignAction::hiddenret_specialreg_void) {
@@ -2320,6 +2365,7 @@ ProtoModel::ProtoModel(Architecture *g)
   injectUponReturn = -1;
   stackgrowsnegative = true;	// Normal stack parameter ordering
   hasThis = false;
+  isRightToLeft = true;
   isConstruct = false;
   isPrinted = true;
   defaultLocalRange();
@@ -2359,6 +2405,7 @@ ProtoModel::ProtoModel(const string &nm,const ProtoModel &op2)
   if (name == "__thiscall")
     hasThis = true;
   compatModel = &op2;
+  isRightToLeft = op2.isRightToLeft;
 }
 
 ProtoModel::~ProtoModel(void)
@@ -2416,21 +2463,49 @@ void ProtoModel::assignParameterStorage(const PrototypePieces &proto,vector<Para
   }
   input->assignMap(proto,*glb->types,res);
 
+  // the following fails with mixed sized pointers (e.g. near & far) for the 'this' & 'hiddenretparm' pieces
   if (hasThis && res.size() > 1) {
     int4 thisIndex = 1;
     if ((res[1].flags & ParameterPieces::hiddenretparm) != 0 && res.size() > 2) {
       if (input->isThisBeforeRetPointer()) {
 					// pointer has been bumped by auto-return-storage
-	res[1].swapMarkup(res[2]);	// must swap markup for slots 1 and 2
+        res[1].swapMarkup(res[2]);	// must swap markup for slots 1 and 2
       }
       else {
-	thisIndex = 2;
+        thisIndex = 2;
       }
     }
     res[thisIndex].flags |= ParameterPieces::isthis;
   }
 }
 
+/// \brief Does \param str end with \param end
+template<typename TString>
+inline bool ends_with(const TString& str, const TString& end) {
+  if (end.size() > str.size()) return false;
+  return std::equal(end.rbegin(), end.rend(), str.rbegin());
+}
+
+/// \brief Used to return the size of a pointer for this model prototype.
+/// @param space is the default AddrSpace
+/// @return size of pointer
+/*
+*/
+int ProtoModel::getPointerSize(const AddrSpace* space) const
+
+{
+//  if (space == (const AddrSpace*)0)
+  //  return -1;
+  int4 pointerSize = (space == (const AddrSpace*)0) ? -1 : space->getAddrSize();
+  if (ends_with<string>(name, "16near")) {
+    pointerSize = 2;
+  }
+  else if (ends_with<string>(name, "16far")) {
+    pointerSize = 4;
+  }
+  return pointerSize;
+}
+
 /// \brief Look up an effect from the given EffectRecord list
 ///
 /// If a given memory range matches an EffectRecord, return the effect type.
@@ -2532,6 +2607,7 @@ void ProtoModel::decode(Decoder &decoder)
   extrapop = -300;
   hasThis = false;
   isConstruct = false;
+  isRightToLeft = false;
   isPrinted = true;
   effectlist.clear();
   injectUponEntry = -1;
@@ -2559,6 +2635,9 @@ void ProtoModel::decode(Decoder &decoder)
     else if (attribId == ATTRIB_CONSTRUCTOR) {
       isConstruct = decoder.readBool();
     }
+    else if (attribId == ATTRIB_ISRIGHTTOLEFT) {
+      isRightToLeft = decoder.readBool();
+    }
     else
       throw LowlevelError("Unknown prototype attribute");
   }
@@ -4059,7 +4138,7 @@ void FuncProto::updateInputTypes(Funcdata &data,const vector<Varnode *> &trialli
 	  pieces.type = vn->getHigh()->getType();
 	else
 	  pieces.type = data.getArch()->types->getBase(sz, TYPE_UNKNOWN);
-	pieces.flags = 0;
+        pieces.flags = 0;
       }
       else {
 	pieces.addr = trial.getAddress();
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.hh b/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.hh
index eb4c4f4ce8..55753dec41 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.hh
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/fspec.hh
@@ -43,6 +43,7 @@ extern AttributeId ATTRIB_STACKSHIFT;	///< Marshaling attribute "stackshift"
 extern AttributeId ATTRIB_STRATEGY;	///< Marshaling attribute "strategy"
 extern AttributeId ATTRIB_THISBEFORERETPOINTER;	///< Marshaling attribute "thisbeforeretpointer"
 extern AttributeId ATTRIB_VOIDLOCK;	///< Marshaling attribute "voidlock"
+extern AttributeId ATTRIB_ISRIGHTTOLEFT;	///< Marshaling attribute "isrighttoleft"
 
 extern ElementId ELEM_GROUP;		///< Marshaling element \<group>
 extern ElementId ELEM_INTERNALLIST;	///< Marshaling element \<internallist>
@@ -437,7 +438,7 @@ public:
   /// \param proto is the ordered list of data-types
   /// \param typefactory is the TypeFactory (for constructing pointers)
   /// \param res will contain the storage locations corresponding to the datatypes
-  virtual void assignMap(const PrototypePieces &proto,TypeFactory &typefactory,vector<ParameterPieces> &res) const=0;
+  virtual void assignMap(const PrototypePieces &proto, TypeFactory &typefactory, vector<ParameterPieces> &res) const = 0;
 
   /// \brief Given an unordered list of storage locations, calculate a function prototype
   ///
@@ -622,6 +623,8 @@ public:
   uint4 assignAddress(Datatype *dt,const PrototypePieces &proto,int4 pos,TypeFactory &tlst,
 		      vector<int4> &status,ParameterPieces &res) const;
   virtual uint4 getType(void) const { return p_standard; }
+  virtual void assignMapRtoL(const PrototypePieces &proto,TypeFactory &typefactory,vector<ParameterPieces> &res) const;
+  virtual void assignMapLtoR(const PrototypePieces &proto,TypeFactory &typefactory,vector<ParameterPieces> &res) const;
   virtual void assignMap(const PrototypePieces &proto,TypeFactory &typefactory,vector<ParameterPieces> &res) const;
   virtual void fillinMap(ParamActive *active) const;
   virtual bool checkJoin(const Address &hiaddr,int4 hisize,const Address &loaddr,int4 losize) const;
@@ -759,6 +762,7 @@ class ProtoModel {
   bool stackgrowsnegative;	///< True if stack parameters have (normal) low address to high address ordering
   bool hasThis;			///< True if this model has a \b this parameter (auto-parameter)
   bool isConstruct;		///< True if this model is a constructor for a particular object
+  bool isRightToLeft;		///< True if parameters are stacked from right to left (default)
   bool isPrinted;		///< True if this model should be printed as part of function declarations
   void defaultLocalRange(void);	///< Set the default stack range used for local variables
   void defaultParamRange(void);	///< Set the default stack range used for input parameters
@@ -779,6 +783,7 @@ public:
   int4 getInjectUponEntry(void) const { return injectUponEntry; }	///< Get the inject \e uponentry id
   int4 getInjectUponReturn(void) const { return injectUponReturn; }	///< Get the inject \e uponreturn id
   bool isCompatible(const ProtoModel *op2) const;	///< Return \b true if other given model can be substituted for \b this
+  bool getRightToLeft(void) const { return isRightToLeft; }  ///< Return \b true if model uses right-to-left stacking of parameters
 
   /// \brief Given a list of input \e trials, derive the most likely input prototype
   ///
@@ -796,6 +801,11 @@ public:
 
   void assignParameterStorage(const PrototypePieces &proto,vector<ParameterPieces> &res,bool ignoreOutputError);
 
+  /// \brief Get pointer size based upon current address model or proto model name
+  /// \param space is the AddrSpace to get the default pointer (aka address) size
+  /// \return \b pointersize (or -1 if null \e space or no specific) for \b this model
+  int getPointerSize(const AddrSpace *space) const;
+
   /// \brief Check if the given two input storage locations can represent a single logical parameter
   ///
   /// Within the conventions of this model, do the two (hi/lo) locations represent
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/marshal.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/marshal.cc
index 3610a7da36..6a2bad4475 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/marshal.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/marshal.cc
@@ -1254,7 +1254,7 @@ AttributeId ATTRIB_WORDSIZE = AttributeId("wordsize",26);
 AttributeId ATTRIB_STORAGE = AttributeId("storage",149);
 AttributeId ATTRIB_STACKSPILL = AttributeId("stackspill",150);
 
-AttributeId ATTRIB_UNKNOWN = AttributeId("XMLunknown",152); // Number serves as next open index
+AttributeId ATTRIB_UNKNOWN = AttributeId("XMLunknown",154); // Number serves as next open index
 
 ElementId ELEM_DATA = ElementId("data",1);
 ElementId ELEM_INPUT = ElementId("input",2);
diff --git a/Ghidra/Features/Decompiler/src/decompile/cpp/modelrules.cc b/Ghidra/Features/Decompiler/src/decompile/cpp/modelrules.cc
index f93b95061e..6fd213d710 100644
--- a/Ghidra/Features/Decompiler/src/decompile/cpp/modelrules.cc
+++ b/Ghidra/Features/Decompiler/src/decompile/cpp/modelrules.cc
@@ -700,7 +700,7 @@ uint4 ConvertToPointer::assignAddress(Datatype *dt,const PrototypePieces &proto,
   AddrSpace *spc = space;
   if (spc == (AddrSpace*)0)
     spc = tlist.getArch()->getDefaultDataSpace();
-  int4 pointersize = spc->getAddrSize();
+  int4 pointersize = proto.model->getPointerSize(spc);
   int4 wordsize = spc->getWordSize();
   // Convert the data-type to a pointer
   Datatype *pointertp = tlist.getTypePointer(pointersize,dt,wordsize);
diff --git a/Ghidra/Framework/SoftwareModeling/data/languages/compiler_spec.rxg b/Ghidra/Framework/SoftwareModeling/data/languages/compiler_spec.rxg
index fb8febbf93..7a92e35ca7 100644
--- a/Ghidra/Framework/SoftwareModeling/data/languages/compiler_spec.rxg
+++ b/Ghidra/Framework/SoftwareModeling/data/languages/compiler_spec.rxg
@@ -463,6 +463,7 @@
     
     <optional> <attribute name="hasthis"/> </optional>
     <optional> <attribute name="constructor"/> </optional>
+    <optional> <attribute name="isrighttoleft"/> </optional>
 
     <interleave>
 
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/AddressModelDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/AddressModelDB.java
new file mode 100644
index 0000000000..fc0206b63b
--- /dev/null
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/AddressModelDB.java
@@ -0,0 +1,221 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.program.database.data;
+
+import java.io.IOException;
+import java.util.*;
+
+import db.DBRecord;
+import db.Field;
+import ghidra.docking.settings.Settings;
+import ghidra.program.database.DBObjectCache;
+import ghidra.program.model.data.*;
+import ghidra.program.model.mem.MemBuffer;
+import ghidra.program.model.symbol.SourceType;
+import ghidra.util.InvalidNameException;
+import ghidra.util.Msg;
+import ghidra.util.UniversalID;
+
+class AddressModelDB extends DataTypeDB {//implements AddressModel {
+
+	private AddressModelDBAdapter addrModelAdapter;
+
+	AddressModelDB(DataTypeManagerDB dataMgr, DBObjectCache<DataTypeDB> cache,
+			AddressModelDBAdapter adapter, FunctionParameterAdapter paramAdapter,
+			DBRecord record) {
+		super(dataMgr, cache, record);
+		this.addrModelAdapter = adapter;
+	}
+
+	@Override
+	public boolean hasLanguageDependantLength() {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	@Override
+	public DataType clone(DataTypeManager dtm) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public DataType copy(DataTypeManager dtm) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public String getMnemonic(Settings settings) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public int getLength() {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	@Override
+	public String getDescription() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public Object getValue(MemBuffer buf, Settings settings, int length) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public String getRepresentation(MemBuffer buf, Settings settings, int length) {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public boolean isEquivalent(DataType dt) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	@Override
+	public void dataTypeDeleted(DataType dt) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void dataTypeReplaced(DataType oldDt, DataType newDt) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void dataTypeNameChanged(DataType dt, String oldName) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public long getLastChangeTime() {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	@Override
+	public long getLastChangeTimeInSourceArchive() {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	@Override
+	public UniversalID getUniversalID() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	public void setLastChangeTime(long lastChangeTime) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public void setLastChangeTimeInSourceArchive(long lastChangeTimeInSourceArchive) {
+		// TODO Auto-generated method stub
+
+	}
+//
+//	@Override
+//	public String name() {
+//		// TODO Auto-generated method stub
+//		return null;
+//	}
+//
+//	@Override
+//	public int ordinal() {
+//		// TODO Auto-generated method stub
+//		return 0;
+//	}
+//
+//	@Override
+//	public void setComment(String comment) {
+//		// TODO Auto-generated method stub
+//
+//	}
+//
+//	@Override
+//	public String getComment() {
+//		// TODO Auto-generated method stub
+//		return null;
+//	}
+//
+	@Override
+	protected String doGetName() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	protected long doGetCategoryID() {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	@Override
+	protected void doSetCategoryPathRecord(long categoryID) throws IOException {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	protected void doSetNameRecord(String newName) throws IOException, InvalidNameException {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	protected UniversalID getSourceArchiveID() {
+		// TODO Auto-generated method stub
+		return null;
+	}
+
+	@Override
+	protected void setSourceArchiveID(UniversalID id) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	void setUniversalID(UniversalID oldUniversalID) {
+		// TODO Auto-generated method stub
+
+	}
+
+	@Override
+	public int getAlignedLength() {
+		// TODO Auto-generated method stub
+		return 0;
+	}
+
+	@Override
+	protected boolean isEquivalent(DataType dataType, DataTypeConflictHandler handler) {
+		return this.addressModel.equals(dataType.getAddressModel());
+	}
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/AddressModelDBAdapter.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/AddressModelDBAdapter.java
new file mode 100644
index 0000000000..752e138b72
--- /dev/null
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/AddressModelDBAdapter.java
@@ -0,0 +1,190 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.program.database.data;
+
+import java.io.IOException;
+
+import db.*;
+import ghidra.framework.data.OpenMode;
+import ghidra.util.UniversalID;
+import ghidra.util.exception.VersionException;
+import ghidra.util.task.TaskMonitor;
+
+/**
+ * Adapter to access the Address Model database table.
+ */
+abstract class AddressModelDBAdapter {
+
+	static final String ADDRESS_MODEL_TABLE_NAME = "Address Models";
+	static final Schema ADDRESS_MODEL_SCHEMA = AddressModelDBAdapterV0.V0_ADDRESS_MODEL_SCHEMA;
+
+	static final int ADDRESS_MODEL_DT_ID_COL = AddressModelDBAdapterV0.V0_ADDRESS_MODEL_DT_ID_COL;
+	static final int ADDRESS_MODEL_ID_COL = AddressModelDBAdapterV0.V0_ADDRESS_MODEL_ID_COL;
+
+	/**
+	 * Gets an adapter for working with the Address Model data type database table. The adapter is based
+	 * on the version of the database associated with the specified database handle and the openMode.
+	 * @param handle handle to the database to be accessed.
+	 * @param openMode the mode this adapter is to be opened for (CREATE, UPDATE, READ_ONLY, UPGRADE).
+	 * @param monitor the monitor to use for displaying status or for cancelling.
+	 * @return the adapter for accessing the table of Address Model data types.
+	 * @throws VersionException if the database handle's version doesn't match the expected version.
+	 * @throws IOException if there is trouble accessing the database.
+	 */
+	static AddressModelDBAdapter getAdapter(DBHandle handle, OpenMode openMode,
+			TaskMonitor monitor) throws VersionException, IOException {
+		try {
+			return new AddressModelDBAdapterV0(handle, openMode);
+		}
+		catch (VersionException e) {
+			if (!e.isUpgradable() || openMode == OpenMode.UPDATE) {
+				throw e;
+			}
+			AddressModelDBAdapter adapter = findReadOnlyAdapter(handle);
+			if (openMode == OpenMode.UPGRADE) {
+				adapter = upgrade(handle, adapter);
+			}
+			return adapter;
+		}
+	}
+
+	/**
+	 * Tries to get a read only adapter for the database whose handle is passed to this method.
+	 * @param handle handle to prior version of the database.
+	 * @return the read only Address Model data type table adapter
+	 * @throws VersionException if a read only adapter can't be obtained for the database handle's version.
+	 * @throws IOException if unable to access database.
+	 */
+	static AddressModelDBAdapter findReadOnlyAdapter(DBHandle handle)
+			throws VersionException, IOException {
+		try {
+			return new AddressModelDBAdapterV0(handle, OpenMode.IMMUTABLE);
+		}
+		catch (VersionException e) {
+			if (!e.isUpgradable()) {
+				throw e;
+			}
+		}
+
+		return new AddressModelDBAdapterNoTable(handle);
+	}
+
+	/**
+	 * Upgrades the Address Model data type table from the oldAdapter's version to the current version.
+	 * @param handle handle to the database whose table is to be upgraded to a newer version.
+	 * @param oldAdapter the adapter for the existing table to be upgraded.
+	 * @return the adapter for the new upgraded version of the table.
+	 * @throws VersionException if the the table's version does not match the expected version
+	 * for this adapter.
+	 * @throws IOException if the database can't be read or written.
+	 */
+	static AddressModelDBAdapter upgrade(DBHandle handle,
+			AddressModelDBAdapter oldAdapter) throws VersionException, IOException {
+
+		DBHandle tmpHandle = new DBHandle();
+		long id = tmpHandle.startTransaction();
+		AddressModelDBAdapter tmpAdapter = null;
+		try {
+			tmpAdapter = new AddressModelDBAdapterV0(tmpHandle, OpenMode.CREATE);
+			RecordIterator it = oldAdapter.getRecords();
+			while (it.hasNext()) {
+				DBRecord rec = it.next();
+				tmpAdapter.updateRecord(rec, false);
+			}
+			oldAdapter.deleteTable(handle);
+			AddressModelDBAdapterV0 newAdapter =
+				new AddressModelDBAdapterV0(handle, OpenMode.CREATE);
+			it = tmpAdapter.getRecords();
+			while (it.hasNext()) {
+				DBRecord rec = it.next();
+				newAdapter.updateRecord(rec, false);
+			}
+			return newAdapter;
+		}
+		finally {
+			tmpHandle.endTransaction(id, true);
+			tmpHandle.close();
+		}
+	}
+
+	/**
+	 * Creates a database record for the data types associated Address Model.
+	 * @param dataTypeID data type ID associated with the Address Model.
+	 * @param modelID the ID of the Address Model.
+	 * @return the database record for this data type.
+	 * @throws IOException if the database can't be accessed.
+	 */
+	abstract DBRecord createRecord(long dataTypeID, byte modelID) throws IOException;
+
+	/**
+	 * Gets a Address Model data type record from the database based on its ID.
+	 * @param dataTypeID the data type's ID.
+	 * @return the record for the Address Model data type.
+	 * @throws IOException if the database can't be accessed.
+	 */
+	abstract DBRecord getRecord(long dataTypeID) throws IOException;
+
+	/**
+	 * Gets an iterator over all Address Model data type records.
+	 * @return the Address Model data type record iterator.
+	 * @throws IOException if the database can't be accessed.
+	 */
+	abstract RecordIterator getRecords() throws IOException;
+
+	/**
+	 * Removes the Address Model data type record with the specified ID.
+	 * @param dataTypeID the ID of the data type.
+	 * @return true if the record is removed.
+	 * @throws IOException if the database can't be accessed.
+	 */
+	abstract boolean removeRecord(long dataTypeID) throws IOException;
+
+	/**
+	 * Updates the Address Model data type table with the provided record.
+	 * @param record the new record
+	 * @param setLastChangeTime true means change the last change time in the record to the
+	 * current time before putting the record in the database.
+	 * @throws IOException if the database can't be accessed.
+	 */
+	abstract void updateRecord(DBRecord record, boolean setLastChangeTime) throws IOException;
+
+	/**
+	 * Deletes the Address Model data type table from the database with the specified database handle.
+	 * @param handle handle to the database where the table should get deleted.
+	 * @throws IOException if the database can't be accessed.
+	 */
+	abstract void deleteTable(DBHandle handle) throws IOException;
+
+	/**
+	 * Gets an array with the IDs of all data types in the Address Model table that were derived
+	 * from the source data type archive indicated by the source archive ID.
+	 * @param archiveID the ID of the source archive whose data types we want.
+	 * @return the array data type IDs.
+	 * @throws IOException if the database can't be accessed.
+	 */
+//	abstract Field[] getRecordIdsForSourceArchive(long archiveID) throws IOException;
+
+	/**
+	 * Get Address Model record whose sourceID and datatypeID match the specified Universal IDs.
+	 * @param sourceID universal source archive ID
+	 * @param datatypeID universal datatype ID
+	 * @return Address Model record found or null
+	 * @throws IOException if IO error occurs
+	 */
+//	abstract DBRecord getRecordWithIDs(UniversalID sourceID, UniversalID datatypeID)
+//			throws IOException;
+
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/AddressModelDBAdapterNoTable.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/AddressModelDBAdapterNoTable.java
new file mode 100644
index 0000000000..dfc24b6389
--- /dev/null
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/AddressModelDBAdapterNoTable.java
@@ -0,0 +1,70 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.program.database.data;
+
+import ghidra.program.database.util.EmptyRecordIterator;
+import ghidra.util.UniversalID;
+
+import java.io.IOException;
+
+import db.*;
+
+/**
+ * Adapter needed for a read-only version of data type manager that is not going
+ * to be upgraded, and there is no Address Model table in the data type manager.
+ */
+class AddressModelDBAdapterNoTable extends AddressModelDBAdapter {
+
+	/**
+	 * Gets a pre-table version of the adapter for the Address Model database table.
+	 * @param handle handle to the database which doesn't contain the table.
+	 */
+	public AddressModelDBAdapterNoTable(DBHandle handle) {
+		// no table required
+	}
+
+	@Override
+	DBRecord createRecord(long dataTypeID, byte modelID) throws IOException {
+		throw new UnsupportedOperationException(
+			"Not allowed to update version prior to existence of Address Model Data Types table.");
+	}
+
+	@Override
+	public DBRecord getRecord(long addrModelID) throws IOException {
+		return null;
+	}
+
+	@Override
+	public RecordIterator getRecords() throws IOException {
+		return new EmptyRecordIterator();
+	}
+
+	@Override
+	public void updateRecord(DBRecord record, boolean setLastChangeTime) throws IOException {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean removeRecord(long addrModelID) throws IOException {
+		return false;
+	}
+
+	@Override
+	protected void deleteTable(DBHandle handle) {
+		// do nothing
+	}
+
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/AddressModelDBAdapterV0.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/AddressModelDBAdapterV0.java
new file mode 100644
index 0000000000..eff6e95ec0
--- /dev/null
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/AddressModelDBAdapterV0.java
@@ -0,0 +1,112 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.program.database.data;
+
+import java.io.IOException;
+
+import db.*;
+import ghidra.framework.data.OpenMode;
+import ghidra.program.model.data.*;
+import ghidra.util.Msg;
+import ghidra.util.UniversalID;
+import ghidra.util.UniversalIdGenerator;
+import ghidra.util.exception.VersionException;
+
+/**
+ * Version 0 implementation for accessing the Address Model database table.
+ */
+class AddressModelDBAdapterV0 extends AddressModelDBAdapter {
+	static final int VERSION = 0;
+	static final int V0_ADDRESS_MODEL_DT_ID_COL = 0;
+	static final int V0_ADDRESS_MODEL_ID_COL = 1;
+
+	static final Schema V0_ADDRESS_MODEL_SCHEMA = new Schema(VERSION, "Address Model ID",
+		new Field[] { LongField.INSTANCE, ByteField.INSTANCE },
+		new String[] { "Data Type ID", "Return Type ID" }
+	);
+
+	private Table table;
+
+	/**
+	 * Gets a version 0 adapter for the Function Definition database table.
+	 * @param handle handle to the database containing the table.
+	 * @param openMode {@link OpenMode} value.
+	 * @throws VersionException if the the table's version does not match the expected version
+	 * for this adapter.
+	 * @throws IOException if unable to create database table.
+	 */
+	public AddressModelDBAdapterV0(DBHandle handle, OpenMode openMode) throws VersionException, IOException {
+
+		if (openMode == OpenMode.CREATE) {
+			table = handle.createTable(ADDRESS_MODEL_TABLE_NAME, V0_ADDRESS_MODEL_SCHEMA,
+				new int[] { V0_ADDRESS_MODEL_DT_ID_COL });
+		}
+		else {
+			table = handle.getTable(ADDRESS_MODEL_TABLE_NAME);
+			if (table == null) {
+				throw new VersionException("Missing Table: " + ADDRESS_MODEL_TABLE_NAME, 0, true);
+			}
+			int version = table.getSchema().getVersion();
+			if (version != VERSION) {
+				String msg = "Expected version " + VERSION + " for table " + ADDRESS_MODEL_TABLE_NAME +
+					" but got " + table.getSchema().getVersion();
+				if (version < VERSION) {
+					throw new VersionException(msg, VersionException.OLDER_VERSION, true);
+				}
+				throw new VersionException(msg, VersionException.NEWER_VERSION, false);
+			}
+		}
+	}
+
+	@Override
+	public DBRecord createRecord(long dataTypeID, byte modelID) throws IOException {
+//		throw new UnsupportedOperationException("Not allowed to update prior version #" + VERSION +
+//			" of " + ADDRESS_MODEL_TABLE_NAME + " table.");
+
+		long tableKey = table.getKey();
+		DBRecord record = V0_ADDRESS_MODEL_SCHEMA.createRecord(tableKey);
+		record.setLongValue(V0_ADDRESS_MODEL_DT_ID_COL, dataTypeID);
+		record.setByteValue(V0_ADDRESS_MODEL_ID_COL, modelID);
+		table.putRecord(record);
+		return record;
+	}
+
+	@Override
+	public DBRecord getRecord(long dataTypeID) throws IOException {
+		return table.getRecord(dataTypeID);
+	}
+
+	@Override
+	public RecordIterator getRecords() throws IOException {
+		return table.iterator();
+	}
+
+	@Override
+	public void updateRecord(DBRecord record, boolean setLastChangeTime) throws IOException {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public boolean removeRecord(long dataTypeID) throws IOException {
+		return table.deleteRecord(dataTypeID);
+	}
+
+	@Override
+	protected void deleteTable(DBHandle handle) throws IOException {
+		handle.deleteTable(ADDRESS_MODEL_TABLE_NAME);
+	}
+
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeDB.java
index bfb175e18f..893a6926b9 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/DataTypeDB.java
@@ -47,6 +47,7 @@ abstract class DataTypeDB extends DatabaseObject implements DataType {
 	protected Lock lock;
 	private volatile String name;
 	private volatile Category category;
+	protected AddressModel addressModel;
 
 	protected DataTypeDB(DataTypeManagerDB dataMgr, DBObjectCache<DataTypeDB> cache,
 			DBRecord record) {
@@ -568,6 +569,16 @@ abstract class DataTypeDB extends DatabaseObject implements DataType {
 			getName().equals(otherDt.getName()) && isEquivalent(otherDt);
 	}
 
+	@Override
+	public AddressModel getAddressModel() {
+		return addressModel;
+	}
+
+	@Override
+	public void setAddressModel(AddressModel addressModel) {
+		this.addressModel = addressModel;
+	}
+
 	@Override
 	public boolean isEncodable() {
 		return false;
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/PointerDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/PointerDB.java
index 21aa3c398c..75235c2cf7 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/PointerDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/data/PointerDB.java
@@ -153,6 +153,9 @@ class PointerDB extends DataTypeDB implements Pointer {
 						displayName += Integer.toString(getLength() * 8);
 					}
 				}
+				else if (getLength() != dt.getDataOrganization().getPointerSize()) {
+					displayName = dt.getDisplayName() + "*" + Integer.toString(getLength() * 8);
+				}
 				else {
 					displayName = dt.getDisplayName() + " *";
 				}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/function/FunctionDB.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/function/FunctionDB.java
index 21bbe7ff53..de6f7fa065 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/function/FunctionDB.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/database/function/FunctionDB.java
@@ -1385,7 +1385,7 @@ public class FunctionDB extends DatabaseObject implements Function {
 
 				if (updateType == FunctionUpdateType.DYNAMIC_STORAGE_ALL_PARAMS &&
 					!thisParamRemoved &&
-					CompilerSpec.CALLING_CONVENTION_thiscall.equals(callingConvention) &&
+					callingConvention.startsWith(CompilerSpec.CALLING_CONVENTION_thiscall) &&
 					newParams.size() != 0) {
 					// Attempt to remove inferred unnamed 'this' parameter
 					// WARNING! This is a bit of a hack - not sure how to account for what may be auto-params
@@ -2240,7 +2240,7 @@ public class FunctionDB extends DatabaseObject implements Function {
 	 */
 	private static boolean removeExplicitThisParameter(List<? extends Variable> params,
 			String callingConventionName) {
-		if (CompilerSpec.CALLING_CONVENTION_thiscall.equals(callingConventionName)) {
+		if (callingConventionName.startsWith(CompilerSpec.CALLING_CONVENTION_thiscall)) {
 			int thisIndex = findExplicitThisParameter(params);
 			if (thisIndex >= 0) {
 				params.remove(thisIndex); // remove explicit 'this' parameter
@@ -2256,7 +2256,7 @@ public class FunctionDB extends DatabaseObject implements Function {
 	 * @return true if 'this' parameter removed
 	 */
 	private boolean removeExplicitThisParameter() {
-		if (CompilerSpec.CALLING_CONVENTION_thiscall.equals(getCallingConventionName())) {
+		if (getCallingConventionName().startsWith(CompilerSpec.CALLING_CONVENTION_thiscall)) {
 			int thisIndex = findExplicitThisParameter(params);
 			if (thisIndex >= 0) {
 				removeParameter(thisIndex); // remove explicit 'this' parameter
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/AbstractDataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/AbstractDataType.java
index 99e3f6a146..723fddad82 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/AbstractDataType.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/AbstractDataType.java
@@ -36,6 +36,8 @@ public abstract class AbstractDataType implements DataType {
 	protected String name;
 	protected CategoryPath categoryPath;
 	protected final DataTypeManager dataMgr;
+	private DataOrganization dataOrganization;
+	protected AddressModel addressModel;
 
 	protected AbstractDataType(CategoryPath path, String name, DataTypeManager dataTypeManager) {
 		if (path == null) {
@@ -110,7 +112,11 @@ public abstract class AbstractDataType implements DataType {
 
 	@Override
 	public String getName() {
-		return name;
+		if (null == addressModel) {
+			return name;
+		} else {
+			return name + " " + addressModel.toString();
+		}
 	}
 
 	@Override
@@ -286,6 +292,16 @@ public abstract class AbstractDataType implements DataType {
 		return getDefaultLabelPrefix(buf, settings, len, options);
 	}
 
+	@Override
+	public AddressModel getAddressModel() {
+		return addressModel;
+	}
+
+	@Override
+	public void setAddressModel(AddressModel addressModel) {
+		this.addressModel = addressModel;
+	}
+
 	@Override
 	public boolean isEncodable() {
 		return false;
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/AddressModel.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/AddressModel.java
new file mode 100644
index 0000000000..174173f1da
--- /dev/null
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/AddressModel.java
@@ -0,0 +1,71 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ghidra.program.model.data;
+
+/**
+ *
+ */
+public enum AddressModel {
+	unknown(""),
+	near("near"),
+	far("far"),
+	huge("huge");
+
+	@SuppressWarnings("unused")
+	private String modelName;
+
+	private AddressModel(String name) {
+		this.modelName = name;
+	}
+
+	/**
+	 * Returns the AddressModel which is likely to correspond with the
+	 * specified prototype name.
+	 * @param modelName specific address model name
+	 * @return AddressModel
+	 */
+	public static AddressModel guessFromName(String modelName) {
+		if (modelName == null) {
+			return unknown;
+		}
+		modelName = modelName.toLowerCase();
+		for (AddressModel value : AddressModel.values()) {
+			if (value == unknown) {
+				continue;
+			}
+			if (modelName.contains(value.name())) {
+				return value;
+			}
+		}
+		return unknown;
+	}
+
+	/**
+	 * Returns the AddressModel corresponding to the specified
+	 * ordinal.
+	 * @param ordinal generic address model ordinal
+	 * @return AddressModel
+	 */
+	public static AddressModel get(int ordinal) {
+		AddressModel[] values = AddressModel.values();
+		if (ordinal >= 0 && ordinal < values.length) {
+			return values[ordinal];
+		}
+		return unknown;
+	}
+
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/AddressModelDataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/AddressModelDataType.java
new file mode 100644
index 0000000000..26123476a4
--- /dev/null
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/AddressModelDataType.java
@@ -0,0 +1,120 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ghidra.program.model.data;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.NoSuchElementException;
+
+/**
+ *
+ */
+public class AddressModelDataType {//implements AddressModel {
+
+//	/**
+//	 * Emulate enum by creating static array of Address Models.
+//	 */
+//	private static List<AddressModel> values = new ArrayList<>(8);
+//
+//	@SuppressWarnings("unused")
+//	private String modelName;
+//	private byte ordinal;
+//
+//	AddressModelDataType(String name, int value) {
+//		this.modelName = name;
+//		this.ordinal = (byte) value;
+//		try {
+//			values.stream().filter(conv -> conv.name().equals(modelName)).findAny().orElseThrow();
+//		} catch (NoSuchElementException e) {
+//			values.add(this);
+//			System.out.print("Adding Address Model ".concat(Integer.toString(ordinal)).concat(" = '")
+//					.concat(modelName).concat("'\n"));
+//		}
+//	}
+//
+//	/**
+//	 * Returns the AddressModel which is likely to correspond with the
+//	 * specified prototype name.
+//	 * @param modelName specific address model name
+//	 * @return AddressModel
+//	 */
+//	public static AddressModel guessFromName(String modelName) {
+//		if (modelName == null) {
+//			return unknown;
+//		}
+//		modelName = modelName.toLowerCase();
+//		for (AddressModel value : AddressModelDataType.values()) {
+//			if (value == unknown) {
+//				continue;
+//			}
+//			if (modelName.contains(value.name())) {
+//				return value;
+//			}
+//		}
+//		return unknown;
+//	}
+//
+//	/**
+//	 * Returns the AddressModel corresponding to the specified
+//	 * ordinal.
+//	 * @param ordinal generic address model ordinal
+//	 * @return AddressModel
+//	 */
+//	public static AddressModel get(int ordinal) {
+//		AddressModel[] values = AddressModelDataType.values();
+//		if (ordinal >= 0 && ordinal < values.length) {
+//			return values[ordinal];
+//		}
+//		return unknown;
+//	}
+//
+//	/**
+//	 * Part of emulation of enums
+//	 */
+//	@Override
+//	public String name() {
+//		return modelName;
+//	}
+//
+//	/**
+//	 * Part of emulation of enums
+//	 */
+//	@Override
+//	public int ordinal() {
+//		return ordinal;
+//	}
+//
+//	/**
+//	 * Part of emulation of enums
+//	 */
+//	public static AddressModel[] values() {
+//		return values.toArray(AddressModel[]::new);
+//	}
+//
+//	@Override
+//	public void setComment(String comment) {
+//		// TODO Auto-generated method stub
+//
+//	}
+//
+//	@Override
+//	public String getComment() {
+//		// TODO Auto-generated method stub
+//		return null;
+//	}
+
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataType.java
index 29aaedaad8..8ad5002b7c 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataType.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataType.java
@@ -65,6 +65,10 @@ public interface DataType {
 	static final long NO_SOURCE_SYNC_TIME = 0L;
 	static final long NO_LAST_CHANGE_TIME = 0L;
 
+	public AddressModel getAddressModel();
+
+	public void setAddressModel(AddressModel addressModel);
+
 	/**
 	 * Indicates if the length of this data-type is determined based upon the
 	 * {@link DataOrganization} obtained from the associated {@link DataTypeManager}.
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataTypeWriter.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataTypeWriter.java
index 9594fbd99b..829bb57cd0 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataTypeWriter.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/DataTypeWriter.java
@@ -830,8 +830,12 @@ public class DataTypeWriter {
 		}
 		if (functionPointerArrayType instanceof Pointer) {
 			Pointer p = (Pointer) functionPointerArrayType;
+			String pointer = "*";
+			if (p.getLength() != p.getDataOrganization().getPointerSize()) {
+				pointer += Integer.toString(p.getLength() * 8);
+			}
 			for (int i = 0; i < getPointerDepth(p); i++) {
-				sb.append('*');
+				sb.append(pointer);
 			}
 			if (name != null) {
 				sb.append(' ');
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/GenericCallingConvention.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/GenericCallingConvention.java
index 49cd2acae6..440693adc1 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/GenericCallingConvention.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/GenericCallingConvention.java
@@ -59,7 +59,18 @@ public enum GenericCallingConvention {
 	/**
 	 * Similar to fastcall but extended vector registers are used
 	 */
-	vectorcall(CompilerSpec.CALLING_CONVENTION_vectorcall);
+	vectorcall(CompilerSpec.CALLING_CONVENTION_vectorcall),
+
+	/**
+	 * Similar to stdcall but with reverse parameter stacking
+	 */
+	pascal(CompilerSpec.CALLING_CONVENTION_pascal),
+
+	/**
+	 * Similar to pascal but using a far pointer
+	 */
+	pascal16far(CompilerSpec.CALLING_CONVENTION_pascal + "16far")
+	;
 
 	// Append new conventions to the bottom only so that ordinal values will not change!!
 
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/OffsetCodePointerDataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/OffsetCodePointerDataType.java
new file mode 100644
index 0000000000..ac5d93b882
--- /dev/null
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/OffsetCodePointerDataType.java
@@ -0,0 +1,100 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.program.model.data;
+
+import ghidra.docking.settings.Settings;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.address.AddressOutOfBoundsException;
+import ghidra.program.model.mem.MemBuffer;
+import ghidra.program.model.mem.MemoryAccessException;
+import ghidra.util.classfinder.ClassTranslator;
+
+public class OffsetCodePointerDataType extends BuiltIn {
+	static {
+		ClassTranslator.put("ghidra.program.model.data.OffsetCodePointer",
+			OffsetCodePointerDataType.class.getName());
+	}
+
+	public static OffsetCodePointerDataType dataType = new OffsetCodePointerDataType();
+
+	public OffsetCodePointerDataType() {
+		this(null);
+	}
+
+	public OffsetCodePointerDataType(DataTypeManager dtm) {
+		super(null, "OffsetCodeAddress", dtm);
+	}
+
+	@Override
+	public DataType clone(DataTypeManager dtm) {
+		if (dtm == getDataTypeManager()) {
+			return this;
+		}
+		return new OffsetCodePointerDataType(dtm);
+	}
+
+	@Override
+	public String getMnemonic(Settings settings) {
+		return "_offsetAddr";
+	}
+
+	@Override
+	public int getLength() {
+		return 2;
+	}
+
+	@Override
+	public String getDescription() {
+		return "16 bit offset address";
+	}
+
+	/**
+	 * @see ghidra.program.model.data.DataType#getValue(ghidra.program.model.mem.MemBuffer, ghidra.docking.settings.Settings, int)
+	 */
+	@Override
+	public Object getValue(MemBuffer buf, Settings settings, int length) {
+		Address addr = buf.getAddress();
+		try {
+			long segment = 0;
+			long offset = buf.getShort(2) & 0xffff;
+			long addrValue = segment << 16 | offset;
+			return addr.getNewAddress(addrValue, true);
+		}
+		catch (AddressOutOfBoundsException | MemoryAccessException ex) {
+			// Do nothing... Tried to form an address that was not readable or
+			// writeable.
+		}
+		return null;
+	}
+
+	@Override
+	public Class<?> getValueClass(Settings settings) {
+		return Address.class;
+	}
+
+	/**
+	 * @see ghidra.program.model.data.DataType#getRepresentation(ghidra.program.model.mem.MemBuffer, ghidra.docking.settings.Settings, int)
+	 */
+	@Override
+	public String getRepresentation(MemBuffer buf, Settings settings, int length) {
+
+		Object obj = getValue(buf, settings, length);
+		if (obj == null)
+			return "??";
+		return obj.toString();
+	}
+
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/PointerDataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/PointerDataType.java
index cec2950f24..0d280f2a43 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/PointerDataType.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/PointerDataType.java
@@ -274,7 +274,8 @@ public class PointerDataType extends BuiltIn implements Pointer {
 	@Override
 	public String getDisplayName() {
 		// NOTE: Pointer display name only specifies length if null base type
-		if (displayName == null) {
+		// or length is different to compiler default
+		if ((displayName == null) || (length != getDataOrganization().getPointerSize())) {
 			DataType dt = getDataType();
 			if (dt == null) {
 				displayName = POINTER_NAME;
@@ -284,6 +285,9 @@ public class PointerDataType extends BuiltIn implements Pointer {
 			}
 			else {
 				displayName = dt.getDisplayName() + " *";
+				if ((length > 0) && (length != getDataOrganization().getPointerSize())) {
+					displayName += Integer.toString(8 * length);
+				}
 			}
 		}
 		return displayName;
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/SegmentCodePointerDataType.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/SegmentCodePointerDataType.java
new file mode 100644
index 0000000000..1754b028d7
--- /dev/null
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/data/SegmentCodePointerDataType.java
@@ -0,0 +1,101 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.program.model.data;
+
+import ghidra.docking.settings.Settings;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.address.AddressOutOfBoundsException;
+import ghidra.program.model.mem.MemBuffer;
+import ghidra.program.model.mem.MemoryAccessException;
+import ghidra.util.classfinder.ClassTranslator;
+
+public class SegmentCodePointerDataType extends BuiltIn {
+	static {
+		ClassTranslator.put("ghidra.program.model.data.SegmentCodePointer",
+			SegmentCodePointerDataType.class.getName());
+	}
+
+	public static SegmentCodePointerDataType dataType = new SegmentCodePointerDataType();
+
+	public SegmentCodePointerDataType() {
+		this(null);
+	}
+
+	public SegmentCodePointerDataType(DataTypeManager dtm) {
+		super(null, "SegmentCodeAddress", dtm);
+	}
+
+	@Override
+	public DataType clone(DataTypeManager dtm) {
+		if (dtm == getDataTypeManager()) {
+			return this;
+		}
+		return new SegmentCodePointerDataType(dtm);
+	}
+
+	@Override
+	public String getMnemonic(Settings settings) {
+		return "_segmentAddr";
+	}
+
+	@Override
+	public int getLength() {
+		return 2;
+	}
+
+
+	@Override
+	public String getDescription() {
+		return "Code 16 bit segment address";
+	}
+
+	/**
+	 * @see ghidra.program.model.data.DataType#getValue(ghidra.program.model.mem.MemBuffer, ghidra.docking.settings.Settings, int)
+	 */
+	@Override
+	public Object getValue(MemBuffer buf, Settings settings, int length) {
+		Address addr = buf.getAddress();
+		try {
+			long segment = buf.getShort(0) & 0xffff;
+			long offset = 0;
+			long addrValue = segment << 16 | offset;
+			return addr.getNewAddress(addrValue, true);
+		}
+		catch (AddressOutOfBoundsException | MemoryAccessException ex) {
+			// Do nothing... Tried to form an address that was not readable or
+			// writeable.
+		}
+		return null;
+	}
+
+	@Override
+	public Class<?> getValueClass(Settings settings) {
+		return Address.class;
+	}
+
+	/**
+	 * @see ghidra.program.model.data.DataType#getRepresentation(ghidra.program.model.mem.MemBuffer, ghidra.docking.settings.Settings, int)
+	 */
+	@Override
+	public String getRepresentation(MemBuffer buf, Settings settings, int length) {
+
+		Object obj = getValue(buf, settings, length);
+		if (obj == null)
+			return "??";
+		return obj.toString();
+	}
+
+}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/ParamListStandard.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/ParamListStandard.java
index 9623df4f2d..8f41073a1d 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/ParamListStandard.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/ParamListStandard.java
@@ -175,8 +175,10 @@ public class ParamListStandard implements ParamList {
 			status[i] = 0;
 		}
 
-		if (addAutoParams && res.size() == 2) {	// Check for hidden parameters defined by the output list
-			ParameterPieces last = res.get(res.size() - 1);
+		boolean hiddenParam = (addAutoParams && res.size() == 2);
+
+		if (hiddenParam && proto.model.isRightToLeft()) {	// Check for hidden parameters defined by the output list
+			ParameterPieces last = res.get(1);
 			StorageClass store;
 			if (last.hiddenReturnPtr) {
 				store = StorageClass.HIDDENRET;
@@ -202,6 +204,18 @@ public class ParamListStandard implements ParamList {
 				return;
 			}
 		}
+		if (hiddenParam && !proto.model.isRightToLeft()) {	// Check for hidden parameters defined by the output list
+			ParameterPieces last = res.get(1);
+			StorageClass store;
+			if (last.hiddenReturnPtr) {
+				store = StorageClass.HIDDENRET;
+			}
+			else {
+				store = ParamEntry.getBasicTypeClass(last.type);
+			}
+			assignAddressFallback(store, last.type, false, status, last);
+			last.hiddenReturnPtr = true;
+		}
 	}
 
 	@Override
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/ParamListStandardOut.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/ParamListStandardOut.java
index 35f36cfb6c..ba6610a485 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/ParamListStandardOut.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/ParamListStandardOut.java
@@ -4,9 +4,9 @@
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
  * You may obtain a copy of the License at
- * 
+ *
  *      http://www.apache.org/licenses/LICENSE-2.0
- * 
+ *
  * Unless required by applicable law or agreed to in writing, software
  * distributed under the License is distributed on an "AS IS" BASIS,
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@@ -23,13 +23,13 @@ import ghidra.program.model.lang.protorules.AssignAction;
 /**
  * A list of resources describing possible storage locations for a function's return value,
  * and a strategy for selecting a storage location based on data-types in a function signature.
- * 
+ *
  * Similar to the parent class, when assigning storage, the first entry that matches the data-type
  * is chosen.  But if this instance fails to find a match (because the return value data-type is too
  * big) the data-type is converted to a pointer and storage is assigned based on that pointer.
  * Additionally, if configured, this instance will signal that a hidden input parameter is required
  * to fully model where the large return value is stored.
- * 
+ *
  * The resource list is checked to ensure entries are distinguishable.
  */
 public class ParamListStandardOut extends ParamListStandard {
@@ -58,7 +58,7 @@ public class ParamListStandardOut extends ParamListStandard {
 			responseCode == AssignAction.HIDDENRET_SPECIALREG ||
 			responseCode == AssignAction.HIDDENRET_SPECIALREG_VOID) {
 			// If the storage is not assigned (because the datatype is too big) create a hidden input parameter
-			int sz = (spacebase == null) ? -1 : spacebase.getPointerSize();
+			int sz = proto.model.getPointerSize(spacebase);
 			DataType pointerType = dtManager.getPointer(proto.outtype, sz);
 			if (responseCode == AssignAction.HIDDENRET_SPECIALREG_VOID) {
 				store.type = VoidDataType.dataType;
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/PrototypeModel.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/PrototypeModel.java
index fef08a80ca..995786ff56 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/PrototypeModel.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/PrototypeModel.java
@@ -57,6 +57,7 @@ public class PrototypeModel {
 	private InputListType inputListType = InputListType.STANDARD;
 	private boolean hasThis;		// Convention has a this (auto-parameter)
 	private boolean isConstruct;		// Convention is used for object construction
+	private boolean isRightToLeft;	// Parameter stacking convention
 	private boolean hasUponEntry;	// Does this have an uponentry injection
 	private boolean hasUponReturn;	// Does this have an uponreturn injection
 
@@ -86,8 +87,9 @@ public class PrototypeModel {
 		compatModel = model;
 		localRange = new AddressSet(model.localRange);
 		paramRange = new AddressSet(model.paramRange);
-		hasThis = model.hasThis || name.equals(CompilerSpec.CALLING_CONVENTION_thiscall);
+		hasThis = model.hasThis || name.startsWith(CompilerSpec.CALLING_CONVENTION_thiscall);
 		isConstruct = model.isConstruct;
+		isRightToLeft = model.isRightToLeft;
 		hasUponEntry = model.hasUponEntry;
 		hasUponReturn = model.hasUponReturn;
 	}
@@ -109,6 +111,7 @@ public class PrototypeModel {
 		paramRange = null;
 		hasThis = false;
 		isConstruct = false;
+		isRightToLeft = true;	// the default
 		hasUponEntry = false;
 		hasUponReturn = false;
 	}
@@ -188,7 +191,7 @@ public class PrototypeModel {
 	 * Returns the number of extra bytes popped from the stack when a function that uses
 	 * this model returns to its caller. This is usually just the number of bytes used to
 	 * store the return value, but some conventions may do additional clean up of stack parameters.
-	 * A special value of UNKNOWN_EXTRAPOP indicates that the number of bytes is unknown.  
+	 * A special value of UNKNOWN_EXTRAPOP indicates that the number of bytes is unknown.
 	 * @return the number of extra bytes popped
 	 */
 	public int getExtrapop() {
@@ -216,6 +219,12 @@ public class PrototypeModel {
 		return isConstruct;
 	}
 
+	/**
+	 * @return true if this model uses right-to-left parameter stacking
+	 */
+	public boolean isRightToLeft() {
+		return isRightToLeft;
+	}
 	/**
 	 * @return the allocation strategy for this model
 	 */
@@ -226,7 +235,7 @@ public class PrototypeModel {
 	/**
 	 * Return true if this model has specific p-code injections associated with it
 	 * (either an "uponentry" or "uponreturn" payload),
-	 * which are used to decompile functions with this model. 
+	 * which are used to decompile functions with this model.
 	 * @return true if this model uses p-code injections
 	 */
 	public boolean hasInjection() {
@@ -259,6 +268,22 @@ public class PrototypeModel {
 		return null;
 	}
 
+	/**
+	 * Used to return the size of a pointer for this model prototype.
+	 * @param space is the default AddressSpace
+	 * @return size of pointer
+	 */
+	public int getPointerSize(AddressSpace space) {
+		int pointerSize = (space == null) ? -1 : space.getPointerSize();
+		if (name.endsWith("16near")) {
+			pointerSize = 2;
+		}
+		else if (name.endsWith("16far")) {
+			pointerSize = 4;
+		}
+		return pointerSize;
+	}
+
 	/**
 	 * Get the preferred parameter location for a new parameter which will appended
 	 * to the end of an existing set of params.  If existing parameters use custom
@@ -321,7 +346,7 @@ public class PrototypeModel {
 
 		if (dataType != null) {
 			dataType = dataType.clone(program.getDataTypeManager());
-			// Identify next arg index based upon number of storage varnodes 
+			// Identify next arg index based upon number of storage varnodes
 			// already assigned to parameters - this may not work well if
 			// customized storage has been used
 		}
@@ -359,9 +384,36 @@ public class PrototypeModel {
 	 */
 	public void assignParameterStorage(PrototypePieces proto, DataTypeManager dtManager,
 			ArrayList<ParameterPieces> res, boolean addAutoParams) {
+
 		outputParams.assignMap(proto, dtManager, res, addAutoParams);
+
+		// Deal with left-to-right (PASCAL convention) parameter ordering
+		if (!isRightToLeft) {
+			// swap around the datatypes to map variable storage high-to-low
+			for (int i = 0; i < proto.intypes.size() / 2; i++) {
+				DataType tmp = proto.intypes.get(proto.intypes.size()-1 - i);
+				proto.intypes.set(proto.intypes.size()-1 - i, proto.intypes.get(i));
+				proto.intypes.set(i, tmp);
+			}
+		}
+
 		inputParams.assignMap(proto, dtManager, res, addAutoParams);
 
+		// Deal with left-to-right (PASCAL convention) parameter ordering
+		if (!isRightToLeft) {
+			int inputOffset = (res.size() - proto.intypes.size());
+			for (int i = 0; i < proto.intypes.size() / 2; i++) {
+				// swap back the input datatypes
+				DataType tmpDt = proto.intypes.get(proto.intypes.size()-1 - i);
+				proto.intypes.set(proto.intypes.size()-1 - i, proto.intypes.get(i));
+				proto.intypes.set(i, tmpDt);
+				// swap back the resulting input only storage to be ordered correctly
+				ParameterPieces tmpPiece = res.get(res.size()-1 - i);
+				res.set(res.size()-1 - i, res.get(inputOffset+i));
+				res.set(inputOffset+i, tmpPiece);
+			}
+		}
+
 		if (hasThis && addAutoParams && res.size() > 1) {
 			int thisIndex = 1;
 			if (res.get(1).hiddenReturnPtr && res.size() > 2) {
@@ -389,21 +441,23 @@ public class PrototypeModel {
 	 * or zero-length datatypes or any subsequent parameter following such a parameter.
 	 * 
 	 * @param program is the Program
-	 * @param dataTypes return/parameter datatypes (first element is always the return datatype, 
+	 * @param dataTypes return/parameter datatypes (first element is always the return datatype,
 	 * i.e., minimum array length is 1)
 	 * @param addAutoParams true if auto-parameter storage locations can be generated
 	 * @return dynamic storage locations orders by ordinal where first element corresponds to
-	 * return storage. The returned array may also include additional auto-parameter storage 
-	 * locations. 
+	 * return storage. The returned array may also include additional auto-parameter storage
+	 * locations.
 	 */
 	public VariableStorage[] getStorageLocations(Program program, DataType[] dataTypes,
 			boolean addAutoParams) {
 
+		int pointerSize = getPointerSize(program.getAddressFactory().getDefaultAddressSpace());
+
 		DataType injectedThis = null;
 		if (addAutoParams && hasThis) {
 			// explicit support for auto 'this' parameter
 			// must inject pointer arg to obtain storage assignment
-			injectedThis = new PointerDataType(program.getDataTypeManager());
+			injectedThis = new PointerDataType(null, pointerSize, program.getDataTypeManager());
 		}
 		PrototypePieces proto = new PrototypePieces(this, dataTypes, injectedThis);
 
@@ -414,6 +468,7 @@ public class PrototypeModel {
 		for (int i = 0; i < finalres.length; ++i) {
 			finalres[i] = res.get(i).getVariableStorage(program);
 		}
+
 		return finalres;
 	}
 
@@ -479,6 +534,9 @@ public class PrototypeModel {
 		if (isConstruct) {
 			encoder.writeBool(ATTRIB_CONSTRUCTOR, true);
 		}
+		if (isRightToLeft) {
+			encoder.writeBool(ATTRIB_ISRIGHTTOLEFT, true);
+		}
 		if (inputListType != InputListType.STANDARD) {
 			encoder.writeString(ATTRIB_STRATEGY, "register");
 		}
@@ -639,17 +697,22 @@ public class PrototypeModel {
 		stackshift = SpecXmlUtils.decodeInt(protoElement.getAttribute(ATTRIB_STACKSHIFT.name()));
 		hasThis = false;
 		isConstruct = false;
+		isRightToLeft = true;
 		String thisString = protoElement.getAttribute(ATTRIB_HASTHIS.name());
 		if (thisString != null) {
 			hasThis = SpecXmlUtils.decodeBoolean(thisString);
 		}
 		else {
-			hasThis = name.equals(CompilerSpec.CALLING_CONVENTION_thiscall);
+			hasThis = name.startsWith(CompilerSpec.CALLING_CONVENTION_thiscall);
 		}
 		String constructString = protoElement.getAttribute(ATTRIB_CONSTRUCTOR.name());
 		if (constructString != null) {
 			isConstruct = SpecXmlUtils.decodeBoolean(constructString);
 		}
+		String isrighttoleftString = protoElement.getAttribute(ATTRIB_ISRIGHTTOLEFT.name());
+		if (isrighttoleftString != null) {
+			isRightToLeft = SpecXmlUtils.decodeBoolean(isrighttoleftString);
+		}
 
 		buildParamList(protoElement.getAttribute(ATTRIB_STRATEGY.name()));
 		while (parser.peek().isStart()) {
@@ -750,7 +813,7 @@ public class PrototypeModel {
 	}
 
 	/**
-	 * Get a list of all input storage locations consisting of a single register 
+	 * Get a list of all input storage locations consisting of a single register
 	 * @param prog is the current Program
 	 * @return a VariableStorage ojbect for each register
 	 */
@@ -773,6 +836,9 @@ public class PrototypeModel {
 		if (extrapop != obj.extrapop || stackshift != obj.stackshift) {
 			return false;
 		}
+		if (isRightToLeft != obj.isRightToLeft) {
+			return false;
+		}
 		if (hasThis != obj.hasThis || isConstruct != obj.isConstruct) {
 			return false;
 		}
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/protorules/ConvertToPointer.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/protorules/ConvertToPointer.java
index 0a19239dae..b8afcb0564 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/protorules/ConvertToPointer.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/lang/protorules/ConvertToPointer.java
@@ -67,7 +67,8 @@ public class ConvertToPointer extends AssignAction {
 	public int assignAddress(DataType dt, PrototypePieces proto, int pos, DataTypeManager dtManager,
 			int[] status, ParameterPieces res) {
 
-		int pointersize = (space != null) ? space.getPointerSize() : -1;
+		int pointersize = proto.model.getPointerSize(space);
+
 		// Convert the data-type to a pointer
 		DataType pointertp = dtManager.getPointer(dt, pointersize);
 		// (Recursively) assign storage
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/FunctionSignature.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/FunctionSignature.java
index 8ae21a15db..eb5f52659c 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/FunctionSignature.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/listing/FunctionSignature.java
@@ -15,6 +15,7 @@
  */
 package ghidra.program.model.listing;
 
+import ghidra.program.model.data.AddressModel;
 import ghidra.program.model.data.DataType;
 import ghidra.program.model.data.ParameterDefinition;
 import ghidra.program.model.lang.PrototypeModel;
@@ -110,4 +111,9 @@ public interface FunctionSignature {
 	 * @return true if the if the given signature is equivalent to this signature.
 	 */
 	public boolean isEquivalentSignature(FunctionSignature signature);
+
+	/**
+	 * Returns the address model.
+	 */
+	public AddressModel getAddressModel();
 }
diff --git a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/AttributeId.java b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/AttributeId.java
index 5944e0371c..a7c1e1112c 100644
--- a/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/AttributeId.java
+++ b/Ghidra/Framework/SoftwareModeling/src/main/java/ghidra/program/model/pcode/AttributeId.java
@@ -248,5 +248,8 @@ public record AttributeId(String name, int id) {
 	public static final AttributeId ATTRIB_SIZES = new AttributeId("sizes", 151);
 	public static final AttributeId ATTRIB_BACKFILL = new AttributeId("backfill", 152);
 
-	public static final AttributeId ATTRIB_UNKNOWN = new AttributeId("XMLunknown", 153);
+	// function parameter stacking direction
+	public static final AttributeId ATTRIB_ISRIGHTTOLEFT = new AttributeId("isrighttoleft", 153);
+
+	public static final AttributeId ATTRIB_UNKNOWN = new AttributeId("XMLunknown", 154);
 }
diff --git a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/model/TestDoubleFunctionSignature.java b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/model/TestDoubleFunctionSignature.java
index bac52f7e74..2551eca6f9 100644
--- a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/model/TestDoubleFunctionSignature.java
+++ b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/model/TestDoubleFunctionSignature.java
@@ -15,6 +15,7 @@
  */
 package ghidra.program.model;
 
+import ghidra.program.model.data.AddressModel;
 import ghidra.program.model.data.DataType;
 import ghidra.program.model.data.ParameterDefinition;
 import ghidra.program.model.lang.PrototypeModel;
@@ -96,4 +97,9 @@ public class TestDoubleFunctionSignature implements FunctionSignature {
 	public boolean isEquivalentSignature(FunctionSignature signature) {
 		throw new UnsupportedOperationException();
 	}
+
+	@Override
+	public AddressModel getAddressModel() {
+		throw new UnsupportedOperationException();
+	}
 }
diff --git a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/model/data/StubDataType.java b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/model/data/StubDataType.java
index 0db346441c..99789b5362 100644
--- a/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/model/data/StubDataType.java
+++ b/Ghidra/Framework/SoftwareModeling/src/test/java/ghidra/program/model/data/StubDataType.java
@@ -317,4 +317,14 @@ public class StubDataType implements DataType {
 	public DataOrganization getDataOrganization() {
 		throw new UnsupportedOperationException();
 	}
+
+	@Override
+	public AddressModel getAddressModel() {
+		throw new UnsupportedOperationException();
+	}
+
+	@Override
+	public void setAddressModel(AddressModel addressModel) {
+		throw new UnsupportedOperationException();
+	}
 }
diff --git a/Ghidra/Processors/x86/data/languages/x86-16.cspec b/Ghidra/Processors/x86/data/languages/x86-16.cspec
index 9b7c3a602d..00ebb0f2b9 100644
--- a/Ghidra/Processors/x86/data/languages/x86-16.cspec
+++ b/Ghidra/Processors/x86/data/languages/x86-16.cspec
@@ -18,19 +18,20 @@
 	<long_double_size value="10" />
 	<!-- alignment varies between MIcrosoft and Borland -->
 	<!--
+	-->
 	<size_alignment_map>
 		<entry size="1" alignment="1" />
 		<entry size="2" alignment="2" />
 		<entry size="4" alignment="2" />
 		<entry size="8" alignment="2" />
 	</size_alignment_map>
-	-->
   </data_organization>
   
   <global>
     <range space="ram"/>
   </global>
   <stackpointer register="SP" space="ram"/>
+
   <default_proto>
     <prototype name="__stdcall16near" extrapop="unknown" stackshift="2">
       <input>
@@ -54,6 +55,8 @@
         <register name="DS"/>
         <register name="CS"/>
         <register name="ES"/>
+        <register name="FS"/>
+        <register name="GS"/>
         <register name="SS"/>
         <register name="DF"/>
       </unaffected>
@@ -81,6 +84,226 @@
       <register name="DS"/>
       <register name="CS"/>
       <register name="ES"/>
+      <register name="FS"/>
+      <register name="GS"/>
+      <register name="SS"/>
+      <register name="DF"/>
+    </unaffected>
+  </prototype>
+  <prototype name="__pascal16near" extrapop="unknown" stackshift="2" isrighttoleft="false">
+    <input>
+      <pentry minsize="1" maxsize="500" align="2">
+        <addr offset="2" space="stack"/>
+      </pentry>
+    </input>
+    <output>
+      <pentry minsize="1" maxsize="2">
+        <register name="AX"/>
+      </pentry>
+      <pentry minsize="3" maxsize="4">
+        <addr space="join" piece1="DX" piece2="AX"/>
+      </pentry>
+    </output>
+    <unaffected>
+      <register name="SP"/>
+      <register name="BP"/>
+      <register name="SI"/>
+      <register name="DI"/>
+      <register name="DS"/>
+      <register name="CS"/>
+      <register name="ES"/>
+      <register name="FS"/>
+      <register name="GS"/>
+      <register name="SS"/>
+      <register name="DF"/>
+    </unaffected>
+  </prototype>
+  <prototype name="__pascal16far" extrapop="unknown" stackshift="4" isrighttoleft="false">
+    <input>
+      <pentry minsize="1" maxsize="500" align="2">
+        <addr offset="4" space="stack"/>
+      </pentry>
+    </input>
+    <output>
+        <pentry minsize="1" maxsize="2">
+          <register name="AX"/>
+        </pentry>
+        <pentry minsize="3" maxsize="4">
+          <addr space="join" piece1="DX" piece2="AX"/>
+        </pentry>
+    </output>
+    <unaffected>
+      <register name="SP"/>
+      <register name="BP"/>
+      <register name="SI"/>
+      <register name="DI"/>
+      <register name="DS"/>
+      <register name="CS"/>
+      <register name="ES"/>
+      <register name="FS"/>
+      <register name="GS"/>
+      <register name="SS"/>
+      <register name="DF"/>
+    </unaffected>
+  </prototype>
+
+  <prototype name="__thispascal16near" extrapop="unknown" stackshift="2" hasthis="true" isrighttoleft="false">
+    <input>
+      <pentry minsize="1" maxsize="500" align="2">
+        <addr offset="2" space="stack"/>
+      </pentry>
+    </input>
+    <output>
+      <pentry minsize="1" maxsize="2">
+        <register name="AX"/>
+      </pentry>
+      <pentry minsize="3" maxsize="4">
+        <addr space="join" piece1="DX" piece2="AX"/>
+      </pentry>
+    </output>
+    <unaffected>
+      <register name="SP"/>
+      <register name="BP"/>
+      <register name="SI"/>
+      <register name="DI"/>
+      <register name="DS"/>
+      <register name="CS"/>
+      <register name="ES"/>
+      <register name="FS"/>
+      <register name="GS"/>
+      <register name="SS"/>
+      <register name="DF"/>
+    </unaffected>
+  </prototype>
+
+  <prototype name="__thispascal16far" extrapop="unknown" stackshift="4" hasthis="true" isrighttoleft="false">
+    <input>
+      <pentry minsize="1" maxsize="500" align="2">
+        <addr offset="4" space="stack"/>
+      </pentry>
+    </input>
+    <output>
+        <pentry minsize="1" maxsize="2">
+          <register name="AX"/>
+        </pentry>
+        <pentry minsize="3" maxsize="4">
+          <addr space="join" piece1="DX" piece2="AX"/>
+        </pentry>
+    </output>
+    <unaffected>
+      <register name="SP"/>
+      <register name="BP"/>
+      <register name="SI"/>
+      <register name="DI"/>
+      <register name="DS"/>
+      <register name="CS"/>
+      <register name="ES"/>
+      <register name="FS"/>
+      <register name="GS"/>
+      <register name="SS"/>
+      <register name="DF"/>
+    </unaffected>
+  </prototype>
+
+  <prototype name="__thiscall16far" extrapop="unknown" stackshift="4" hasthis="true">
+    <input>
+      <pentry minsize="1" maxsize="500" align="2">
+        <addr offset="4" space="stack"/>
+      </pentry>
+    </input>
+    <output>
+        <pentry minsize="1" maxsize="2">
+          <register name="AX"/>
+        </pentry>
+        <pentry minsize="3" maxsize="4">
+          <addr space="join" piece1="DX" piece2="AX"/>
+        </pentry>
+    </output>
+    <unaffected>
+      <register name="SP"/>
+      <register name="BP"/>
+      <register name="SI"/>
+      <register name="DI"/>
+      <register name="DS"/>
+      <register name="CS"/>
+      <register name="ES"/>
+      <register name="FS"/>
+      <register name="GS"/>
+      <register name="SS"/>
+      <register name="DF"/>
+    </unaffected>
+  </prototype>
+
+  <prototype name="__fastcall16near" extrapop="unknown" stackshift="2">
+    <input>
+      <pentry minsize="1" maxsize="2">
+        <register name="AX"/>
+      </pentry>
+      <pentry minsize="1" maxsize="2">
+        <register name="DX"/>
+      </pentry>
+      <pentry minsize="1" maxsize="2">
+        <register name="CX"/>
+      </pentry>
+      <pentry minsize="1" maxsize="500" align="2">
+        <addr offset="2" space="stack"/>
+      </pentry>
+    </input>
+    <output>
+      <pentry minsize="1" maxsize="2">
+        <register name="AX"/>
+      </pentry>
+      <pentry minsize="3" maxsize="4">
+        <addr space="join" piece1="DX" piece2="AX"/>
+      </pentry>
+    </output>
+    <unaffected>
+      <register name="SP"/>
+      <register name="BP"/>
+      <register name="SI"/>
+      <register name="DI"/>
+      <register name="DS"/>
+      <register name="CS"/>
+      <register name="ES"/>
+      <register name="FS"/>
+      <register name="GS"/>
+      <register name="SS"/>
+      <register name="DF"/>
+    </unaffected>
+  </prototype>
+  <prototype name="__fastcall16far" extrapop="unknown" stackshift="4">
+    <input>
+      <pentry minsize="1" maxsize="2">
+        <register name="AX"/>
+      </pentry>
+      <pentry minsize="1" maxsize="2">
+        <register name="DX"/>
+      </pentry>
+      <pentry minsize="1" maxsize="2">
+        <register name="CX"/>
+      </pentry>
+      <pentry minsize="1" maxsize="500" align="2">
+        <addr offset="4" space="stack"/>
+      </pentry>
+    </input>
+    <output>
+        <pentry minsize="1" maxsize="2">
+          <register name="AX"/>
+        </pentry>
+        <pentry minsize="3" maxsize="4">
+          <addr space="join" piece1="DX" piece2="AX"/>
+        </pentry>
+    </output>
+    <unaffected>
+      <register name="SP"/>
+      <register name="BP"/>
+      <register name="SI"/>
+      <register name="DI"/>
+      <register name="DS"/>
+      <register name="CS"/>
+      <register name="ES"/>
+      <register name="FS"/>
+      <register name="GS"/>
       <register name="SS"/>
       <register name="DF"/>
     </unaffected>
@@ -107,6 +330,8 @@
       <register name="DS"/>
       <register name="CS"/>
       <register name="ES"/>
+      <register name="FS"/>
+      <register name="GS"/>
       <register name="SS"/>
       <register name="DF"/>
     </unaffected>
@@ -133,6 +358,8 @@
       <register name="DS"/>
       <register name="CS"/>
       <register name="ES"/>
+      <register name="FS"/>
+      <register name="GS"/>
       <register name="SS"/>
       <register name="DF"/>
     </unaffected>
@@ -170,6 +397,65 @@
       <register name="DS"/>
       <register name="CS"/>
       <register name="ES"/>
+      <register name="FS"/>
+      <register name="GS"/>
+      <register name="SS"/>
+      <register name="DF"/>
+    </unaffected>
+  </prototype>
+
+  <prototype name="__thiscdecl16near" extrapop="2" stackshift="2" hasthis="true">
+    <input>
+      <pentry minsize="1" maxsize="500" align="2">
+        <addr offset="4" space="stack"/>
+      </pentry>
+    </input>
+    <output>
+      <pentry minsize="1" maxsize="2">
+        <register name="AX"/>
+      </pentry>
+      <pentry minsize="3" maxsize="4">
+        <addr space="join" piece1="DX" piece2="AX"/>
+      </pentry>
+    </output>
+    <unaffected>
+      <register name="SP"/>
+      <register name="BP"/>
+      <register name="SI"/>
+      <register name="DI"/>
+      <register name="DS"/>
+      <register name="CS"/>
+      <register name="ES"/>
+      <register name="FS"/>
+      <register name="GS"/>
+      <register name="SS"/>
+      <register name="DF"/>
+    </unaffected>
+  </prototype>
+  <prototype name="__thiscdecl16far" extrapop="4" stackshift="4" hasthis="true">
+    <input>
+      <pentry minsize="1" maxsize="500" align="2">
+        <addr offset="4" space="stack"/>
+      </pentry>
+    </input>
+    <output>
+      <pentry minsize="1" maxsize="2">
+        <register name="AX"/>
+      </pentry>
+      <pentry minsize="3" maxsize="4">
+        <addr space="join" piece1="DX" piece2="AX"/>
+      </pentry>
+    </output>
+    <unaffected>
+      <register name="SP"/>
+      <register name="BP"/>
+      <register name="SI"/>
+      <register name="DI"/>
+      <register name="DS"/>
+      <register name="CS"/>
+      <register name="ES"/>
+      <register name="FS"/>
+      <register name="GS"/>
       <register name="SS"/>
       <register name="DF"/>
     </unaffected>
-- 
2.45.1

