From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Johannes Obermayr <johannesobermayr@gmx.de>
Date: Sun, 17 Sep 2023 12:07:16 +0200
Subject: [PATCH] 5788: Simplify {CMPXCHG,DEC,INC,XADD}.LOCK in Decompiler

---
 Ghidra/Processors/x86/data/languages/ia.sinc  |   4 +
 .../x86/data/languages/lockable.sinc          | 226 +++++-------------
 2 files changed, 59 insertions(+), 171 deletions(-)

diff --git a/Ghidra/Processors/x86/data/languages/ia.sinc b/Ghidra/Processors/x86/data/languages/ia.sinc
index c1a0856e1..b56b22dc0 100644
--- a/Ghidra/Processors/x86/data/languages/ia.sinc
+++ b/Ghidra/Processors/x86/data/languages/ia.sinc
@@ -1103,10 +1103,14 @@ alwaysLock:        	    is epsilon { LOCK(); }
 #check for LOCK prefix and the optional XACQUIRE/XRELEASE
 lockx: xacq_xrel_prefx^".LOCK"	is lockprefx=1 & xacq_xrel_prefx { build xacq_xrel_prefx; LOCK(); }
 lockx: 		                    is epsilon { }
+lockx_: xacq_xrel_prefx^".LOCK"	is lockprefx=1 & xacq_xrel_prefx { build xacq_xrel_prefx; }
+lockx_:				is epsilon { }
 
 #"unlock" constructor is used to pair every LOCK pcodeop with a matching UNLOCK pcodeop
 unlock:		is lockprefx=1 { UNLOCK(); }
 unlock:		is epsilon { }
+unlock_:	is lockprefx=1 { }
+unlock_:	is epsilon { }
 
 # Some macros
 
diff --git a/Ghidra/Processors/x86/data/languages/lockable.sinc b/Ghidra/Processors/x86/data/languages/lockable.sinc
index 929c087d9..9ceba3170 100644
--- a/Ghidra/Processors/x86/data/languages/lockable.sinc
+++ b/Ghidra/Processors/x86/data/languages/lockable.sinc
@@ -109,6 +109,7 @@
 }
 @endif
 
+define pcodeop InterlockedAdd;
 :ADD^lockx spec_m8,imm8		is vexMode=0 & lockx & unlock & (byte=0x80 | byte=0x82); spec_m8 & reg_opcode=0 ...; imm8		
 {
     build lockx;
@@ -140,6 +141,7 @@
 }
 
 @ifdef IA64
+define pcodeop InterlockedAdd64;
 :ADD^lockx spec_m64,simm32		is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x81; spec_m64 & reg_opcode=0 ...; simm32	
 {
     build lockx;
@@ -183,45 +185,25 @@
 }
 @endif
 
-:ADD^lockx m8,Reg8      is vexMode=0 & lockx & unlock & byte=0x00; m8 & Reg8 ...                 
+:ADD^lockx_ Mem,Reg8     is vexMode=0 & lockx_ & unlock_ & byte=0x00; Mem & Reg8 ...
 {
-    build lockx;
-    build m8;
-    addflags(  m8,Reg8 );
-    m8 =   m8 +  Reg8;
-    resultflags(  m8);
-    build unlock;
+    Mem = InterlockedAdd(Mem, Reg8);
 }
 
-:ADD^lockx m16,Reg16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0x1; m16 & Reg16 ...     
+:ADD^lockx_ Mem,Reg16    is vexMode=0 & lockx_ & unlock_ & opsize=0 & byte=0x1; Mem & Reg16 ...
 {
-    build lockx;
-    build m16;
-    addflags( m16,Reg16);
-    m16 =  m16 + Reg16;
-    resultflags( m16);
-    build unlock;
+    Mem = InterlockedAdd(Mem, Reg16);
 }
 
-:ADD^lockx m32,Reg32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0x1; m32 & Reg32 ...     
+:ADD^lockx_ Mem,Reg32    is vexMode=0 & lockx_ & unlock_ & opsize=1 & byte=0x1; Mem & Reg32 ...
 {
-    build lockx;
-    build m32;
-    addflags( m32,Reg32);
-    m32 =  m32 + Reg32;
-    resultflags( m32);
-    build unlock;
+    Mem = InterlockedAdd(Mem, Reg32);
 }
 
 @ifdef IA64
-:ADD^lockx m64,Reg64    is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x1; m64 & Reg64 ...    
+:ADD^lockx_ Mem,Reg64    is $(LONGMODE_ON) & vexMode=0 & lockx_ & unlock_ & opsize=2 & byte=0x1; Mem & Reg64 ...
 {
-    build lockx;
-    build m64;
-    addflags( m64,Reg64);
-    m64 =  m64 + Reg64;
-    resultflags( m64);
-    build unlock;
+    Mem = InterlockedAdd(Mem, Reg64);
 }
 @endif
 
@@ -572,71 +554,33 @@
 }
 @endif
 
-:CMPXCHG^lockx m8,Reg8  is vexMode=0 & lockx & unlock & byte=0xf; byte=0xb0; m8 & Reg8 ...           
+define pcodeop InterlockedCompareExchange;
+define pcodeop InterlockedCompareExchange8;
+define pcodeop InterlockedCompareExchange16;
+:CMPXCHG^lockx_ Mem,Reg8  is vexMode=0 & lockx_ & unlock_ & byte=0xf; byte=0xb0; Mem & Reg8 ...
 {
-    build lockx;
-    build m8;
-    subflags(AL,m8);
-    local tmp=AL-m8;
-    resultflags(tmp);
-    local diff = m8^Reg8;
-    m8 = m8 ^ (ZF*diff);
-    diff = AL ^ m8; AL = AL ^ ((ZF==0)*diff);
-    build unlock; 
+    AL = InterlockedCompareExchange8(Mem, Reg8, AL);
 }
 
-:CMPXCHG^lockx m16,Reg16    is vexMode=0 & lockx & unlock & opsize=0 & byte=0xf; byte=0xb1; m16 & Reg16 ...  
+:CMPXCHG^lockx_ Mem,Reg16    is vexMode=0 & lockx_ & unlock_ & opsize=0 & byte=0xf; byte=0xb1; Mem & Reg16 ...
 {
-    build lockx;
-    build m16;
-    subflags(AX,m16);
-    local tmp=AX-m16;
-    resultflags(tmp);
-    local diff = m16^Reg16;
-    m16 = m16 ^ (zext(ZF) * diff);
-    diff = AX ^ m16;
-    AX = AX ^ (zext(ZF==0) * diff);
-    build unlock; 
+    AX = InterlockedCompareExchange16(Mem, Reg16, AX);
 }
 
-:CMPXCHG^lockx m32,Reg32    is vexMode=0 & lockx & unlock & opsize=1 & byte=0xf; byte=0xb1; m32 & Reg32 ... & check_EAX_dest ...
+:CMPXCHG^lockx_ Mem,Reg32    is vexMode=0 & lockx_ & unlock_ & opsize=1 & byte=0xf; byte=0xb1; Mem & Reg32 ...
 {
-    build lockx;
-    build m32;
-	#this instruction writes to either EAX or m32
-	#in 64-bit mode, a 32-bit register that is written to
-	#(and only the register that is written to)
-	#must be zero-extended to 64 bits
-	subflags(EAX,m32);
-	local tmp=EAX-m32;
-	resultflags(tmp);
-    if (ZF==1) goto <equal>;
-    EAX = m32;
-    build check_EAX_dest;
-    goto <inst_end>;
-<equal>
-    m32 = Reg32;
-<inst_end>
-    build unlock;
+    EAX = InterlockedCompareExchange(Mem, Reg32, EAX);
 }
 
 @ifdef IA64
-:CMPXCHG^lockx m64,Reg64    is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xf; byte=0xb1; m64 & Reg64 ...  
+define pcodeop InterlockedCompareExchange64;
+:CMPXCHG^lockx_ Mem,Reg64    is $(LONGMODE_ON) & vexMode=0 & lockx_ & unlock_ & opsize=2 & byte=0xf; byte=0xb1; Mem & Reg64 ...
 {
-    build lockx;
-    build m64;
-    subflags(RAX,m64);
-    local tmp=RAX-m64;
-    resultflags(tmp);
-    local diff = m64^Reg64;
-    m64 = m64 ^ (zext(ZF) * diff);
-    diff = RAX ^ m64;
-    RAX = RAX ^ (zext(ZF==0) * diff);
-    build unlock; 
+    RAX = InterlockedCompareExchange64(Mem, Reg64, RAX);
 }
 @endif
 
-:CMPXCHG8B^lockx  m64        is vexMode=0 & lockx & unlock & byte=0xf; byte=0xc7; ( mod != 0b11 & reg_opcode=1 ) ... & m64 
+:CMPXCHG8B^lockx  m64        is vexMode=0 & lockx & unlock & byte=0xf; byte=0xc7; ( mod != 0b11 & reg_opcode=1 ) ... & m64
 {
     build lockx;
     build m64;
@@ -667,87 +611,53 @@
 }
 @endif
 
-:DEC^lockx spec_m8       is vexMode=0 & lockx & unlock & byte=0xfe; spec_m8 & reg_opcode=1 ...         
+define pcodeop InterlockedDecrement;
+define pcodeop InterlockedDecrement16;
+:DEC^lockx_ Mem	is vexMode=0 & lockx_ & unlock_ & byte=0xfe; Mem & reg_opcode=1 ...
 {
-    build lockx;
-    build spec_m8;
-    OF = sborrow(spec_m8,1);
-    spec_m8 =  spec_m8 - 1;
-    resultflags( spec_m8);
-    build unlock; 
+    InterlockedDecrement(Mem);
 }
 
-:DEC^lockx spec_m16      is vexMode=0 & lockx & unlock & opsize=0 & byte=0xff; spec_m16 & reg_opcode=1 ... 
+:DEC^lockx_ Mem	is vexMode=0 & lockx_ & unlock_ & opsize=0 & byte=0xff; Mem & reg_opcode=1 ...
 {
-    build lockx;
-    build spec_m16;
-    OF = sborrow(spec_m16,1);
-    spec_m16 = spec_m16 - 1;
-    resultflags(spec_m16);
-    build unlock; 
+    InterlockedDecrement16(Mem);
 }
 
-:DEC^lockx spec_m32      is vexMode=0 & lockx & unlock & opsize=1 & byte=0xff; spec_m32 & reg_opcode=1 ... 
+:DEC^lockx_ Mem	is vexMode=0 & lockx_ & unlock_ & opsize=1 & byte=0xff; Mem & reg_opcode=1 ...
 {
-    build lockx;
-    build spec_m32;
-    OF = sborrow(spec_m32,1);
-    spec_m32 = spec_m32 - 1;
-    resultflags(spec_m32);
-    build unlock; 
+    InterlockedDecrement(Mem);
 }
 
 @ifdef IA64
-:DEC^lockx spec_m64      is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xff; spec_m64 & reg_opcode=1 ... 
+define pcodeop InterlockedDecrement64;
+:DEC^lockx_ Mem	is $(LONGMODE_ON) & vexMode=0 & lockx_ & unlock_ & opsize=2 & byte=0xff; Mem & reg_opcode=1 ...
 {
-    build lockx;
-    build spec_m64;
-    OF = sborrow(spec_m64,1);
-    spec_m64 = spec_m64 - 1;
-    resultflags(spec_m64);
-    build unlock; 
+    InterlockedDecrement64(Mem);
 }
 @endif
 
-:INC^lockx  spec_m8	is vexMode=0 & lockx & unlock & byte=0xfe; spec_m8 ...				
+define pcodeop InterlockedIncrement;
+define pcodeop InterlockedIncrement16;
+:INC^lockx_ Mem	is vexMode=0 & lockx_ & unlock_ & byte=0xfe; Mem ...
 {
-    build lockx;
-    build spec_m8;
-    OF = scarry(spec_m8,1);
-    spec_m8 =  spec_m8 + 1;
-    resultflags( spec_m8);
-    build unlock; 
+    InterlockedIncrement(Mem);
 }
 
-:INC^lockx spec_m16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0xff; spec_m16 ...	
+:INC^lockx_ Mem	is vexMode=0 & lockx_ & unlock_ & opsize=0 & byte=0xff; Mem ...
 {
-    build lockx;
-    build spec_m16;
-    OF = scarry(spec_m16,1);
-    spec_m16 = spec_m16 + 1;
-    resultflags(spec_m16);
-    build unlock; 
+    InterlockedIncrement16(Mem);
 }
 
-:INC^lockx spec_m32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0xff; spec_m32 ...	
+:INC^lockx_ Mem	is vexMode=0 & lockx_ & unlock_ & opsize=1 & byte=0xff; Mem ...
 {
-    build lockx;
-    build spec_m32;
-    OF = scarry(spec_m32,1);
-    spec_m32 = spec_m32 + 1;
-    resultflags(spec_m32);
-    build unlock; 
+    InterlockedIncrement(Mem);
 }
 
 @ifdef IA64
-:INC^lockx spec_m64	is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0xff; spec_m64 ... 
+define pcodeop InterlockedIncrement64;
+:INC^lockx_ Mem	is $(LONGMODE_ON) & vexMode=0 & lockx_ & unlock_ & opsize=2 & byte=0xff; Mem ...
 {
-    build lockx;
-    build spec_m64;
-    OF = scarry(spec_m64,1);
-    spec_m64 = spec_m64 + 1;
-    resultflags(spec_m64);
-    build unlock; 
+    InterlockedIncrement64(Mem);
 }
 @endif
 
@@ -1165,53 +1075,27 @@
 }
 @endif
 
-:XADD^lockx  m8,Reg8 	is vexMode=0 & lockx & unlock & byte=0x0F; byte=0xC0;  m8 & Reg8  ...        
+define pcodeop InterlockedExchangeAdd;
+:XADD^lockx_ Mem,Reg8 	is vexMode=0 & lockx_ & unlock_ & byte=0x0F; byte=0xC0;  Mem & Reg8  ...
 {
-    build lockx;
-    build m8;
-    addflags( m8,Reg8 );
-    local tmp =  m8 +  Reg8;
-    Reg8 = m8;
-    m8 = tmp;
-    resultflags(tmp);
-    build unlock; 
+    Reg8 = InterlockedExchangeAdd(Mem, Reg8);
 }
 
-:XADD^lockx m16,Reg16	is vexMode=0 & lockx & unlock & opsize=0 & byte=0x0F; byte=0xC1; m16 & Reg16 ... 
+:XADD^lockx_ Mem,Reg16	is vexMode=0 & lockx_ & unlock_ & opsize=0 & byte=0x0F; byte=0xC1; Mem & Reg16 ...
 {
-    build lockx;
-    build m16;
-    addflags(m16,Reg16);
-    local tmp = m16 + Reg16;
-    Reg16 = m16;
-    m16 = tmp;
-    resultflags(tmp);
-    build unlock; 
+    Reg16 = InterlockedExchangeAdd(Mem, Reg16);
 }
 
-:XADD^lockx m32,Reg32	is vexMode=0 & lockx & unlock & opsize=1 & byte=0x0F; byte=0xC1; m32 & Reg32 ... 
+:XADD^lockx_ Mem,Reg32	is vexMode=0 & lockx_ & unlock_ & opsize=1 & byte=0x0F; byte=0xC1; Mem & Reg32 ...
 {
-    build lockx;
-    build m32;
-    addflags(m32,Reg32);
-    local tmp = m32 + Reg32;
-    Reg32 = m32;
-    m32 = tmp;
-    resultflags(tmp);
-    build unlock; 
+    Reg32 = InterlockedExchangeAdd(Mem, Reg32);
 }
 
 @ifdef IA64
-:XADD^lockx m64,Reg64	is $(LONGMODE_ON) & vexMode=0 & lockx & unlock & opsize=2 & byte=0x0F; byte=0xC1; m64 & Reg64 ... 
+define pcodeop InterlockedExchangeAdd64;
+:XADD^lockx_ Mem,Reg64	is $(LONGMODE_ON) & vexMode=0 & lockx_ & unlock_ & opsize=2 & byte=0x0F; byte=0xC1; Mem & Reg64 ...
 {
-    build lockx;
-    build m64;
-    addflags(m64,Reg64);
-    local tmp = m64 + Reg64;
-    Reg64 = m64;
-    m64 = tmp;
-    resultflags(tmp);
-    build unlock; 
+    Reg64 = InterlockedExchangeAdd64(Mem, Reg64);
 }
 @endif
 
-- 
2.41.0

