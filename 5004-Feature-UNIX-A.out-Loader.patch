From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Colin Bourassa <colin.bourassa@gmail.com>
Date: Fri, 17 Feb 2023 11:48:14 -0500
Subject: [PATCH] 5004: Feature: UNIX A.out Loader

Address review comments; fix bss block init

This addresses review comments concerning (a) the unreliability of A.out format
consistency for OLDSUN2 files, (b) the behavior of NetBSD with respect to header
field endianness, and (c) formatting errors in some of the language specs.

This also adds generation of the .bss block when the object file specifies a
nonzero size for .bss.

Fix missing import for Loader

Delay creation of .bss

Refactored into multiple funcs; still needs beautifying

Add missing comment blocks for methods
---
 .../bin/format/unixaout/UnixAoutHeader.java   | 492 +++++++++++++++
 .../format/unixaout/UnixAoutMachineType.java  |  79 +++
 .../UnixAoutRelocationTableEntry.java         |  64 ++
 .../unixaout/UnixAoutSymbolTableEntry.java    |  66 ++
 .../app/util/opinion/UnixAoutLoader.java      | 583 ++++++++++++++++++
 5 files changed, 1284 insertions(+)
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutHeader.java
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutMachineType.java
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutRelocationTableEntry.java
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutSymbolTableEntry.java
 create mode 100644 Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/UnixAoutLoader.java

diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutHeader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutHeader.java
new file mode 100644
index 000000000..fcb2fb72b
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutHeader.java
@@ -0,0 +1,492 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ghidra.app.util.bin.format.aout;
+
+import java.io.IOException;
+
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.ByteProvider;
+
+public class UnixAoutHeader {
+
+    enum ExecutableType {
+        OMAGIC, NMAGIC, ZMAGIC, QMAGIC, CMAGIC, UNKNOWN
+    }
+
+    private long binarySize;
+    private ExecutableType exeType;
+    private boolean machineTypeValid;
+    private String languageSpec;
+    private String compilerSpec = "default";
+    private long pageSize;
+
+    private boolean isNetBSD = false;
+    private boolean isSparc = false;
+
+    private long a_magic;
+    private long a_text;
+    private long a_data;
+    private long a_bss;
+    private long a_syms;
+    private long a_entry;
+    private long a_trsize;
+    private long a_drsize;
+
+    private long txtOffset;
+    private long datOffset;
+    private long txtRelOffset;
+    private long datRelOffset;
+    private long symOffset;
+    private long strOffset;
+
+    private long txtAddr;
+    private long txtEndAddr;
+    private long datAddr;
+    private long bssAddr;
+
+    // The Linux implementation of a.out support might have a different header
+    // size, but it looks as though that might be caused by a strange mix of
+    // 32- and 64-bit integers being padded out in the struct. The intended
+    // size seems to be eight 32-bit words (32 bytes total.)
+    private static final int sizeOfExecHeader = 32;
+
+    /**
+     * Interprets binary data as an exec header from a UNIX-style a.out executable,
+     * and validates the contained fields.
+     *
+     * @param provider       Source of header binary data
+     * @param isLittleEndian Flag indicating whether to interpret the data as
+     *                       little-endian.
+     * @throws IOException
+     */
+    public UnixAoutHeader(ByteProvider provider, boolean isLittleEndian) throws IOException {
+        BinaryReader reader = new BinaryReader(provider, isLittleEndian);
+
+        this.a_magic = reader.readNextUnsignedInt();
+        this.a_text = reader.readNextUnsignedInt();
+        this.a_data = reader.readNextUnsignedInt();
+        this.a_bss = reader.readNextUnsignedInt();
+        this.a_syms = reader.readNextUnsignedInt();
+        this.a_entry = reader.readNextUnsignedInt();
+        this.a_trsize = reader.readNextUnsignedInt();
+        this.a_drsize = reader.readNextUnsignedInt();
+        this.binarySize = reader.length();
+
+        checkExecutableType();
+
+        // NOTE: In NetBSD/i386 examples of a.out, the "new-style" 32-bit a_magic/midmag word
+        // is written in big-endian regardless of the data endianness in the rest of the file.
+        if ((this.exeType == ExecutableType.UNKNOWN) && isLittleEndian) {
+            this.a_magic = Integer.reverseBytes((int)this.a_magic);
+            checkExecutableType();
+        }
+
+        checkMachineTypeValidity(isLittleEndian);
+        determineTextOffset(isLittleEndian);
+
+        this.datOffset = this.txtOffset + this.a_text;
+        this.txtRelOffset = this.datOffset + this.a_data;
+        this.datRelOffset = this.txtRelOffset + this.a_trsize;
+        this.symOffset = this.datRelOffset + this.a_drsize;
+        this.strOffset = this.symOffset + this.a_syms;
+
+        determineTextAddr();
+        this.txtEndAddr = this.txtAddr + this.a_text;
+        this.datAddr = (this.exeType == ExecutableType.OMAGIC) ?
+                this.txtEndAddr : segmentRound(this.txtEndAddr);
+        this.bssAddr = this.datAddr + this.a_data;
+    }
+
+    /**
+     * Returns the processor/language specified by this header.
+     */
+    public String getLanguageSpec() {
+        return this.languageSpec;
+    }
+
+    /**
+     * Returns the compiler used by this executable. This is left as 'default' for
+     * all machine types other than i386, where it is assumed to be gcc.
+     */
+    public String getCompilerSpec() {
+        return this.compilerSpec;
+    }
+
+    /**
+     * Returns the enumerated type of executable contained in this A.out file.
+     */
+    public ExecutableType getExecutableType() {
+        return this.exeType;
+    }
+
+    /**
+     * Returns an indication of whether this header's fields are all valid; this
+     * includes the machine type, executable type, and section offsets.
+     */
+    public boolean isValid() {
+        return isMachineTypeValid() &&
+                (this.exeType != ExecutableType.UNKNOWN) &&
+                areOffsetsValid();
+    }
+
+    public long getTextSize() {
+        return this.a_text;
+    }
+
+    public long getDataSize() {
+        return this.a_data;
+    }
+
+    public long getBssSize() {
+        return this.a_bss;
+    }
+
+    public long getSymSize() {
+        return this.a_syms;
+    }
+
+    public long getEntryPoint() {
+        return this.a_entry;
+    }
+
+    public long getTextRelocSize() {
+        return this.a_trsize;
+    }
+
+    public long getDataRelocSize() {
+        return this.a_drsize;
+    }
+
+    public long getTextOffset() {
+        return this.txtOffset;
+    }
+
+    public long getDataOffset() {
+        return this.datOffset;
+    }
+
+    public long getTextRelocOffset() {
+        return this.txtRelOffset;
+    }
+
+    public long getDataRelocOffset() {
+        return this.datRelOffset;
+    }
+
+    public long getSymOffset() {
+        return this.symOffset;
+    }
+
+    public long getStrOffset() {
+        return this.strOffset;
+    }
+
+    public long getTextAddr() {
+        return this.txtAddr;
+    }
+
+    public long getDataAddr() {
+        return this.datAddr;
+    }
+
+    public long getBssAddr() {
+        return this.bssAddr;
+    }
+
+    /**
+     * Checks the magic word in the header for a known machine type ID, and sets the
+     * languageSpec string accordingly.
+     */
+    private void checkMachineTypeValidity(boolean readingAsLittleEndian) {
+
+        this.machineTypeValid = true;
+        this.pageSize = 4096;
+        final short machtype = (short) ((this.a_magic >> 16) & 0xFF);
+        final String readEndianness = readingAsLittleEndian ? "LE" : "BE";
+
+        switch (machtype) {
+            /**
+             * Motorola 68K family
+             */
+        case UnixAoutMachineType.M_68010:
+            this.languageSpec = "68000:BE:32:MC68010";
+            break;
+        case UnixAoutMachineType.M_68020:
+            this.languageSpec = "68000:BE:32:MC68020";
+            break;
+        case UnixAoutMachineType.M_M68K_NETBSD:
+            this.pageSize = 8192;
+        case UnixAoutMachineType.M_M68K4K_NETBSD:
+            this.isNetBSD = true;
+            this.languageSpec = "68000:BE:32:default";
+            break;
+
+            /**
+             * SPARC family
+             */
+        case UnixAoutMachineType.M_SPARC_NETBSD:
+            this.isNetBSD = true;
+        case UnixAoutMachineType.M_SPARC:
+        case UnixAoutMachineType.M_SPARCLET:
+            this.isSparc = true;
+            this.pageSize = 8192;
+            this.languageSpec = "sparc:BE:32:default";
+            break;
+        case UnixAoutMachineType.M_SPARC64_NETBSD:
+            this.isNetBSD = true;
+            this.isSparc = true;
+            this.languageSpec = "sparc:BE:64:default";
+            break;
+
+            /**
+             * MIPS family
+             */
+        case UnixAoutMachineType.M_PMAX_NETBSD:
+            this.isNetBSD = true;
+        case UnixAoutMachineType.M_MIPS1:
+        case UnixAoutMachineType.M_MIPS2:
+        case UnixAoutMachineType.M_R3000:
+            this.languageSpec = "MIPS:LE:32:default";
+            break;
+        case UnixAoutMachineType.M_MIPS:
+            this.languageSpec = "MIPS:BE:32:default";
+            break;
+
+            /**
+             * National Semiconductor NS32000 family
+             */
+        case UnixAoutMachineType.M_532_NETBSD:
+            this.isNetBSD = true;
+        case UnixAoutMachineType.M_NS32032:
+        case UnixAoutMachineType.M_NS32532:
+            this.languageSpec = "UNKNOWN:LE:32:default";
+            break;
+
+            /**
+             * x86 family
+             */
+        case UnixAoutMachineType.M_386_NETBSD:
+            this.isNetBSD = true;
+        case UnixAoutMachineType.M_386:
+        case UnixAoutMachineType.M_386_DYNIX:
+            this.compilerSpec = "gcc";
+            this.languageSpec = "x86:LE:32:default";
+            break;
+        case UnixAoutMachineType.M_X86_64_NETBSD:
+            this.compilerSpec = "gcc";
+            this.languageSpec = "x86:LE:64:default";
+            break;
+
+            /**
+             * ARM family
+             */
+        case UnixAoutMachineType.M_ARM6_NETBSD:
+            this.isNetBSD = true;
+        case UnixAoutMachineType.M_ARM:
+            this.languageSpec = "ARM:" + readEndianness + ":32:default";
+            break;
+        case UnixAoutMachineType.M_AARCH64:
+            this.languageSpec = "AARCH64:" + readEndianness + ":64:default";
+            break;
+
+            /**
+             * RISC family
+             */
+        case UnixAoutMachineType.M_OR1K:
+            this.languageSpec = "UNKNOWN:BE:32:default";
+            break;
+        case UnixAoutMachineType.M_RISCV:
+            this.languageSpec = "RISCV:LE:32:default";
+            break;
+        case UnixAoutMachineType.M_HPPA_OPENBSD:
+            this.languageSpec = "pa-risc:BE:32:default";
+            break;
+
+            /**
+             * PowerPC family
+             */
+        case UnixAoutMachineType.M_POWERPC_NETBSD:
+            this.isNetBSD = true;
+            this.languageSpec = "PowerPC:" + readEndianness + ":32:default";
+            break;
+        case UnixAoutMachineType.M_POWERPC64:
+            this.languageSpec = "PowerPC:" + readEndianness + ":64:default";
+            break;
+
+            /**
+             * SuperH family
+             * NOTE: It's unclear if there is support for SuperH SH-3 or SH-5 cores;
+             * the primary SuperH language seems to support SH-1 and SH-2 variants
+             * and the alternative is the SuperH4 language.
+             */
+        case UnixAoutMachineType.M_SH3:
+        case UnixAoutMachineType.M_SH5_32:
+            this.languageSpec = "SuperH:BE:32:default";
+            break;
+        case UnixAoutMachineType.M_SH5_64:
+            this.languageSpec = "SuperH:BE:64:default";
+            break;
+
+            /**
+             * VAX family
+             */
+        case UnixAoutMachineType.M_VAX_NETBSD:
+            this.pageSize = 512;
+        case UnixAoutMachineType.M_VAX4K_NETBSD:
+            this.isNetBSD = true;
+            this.languageSpec = "UNKNOWN:LE:32:default";
+            break;
+
+            /**
+             * Other
+             */
+        case UnixAoutMachineType.M_CRIS:
+            this.languageSpec = "UNKNOWN:LE:32:default";
+            break;
+        case UnixAoutMachineType.M_ALPHA_NETBSD:
+            this.isNetBSD = true;
+        case UnixAoutMachineType.M_IA64:
+            this.languageSpec = "UNKNOWN:" + readEndianness + ":64:default";
+            break;
+        case UnixAoutMachineType.M_29K:
+        case UnixAoutMachineType.M_88K_OPENBSD:
+            this.languageSpec = "UNKNOWN:" + readEndianness + ":32:default";
+            break;
+        case UnixAoutMachineType.M_UNKNOWN:
+            this.languageSpec = "UNKNOWN:" + readEndianness + ":32:default";
+            break;
+        default:
+            this.machineTypeValid = false;
+        }
+
+        // Check that the detected architecture's endianness matches the endianness
+        // with which we're reading the file; if there's a mismatch, clear the
+        // machineTypeValid flag because this was evidently a false reading.
+        if (this.machineTypeValid) {
+            String[] languageTokens = this.languageSpec.split(":");
+            if ((languageTokens.length < 2) ||
+                    !languageTokens[1].equalsIgnoreCase(readEndianness)) {
+                this.machineTypeValid = false;
+            }
+        }
+    }
+
+    /**
+     * Returns a flag indicating whether the header contains a known machine type
+     * ID.
+     */
+    private boolean isMachineTypeValid() {
+        return this.machineTypeValid;
+    }
+
+    /**
+     * Returns a flag indicating whether this header contains a representation of a
+     * valid executable type.
+     */
+    private void checkExecutableType() {
+        final short exetypeMagic = (short) (this.a_magic & 0xFFFF);
+
+        switch (exetypeMagic) {
+        case 0x111: // 0421: core file
+            this.exeType = ExecutableType.CMAGIC;
+            break;
+        case 0x108: // 0410: pure executable
+            this.exeType = ExecutableType.NMAGIC;
+            break;
+        case 0x107: // 0407: object file or impure executable
+            this.exeType = ExecutableType.OMAGIC;
+            break;
+        case 0x0CC: // 0314: demand-paged exe w/ header in .text
+            this.exeType = ExecutableType.QMAGIC;
+            break;
+        case 0x10B: // 0413: demand-paged executable
+            this.exeType = ExecutableType.ZMAGIC;
+            break;
+        default:
+            this.exeType = ExecutableType.UNKNOWN;
+        }
+    }
+
+    /**
+     * Determines the offset in the binary file at which the .text segment begins.
+     * This routine should attempt to replicate the logic from the N_TXTOFF macro
+     * that appears in the different incarnations of a.out.h.
+     *
+     * NOTE: The FreeBSD imgact_aout.h implies that, if the a_magic word contains
+     * ZMAGIC when read as little endian, the file offset for .text is __LDPGSZ;
+     * otherwise, if a_magic contains ZMAGIC when read as big endian, the file offset
+     * for .text is 0. Indeed, it looks like NetBSD uses big-endian ordering for
+     * the a_magic word even when the file contains code for a little-endian
+     * processor. This seems strange.
+     */
+    private void determineTextOffset(boolean isLittleEndian) {
+
+        // Some combinations of executable type and architecture actually include the
+        // header in the .text section. This includes QMAGIC type and some (most? all?)
+        // big-endian ZMAGICs.
+        if ((this.exeType == ExecutableType.QMAGIC) ||
+            (this.exeType == ExecutableType.ZMAGIC)) {
+            this.txtOffset = 0;
+
+        } else {
+            this.txtOffset = sizeOfExecHeader;
+        }
+    }
+
+    /**
+     * Uses the combination of executable type and architecture to set the appropriate
+     * base address of the .text segment when loaded.
+     */
+    private void determineTextAddr() {
+
+        if ((this.isSparc && (this.exeType == ExecutableType.NMAGIC)) ||
+            (this.isNetBSD) ||
+            (this.exeType == ExecutableType.QMAGIC)) {
+            this.txtAddr = this.pageSize;
+
+        } else {
+            this.txtAddr = 0;
+        }
+    }
+
+    /**
+     * Returns a flag indicating whether all the file offsets in the header
+     * (for the segments of nonzero size) fall within the size of the file.
+     */
+    private boolean areOffsetsValid() {
+        // Note that we can't check the string table validity because, if it
+        // doesn't exist, its offset will be computed to be beyond the end of
+        // the file. The string table is also not given an explicit size in
+        // the header.
+        boolean status =
+                ((this.a_text == 0)   || (this.txtOffset    < this.binarySize)  &&
+                ((this.a_data == 0)   || (this.datOffset    < this.binarySize)) &&
+                ((this.a_trsize == 0) || (this.txtRelOffset < this.binarySize)) &&
+                ((this.a_drsize == 0) || (this.datRelOffset < this.binarySize)) &&
+                ((this.a_syms == 0)   || (this.symOffset    < this.binarySize)));
+        return status;
+    }
+
+    /**
+     * Rounds the provided address up to the next page boundary.
+     */
+    private long segmentRound(long addr) {
+        final long mask = this.pageSize - 1;
+        long rounded = ((addr + mask) & ~mask);
+        return rounded;
+    }
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutMachineType.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutMachineType.java
new file mode 100644
index 000000000..389ed6195
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutMachineType.java
@@ -0,0 +1,79 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ghidra.app.util.bin.format.aout;
+
+public class UnixAoutMachineType {
+
+    // These values come from a combination of sources, including NetBSD's aout_mids.h
+    // and the GNU BFD Library's libaout.h.
+    //
+    // Note: some a.out header files list a few HP values (for the 300 Series, 800 Series, etc.)
+    // and these values exceed a full eight-bit count. Occasionally, this is accounted for by
+    // extending the Machine ID field of the a_magic word two bits higher, leaving only six bits
+    // in the MSB for other flags. This may not be correct, because those high-value HP machine
+    // IDs probably only appear in HP UX binaries, which use a different format. (This format is
+    // still named "a.out", but has a completely different header and internal organization.)
+    // The 10-bit Machine ID field would also interfere with flags used by VxWorks, NetBSD, and
+    // probably others.
+
+    public final static short M_UNKNOWN        = 0x00;
+    public final static short M_68010          = 0x01;
+    public final static short M_68020          = 0x02;
+    public final static short M_SPARC          = 0x03;
+    public final static short M_R3000          = 0x04;
+    public final static short M_NS32032        = 0x40;
+    public final static short M_NS32532        = 0x45;
+    public final static short M_386            = 0x64;
+    public final static short M_29K            = 0x65; // AMD 29000
+    public final static short M_386_DYNIX      = 0x66; // i386-based Sequet machine running DYNIX
+    public final static short M_ARM            = 0x67;
+    public final static short M_SPARCLET       = 0x83; // Sparclet = M_SPARC + 128
+    public final static short M_386_NETBSD     = 0x86; // NetBSD/i386
+    public final static short M_M68K_NETBSD    = 0x87; // NetBSD/m68k, 8K pages
+    public final static short M_M68K4K_NETBSD  = 0x88; // NetBSD/m68k, 4K pages
+    public final static short M_532_NETBSD     = 0x89; // NetBSD/ns32k
+    public final static short M_SPARC_NETBSD   = 0x8a; // NetBSD/sparc
+    public final static short M_PMAX_NETBSD    = 0x8b; // NetBSD/pmax (MIPS little-endian)
+    public final static short M_VAX_NETBSD     = 0x8c; // NetBSD/VAX (1K pages?)
+    public final static short M_ALPHA_NETBSD   = 0x8d; // NetBSD/Alpha
+    public final static short M_MIPS           = 0x8e; // big-endian
+    public final static short M_ARM6_NETBSD    = 0x8f; // NetBSD/arm32
+    public final static short M_SH3            = 0x91;
+    public final static short M_POWERPC64      = 0x94; // PowerPC 64
+    public final static short M_POWERPC_NETBSD = 0x95; // NetBSD/PowerPC (big-endian)
+    public final static short M_VAX4K_NETBSD   = 0x96; // NetBSD/VAX (4K pages)
+    public final static short M_MIPS1          = 0x97; // MIPS R2000/R3000
+    public final static short M_MIPS2          = 0x98; // MIPS R4000/R6000
+    public final static short M_88K_OPENBSD    = 0x99; // OpenBSD/m88k
+    public final static short M_HPPA_OPENBSD   = 0x9a; // OpenBSD/hppa (PA-RISC)
+    public final static short M_SH5_64         = 0x9b; // SuperH 64-bit
+    public final static short M_SPARC64_NETBSD = 0x9c; // NetBSD/sparc64
+    public final static short M_X86_64_NETBSD  = 0x9d; // NetBSD/amd64
+    public final static short M_SH5_32         = 0x9e; // SuperH 32-bit (ILP 32)
+    public final static short M_IA64           = 0x9f; // Itanium
+    public final static short M_AARCH64        = 0xb7; // ARM AARCH64
+    public final static short M_OR1K           = 0xb8; // OpenRISC 1000
+    public final static short M_RISCV          = 0xb9; // RISC-V
+    public final static short M_CRIS           = 0xff; // Axis ETRAX CRIS
+
+    /**
+     * Machine IDs that should only appear in the incompatible HP UX a.out format:
+     *   HP300 (68020+68881): 0x12c
+     *   HP200/300          : 0x20c
+     *   HP800              : 0x20b
+     */
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutRelocationTableEntry.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutRelocationTableEntry.java
new file mode 100644
index 000000000..44ffd538e
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutRelocationTableEntry.java
@@ -0,0 +1,64 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ghidra.app.util.bin.format.aout;
+
+/**
+ * Represents the content of a single entry in the relocation table format used
+ * by the UNIX a.out executable.
+ */
+public class UnixAoutRelocationTableEntry {
+    public long address;
+    public long symbolNum;
+    public boolean pcRelativeAddressing;
+    public byte pointerLength;
+    public boolean extern;
+    public boolean baseRelative;
+    public boolean jmpTable;
+    public boolean relative;
+    public boolean copy;
+
+    /**
+     *
+     * @param address First of the two words in the table entry (a 32-bit address)
+     * @param flags   Second of the two words in the table entry (containing several
+     *                bitfields)
+     */
+    public UnixAoutRelocationTableEntry(long address, long flags, boolean bigEndian) {
+        this.address = (0xFFFFFFFF & address);
+
+        if (bigEndian) {
+            this.symbolNum = ((flags & 0xFFFFFF00) >> 8);
+            this.pcRelativeAddressing = ((flags & 0x80) != 0);
+            this.pointerLength = (byte) (1 << ((flags & 0x60) >> 5));
+            this.extern = ((flags & 0x10) != 0);
+            this.baseRelative = ((flags & 0x8) != 0);
+            this.jmpTable = ((flags & 0x4) != 0);
+            this.relative = ((flags & 0x2) != 0);
+            this.copy = ((flags & 0x1) != 0);
+        } else {
+            this.symbolNum = (flags & 0x00FFFFFF);
+            final byte hibyte = (byte) ((flags & 0xFF000000) >> 24);
+            this.pcRelativeAddressing = ((hibyte & 0x01) != 0);
+            this.pointerLength = (byte) (1 << ((hibyte & 0x06) >> 1));
+            this.extern = ((hibyte & 0x08) != 0);
+            this.baseRelative = ((hibyte & 0x10) != 0);
+            this.jmpTable = ((hibyte & 0x20) != 0);
+            this.relative = ((hibyte & 0x40) != 0);
+            this.copy = ((hibyte & 0x80) != 0);
+        }
+    }
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutSymbolTableEntry.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutSymbolTableEntry.java
new file mode 100644
index 000000000..e05e6350d
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/bin/format/unixaout/UnixAoutSymbolTableEntry.java
@@ -0,0 +1,66 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package ghidra.app.util.bin.format.aout;
+
+/**
+ * Represents the content of a single entry in the symbol table format used by
+ * the UNIX a.out executable.
+ */
+public class UnixAoutSymbolTableEntry {
+
+    enum SymbolType { N_UNDF, N_ABS, N_TEXT, N_DATA, N_BSS, N_FN, N_EXT, UNKNOWN }
+
+    public long nameStringOffset;
+    public String name;
+    public SymbolType type;
+    public byte otherByte;
+    public short desc;
+    public long value;
+    public boolean isExt;
+
+    public UnixAoutSymbolTableEntry(long nameStringOffset, byte typeByte, byte otherByte, short desc, long value) {
+        this.nameStringOffset = nameStringOffset;
+        this.otherByte = otherByte;
+        this.desc = desc;
+        this.value = value;
+        this.isExt = (typeByte & 1) == 1;
+
+        switch (typeByte & 0xfe) {
+        case 0:
+            type = SymbolType.N_UNDF;
+            break;
+        case 1:
+            type = SymbolType.N_EXT;
+            break;
+        case 2:
+            type = SymbolType.N_ABS;
+            break;
+        case 4:
+            type = SymbolType.N_TEXT;
+            break;
+        case 6:
+            type = SymbolType.N_DATA;
+            break;
+        case 8:
+            type = SymbolType.N_BSS;
+            break;
+        default:
+            type = SymbolType.N_UNDF;
+        }
+    }
+
+}
diff --git a/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/UnixAoutLoader.java b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/UnixAoutLoader.java
new file mode 100644
index 000000000..f95a21307
--- /dev/null
+++ b/Ghidra/Features/Base/src/main/java/ghidra/app/util/opinion/UnixAoutLoader.java
@@ -0,0 +1,583 @@
+/* ###
+ * IP: GHIDRA
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package ghidra.app.util.bin.format.aout;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.*;
+
+import ghidra.app.util.Option;
+import ghidra.app.util.bin.BinaryReader;
+import ghidra.app.util.bin.ByteProvider;
+import ghidra.app.util.bin.format.aout.UnixAoutHeader.ExecutableType;
+import ghidra.app.util.importer.MessageLog;
+import ghidra.app.util.opinion.AbstractProgramWrapperLoader;
+import ghidra.app.util.opinion.Loader;
+import ghidra.app.util.opinion.LoadSpec;
+import ghidra.framework.store.LockException;
+import ghidra.program.flatapi.FlatProgramAPI;
+import ghidra.program.model.address.Address;
+import ghidra.program.model.address.AddressOverflowException;
+import ghidra.program.model.address.AddressSpace;
+import ghidra.program.model.lang.LanguageCompilerSpecPair;
+import ghidra.program.model.listing.Function;
+import ghidra.program.model.listing.Program;
+import ghidra.program.model.mem.MemoryAccessException;
+import ghidra.program.model.mem.MemoryBlock;
+import ghidra.program.model.mem.MemoryConflictException;
+import ghidra.program.model.symbol.Namespace;
+import ghidra.program.model.symbol.RefType;
+import ghidra.program.model.symbol.SourceType;
+import ghidra.program.model.symbol.Symbol;
+import ghidra.util.exception.CancelledException;
+import ghidra.util.exception.DuplicateNameException;
+import ghidra.util.exception.InvalidInputException;
+import ghidra.util.task.TaskMonitor;
+
+/**
+ * A {@link Loader} for processing UNIX-style A.out executables
+ *
+ * This style was also used by UNIX-like systems such as SunOS, BSD, and
+ * VxWorks, as well as some early distributions of Linux. Although there do
+ * exist implementations of A.out with 64-bit and GNU extensions, this loader
+ * does not currently support them.
+ *
+ * @see <a href="https://wiki.osdev.org/A.out">OSDev.org A.out</a>
+ * @see <a href="https://man.freebsd.org/cgi/man.cgi?a.out(5)">FreeBSD
+ *      manpage</a>
+ */
+public class UnixAoutLoader extends AbstractProgramWrapperLoader {
+
+  MemoryBlock textBlock;
+  AddressSpace textAddrSpace;
+  MemoryBlock dataBlock;
+  AddressSpace dataAddrSpace;
+  MemoryBlock bssBlock;
+  AddressSpace bssAddrSpace;
+  Hashtable<String,Long> bssSymbols;
+  Hashtable<String,Long> possibleBssSymbols;
+  Namespace namespace;
+  Vector<UnixAoutSymbolTableEntry> symTab;
+  Vector<UnixAoutRelocationTableEntry> textRelocTab;
+  Vector<UnixAoutRelocationTableEntry> dataRelocTab;
+	Hashtable<Address,String> localFunctions = new Hashtable<Address, String>();
+  long bssLocation = 0;
+  FlatProgramAPI api;
+  Program program;
+  MessageLog log;
+  UnixAoutHeader header;
+  String filename;
+  boolean isOverlay;
+  boolean bigEndian;
+
+	@Override
+	public String getName() {
+		return "UNIX A.out executable";
+	}
+
+	@Override
+	public boolean supportsLoadIntoProgram() {
+		return true;
+	}
+
+	@Override
+	public Collection<LoadSpec> findSupportedLoadSpecs(ByteProvider provider) throws IOException {
+		List<LoadSpec> loadSpecs = new ArrayList<>();
+
+		// Attempt to parse the header as both little- and big-endian.
+		// It is likely that only one of these will produce sensible values.
+		UnixAoutHeader hdrBE = new UnixAoutHeader(provider, false);
+		UnixAoutHeader hdrLE = new UnixAoutHeader(provider, true);
+		boolean beValid = false;
+
+		if (hdrBE.isValid()) {
+			final String lang = hdrBE.getLanguageSpec();
+			final String comp = hdrBE.getCompilerSpec();
+			loadSpecs.add(new LoadSpec(this, 0, new LanguageCompilerSpecPair(lang, comp), true));
+			beValid = true;
+		}
+		if (hdrLE.isValid()) {
+			final String lang = hdrLE.getLanguageSpec();
+			final String comp = hdrLE.getCompilerSpec();
+			loadSpecs.add(new LoadSpec(this, 0, new LanguageCompilerSpecPair(lang, comp), !beValid));
+		}
+
+		return loadSpecs;
+	}
+
+  /**
+   * Creates an AddressSpace and MemoryBlock for the .text section of the binary, reading its
+   * contents from the provider.
+   */
+  protected void createTextSection(ByteProvider provider, TaskMonitor monitor, long size,
+    long addressFromHeader, long fileOffset) {
+
+		if (size > 0) {
+			Address address =
+        this.program.getAddressFactory().getDefaultAddressSpace().getAddress(addressFromHeader);
+			try {
+				InputStream stream = provider.getInputStream(fileOffset);
+				this.textBlock = this.program.getMemory().createInitializedBlock(
+          this.filename + ".text", address, stream, size, monitor, this.isOverlay);
+				this.textBlock.setRead(true);
+				this.textBlock.setWrite(false);
+				this.textBlock.setExecute(true);
+				this.textAddrSpace = textBlock.getStart().getAddressSpace();
+			} catch (LockException | MemoryConflictException | AddressOverflowException |
+               CancelledException | IOException e) {
+				e.printStackTrace();
+			}
+		}
+  }
+
+  /**
+   * Creates an AddressSpace and MemoryBlock for the .data section of the binary, reading its
+   * contents from the provider.
+   */
+  protected void createDataSection(ByteProvider provider, TaskMonitor monitor, long size,
+    long addressFromHeader, long fileOffset) {
+
+		if (size > 0) {
+			Address address =
+        program.getAddressFactory().getDefaultAddressSpace().getAddress(addressFromHeader);
+			try {
+				InputStream stream = provider.getInputStream(fileOffset);
+				this.dataBlock = program.getMemory().createInitializedBlock(
+          this.filename + ".data", address, stream, size, monitor, this.isOverlay);
+				this.dataBlock.setRead(true);
+				this.dataBlock.setWrite(true);
+				this.dataBlock.setExecute(false);
+				this.dataAddrSpace = dataBlock.getStart().getAddressSpace();
+			} catch (LockException | MemoryConflictException | AddressOverflowException |
+               CancelledException | IOException e) {
+				e.printStackTrace();
+			}
+		}
+  }
+
+  /**
+   * Creates a .bss section for this binary, ensuring that it has enough space to accommodate
+   * all of the symbols that are explictly assigned to .bss and also the symbols marked as
+   * N_UNDF and that need to be dynamically assigned space in this section.
+   */
+  protected void createBssSection(long bssSize) {
+		// Add up the sizes of all the symbols that are supposed to be allocated
+		// in .bss, and ensure that our .bss segment has enough additional space
+		// to accommodate them (beyond the size allocated by the header.)
+		// Until we search the global symbol table for the symbols in the
+		// 'possibleBssSymbols' list (which will happen as we walk the relocation
+		// table, below), we won't know whether these symbols exist in another
+		// binary file that was previously loaded, or, instead, if we'll need to
+		// mimic the linker behavior and assign them space in .bss.
+		Long additionalBssSpace = (long) 0;
+		for (Long symbolSize : this.possibleBssSymbols.values()) {
+			additionalBssSpace += symbolSize;
+		}
+
+		// Keep track of the next available location in .bss. The dynamically
+    // located symbols (of N_UNDF type) will start after the fix section.
+		this.bssLocation = bssSize;
+
+		bssSize += additionalBssSpace;
+		if (bssSize > 0) {
+			Address bssAddr = this.program.getAddressFactory().getDefaultAddressSpace().getAddress(
+        this.header.getBssAddr());
+			try {
+				this.bssBlock = this.program.getMemory().createUninitializedBlock(this.filename + ".bss",
+          bssAddr, bssSize, this.isOverlay);
+				this.bssAddrSpace = bssBlock.getStart().getAddressSpace();
+				this.bssBlock.setRead(true);
+				this.bssBlock.setWrite(true);
+				this.bssBlock.setExecute(false);
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+  }
+
+  /**
+   * Labels the known symbols in the .bss section.
+   */
+  protected void placeBssSymbols() {
+    if (this.bssSymbols.size() > 0) {
+      if (this.bssAddrSpace != null) {
+        try {
+          for (String bssSymbolName : this.bssSymbols.keySet()) {
+            final Long bssSymbolAddr = this.bssSymbols.get(bssSymbolName);
+            this.api.createLabel(this.bssAddrSpace.getAddress(bssSymbolAddr), bssSymbolName,
+              this.namespace, true, SourceType.IMPORTED);
+          }
+        } catch (Exception e) {
+          e.printStackTrace();
+        }
+      } else {
+        this.log.appendMsg("Warning: some symbols were identified as being in .bss, but .bss" +
+          " could not be created.");
+      }
+    }
+  }
+
+  /**
+   * Processes the binary's symbol table, taking one of four different actions depending on the
+   * symbol type:
+   *  - N_TEXT are added to a list for disassembly later.
+   *  - N_DATA are labeled immediately.
+   *  - N_BSS are added to a list for labeling after the .bss section size has been established.
+   *  - N_UNDF are added to a list for address assignment and labeling in .bss if the symbol is
+   *    not found to already exist in a global symbol table (i.e. provided by another binary.)
+   */
+  protected void processSymbolTable(Vector<UnixAoutSymbolTableEntry> symTab) {
+
+		this.bssSymbols = new Hashtable<String, Long>();
+		this.possibleBssSymbols = new Hashtable<String, Long>();
+
+		// Process the symbol table by applying labels to identify any symbols whose
+		// addresses are given
+		for (Integer i = 0; i < symTab.size(); i++) {
+			UnixAoutSymbolTableEntry symTabEntry = symTab.elementAt(i);
+			try {
+				if (symTabEntry.value != 0) {
+					if (symTabEntry.type == UnixAoutSymbolTableEntry.SymbolType.N_TEXT) {
+						if (symTabEntry.isExt) {
+							// Save the entry point to this function in a list. Disassembly should wait
+							// until
+							// after we've processed the relocation tables.
+							Address funcAddr = this.textAddrSpace.getAddress(symTabEntry.value);
+							this.localFunctions.put(funcAddr, symTabEntry.name);
+						}
+					} else if (symTabEntry.type == UnixAoutSymbolTableEntry.SymbolType.N_DATA) {
+						this.api.createLabel(this.dataAddrSpace.getAddress(symTabEntry.value), symTabEntry.name,
+              this.namespace, true, SourceType.IMPORTED);
+
+					} else if (symTabEntry.type == UnixAoutSymbolTableEntry.SymbolType.N_BSS) {
+						// Save the symbols that are explicitly identified as being in .bss
+            // to a list so that they can be labeled later (after we actually
+            // create the .bss block, which must wait until after we total all
+            // the space used by N_UNDF symbols; see below.)
+						this.bssSymbols.put(symTabEntry.name, symTabEntry.value);
+
+					} else if (symTabEntry.type == UnixAoutSymbolTableEntry.SymbolType.N_UNDF) {
+						// This is a special case given by the A.out spec: if the linker cannot find
+						// this
+						// symbol in any of the other binary files, then the fact that it is marked as
+						// N_UNDF but has a non-zero value means that its value should be interpreted as
+						// a size, and the linker should reserve space in .bss for it.
+						this.possibleBssSymbols.put(symTabEntry.name, symTabEntry.value);
+					}
+				}
+			} catch (Exception e) {
+				e.printStackTrace();
+			}
+		}
+  }
+
+  /**
+   * Processes the text relocation table by fixing addresses based on the true location of each
+   * symbol.
+   */
+  protected void processTextRelocation() {
+		for (Integer i = 0; i < this.textRelocTab.size(); i++) {
+
+			UnixAoutRelocationTableEntry relocationEntry = this.textRelocTab.elementAt(i);
+			if (relocationEntry.symbolNum < symTab.size()) {
+
+				UnixAoutSymbolTableEntry symbolEntry = this.symTab.elementAt((int) relocationEntry.symbolNum);
+				AddressSpace addrSpace = this.textBlock.getStart().getAddressSpace();
+				Address relocAddr =
+          addrSpace.getAddress(relocationEntry.address + this.header.getTextAddr());
+
+				// If this symbol's N_EXT flag is clear, then we didn't mark it as a function when
+				// we were processing the symbol table (above). This is because special symbols like
+				// "gcc2_compiled", "___gnu_compiled_c", and names of object files are in the symbol
+				// table for this segment, but do not point to disassemblable code. However, since
+				// there is now a reference from the relocation table, we should be able to
+				// disassemble at its address. Save the address for disassembly later.
+				if (!symbolEntry.isExt) {
+					Address funcAddr = textAddrSpace.getAddress(symbolEntry.value);
+					this.localFunctions.put(funcAddr, symbolEntry.name);
+				}
+
+				if (relocationEntry.extern && this.textBlock.contains(relocAddr)) {
+
+					List<Function> funcs =
+            this.api.getCurrentProgram().getListing().getGlobalFunctions(symbolEntry.name);
+					List<Symbol> symbolsGlobal = this.api.getSymbols(symbolEntry.name, null);
+					List<Symbol> symbolsLocal = this.api.getSymbols(symbolEntry.name, namespace);
+
+					if (funcs.size() > 0) {
+						Address funcAddr = funcs.get(0).getEntryPoint();
+						fixAddress(this.textBlock, relocAddr, funcAddr, relocationEntry.pcRelativeAddressing,
+              this.bigEndian, relocationEntry.pointerLength);
+
+					} else if (symbolsGlobal.size() > 0) {
+						Address globalSymbolAddr = symbolsGlobal.get(0).getAddress();
+						fixAddress(this.textBlock, relocAddr, globalSymbolAddr, relocationEntry.pcRelativeAddressing,
+							this.bigEndian, relocationEntry.pointerLength);
+
+					} else if (symbolsLocal.size() > 0) {
+						Address localSymbolAddr = symbolsLocal.get(0).getAddress();
+						fixAddress(this.textBlock, relocAddr, localSymbolAddr, relocationEntry.pcRelativeAddressing,
+							this.bigEndian, relocationEntry.pointerLength);
+
+					} else if (this.possibleBssSymbols.containsKey(symbolEntry.name)) {
+						try {
+							Address bssSymbolAddress = this.bssBlock.getStart().getAddressSpace().getAddress(bssLocation);
+							long bssSymbolSize = this.possibleBssSymbols.get(symbolEntry.name);
+							this.api.createLabel(bssSymbolAddress, symbolEntry.name, this.namespace, true,
+                SourceType.IMPORTED);
+							fixAddress(this.textBlock, relocAddr, bssSymbolAddress, relocationEntry.pcRelativeAddressing,
+									this.bigEndian, relocationEntry.pointerLength);
+							this.program.getReferenceManager().addMemoryReference(relocAddr, bssSymbolAddress, RefType.DATA,
+									SourceType.IMPORTED, 0);
+							this.bssLocation += bssSymbolSize;
+
+						} catch (Exception e) {
+							e.printStackTrace();
+						}
+					} else {
+						this.log.appendMsg("Symbol '" + symbolEntry.name
+								+ "' was not found and was not a candidate for allocation in .bss.");
+					}
+				}
+			} else {
+				this.log.appendMsg("Symbol number " + relocationEntry.symbolNum + " is beyond symbol table length of "
+						+ symTab.size());
+			}
+		}
+  }
+
+  /**
+   * Processes the data relocation table by fixing addresses based on the true location of each
+   * symbol.
+   */
+  protected void processDataRelocation(long dataAddrFromHeader) {
+		for (Integer i = 0; i < this.dataRelocTab.size(); i++) {
+
+			UnixAoutRelocationTableEntry relocationEntry = this.dataRelocTab.elementAt(i);
+			if (relocationEntry.symbolNum < symTab.size()) {
+
+				UnixAoutSymbolTableEntry symbolEntry = this.symTab.elementAt((int) relocationEntry.symbolNum);
+				AddressSpace addrSpace = this.dataBlock.getStart().getAddressSpace();
+				Address relocAddr = addrSpace.getAddress(relocationEntry.address + dataAddrFromHeader);
+
+				if (this.dataBlock.contains(relocAddr)) {
+
+					List<Function> funcs =
+            this.api.getCurrentProgram().getListing().getGlobalFunctions(symbolEntry.name);
+					List<Symbol> symbolsGlobal = this.api.getSymbols(symbolEntry.name, null);
+					List<Symbol> symbolsLocal = this.api.getSymbols(symbolEntry.name, namespace);
+
+					if (funcs.size() > 0) {
+						Address funcAddr = funcs.get(0).getEntryPoint();
+						fixAddress(this.dataBlock, relocAddr, funcAddr, relocationEntry.pcRelativeAddressing,
+              this.bigEndian, relocationEntry.pointerLength);
+
+					} else if (symbolsGlobal.size() > 0) {
+						Address globalSymbolAddr = symbolsGlobal.get(0).getAddress();
+						fixAddress(this.dataBlock, relocAddr, globalSymbolAddr,
+              relocationEntry.pcRelativeAddressing, this.bigEndian, relocationEntry.pointerLength);
+
+					} else if (symbolsLocal.size() > 0) {
+						Address localSymbolAddr = symbolsLocal.get(0).getAddress();
+						fixAddress(this.dataBlock, relocAddr, localSymbolAddr,
+              relocationEntry.pcRelativeAddressing, this.bigEndian, relocationEntry.pointerLength);
+
+					} else if (this.possibleBssSymbols.containsKey(symbolEntry.name)) {
+						try {
+							Address bssSymbolAddress =
+                this.bssBlock.getStart().getAddressSpace().getAddress(bssLocation);
+							this.api.createLabel(bssSymbolAddress, symbolEntry.name, namespace, true,
+                SourceType.IMPORTED);
+							fixAddress(this.dataBlock, relocAddr, bssSymbolAddress,
+                relocationEntry.pcRelativeAddressing, this.bigEndian, relocationEntry.pointerLength);
+							this.program.getReferenceManager().addMemoryReference(relocAddr, bssSymbolAddress,
+                RefType.DATA, SourceType.IMPORTED, 0);
+							this.bssLocation += this.possibleBssSymbols.get(symbolEntry.name);
+
+						} catch (Exception e) {
+							e.printStackTrace();
+						}
+					} else {
+						this.log.appendMsg("Symbol '" + symbolEntry.name
+								+ "' was not found and was not a candidate for allocation in .bss.");
+					}
+				}
+			} else {
+				this.log.appendMsg("Symbol number " + relocationEntry.symbolNum +
+          " is beyond symbol table length of " + symTab.size());
+			}
+		}
+  }
+
+  /**
+   * Walks through the table of local function addresses, marks the locations as functions, and
+   * starts disassembly of those routines.
+   */
+  protected void disassembleKnownFuncs() {
+		// Now that all relocation addresses have been rewritten, it's safe to start disassembly
+		// at all the known function entry points.
+		for (Address funcAddr : this.localFunctions.keySet()) {
+			this.api.disassemble(funcAddr);
+			this.api.createFunction(funcAddr, this.localFunctions.get(funcAddr));
+		}
+
+		if ((this.header.getExecutableType() != UnixAoutHeader.ExecutableType.OMAGIC)
+				&& (this.header.getExecutableType() != UnixAoutHeader.ExecutableType.CMAGIC)) {
+			this.api.disassemble(textAddrSpace.getAddress(this.header.getEntryPoint()));
+		}
+  }
+
+	@Override
+	protected void load(ByteProvider provider, LoadSpec loadSpec, List<Option> options, Program program,
+			TaskMonitor monitor, MessageLog log) throws CancelledException, IOException {
+
+		this.bigEndian = program.getLanguage().isBigEndian();
+    this.program = program;
+    this.log = log;
+		this.api = new FlatProgramAPI(program, monitor);
+		this.header = new UnixAoutHeader(provider, !this.bigEndian);
+    this.filename = provider.getFile().getName();
+		this.isOverlay = (header.getExecutableType() == ExecutableType.OMAGIC);
+
+		try {
+			this.namespace = this.api.createNamespace(program.getGlobalNamespace(), this.filename);
+		} catch (DuplicateNameException | InvalidInputException e1) {
+			e1.printStackTrace();
+		}
+
+    createTextSection(
+      provider, monitor, header.getTextSize(), header.getTextAddr(), header.getTextOffset());
+    createDataSection(
+      provider, monitor, header.getDataSize(), header.getDataAddr(), header.getDataOffset());
+
+		BinaryReader reader = new BinaryReader(provider, !this.bigEndian);
+
+		this.symTab =
+      getSymbolTable(reader, header.getSymOffset(), header.getSymSize(), header.getStrOffset());
+		this.textRelocTab =
+      getRelocationTable(reader, header.getTextRelocOffset(), header.getTextRelocSize());
+		this.dataRelocTab =
+      getRelocationTable(reader, header.getDataRelocOffset(), header.getDataRelocSize());
+
+    processSymbolTable(symTab);
+		createBssSection(header.getBssSize());
+    placeBssSymbols();
+    processTextRelocation();
+    processDataRelocation(header.getDataAddr());
+    disassembleKnownFuncs();
+	}
+
+	/**
+	 * Rewrites the pointer at the specified location to instead point to the
+	 * provided address.
+	 *
+	 * @param block           Memory block containing the pointer to be rewritten.
+	 * @param pointerLocation Address at which the pointer to be rewritten is.
+	 * @param newAddress      Address that will be the new pointer target.
+	 * @param isPcRelative    Indicates whether the address is program counter
+	 *                        relative, in which case the pointer will be written
+	 *                        with the delta between the pointer location and the
+	 *                        new destination address. Otherwise it will be written
+	 *                        with the absolute address.
+	 * @param isBigEndian     True if the program (and therefore the byte order of
+	 *                        the pointer) is big endian. False if little endian.
+	 * @param pointerSize     1, 2, and 4-byte pointers are supported.
+	 */
+	private void fixAddress(MemoryBlock block, Address pointerLocation, Address newAddress, boolean isPcRelative,
+			boolean isBigEndian, int pointerSize) {
+
+		final long value = isPcRelative ? (newAddress.getOffset() - pointerLocation.getOffset())
+				: newAddress.getOffset();
+
+		byte[] valueBytes = new byte[pointerSize];
+
+		for (int i = 0; i < pointerSize; i++) {
+			int shiftCount = isBigEndian ? (24 - (i * 8)) : (i * 8);
+			valueBytes[i] = (byte) ((value >> shiftCount) & 0xff);
+		}
+		try {
+			block.putBytes(pointerLocation, valueBytes);
+		} catch (MemoryAccessException e) {
+			e.printStackTrace();
+		}
+	}
+
+	/**
+	 * Reads a single relocation table for either text or data relocations,
+	 * depending on the offset/length provided.
+	 *
+	 * @param reader Source of file data
+	 * @param offset File byte offset to the start of the relocation table
+	 * @param len    Length of the relocation table in bytes
+	 * @return Vector of relocation table entries
+	 */
+	private Vector<UnixAoutRelocationTableEntry> getRelocationTable(BinaryReader reader, long offset, long len) {
+		Vector<UnixAoutRelocationTableEntry> relocTable = new Vector<UnixAoutRelocationTableEntry>();
+		reader.setPointerIndex(offset);
+
+		try {
+			while (reader.getPointerIndex() < (offset + len)) {
+				long address = reader.readNextUnsignedInt();
+				long flags = reader.readNextUnsignedInt();
+				relocTable.add(new UnixAoutRelocationTableEntry(address, flags, reader.isBigEndian()));
+			}
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+
+		return relocTable;
+	}
+
+	/**
+	 * Reads all the symbol table entries from the file, returning their
+	 * representation.
+	 *
+	 * @param reader           Source of file data
+	 * @param offset           File byte offset to the start of the symbol table
+	 * @param len              Length of the symbol table in bytes
+	 * @param strTabBaseOffset File byte offset to the start of the string table
+	 *                         (containing symbol names)
+	 * @return Vector of symbol table entries
+	 */
+	private Vector<UnixAoutSymbolTableEntry> getSymbolTable(BinaryReader reader, long offset, long len,
+			long strTabBaseOffset) {
+		Vector<UnixAoutSymbolTableEntry> symtab = new Vector<UnixAoutSymbolTableEntry>();
+		reader.setPointerIndex(offset);
+
+		try {
+			// read each symbol table entry
+			while (reader.getPointerIndex() < (offset + len)) {
+				long strOffset = reader.readNextUnsignedInt();
+				byte typeByte = reader.readNextByte();
+				byte otherByte = reader.readNextByte();
+				short desc = reader.readNextShort();
+				long value = reader.readNextUnsignedInt();
+				symtab.add(new UnixAoutSymbolTableEntry(strOffset, typeByte, otherByte, desc, value));
+			}
+
+			// lookup and set each string table symbol name
+			for (Integer i = 0; i < symtab.size(); i++) {
+				String symstr = reader.readAsciiString(strTabBaseOffset + symtab.get(i).nameStringOffset);
+				symtab.get(i).name = symstr;
+			}
+
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+
+		return symtab;
+	}
+}
-- 
2.39.1

